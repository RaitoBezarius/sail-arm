/**************************************************************************/
/* BSD 3-clause Clear License                                             */
/*                                                                        */
/* Copyright (c) 2019                                                     */
/*   Arm Limited (or its affiliates),                                     */
/*   Alasdair Armstrong,                                                  */
/*   Alastair Reid,                                                       */
/*   Thomas Bauereiss,                                                    */
/*   Peter Sewell,                                                        */
/*   Kathryn Gray,                                                        */
/*   Anthony Fox                                                          */
/*                                                                        */
/* All rights reserved.                                                   */
/*                                                                        */
/* Redistribution and use in source and binary forms, with or without     */
/* modification, are permitted (subject to the limitations in the         */
/* disclaimer below) provided that the following conditions are met:      */
/*                                                                        */
/* 	* Redistributions of source code must retain the above            */
/*        copyright notice, this list of conditions and the following     */
/* 	  disclaimer.                                                     */
/*      * Redistributions in binary form must reproduce the above         */
/*        copyright notice, this list of conditions and the following     */
/*        disclaimer in the documentation and/or other materials          */
/* 	  provided with the distribution.                                 */
/* 	* Neither the name of ARM Limited nor the names of its            */
/*        contributors may be used to endorse or promote products         */
/*        derived from this software without specific prior written       */
/*        permission.                                                     */
/*                                                                        */
/* NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE        */
/* GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT    */
/* HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED            */
/* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF   */
/* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE               */
/* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  */
/* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    */
/* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   */
/* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        */
/* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  */
/* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE   */
/* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN */
/* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                          */
/**************************************************************************/

val println : unit -> unit

function println () = {
    prerr("\n")
}

register __unconditional : bool

register __saved_exception_level : bits(2)

register configuration __exclusive_granule_size : bits(4) = 0x4

register __exclusive_block_address : bits(52)

register __currentCond : bits(4)

val __UNKNOWN_string : unit -> string

function __UNKNOWN_string () = {
    "UNKNOWN"
}

register configuration semihost_clock : bits(64) = __GetSlice_int(64, 0, 0)

register _V : vector(32, dec, bits(128))

val set_VTTBR : bits(64) -> unit effect {rreg, wreg}

function set_VTTBR val_name = {
    let r : bits(64) = val_name;
    VTTBR_EL2 = __SetSlice_bits(64, 64, VTTBR_EL2, 0, slice(r, 0, 64));
    return()
}

val set_VTCR : bits(32) -> unit effect {rreg, wreg}

function set_VTCR val_name = {
    let r : bits(32) = val_name;
    VTCR_EL2 = __SetSlice_bits(32, 32, VTCR_EL2, 0, slice(r, 0, 32));
    return()
}

register VPIDR_EL2 : bits(32)

register VNCR_EL2 : bits(64)

register VMPIDR_EL2 : bits(64)

val set_VMPIDR : bits(32) -> unit effect {rreg, wreg}

function set_VMPIDR val_name = {
    let r : bits(32) = val_name;
    VMPIDR_EL2 = __SetSlice_bits(64, 32, VMPIDR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_VMPIDR : unit -> bits(32) effect {rreg, undef}

function get_VMPIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(VMPIDR_EL2, 0, 32));
    r
}

register VDISR_EL2 : bits(64)

val set_VDISR : bits(32) -> unit effect {rreg, wreg}

function set_VDISR val_name = {
    VDISR_EL2 = __SetSlice_bits(64, 32, VDISR_EL2, 0, val_name)
}

val set_HVBAR : bits(32) -> unit effect {rreg, wreg}

function set_HVBAR val_name = {
    let r : bits(32) = val_name;
    VBAR_EL2 = __SetSlice_bits(64, 32, VBAR_EL2, 0, slice(r, 0, 32));
    return()
}

val set_VBAR_NS : bits(32) -> unit effect {rreg, wreg}

function set_VBAR_NS val_name = {
    let r : bits(32) = val_name;
    VBAR_EL1 = __SetSlice_bits(64, 32, VBAR_EL1, 0, slice(r, 0, 32));
    return()
}

register VBAR_EL0 : bits(64)

val TraceSynchronizationBarrier : unit -> unit effect {escape}

function TraceSynchronizationBarrier () = {
    throw(Error_Implementation_Defined("TraceSynchronizationBarrier unimplemented"))
}

val set_TTBR1_NS : bits(64) -> unit effect {rreg, wreg}

function set_TTBR1_NS val_name = {
    let r : bits(64) = val_name;
    TTBR1_EL1 = __SetSlice_bits(64, 64, TTBR1_EL1, 0, slice(r, 0, 64));
    return()
}

val set_HTTBR : bits(64) -> unit effect {rreg, wreg}

function set_HTTBR val_name = {
    let r : bits(64) = val_name;
    TTBR0_EL2 = __SetSlice_bits(64, 64, TTBR0_EL2, 0, slice(r, 0, 64));
    return()
}

val set_TTBR0_NS : bits(64) -> unit effect {rreg, wreg}

function set_TTBR0_NS val_name = {
    let r : bits(64) = val_name;
    TTBR0_EL1 = __SetSlice_bits(64, 64, TTBR0_EL1, 0, slice(r, 0, 64));
    return()
}

register configuration __vmid16_implemented : bool = true

register configuration __pan_implemented : bool = true

register configuration __fp16_implemented : bool = true

register configuration __dot_product_implemented : bool = true

register configuration __crc32_implemented : bool = true

register configuration __aa32_hpd_implemented : bool = true

register TRFCR_EL2 : bits(32)

val set_HTRFCR : bits(32) -> unit effect {rreg, wreg}

function set_HTRFCR val_name = {
    let r : bits(32) = val_name;
    TRFCR_EL2 = __SetSlice_bits(32, 32, TRFCR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HTRFCR : unit -> bits(32) effect {rreg, undef}

function get_HTRFCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TRFCR_EL2, 0, 32));
    r
}

register TRFCR_EL1 : bits(32)

val set_TRFCR : bits(32) -> unit effect {rreg, wreg}

function set_TRFCR val_name = {
    let r : bits(32) = val_name;
    TRFCR_EL1 = __SetSlice_bits(32, 32, TRFCR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_TRFCR : unit -> bits(32) effect {rreg, undef}

function get_TRFCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(TRFCR_EL1, 0, 32));
    r
}

register TPIDR_EL3 : bits(64)

register TPIDR_EL2 : bits(64)

register TPIDR_EL1 : bits(64)

register TPIDR_EL0 : bits(64)

register TPIDRRO_EL0 : bits(64)

register TLBTR : bits(32)

val TLBI_RVALE3OS : bits(64) -> unit

function TLBI_RVALE3OS val_name = ()

val set_TTBCR_NS : bits(32) -> unit effect {rreg, wreg}

function set_TTBCR_NS val_name = {
    let r : bits(32) = val_name;
    TCR_EL1 = __SetSlice_bits(64, 32, TCR_EL1, 0, slice(r, 0, 32));
    return()
}

val set_TTBCR2_NS : bits(32) -> unit effect {rreg, wreg}

function set_TTBCR2_NS val_name = {
    let r : bits(32) = val_name;
    TCR_EL1 = __SetSlice_bits(64, 32, TCR_EL1, 32, slice(r, 0, 32));
    return()
}

val __UNKNOWN_SystemHintOp : unit -> SystemHintOp

function __UNKNOWN_SystemHintOp () = {
    SystemHintOp_NOP
}

val SpeculativeSynchronizationBarrierToVA : unit -> unit

function SpeculativeSynchronizationBarrierToVA () = {
    return()
}

val SpeculativeSynchronizationBarrierToPA : unit -> unit

function SpeculativeSynchronizationBarrierToPA () = {
    return()
}

val SpeculationBarrier : unit -> unit

function SpeculationBarrier () = {
    return()
}

register ShouldAdvanceIT : bool

let STDOUT_HANDLE : int(2) = 2

let STDIN_HANDLE : int(1) = 1

let STDERR_HANDLE : int(3) = 3

let STACK_LIMIT : bits(64) = __GetSlice_int(64, 251658240, 0)

let STACK_BASE : bits(64) = __GetSlice_int(64, 268435456, 0)

register SP_EL3 : bits(64)

register SP_EL2 : bits(64)

register SP_EL1 : bits(64)

register SP_EL0 : bits(64)

val get_SPSR_mon : unit -> bits(32) effect {rreg, undef}

function get_SPSR_mon () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(SPSR_EL3, 0, 32));
    r
}

val get_SPSR_hyp : unit -> bits(32) effect {rreg, undef}

function get_SPSR_hyp () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(SPSR_EL2, 0, 32));
    r
}

val get_SPSR_svc : unit -> bits(32) effect {rreg, undef}

function get_SPSR_svc () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(SPSR_EL1, 0, 32));
    r
}

register SPSR_EL0 : bits(32)

val set_SDER : bits(32) -> unit effect {rreg, wreg}

function set_SDER val_name = {
    let r : bits(32) = val_name;
    SDER32_EL3 = __SetSlice_bits(32, 32, SDER32_EL3, 0, slice(r, 0, 32));
    return()
}

register SDER32_EL2 : bits(32)

register SCXTNUM_EL3 : bits(64)

register SCXTNUM_EL2 : bits(64)

register SCXTNUM_EL1 : bits(64)

register SCXTNUM_EL0 : bits(64)

val set_HSCTLR : bits(32) -> unit effect {rreg, wreg}

function set_HSCTLR val_name = {
    let r : bits(32) = val_name;
    SCTLR_EL2 = __SetSlice_bits(64, 32, SCTLR_EL2, 0, slice(r, 0, 32));
    return()
}

val set_SCTLR_NS : bits(32) -> unit effect {rreg, wreg}

function set_SCTLR_NS val_name = {
    let r : bits(32) = val_name;
    SCTLR_EL1 = __SetSlice_bits(64, 32, SCTLR_EL1, 0, slice(r, 0, 32));
    return()
}

val ResetExternalDebugRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit

function ResetExternalDebugRegisters cold_reset = {
    return()
}

register RVBAR_EL3 : bits(64)

register RVBAR_EL2 : bits(64)

register RVBAR_EL1 : bits(64)

register RVBAR : bits(32)

register RNDRRS : bits(64)

register RNDR : bits(64)

register RMUID_EL0 : bits(32)

register RMR_EL3 : bits(32)

register RMR_EL2 : bits(32)

val set_HRMR : bits(32) -> unit effect {rreg, wreg}

function set_HRMR val_name = {
    let r : bits(32) = val_name;
    RMR_EL2 = __SetSlice_bits(32, 32, RMR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HRMR : unit -> bits(32) effect {rreg, undef}

function get_HRMR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(RMR_EL2, 0, 32));
    r
}

register RMR_EL1 : bits(32)

val set_RMR : bits(32) -> unit effect {rreg, wreg}

function set_RMR val_name = {
    let r : bits(32) = val_name;
    RMR_EL1 = __SetSlice_bits(32, 32, RMR_EL1, 0, slice(r, 0, 32));
    RMR_EL3 = __SetSlice_bits(32, 32, RMR_EL3, 0, slice(r, 0, 32));
    return()
}

val get_RMR : unit -> bits(32) effect {rreg, undef}

function get_RMR () = {
    r : bits(32) = undefined : bits(32);
    r = __SetSlice_bits(32, 32, r, 0, slice(RMR_EL1, 0, 32));
    let r = __SetSlice_bits(32, 32, r, 0, slice(RMR_EL3, 0, 32));
    r
}

register RGSR_EL1 : bits(32)

register REVIDR_EL1 : bits(32)

register RD_EL0 : bits(64)

register RC : vector(5, dec, bits(64))

val ProfilingSynchronizationBarrier : unit -> unit effect {escape}

function ProfilingSynchronizationBarrier () = {
    throw(Error_Implementation_Defined("ProfilingSynchronizationBarrier unimplemented"))
}

val __UNKNOWN_PrefetchHint : unit -> PrefetchHint

function __UNKNOWN_PrefetchHint () = {
    Prefetch_READ
}

val __UNKNOWN_PSTATEField : unit -> PSTATEField

function __UNKNOWN_PSTATEField () = {
    PSTATEField_DAIFSet
}

val set_UAO : bits(32) -> unit effect {rreg, wreg}

function set_UAO val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.UAO;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[23]]);
    PSTATE.UAO = __tc1;
    return()
}

val set_TCO : bits(32) -> unit effect {rreg, wreg}

function set_TCO val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.TCO;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[25]]);
    PSTATE.TCO = __tc1;
    return()
}

val set_SSBS : bits(32) -> unit effect {rreg, wreg}

function set_SSBS val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.SSBS;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[12]]);
    PSTATE.SSBS = __tc1;
    return()
}

val set_SPSel : bits(32) -> unit effect {rreg, wreg}

function set_SPSel val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.SP;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[0]]);
    PSTATE.SP = __tc1;
    return()
}

val set_PAN : bits(32) -> unit effect {rreg, wreg}

function set_PAN val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.PAN;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[22]]);
    PSTATE.PAN = __tc1;
    return()
}

val set_NZCV : bits(32) -> unit effect {rreg, wreg}

function set_NZCV val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.C;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[29]]);
    PSTATE.C = __tc1;
    __tc2 : bits(1) = PSTATE.V;
    let __tc2 = __SetSlice_bits(1, 1, __tc2, 0, [r[28]]);
    PSTATE.V = __tc2;
    __tc3 : bits(1) = PSTATE.N;
    let __tc3 = __SetSlice_bits(1, 1, __tc3, 0, [r[31]]);
    PSTATE.N = __tc3;
    __tc4 : bits(1) = PSTATE.Z;
    let __tc4 = __SetSlice_bits(1, 1, __tc4, 0, [r[30]]);
    PSTATE.Z = __tc4;
    return()
}

val set_DIT : bits(32) -> unit effect {rreg, wreg}

function set_DIT val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.DIT;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[24]]);
    PSTATE.DIT = __tc1;
    return()
}

val set_DAIF : bits(32) -> unit effect {rreg, wreg}

function set_DAIF val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(1) = PSTATE.I;
    let __tc1 = __SetSlice_bits(1, 1, __tc1, 0, [r[7]]);
    PSTATE.I = __tc1;
    __tc2 : bits(1) = PSTATE.D;
    let __tc2 = __SetSlice_bits(1, 1, __tc2, 0, [r[9]]);
    PSTATE.D = __tc2;
    __tc3 : bits(1) = PSTATE.F;
    let __tc3 = __SetSlice_bits(1, 1, __tc3, 0, [r[6]]);
    PSTATE.F = __tc3;
    __tc4 : bits(1) = PSTATE.A;
    let __tc4 = __SetSlice_bits(1, 1, __tc4, 0, [r[8]]);
    PSTATE.A = __tc4;
    return()
}

val get_UAO : unit -> bits(32) effect {rreg, undef}

function get_UAO () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 23, [PSTATE.UAO[0]]);
    r
}

val get_TCO : unit -> bits(32) effect {rreg, undef}

function get_TCO () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 25, [PSTATE.TCO[0]]);
    r
}

val get_SSBS : unit -> bits(32) effect {rreg, undef}

function get_SSBS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 12, [PSTATE.SSBS[0]]);
    r
}

val get_SPSel : unit -> bits(32) effect {rreg, undef}

function get_SPSel () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 0, [PSTATE.SP[0]]);
    r
}

val get_PAN : unit -> bits(32) effect {rreg, undef}

function get_PAN () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 22, [PSTATE.PAN[0]]);
    r
}

val get_NZCV : unit -> bits(32) effect {rreg, undef}

function get_NZCV () = {
    r : bits(32) = undefined : bits(32);
    r = __SetSlice_bits(32, 1, r, 29, [PSTATE.C[0]]);
    r = __SetSlice_bits(32, 1, r, 28, [PSTATE.V[0]]);
    r = __SetSlice_bits(32, 1, r, 31, [PSTATE.N[0]]);
    let r = __SetSlice_bits(32, 1, r, 30, [PSTATE.Z[0]]);
    r
}

val get_DIT : unit -> bits(32) effect {rreg, undef}

function get_DIT () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 1, r, 24, [PSTATE.DIT[0]]);
    r
}

val get_DAIF : unit -> bits(32) effect {rreg, undef}

function get_DAIF () = {
    r : bits(32) = undefined : bits(32);
    r = __SetSlice_bits(32, 1, r, 7, [PSTATE.I[0]]);
    r = __SetSlice_bits(32, 1, r, 9, [PSTATE.D[0]]);
    r = __SetSlice_bits(32, 1, r, 6, [PSTATE.F[0]]);
    let r = __SetSlice_bits(32, 1, r, 8, [PSTATE.A[0]]);
    r
}

val get_CurrentEL : unit -> bits(32) effect {rreg, undef}

function get_CurrentEL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 2, r, 2, slice(PSTATE.EL, 0, 2));
    r
}

val __SAVE_EL : bits(2) -> unit effect {rreg, wreg}

function __SAVE_EL __new_exception_level = {
    __saved_exception_level = PSTATE.EL;
    PSTATE.EL = __new_exception_level
}

val __RESTORE_EL : unit -> unit effect {rreg, wreg}

function __RESTORE_EL () = {
    PSTATE.EL = __saved_exception_level
}

register PMXEVTYPER_EL0 : bits(32)

register PMXEVCNTR_EL0 : bits(32)

register PMVIDSR : bits(32)

register PMUSERENR_EL0 : bits(32)

val set_PMUSERENR : bits(32) -> unit effect {rreg, wreg}

function set_PMUSERENR val_name = {
    let r : bits(32) = val_name;
    PMUSERENR_EL0 = __SetSlice_bits(32, 32, PMUSERENR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMUSERENR : unit -> bits(32) effect {rreg, undef}

function get_PMUSERENR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMUSERENR_EL0, 0, 32));
    r
}

register PMSWINC_EL0 : bits(32)

val set_PMSWINC : bits(32) -> unit effect {rreg, wreg}

function set_PMSWINC val_name = {
    let r : bits(32) = val_name;
    PMSWINC_EL0 = __SetSlice_bits(32, 32, PMSWINC_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMSWINC : unit -> bits(32) effect {rreg, undef}

function get_PMSWINC () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMSWINC_EL0, 0, 32));
    r
}

register PMSELR_EL0 : bits(32)

val set_PMSELR : bits(32) -> unit effect {rreg, wreg}

function set_PMSELR val_name = {
    let r : bits(32) = val_name;
    PMSELR_EL0 = __SetSlice_bits(32, 32, PMSELR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMSELR : unit -> bits(32) effect {rreg, undef}

function get_PMSELR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMSELR_EL0, 0, 32));
    r
}

register PMPCSR : bits(64)

register PMOVSSET_EL0 : bits(32)

register PMOVSCLR_EL0 : bits(32)

register PMMIR_EL1 : bits(32)

register PMMIR : bits(32)

register PMLSR : bits(32)

register PMINTENSET_EL1 : bits(32)

register PMINTENCLR_EL1 : bits(32)

register PMEVTYPER_EL0 : vector(33, dec, bits(32))

register PMEVCNTR_EL0 : vector(33, dec, bits(32))

register PMCR_EL0 : bits(32)

val set_PMCR : bits(32) -> unit effect {rreg, wreg}

function set_PMCR val_name = {
    let r : bits(32) = val_name;
    PMCR_EL0 = __SetSlice_bits(32, 32, PMCR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMCR : unit -> bits(32) effect {rreg, undef}

function get_PMCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMCR_EL0, 0, 32));
    r
}

register PMCNTENSET_EL0 : bits(32)

register PMCNTENCLR_EL0 : bits(32)

register PMCEID1_EL0 : bits(64)

register PMCEID0_EL0 : bits(64)

val set_PMCEID0 : bits(32) -> unit effect {rreg, wreg}

function set_PMCEID0 val_name = {
    let r : bits(32) = val_name;
    PMCEID0_EL0 = __SetSlice_bits(64, 32, PMCEID0_EL0, 0, slice(r, 0, 32));
    return()
}

register PMCCNTR_EL0 : bits(64)

register PMCCFILTR_EL0 : bits(32)

val set_PMCCFILTR : bits(32) -> unit effect {rreg, wreg}

function set_PMCCFILTR val_name = {
    let r : bits(32) = val_name;
    PMCCFILTR_EL0 = __SetSlice_bits(32, 32, PMCCFILTR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_PMCCFILTR : unit -> bits(32) effect {rreg, undef}

function get_PMCCFILTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(PMCCFILTR_EL0, 0, 32));
    r
}

register PAR_S : bits(64)

register PAR_EL1 : bits(64)

val set_PAR_NS : bits(64) -> unit effect {rreg, wreg}

function set_PAR_NS val_name = {
    let r : bits(64) = val_name;
    PAR_EL1 = __SetSlice_bits(64, 64, PAR_EL1, 0, slice(r, 0, 64));
    return()
}

val get_PAR_NS : unit -> bits(64) effect {rreg, undef}

function get_PAR_NS () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(PAR_EL1, 0, 64));
    r
}

val PACCellShuffle : bits(64) -> bits(64) effect {undef}

function PACCellShuffle indata = {
    outdata : bits(64) = undefined : bits(64);
    outdata = __SetSlice_bits(64, 4, outdata, 0, slice(indata, 52, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 4, slice(indata, 24, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 8, slice(indata, 44, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 12, slice(indata, 0, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 16, slice(indata, 28, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 20, slice(indata, 48, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 24, slice(indata, 4, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 28, slice(indata, 40, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 32, slice(indata, 32, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 36, slice(indata, 12, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 40, slice(indata, 56, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 44, slice(indata, 20, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 48, slice(indata, 8, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 52, slice(indata, 36, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 56, slice(indata, 16, 4));
    let outdata = __SetSlice_bits(64, 4, outdata, 60, slice(indata, 60, 4));
    outdata
}

val PACCellInvShuffle : bits(64) -> bits(64) effect {undef}

function PACCellInvShuffle indata = {
    outdata : bits(64) = undefined : bits(64);
    outdata = __SetSlice_bits(64, 4, outdata, 0, slice(indata, 12, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 4, slice(indata, 24, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 8, slice(indata, 48, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 12, slice(indata, 36, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 16, slice(indata, 56, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 20, slice(indata, 44, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 24, slice(indata, 4, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 28, slice(indata, 16, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 32, slice(indata, 32, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 36, slice(indata, 52, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 40, slice(indata, 28, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 44, slice(indata, 8, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 48, slice(indata, 20, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 52, slice(indata, 0, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 56, slice(indata, 40, 4));
    let outdata = __SetSlice_bits(64, 4, outdata, 60, slice(indata, 60, 4));
    outdata
}

val set_DBGOSLSR : bits(32) -> unit effect {rreg, wreg}

function set_DBGOSLSR val_name = {
    let r : bits(32) = val_name;
    OSLSR_EL1 = __SetSlice_bits(32, 32, OSLSR_EL1, 0, slice(r, 0, 32));
    return()
}

register OSLAR_EL1 : bits(32)

register OSECCR_EL1 : bits(32)

register OSDTRTX_EL1 : bits(32)

register OSDTRRX_EL1 : bits(32)

val set_DBGOSDLR : bits(32) -> unit effect {rreg, wreg}

function set_DBGOSDLR val_name = {
    let r : bits(32) = val_name;
    OSDLR_EL1 = __SetSlice_bits(32, 32, OSDLR_EL1, 0, slice(r, 0, 32));
    return()
}

register NSACR : bits(32)

val integer_flags_cfinv : unit -> unit effect {rreg, wreg}

function integer_flags_cfinv () = {
    PSTATE.C = ~(PSTATE.C)
}

val __UNKNOWN_MoveWideOp : unit -> MoveWideOp

function __UNKNOWN_MoveWideOp () = {
    MoveWideOp_N
}

val __UNKNOWN_MemOp : unit -> MemOp

function __UNKNOWN_MemOp () = {
    MemOp_LOAD
}

val __UNKNOWN_MemBarrierOp : unit -> MemBarrierOp

function __UNKNOWN_MemBarrierOp () = {
    MemBarrierOp_DSB
}

val __UNKNOWN_MemAtomicOp : unit -> MemAtomicOp

function __UNKNOWN_MemAtomicOp () = {
    MemAtomicOp_ADD
}

val MarkExclusiveGlobal : forall ('processorid : Int) ('size : Int).
  (FullAddress, int('processorid), int('size)) -> unit

function MarkExclusiveGlobal (paddress, processorid, size) = {
    return()
}

register MVFR2_EL1 : bits(32)

val set_MVFR2 : bits(32) -> unit effect {rreg, wreg}

function set_MVFR2 val_name = {
    let r : bits(32) = val_name;
    MVFR2_EL1 = __SetSlice_bits(32, 32, MVFR2_EL1, 0, slice(r, 0, 32));
    return()
}

val get_MVFR2 : unit -> bits(32) effect {rreg, undef}

function get_MVFR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MVFR2_EL1, 0, 32));
    r
}

register MVFR1_EL1 : bits(32)

val set_MVFR1 : bits(32) -> unit effect {rreg, wreg}

function set_MVFR1 val_name = {
    let r : bits(32) = val_name;
    MVFR1_EL1 = __SetSlice_bits(32, 32, MVFR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_MVFR1 : unit -> bits(32) effect {rreg, undef}

function get_MVFR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MVFR1_EL1, 0, 32));
    r
}

register MVFR0_EL1 : bits(32)

val set_MVFR0 : bits(32) -> unit effect {rreg, wreg}

function set_MVFR0 val_name = {
    let r : bits(32) = val_name;
    MVFR0_EL1 = __SetSlice_bits(32, 32, MVFR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_MVFR0 : unit -> bits(32) effect {rreg, undef}

function get_MVFR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MVFR0_EL1, 0, 32));
    r
}

val set_MPIDR : bits(32) -> unit effect {rreg, wreg}

function set_MPIDR val_name = {
    let r : bits(32) = val_name;
    MPIDR_EL1 = __SetSlice_bits(64, 32, MPIDR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_MPIDR : unit -> bits(32) effect {rreg, undef}

function get_MPIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MPIDR_EL1, 0, 32));
    r
}

let MODE_W : bits(2) = 0b01

let MODE_R : bits(2) = 0b00

let MODE_A : bits(2) = 0b10

register MIDR_EL1 : bits(32)

val set_MIDR : bits(32) -> unit effect {rreg, wreg}

function set_MIDR val_name = {
    let r : bits(32) = val_name;
    MIDR_EL1 = __SetSlice_bits(32, 32, MIDR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_MIDR : unit -> bits(32) effect {rreg, undef}

function get_MIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MIDR_EL1, 0, 32));
    r
}

register MDRAR_EL1 : bits(64)

val set_DBGDRAR : bits(64) -> unit effect {rreg, wreg}

function set_DBGDRAR val_name = {
    let r : bits(64) = val_name;
    MDRAR_EL1 = __SetSlice_bits(64, 64, MDRAR_EL1, 0, slice(r, 0, 64));
    return()
}

val get_DBGDRAR : unit -> bits(64) effect {rreg, undef}

function get_DBGDRAR () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(MDRAR_EL1, 0, 64));
    r
}

val set_SDCR : bits(32) -> unit effect {rreg, wreg}

function set_SDCR val_name = {
    let r : bits(32) = val_name;
    MDCR_EL3 = __SetSlice_bits(32, 32, MDCR_EL3, 0, slice(r, 0, 32));
    return()
}

val set_HDCR : bits(32) -> unit effect {rreg, wreg}

function set_HDCR val_name = {
    let r : bits(32) = val_name;
    MDCR_EL2 = __SetSlice_bits(32, 32, MDCR_EL2, 0, slice(r, 0, 32));
    return()
}

register MDCCSR_EL0 : bits(32)

register MDCCINT_EL1 : bits(32)

val set_DBGDCCINT : bits(32) -> unit effect {rreg, wreg}

function set_DBGDCCINT val_name = {
    let r : bits(32) = val_name;
    MDCCINT_EL1 = __SetSlice_bits(32, 32, MDCCINT_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGDCCINT : unit -> bits(32) effect {rreg, undef}

function get_DBGDCCINT () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(MDCCINT_EL1, 0, 32));
    r
}

val __UNKNOWN_MBReqTypes : unit -> MBReqTypes

function __UNKNOWN_MBReqTypes () = {
    MBReqTypes_Reads
}

val __UNKNOWN_MBReqDomain : unit -> MBReqDomain

function __UNKNOWN_MBReqDomain () = {
    MBReqDomain_Nonshareable
}

val set_PRRR_NS : bits(32) -> unit effect {rreg, wreg}

function set_PRRR_NS val_name = {
    let r : bits(32) = val_name;
    MAIR_EL1 = __SetSlice_bits(64, 32, MAIR_EL1, 0, slice(r, 0, 32));
    return()
}

val set_NMRR_NS : bits(32) -> unit effect {rreg, wreg}

function set_NMRR_NS val_name = {
    let r : bits(32) = val_name;
    MAIR_EL1 = __SetSlice_bits(64, 32, MAIR_EL1, 32, slice(r, 0, 32));
    return()
}

val __UNKNOWN_LogicalOp : unit -> LogicalOp

function __UNKNOWN_LogicalOp () = {
    LogicalOp_AND
}

register LORSA_EL1 : bits(64)

register LORN_EL1 : bits(32)

register LORID_EL1 : bits(32)

register LOREA_EL1 : bits(64)

register LORC_EL1 : bits(32)

val IsExclusiveGlobal : forall ('processorid : Int) ('size : Int).
  (FullAddress, int('processorid), int('size)) -> bool

function IsExclusiveGlobal (paddress, processorid, size) = {
    true
}

val asl_Int : forall ('N : Int) ('unsigned : Bool), 'N >= 0.
  (bits('N), bool('unsigned)) -> int

function asl_Int (x, unsigned) = {
    let result = if unsigned then UInt(x) else SInt(x);
    result
}

val InstructionSynchronizationBarrier : unit -> unit

function InstructionSynchronizationBarrier () = {
    __barrier_no_effect(Barrier_ISB)
}

register ISR_EL1 : bits(32)

val set_ISR : bits(32) -> unit effect {rreg, wreg}

function set_ISR val_name = {
    let r : bits(32) = val_name;
    ISR_EL1 = __SetSlice_bits(32, 32, ISR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ISR : unit -> bits(32) effect {rreg, undef}

function get_ISR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ISR_EL1, 0, 32));
    r
}

val get_IFSR_NS : unit -> bits(32) effect {rreg, undef}

function get_IFSR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(IFSR32_EL2, 0, 32));
    r
}

register ID_PFR2_EL1 : bits(32)

val set_ID_PFR2 : bits(32) -> unit effect {rreg, wreg}

function set_ID_PFR2 val_name = {
    let r : bits(32) = val_name;
    ID_PFR2_EL1 = __SetSlice_bits(32, 32, ID_PFR2_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_PFR2 : unit -> bits(32) effect {rreg, undef}

function get_ID_PFR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_PFR2_EL1, 0, 32));
    r
}

register ID_PFR1_EL1 : bits(32)

val set_ID_PFR1 : bits(32) -> unit effect {rreg, wreg}

function set_ID_PFR1 val_name = {
    let r : bits(32) = val_name;
    ID_PFR1_EL1 = __SetSlice_bits(32, 32, ID_PFR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_PFR1 : unit -> bits(32) effect {rreg, undef}

function get_ID_PFR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_PFR1_EL1, 0, 32));
    r
}

register ID_PFR0_EL1 : bits(32)

val set_ID_PFR0 : bits(32) -> unit effect {rreg, wreg}

function set_ID_PFR0 val_name = {
    let r : bits(32) = val_name;
    ID_PFR0_EL1 = __SetSlice_bits(32, 32, ID_PFR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_PFR0 : unit -> bits(32) effect {rreg, undef}

function get_ID_PFR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_PFR0_EL1, 0, 32));
    r
}

register ID_MMFR4_EL1 : bits(32)

val set_ID_MMFR4 : bits(32) -> unit effect {rreg, wreg}

function set_ID_MMFR4 val_name = {
    let r : bits(32) = val_name;
    ID_MMFR4_EL1 = __SetSlice_bits(32, 32, ID_MMFR4_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_MMFR4 : unit -> bits(32) effect {rreg, undef}

function get_ID_MMFR4 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_MMFR4_EL1, 0, 32));
    r
}

register ID_MMFR3_EL1 : bits(32)

val set_ID_MMFR3 : bits(32) -> unit effect {rreg, wreg}

function set_ID_MMFR3 val_name = {
    let r : bits(32) = val_name;
    ID_MMFR3_EL1 = __SetSlice_bits(32, 32, ID_MMFR3_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_MMFR3 : unit -> bits(32) effect {rreg, undef}

function get_ID_MMFR3 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_MMFR3_EL1, 0, 32));
    r
}

register ID_MMFR2_EL1 : bits(32)

val set_ID_MMFR2 : bits(32) -> unit effect {rreg, wreg}

function set_ID_MMFR2 val_name = {
    let r : bits(32) = val_name;
    ID_MMFR2_EL1 = __SetSlice_bits(32, 32, ID_MMFR2_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_MMFR2 : unit -> bits(32) effect {rreg, undef}

function get_ID_MMFR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_MMFR2_EL1, 0, 32));
    r
}

register ID_MMFR1_EL1 : bits(32)

val set_ID_MMFR1 : bits(32) -> unit effect {rreg, wreg}

function set_ID_MMFR1 val_name = {
    let r : bits(32) = val_name;
    ID_MMFR1_EL1 = __SetSlice_bits(32, 32, ID_MMFR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_MMFR1 : unit -> bits(32) effect {rreg, undef}

function get_ID_MMFR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_MMFR1_EL1, 0, 32));
    r
}

register ID_MMFR0_EL1 : bits(32)

val set_ID_MMFR0 : bits(32) -> unit effect {rreg, wreg}

function set_ID_MMFR0 val_name = {
    let r : bits(32) = val_name;
    ID_MMFR0_EL1 = __SetSlice_bits(32, 32, ID_MMFR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_MMFR0 : unit -> bits(32) effect {rreg, undef}

function get_ID_MMFR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_MMFR0_EL1, 0, 32));
    r
}

register ID_ISAR6_EL1 : bits(32)

val set_ID_ISAR6 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR6 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR6_EL1 = __SetSlice_bits(32, 32, ID_ISAR6_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR6 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR6 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR6_EL1, 0, 32));
    r
}

register ID_ISAR5_EL1 : bits(32)

val set_ID_ISAR5 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR5 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR5_EL1 = __SetSlice_bits(32, 32, ID_ISAR5_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR5 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR5 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR5_EL1, 0, 32));
    r
}

register ID_ISAR4_EL1 : bits(32)

val set_ID_ISAR4 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR4 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR4_EL1 = __SetSlice_bits(32, 32, ID_ISAR4_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR4 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR4 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR4_EL1, 0, 32));
    r
}

register ID_ISAR3_EL1 : bits(32)

val set_ID_ISAR3 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR3 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR3_EL1 = __SetSlice_bits(32, 32, ID_ISAR3_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR3 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR3 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR3_EL1, 0, 32));
    r
}

register ID_ISAR2_EL1 : bits(32)

val set_ID_ISAR2 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR2 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR2_EL1 = __SetSlice_bits(32, 32, ID_ISAR2_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR2 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR2_EL1, 0, 32));
    r
}

register ID_ISAR1_EL1 : bits(32)

val set_ID_ISAR1 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR1 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR1_EL1 = __SetSlice_bits(32, 32, ID_ISAR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR1 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR1_EL1, 0, 32));
    r
}

register ID_ISAR0_EL1 : bits(32)

val set_ID_ISAR0 : bits(32) -> unit effect {rreg, wreg}

function set_ID_ISAR0 val_name = {
    let r : bits(32) = val_name;
    ID_ISAR0_EL1 = __SetSlice_bits(32, 32, ID_ISAR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_ISAR0 : unit -> bits(32) effect {rreg, undef}

function get_ID_ISAR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_ISAR0_EL1, 0, 32));
    r
}

register ID_DFR0_EL1 : bits(32)

val set_ID_DFR0 : bits(32) -> unit effect {rreg, wreg}

function set_ID_DFR0 val_name = {
    let r : bits(32) = val_name;
    ID_DFR0_EL1 = __SetSlice_bits(32, 32, ID_DFR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_DFR0 : unit -> bits(32) effect {rreg, undef}

function get_ID_DFR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_DFR0_EL1, 0, 32));
    r
}

register ID_AFR0_EL1 : bits(32)

val set_ID_AFR0 : bits(32) -> unit effect {rreg, wreg}

function set_ID_AFR0 val_name = {
    let r : bits(32) = val_name;
    ID_AFR0_EL1 = __SetSlice_bits(32, 32, ID_AFR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ID_AFR0 : unit -> bits(32) effect {rreg, undef}

function get_ID_AFR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ID_AFR0_EL1, 0, 32));
    r
}

register ID_AA64PFR1_EL1 : bits(32)

register ID_AA64PFR0_EL1 : bits(64)

register ID_AA64MMFR2_EL1 : bits(64)

register ID_AA64MMFR1_EL1 : bits(32)

register ID_AA64MMFR0_EL1 : bits(64)

register ID_AA64ISAR1_EL1 : bits(64)

register ID_AA64ISAR0_EL1 : bits(64)

register ID_AA64DFR1_EL1 : bits(32)

register ID_AA64AFR1_EL1 : bits(32)

register ID_AA64AFR0_EL1 : bits(32)

register ICV_RPR_EL1 : bits(32)

val set_ICV_RPR : bits(32) -> unit effect {rreg, wreg}

function set_ICV_RPR val_name = {
    let r : bits(32) = val_name;
    ICV_RPR_EL1 = __SetSlice_bits(32, 32, ICV_RPR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_RPR : unit -> bits(32) effect {rreg, undef}

function get_ICV_RPR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_RPR_EL1, 0, 32));
    r
}

register ICV_PMR_EL1 : bits(32)

val set_ICV_PMR : bits(32) -> unit effect {rreg, wreg}

function set_ICV_PMR val_name = {
    let r : bits(32) = val_name;
    ICV_PMR_EL1 = __SetSlice_bits(32, 32, ICV_PMR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_PMR : unit -> bits(32) effect {rreg, undef}

function get_ICV_PMR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_PMR_EL1, 0, 32));
    r
}

register ICV_IGRPEN1_EL1 : bits(32)

val set_ICV_IGRPEN1 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_IGRPEN1 val_name = {
    let r : bits(32) = val_name;
    ICV_IGRPEN1_EL1 = __SetSlice_bits(32, 32, ICV_IGRPEN1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_IGRPEN1 : unit -> bits(32) effect {rreg, undef}

function get_ICV_IGRPEN1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_IGRPEN1_EL1, 0, 32));
    r
}

register ICV_IGRPEN0_EL1 : bits(32)

val set_ICV_IGRPEN0 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_IGRPEN0 val_name = {
    let r : bits(32) = val_name;
    ICV_IGRPEN0_EL1 = __SetSlice_bits(32, 32, ICV_IGRPEN0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_IGRPEN0 : unit -> bits(32) effect {rreg, undef}

function get_ICV_IGRPEN0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_IGRPEN0_EL1, 0, 32));
    r
}

register ICV_IAR1_EL1 : bits(32)

val set_ICV_IAR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_IAR1 val_name = {
    let r : bits(32) = val_name;
    ICV_IAR1_EL1 = __SetSlice_bits(32, 32, ICV_IAR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_IAR1 : unit -> bits(32) effect {rreg, undef}

function get_ICV_IAR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_IAR1_EL1, 0, 32));
    r
}

register ICV_IAR0_EL1 : bits(32)

val set_ICV_IAR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_IAR0 val_name = {
    let r : bits(32) = val_name;
    ICV_IAR0_EL1 = __SetSlice_bits(32, 32, ICV_IAR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_IAR0 : unit -> bits(32) effect {rreg, undef}

function get_ICV_IAR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_IAR0_EL1, 0, 32));
    r
}

register ICV_HPPIR1_EL1 : bits(32)

val set_ICV_HPPIR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_HPPIR1 val_name = {
    let r : bits(32) = val_name;
    ICV_HPPIR1_EL1 = __SetSlice_bits(32, 32, ICV_HPPIR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_HPPIR1 : unit -> bits(32) effect {rreg, undef}

function get_ICV_HPPIR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_HPPIR1_EL1, 0, 32));
    r
}

register ICV_HPPIR0_EL1 : bits(32)

val set_ICV_HPPIR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_HPPIR0 val_name = {
    let r : bits(32) = val_name;
    ICV_HPPIR0_EL1 = __SetSlice_bits(32, 32, ICV_HPPIR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_HPPIR0 : unit -> bits(32) effect {rreg, undef}

function get_ICV_HPPIR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_HPPIR0_EL1, 0, 32));
    r
}

register ICV_EOIR1_EL1 : bits(32)

val set_ICV_EOIR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_EOIR1 val_name = {
    let r : bits(32) = val_name;
    ICV_EOIR1_EL1 = __SetSlice_bits(32, 32, ICV_EOIR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_EOIR1 : unit -> bits(32) effect {rreg, undef}

function get_ICV_EOIR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_EOIR1_EL1, 0, 32));
    r
}

register ICV_EOIR0_EL1 : bits(32)

val set_ICV_EOIR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_EOIR0 val_name = {
    let r : bits(32) = val_name;
    ICV_EOIR0_EL1 = __SetSlice_bits(32, 32, ICV_EOIR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_EOIR0 : unit -> bits(32) effect {rreg, undef}

function get_ICV_EOIR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_EOIR0_EL1, 0, 32));
    r
}

register ICV_DIR_EL1 : bits(32)

val set_ICV_DIR : bits(32) -> unit effect {rreg, wreg}

function set_ICV_DIR val_name = {
    let r : bits(32) = val_name;
    ICV_DIR_EL1 = __SetSlice_bits(32, 32, ICV_DIR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_DIR : unit -> bits(32) effect {rreg, undef}

function get_ICV_DIR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_DIR_EL1, 0, 32));
    r
}

register ICV_CTLR_EL1 : bits(32)

val set_ICV_CTLR : bits(32) -> unit effect {rreg, wreg}

function set_ICV_CTLR val_name = {
    let r : bits(32) = val_name;
    ICV_CTLR_EL1 = __SetSlice_bits(32, 32, ICV_CTLR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_CTLR : unit -> bits(32) effect {rreg, undef}

function get_ICV_CTLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_CTLR_EL1, 0, 32));
    r
}

register ICV_BPR1_EL1 : bits(32)

val set_ICV_BPR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_BPR1 val_name = {
    let r : bits(32) = val_name;
    ICV_BPR1_EL1 = __SetSlice_bits(32, 32, ICV_BPR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_BPR1 : unit -> bits(32) effect {rreg, undef}

function get_ICV_BPR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_BPR1_EL1, 0, 32));
    r
}

register ICV_BPR0_EL1 : bits(32)

val set_ICV_BPR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICV_BPR0 val_name = {
    let r : bits(32) = val_name;
    ICV_BPR0_EL1 = __SetSlice_bits(32, 32, ICV_BPR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICV_BPR0 : unit -> bits(32) effect {rreg, undef}

function get_ICV_BPR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICV_BPR0_EL1, 0, 32));
    r
}

register ICV_AP1R_EL1 : vector(5, dec, bits(32))

register ICV_AP0R_EL1 : vector(5, dec, bits(32))

register ICH_VTR_EL2 : bits(32)

val set_ICH_VTR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_VTR val_name = {
    let r : bits(32) = val_name;
    ICH_VTR_EL2 = __SetSlice_bits(32, 32, ICH_VTR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_VTR : unit -> bits(32) effect {rreg, undef}

function get_ICH_VTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_VTR_EL2, 0, 32));
    r
}

register ICH_VMCR_EL2 : bits(32)

val set_ICH_VMCR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_VMCR val_name = {
    let r : bits(32) = val_name;
    ICH_VMCR_EL2 = __SetSlice_bits(32, 32, ICH_VMCR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_VMCR : unit -> bits(32) effect {rreg, undef}

function get_ICH_VMCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_VMCR_EL2, 0, 32));
    r
}

register ICH_MISR_EL2 : bits(32)

val set_ICH_MISR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_MISR val_name = {
    let r : bits(32) = val_name;
    ICH_MISR_EL2 = __SetSlice_bits(32, 32, ICH_MISR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_MISR : unit -> bits(32) effect {rreg, undef}

function get_ICH_MISR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_MISR_EL2, 0, 32));
    r
}

register ICH_HCR_EL2 : bits(32)

val set_ICH_HCR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_HCR val_name = {
    let r : bits(32) = val_name;
    ICH_HCR_EL2 = __SetSlice_bits(32, 32, ICH_HCR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_HCR : unit -> bits(32) effect {rreg, undef}

function get_ICH_HCR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_HCR_EL2, 0, 32));
    r
}

register ICH_ELRSR_EL2 : bits(32)

val set_ICH_ELRSR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_ELRSR val_name = {
    let r : bits(32) = val_name;
    ICH_ELRSR_EL2 = __SetSlice_bits(32, 32, ICH_ELRSR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_ELRSR : unit -> bits(32) effect {rreg, undef}

function get_ICH_ELRSR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_ELRSR_EL2, 0, 32));
    r
}

register ICH_EISR_EL2 : bits(32)

val set_ICH_EISR : bits(32) -> unit effect {rreg, wreg}

function set_ICH_EISR val_name = {
    let r : bits(32) = val_name;
    ICH_EISR_EL2 = __SetSlice_bits(32, 32, ICH_EISR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICH_EISR : unit -> bits(32) effect {rreg, undef}

function get_ICH_EISR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICH_EISR_EL2, 0, 32));
    r
}

register ICH_AP1R_EL2 : vector(5, dec, bits(32))

register ICH_AP0R_EL2 : vector(5, dec, bits(32))

register ICC_SRE_EL3 : bits(32)

val set_ICC_MSRE : bits(32) -> unit effect {rreg, wreg}

function set_ICC_MSRE val_name = {
    let r : bits(32) = val_name;
    ICC_SRE_EL3 = __SetSlice_bits(32, 32, ICC_SRE_EL3, 0, slice(r, 0, 32));
    return()
}

val get_ICC_MSRE : unit -> bits(32) effect {rreg, undef}

function get_ICC_MSRE () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_SRE_EL3, 0, 32));
    r
}

register ICC_SRE_EL2 : bits(32)

val set_ICC_HSRE : bits(32) -> unit effect {rreg, wreg}

function set_ICC_HSRE val_name = {
    let r : bits(32) = val_name;
    ICC_SRE_EL2 = __SetSlice_bits(32, 32, ICC_SRE_EL2, 0, slice(r, 0, 32));
    return()
}

val get_ICC_HSRE : unit -> bits(32) effect {rreg, undef}

function get_ICC_HSRE () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_SRE_EL2, 0, 32));
    r
}

register ICC_SRE_EL1_S : bits(32)

register ICC_SRE_EL1_NS : bits(32)

register ICC_SGI1R_EL1 : bits(64)

val set_ICC_SGI1R : bits(64) -> unit effect {rreg, wreg}

function set_ICC_SGI1R val_name = {
    let r : bits(64) = val_name;
    ICC_SGI1R_EL1 = __SetSlice_bits(64, 64, ICC_SGI1R_EL1, 0, slice(r, 0, 64));
    return()
}

val get_ICC_SGI1R : unit -> bits(64) effect {rreg, undef}

function get_ICC_SGI1R () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(ICC_SGI1R_EL1, 0, 64));
    r
}

register ICC_SGI0R_EL1 : bits(64)

val set_ICC_SGI0R : bits(64) -> unit effect {rreg, wreg}

function set_ICC_SGI0R val_name = {
    let r : bits(64) = val_name;
    ICC_SGI0R_EL1 = __SetSlice_bits(64, 64, ICC_SGI0R_EL1, 0, slice(r, 0, 64));
    return()
}

val get_ICC_SGI0R : unit -> bits(64) effect {rreg, undef}

function get_ICC_SGI0R () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(ICC_SGI0R_EL1, 0, 64));
    r
}

register ICC_RPR_EL1 : bits(32)

val set_ICC_RPR : bits(32) -> unit effect {rreg, wreg}

function set_ICC_RPR val_name = {
    let r : bits(32) = val_name;
    ICC_RPR_EL1 = __SetSlice_bits(32, 32, ICC_RPR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_RPR : unit -> bits(32) effect {rreg, undef}

function get_ICC_RPR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_RPR_EL1, 0, 32));
    r
}

register ICC_PMR_EL1 : bits(32)

val set_ICC_PMR : bits(32) -> unit effect {rreg, wreg}

function set_ICC_PMR val_name = {
    let r : bits(32) = val_name;
    ICC_PMR_EL1 = __SetSlice_bits(32, 32, ICC_PMR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_PMR : unit -> bits(32) effect {rreg, undef}

function get_ICC_PMR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_PMR_EL1, 0, 32));
    r
}

register ICC_IGRPEN1_EL3 : bits(32)

val set_ICC_MGRPEN1 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_MGRPEN1 val_name = {
    let r : bits(32) = val_name;
    ICC_IGRPEN1_EL3 = __SetSlice_bits(32, 32, ICC_IGRPEN1_EL3, 0, slice(r, 0, 32));
    return()
}

val get_ICC_MGRPEN1 : unit -> bits(32) effect {rreg, undef}

function get_ICC_MGRPEN1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_IGRPEN1_EL3, 0, 32));
    r
}

register ICC_IGRPEN1_EL1_S : bits(32)

register ICC_IGRPEN1_EL1_NS : bits(32)

register ICC_IGRPEN0_EL1 : bits(32)

val set_ICC_IGRPEN0 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_IGRPEN0 val_name = {
    let r : bits(32) = val_name;
    ICC_IGRPEN0_EL1 = __SetSlice_bits(32, 32, ICC_IGRPEN0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_IGRPEN0 : unit -> bits(32) effect {rreg, undef}

function get_ICC_IGRPEN0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_IGRPEN0_EL1, 0, 32));
    r
}

register ICC_IAR1_EL1 : bits(32)

val set_ICC_IAR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_IAR1 val_name = {
    let r : bits(32) = val_name;
    ICC_IAR1_EL1 = __SetSlice_bits(32, 32, ICC_IAR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_IAR1 : unit -> bits(32) effect {rreg, undef}

function get_ICC_IAR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_IAR1_EL1, 0, 32));
    r
}

register ICC_IAR0_EL1 : bits(32)

val set_ICC_IAR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_IAR0 val_name = {
    let r : bits(32) = val_name;
    ICC_IAR0_EL1 = __SetSlice_bits(32, 32, ICC_IAR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_IAR0 : unit -> bits(32) effect {rreg, undef}

function get_ICC_IAR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_IAR0_EL1, 0, 32));
    r
}

register ICC_HPPIR1_EL1 : bits(32)

val set_ICC_HPPIR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_HPPIR1 val_name = {
    let r : bits(32) = val_name;
    ICC_HPPIR1_EL1 = __SetSlice_bits(32, 32, ICC_HPPIR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_HPPIR1 : unit -> bits(32) effect {rreg, undef}

function get_ICC_HPPIR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_HPPIR1_EL1, 0, 32));
    r
}

register ICC_HPPIR0_EL1 : bits(32)

val set_ICC_HPPIR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_HPPIR0 val_name = {
    let r : bits(32) = val_name;
    ICC_HPPIR0_EL1 = __SetSlice_bits(32, 32, ICC_HPPIR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_HPPIR0 : unit -> bits(32) effect {rreg, undef}

function get_ICC_HPPIR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_HPPIR0_EL1, 0, 32));
    r
}

register ICC_EOIR1_EL1 : bits(32)

val set_ICC_EOIR1 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_EOIR1 val_name = {
    let r : bits(32) = val_name;
    ICC_EOIR1_EL1 = __SetSlice_bits(32, 32, ICC_EOIR1_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_EOIR1 : unit -> bits(32) effect {rreg, undef}

function get_ICC_EOIR1 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_EOIR1_EL1, 0, 32));
    r
}

register ICC_EOIR0_EL1 : bits(32)

val set_ICC_EOIR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_EOIR0 val_name = {
    let r : bits(32) = val_name;
    ICC_EOIR0_EL1 = __SetSlice_bits(32, 32, ICC_EOIR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_EOIR0 : unit -> bits(32) effect {rreg, undef}

function get_ICC_EOIR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_EOIR0_EL1, 0, 32));
    r
}

register ICC_DIR_EL1 : bits(32)

val set_ICC_DIR : bits(32) -> unit effect {rreg, wreg}

function set_ICC_DIR val_name = {
    let r : bits(32) = val_name;
    ICC_DIR_EL1 = __SetSlice_bits(32, 32, ICC_DIR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_DIR : unit -> bits(32) effect {rreg, undef}

function get_ICC_DIR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_DIR_EL1, 0, 32));
    r
}

register ICC_CTLR_EL3 : bits(32)

val set_ICC_MCTLR : bits(32) -> unit effect {rreg, wreg}

function set_ICC_MCTLR val_name = {
    let r : bits(32) = val_name;
    ICC_CTLR_EL3 = __SetSlice_bits(32, 32, ICC_CTLR_EL3, 0, slice(r, 0, 32));
    return()
}

val get_ICC_MCTLR : unit -> bits(32) effect {rreg, undef}

function get_ICC_MCTLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_CTLR_EL3, 0, 32));
    r
}

register ICC_CTLR_EL1_S : bits(32)

register ICC_CTLR_EL1_NS : bits(32)

register ICC_BPR1_EL1_S : bits(32)

register ICC_BPR1_EL1_NS : bits(32)

register ICC_BPR0_EL1 : bits(32)

val set_ICC_BPR0 : bits(32) -> unit effect {rreg, wreg}

function set_ICC_BPR0 val_name = {
    let r : bits(32) = val_name;
    ICC_BPR0_EL1 = __SetSlice_bits(32, 32, ICC_BPR0_EL1, 0, slice(r, 0, 32));
    return()
}

val get_ICC_BPR0 : unit -> bits(32) effect {rreg, undef}

function get_ICC_BPR0 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ICC_BPR0_EL1, 0, 32));
    r
}

register ICC_ASGI1R_EL1 : bits(64)

val set_ICC_ASGI1R : bits(64) -> unit effect {rreg, wreg}

function set_ICC_ASGI1R val_name = {
    let r : bits(64) = val_name;
    ICC_ASGI1R_EL1 = __SetSlice_bits(64, 64, ICC_ASGI1R_EL1, 0, slice(r, 0, 64));
    return()
}

val get_ICC_ASGI1R : unit -> bits(64) effect {rreg, undef}

function get_ICC_ASGI1R () = {
    r : bits(64) = undefined : bits(64);
    let r = __SetSlice_bits(64, 64, r, 0, slice(ICC_ASGI1R_EL1, 0, 64));
    r
}

register ICC_AP1R_EL1 : vector(5, dec, bits(32))

register ICC_AP0R_EL1 : vector(5, dec, bits(32))

val Hint_Yield : unit -> unit

function Hint_Yield () = {
    return()
}

register HSTR_EL2 : bits(32)

val set_HSTR : bits(32) -> unit effect {rreg, wreg}

function set_HSTR val_name = {
    let r : bits(32) = val_name;
    HSTR_EL2 = __SetSlice_bits(32, 32, HSTR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HSTR : unit -> bits(32) effect {rreg, undef}

function get_HSTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(HSTR_EL2, 0, 32));
    r
}

let HEAP_LIMIT : bits(64) = __GetSlice_int(64, 251658240, 0)

let HEAP_BASE : bits(64) = __GetSlice_int(64, 0, 0)

val set_HCR2 : bits(32) -> unit effect {rreg, wreg}

function set_HCR2 val_name = {
    let r : bits(32) = val_name;
    HCR_EL2 = __SetSlice_bits(64, 32, HCR_EL2, 32, slice(r, 0, 32));
    return()
}

val set_HCR : bits(32) -> unit effect {rreg, wreg}

function set_HCR val_name = {
    let r : bits(32) = val_name;
    HCR_EL2 = __SetSlice_bits(64, 32, HCR_EL2, 0, slice(r, 0, 32));
    return()
}

register HACR_EL2 : bits(32)

register GCR_EL1 : bits(32)

register FPSR : bits(32)

register FPSID : bits(32)

register FPSCR : bits(32)

register FPEXC32_EL2 : bits(32)

val set_FPEXC : bits(32) -> unit effect {rreg, wreg}

function set_FPEXC val_name = {
    let r : bits(32) = val_name;
    FPEXC32_EL2 = __SetSlice_bits(32, 32, FPEXC32_EL2, 0, slice(r, 0, 32));
    return()
}

val get_FPEXC : unit -> bits(32) effect {rreg, undef}

function get_FPEXC () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(FPEXC32_EL2, 0, 32));
    r
}

register FPCR : bits(32)

register FCSEIDR : bits(32)

register FAR_EL0 : bits(64)

val TakeUnmaskedSErrorInterrupts : unit -> unit effect {escape, rreg, undef, wreg}

function TakeUnmaskedSErrorInterrupts () = {
    interrupt_req : InterruptReq = undefined : InterruptReq;
    interrupt_req.take_SE = false;
    interrupt_req.take_vSE = false;
    interrupt_req.take_FIQ = false;
    interrupt_req.take_vFIQ = false;
    interrupt_req.take_IRQ = false;
    interrupt_req.take_vIRQ = false;
    interrupt_req.iesb_req = false;
    interrupt_req.take_SE = true;
    interrupt_req.take_vSE = true;
    let interrupt_taken : bool = TakePendingInterrupts(interrupt_req);
    return()
}

val ExclusiveMonitorsStatus : unit -> bits(1)

function ExclusiveMonitorsStatus () = {
    0b0
}

register EventRegister : bits(1)

val SendEventLocal : unit -> unit effect {wreg}

function SendEventLocal () = {
    EventRegister = 0b1;
    return()
}

val SendEvent : unit -> unit effect {wreg}

function SendEvent () = {
    SendEventLocal();
    return()
}

val get_DFSR_NS : unit -> bits(32) effect {rreg, undef}

function get_DFSR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(ESR_EL1, 0, 32));
    r
}

register ESR_EL0 : bits(32)

register ESP_EL0 : bits(64)

val TweakCellRot : bits(4) -> bits(4) effect {undef}

function TweakCellRot incell_name = {
    outcell : bits(4) = undefined : bits(4);
    outcell = __SetSlice_bits(4, 1, outcell, 3, [incell_name[0]] ^ [incell_name[1]]);
    outcell = __SetSlice_bits(4, 1, outcell, 2, [incell_name[3]]);
    outcell = __SetSlice_bits(4, 1, outcell, 1, [incell_name[2]]);
    let outcell = __SetSlice_bits(4, 1, outcell, 0, [incell_name[1]]);
    outcell
}

val TweakShuffle : bits(64) -> bits(64) effect {undef}

function TweakShuffle indata = {
    outdata : bits(64) = undefined : bits(64);
    outdata = __SetSlice_bits(64, 4, outdata, 0, slice(indata, 16, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 4, slice(indata, 20, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 8, TweakCellRot(slice(indata, 24, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 12, slice(indata, 28, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 16, TweakCellRot(slice(indata, 44, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 20, slice(indata, 8, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 24, slice(indata, 12, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 28, TweakCellRot(slice(indata, 32, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 32, slice(indata, 48, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 36, slice(indata, 52, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 40, slice(indata, 56, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 44, TweakCellRot(slice(indata, 60, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 48, TweakCellRot(slice(indata, 0, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 52, slice(indata, 4, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 56, TweakCellRot(slice(indata, 40, 4)));
    let outdata = __SetSlice_bits(64, 4, outdata, 60, TweakCellRot(slice(indata, 36, 4)));
    outdata
}

val TweakCellInvRot : bits(4) -> bits(4) effect {undef}

function TweakCellInvRot incell_name = {
    outcell : bits(4) = undefined : bits(4);
    outcell = __SetSlice_bits(4, 1, outcell, 3, [incell_name[2]]);
    outcell = __SetSlice_bits(4, 1, outcell, 2, [incell_name[1]]);
    outcell = __SetSlice_bits(4, 1, outcell, 1, [incell_name[0]]);
    let outcell = __SetSlice_bits(4, 1, outcell, 0, [incell_name[0]] ^ [incell_name[3]]);
    outcell
}

val TweakInvShuffle : bits(64) -> bits(64) effect {undef}

function TweakInvShuffle indata = {
    outdata : bits(64) = undefined : bits(64);
    outdata = __SetSlice_bits(64, 4, outdata, 0, TweakCellInvRot(slice(indata, 48, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 4, slice(indata, 52, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 8, slice(indata, 20, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 12, slice(indata, 24, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 16, slice(indata, 0, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 20, slice(indata, 4, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 24, TweakCellInvRot(slice(indata, 8, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 28, slice(indata, 12, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 32, TweakCellInvRot(slice(indata, 28, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 36, TweakCellInvRot(slice(indata, 60, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 40, TweakCellInvRot(slice(indata, 56, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 44, TweakCellInvRot(slice(indata, 16, 4)));
    outdata = __SetSlice_bits(64, 4, outdata, 48, slice(indata, 32, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 52, slice(indata, 36, 4));
    outdata = __SetSlice_bits(64, 4, outdata, 56, slice(indata, 40, 4));
    let outdata = __SetSlice_bits(64, 4, outdata, 60, TweakCellInvRot(slice(indata, 44, 4)));
    outdata
}

register ELR_EL0 : bits(64)

register EDVIDSR : bits(32)

register EDPRSR : bits(32)

register EDPRCR : bits(32)

register EDPFR : bits(64)

register EDPCSR : bits(64)

register EDLSR : bits(32)

register EDESR : bits(32)

register EDECR : bits(32)

register EDECCR : bits(32)

val DecodeShift : bits(2) -> ShiftType

function DecodeShift op = {
    match op {
      0b00 => {
          return(ShiftType_LSL)
      },
      0b01 => {
          return(ShiftType_LSR)
      },
      0b10 => {
          return(ShiftType_ASR)
      },
      0b11 => {
          return(ShiftType_ROR)
      }
    }
}

val DecodeRegExtend : bits(3) -> ExtendType

function DecodeRegExtend op = {
    match op {
      0b000 => {
          return(ExtendType_UXTB)
      },
      0b001 => {
          return(ExtendType_UXTH)
      },
      0b010 => {
          return(ExtendType_UXTW)
      },
      0b011 => {
          return(ExtendType_UXTX)
      },
      0b100 => {
          return(ExtendType_SXTB)
      },
      0b101 => {
          return(ExtendType_SXTH)
      },
      0b110 => {
          return(ExtendType_SXTW)
      },
      0b111 => {
          return(ExtendType_SXTX)
      }
    }
}

let DebugHalt_HaltInstruction : bits(6) = 0b101111

val DataSynchronizationBarrier : (MBReqDomain, MBReqTypes) -> unit

function DataSynchronizationBarrier (domain, types) = {
    __barrier_no_effect(to_barrier_kind(true, domain, types))
}

val DataMemoryBarrier : (MBReqDomain, MBReqTypes) -> unit

function DataMemoryBarrier (domain, types) = {
    __barrier_no_effect(to_barrier_kind(false, domain, types))
}

val system_barriers : (MBReqDomain, MemBarrierOp, MBReqTypes) -> unit

function system_barriers (domain, op, types) = {
    match op {
      MemBarrierOp_DSB => {
          DataSynchronizationBarrier(domain, types)
      },
      MemBarrierOp_DMB => {
          DataMemoryBarrier(domain, types)
      },
      MemBarrierOp_ISB => {
          InstructionSynchronizationBarrier()
      },
      MemBarrierOp_SSBB => {
          SpeculativeSynchronizationBarrierToVA()
      },
      MemBarrierOp_PSSBB => {
          SpeculativeSynchronizationBarrierToPA()
      },
      MemBarrierOp_SB => {
          SpeculationBarrier()
      }
    }
}

val DVP_RCTX : bits(64) -> unit

function DVP_RCTX val_name = {
    return()
}

register DISR_EL1 : bits(64)

val set_DISR : bits(32) -> unit effect {rreg, wreg}

function set_DISR val_name = {
    DISR_EL1 = __SetSlice_bits(64, 32, DISR_EL1, 0, val_name)
}

val DC_CVADP : bits(64) -> unit

function DC_CVADP val_name = {
    return()
}

register DCZID_EL0 : bits(32)

register DBGWFAR : bits(32)

val set_DBGVCR : bits(32) -> unit effect {rreg, wreg}

function set_DBGVCR val_name = {
    let r : bits(32) = val_name;
    DBGVCR32_EL2 = __SetSlice_bits(32, 32, DBGVCR32_EL2, 0, slice(r, 0, 32));
    return()
}

val set_DBGPRCR : bits(32) -> unit effect {rreg, wreg}

function set_DBGPRCR val_name = {
    let r : bits(32) = val_name;
    DBGPRCR_EL1 = __SetSlice_bits(32, 32, DBGPRCR_EL1, 0, slice(r, 0, 32));
    return()
}

register DBGDTR_EL0 : bits(64)

register DBGDTRTX_EL0 : bits(32)

register DBGDTRRX_EL0 : bits(32)

register DBGDSCRint : bits(32)

register DBGDEVID2 : bits(32)

register DBGDEVID1 : bits(32)

register DBGCLAIMSET_EL1 : bits(32)

val set_DBGCLAIMSET : bits(32) -> unit effect {rreg, wreg}

function set_DBGCLAIMSET val_name = {
    let r : bits(32) = val_name;
    DBGCLAIMSET_EL1 = __SetSlice_bits(32, 32, DBGCLAIMSET_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGCLAIMSET : unit -> bits(32) effect {rreg, undef}

function get_DBGCLAIMSET () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DBGCLAIMSET_EL1, 0, 32));
    r
}

register DBGCLAIMCLR_EL1 : bits(32)

val set_DBGCLAIMCLR : bits(32) -> unit effect {rreg, wreg}

function set_DBGCLAIMCLR val_name = {
    let r : bits(32) = val_name;
    DBGCLAIMCLR_EL1 = __SetSlice_bits(32, 32, DBGCLAIMCLR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGCLAIMCLR : unit -> bits(32) effect {rreg, undef}

function get_DBGCLAIMCLR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DBGCLAIMCLR_EL1, 0, 32));
    r
}

register DBGAUTHSTATUS_EL1 : bits(32)

val set_DBGAUTHSTATUS : bits(32) -> unit effect {rreg, wreg}

function set_DBGAUTHSTATUS val_name = {
    let r : bits(32) = val_name;
    DBGAUTHSTATUS_EL1 = __SetSlice_bits(32, 32, DBGAUTHSTATUS_EL1, 0, slice(r, 0, 32));
    return()
}

val get_DBGAUTHSTATUS : unit -> bits(32) effect {rreg, undef}

function get_DBGAUTHSTATUS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(DBGAUTHSTATUS_EL1, 0, 32));
    r
}

val ConsumptionOfSpeculativeDataBarrier : unit -> unit

function ConsumptionOfSpeculativeDataBarrier () = {
    return()
}

val ClearExclusiveLocal : forall ('processorid : Int).
  int('processorid) -> unit effect {undef, wreg}

function ClearExclusiveLocal processorid = {
    /*
    __exclusive_block_address = undefined : bits(52);
    return()
    */
    ()
}

val ClearEventRegister : unit -> unit effect {wreg}

function ClearEventRegister () = {
    EventRegister = 0b0;
    return()
}

register CTR_EL0 : bits(64)

val set_CTR : bits(32) -> unit effect {rreg, wreg}

function set_CTR val_name = {
    let r : bits(32) = val_name;
    CTR_EL0 = __SetSlice_bits(64, 32, CTR_EL0, 0, slice(r, 0, 32));
    return()
}

val get_CTR : unit -> bits(32) effect {rreg, undef}

function get_CTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CTR_EL0, 0, 32));
    r
}

register CSSELR_S : bits(32)

register CSSELR_EL1 : bits(32)

val set_CSSELR_NS : bits(32) -> unit effect {rreg, wreg}

function set_CSSELR_NS val_name = {
    let r : bits(32) = val_name;
    CSSELR_EL1 = __SetSlice_bits(32, 32, CSSELR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CSSELR_NS : unit -> bits(32) effect {rreg, undef}

function get_CSSELR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CSSELR_EL1, 0, 32));
    r
}

register CPTR_EL3 : bits(32)

val CPP_RCTX : bits(64) -> unit

function CPP_RCTX val_name = {
    return()
}

register CPACR_EL1 : bits(32)

val set_CPACR : bits(32) -> unit effect {rreg, wreg}

function set_CPACR val_name = {
    let r : bits(32) = val_name;
    CPACR_EL1 = __SetSlice_bits(32, 32, CPACR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CPACR : unit -> bits(32) effect {rreg, undef}

function get_CPACR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CPACR_EL1, 0, 32));
    r
}

register CNTV_TVAL_EL0 : bits(32)

register CNTV_CVAL_EL0 : bits(64)

register CNTV_CTL_EL0 : bits(32)

val set_CNTV_CTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTV_CTL val_name = {
    let r : bits(32) = val_name;
    CNTV_CTL_EL0 = __SetSlice_bits(32, 32, CNTV_CTL_EL0, 0, slice(r, 0, 32));
    return()
}

val get_CNTV_CTL : unit -> bits(32) effect {rreg, undef}

function get_CNTV_CTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTV_CTL_EL0, 0, 32));
    r
}

register CNTVOFF_EL2 : bits(64)

register CNTVCT_EL0 : bits(64)

register CNTP_TVAL_EL0 : bits(32)

register CNTP_CVAL_EL0 : bits(64)

register CNTP_CTL_S : bits(32)

register CNTP_CTL_EL0 : bits(32)

val set_CNTP_CTL_NS : bits(32) -> unit effect {rreg, wreg}

function set_CNTP_CTL_NS val_name = {
    let r : bits(32) = val_name;
    CNTP_CTL_EL0 = __SetSlice_bits(32, 32, CNTP_CTL_EL0, 0, slice(r, 0, 32));
    return()
}

val get_CNTP_CTL_NS : unit -> bits(32) effect {rreg, undef}

function get_CNTP_CTL_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTP_CTL_EL0, 0, 32));
    r
}

register CNTPS_TVAL_EL1 : bits(32)

register CNTPS_CVAL_EL1 : bits(64)

register CNTPS_CTL_EL1 : bits(32)

register CNTPCT_EL0 : bits(64)

register CNTKCTL_EL1 : bits(32)

val set_CNTKCTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTKCTL val_name = {
    let r : bits(32) = val_name;
    CNTKCTL_EL1 = __SetSlice_bits(32, 32, CNTKCTL_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CNTKCTL : unit -> bits(32) effect {rreg, undef}

function get_CNTKCTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTKCTL_EL1, 0, 32));
    r
}

register CNTHV_TVAL_EL2 : bits(32)

register CNTHV_CVAL_EL2 : bits(64)

register CNTHV_CTL_EL2 : bits(32)

val set_CNTHV_CTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHV_CTL val_name = {
    let r : bits(32) = val_name;
    CNTHV_CTL_EL2 = __SetSlice_bits(32, 32, CNTHV_CTL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHV_CTL : unit -> bits(32) effect {rreg, undef}

function get_CNTHV_CTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHV_CTL_EL2, 0, 32));
    r
}

register CNTHVS_TVAL_EL2 : bits(32)

register CNTHVS_CVAL_EL2 : bits(64)

register CNTHVS_CTL_EL2 : bits(32)

val set_CNTHVS_CTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHVS_CTL val_name = {
    let r : bits(32) = val_name;
    CNTHVS_CTL_EL2 = __SetSlice_bits(32, 32, CNTHVS_CTL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHVS_CTL : unit -> bits(32) effect {rreg, undef}

function get_CNTHVS_CTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHVS_CTL_EL2, 0, 32));
    r
}

register CNTHP_TVAL_EL2 : bits(32)

register CNTHP_CVAL_EL2 : bits(64)

register CNTHP_CTL_EL2 : bits(32)

val set_CNTHP_CTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHP_CTL val_name = {
    let r : bits(32) = val_name;
    CNTHP_CTL_EL2 = __SetSlice_bits(32, 32, CNTHP_CTL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHP_CTL : unit -> bits(32) effect {rreg, undef}

function get_CNTHP_CTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHP_CTL_EL2, 0, 32));
    r
}

register CNTHPS_TVAL_EL2 : bits(32)

register CNTHPS_CVAL_EL2 : bits(64)

register CNTHPS_CTL_EL2 : bits(32)

val set_CNTHPS_CTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHPS_CTL val_name = {
    let r : bits(32) = val_name;
    CNTHPS_CTL_EL2 = __SetSlice_bits(32, 32, CNTHPS_CTL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHPS_CTL : unit -> bits(32) effect {rreg, undef}

function get_CNTHPS_CTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHPS_CTL_EL2, 0, 32));
    r
}

register CNTFRQ_EL0 : bits(32)

register CLIDR_EL1 : bits(64)

val set_CLIDR : bits(32) -> unit effect {rreg, wreg}

function set_CLIDR val_name = {
    let r : bits(32) = val_name;
    CLIDR_EL1 = __SetSlice_bits(64, 32, CLIDR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CLIDR : unit -> bits(32) effect {rreg, undef}

function get_CLIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CLIDR_EL1, 0, 32));
    r
}

val CFP_RCTX : bits(64) -> unit

function CFP_RCTX val_name = {
    return()
}

register configuration CFG_RMR_AA64 : bits(1) = 0b1

register CCSIDR2_EL1 : bits(32)

val set_CCSIDR2 : bits(32) -> unit effect {rreg, wreg}

function set_CCSIDR2 val_name = {
    let r : bits(32) = val_name;
    CCSIDR2_EL1 = __SetSlice_bits(32, 32, CCSIDR2_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CCSIDR2 : unit -> bits(32) effect {rreg, undef}

function get_CCSIDR2 () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CCSIDR2_EL1, 0, 32));
    r
}

val __UNKNOWN_BranchType : unit -> BranchType

function __UNKNOWN_BranchType () = {
    BranchType_DIRCALL
}

register BTypeNext : bits(2)

register BTypeCompatible : bool

register APIBKeyLo_EL1 : bits(64)

register APIBKeyHi_EL1 : bits(64)

register APIAKeyLo_EL1 : bits(64)

register APIAKeyHi_EL1 : bits(64)

register APGAKeyLo_EL1 : bits(64)

register APGAKeyHi_EL1 : bits(64)

register APDBKeyLo_EL1 : bits(64)

register APDBKeyHi_EL1 : bits(64)

register APDAKeyLo_EL1 : bits(64)

register APDAKeyHi_EL1 : bits(64)

val get_TargetCPU : unit -> bits(32) effect {rreg}

function get_TargetCPU () = {
    val_name : bits(32) = _TargetCPU;
    let val_name = val_name & ~(__GetSlice_int(32, 4294967280, 0)) | __GetSlice_int(32, 0, 0);
    val_name
}

val system_register_cpsr : (PSTATEField, bits(4)) -> unit effect {rreg, wreg}

function system_register_cpsr (field, operand) = {
    match field {
      PSTATEField_SP => {
          PSTATE.SP = [operand[0]]
      },
      PSTATEField_DAIFSet => {
          PSTATE.D = PSTATE.D | [operand[3]];
          PSTATE.A = PSTATE.A | [operand[2]];
          PSTATE.I = PSTATE.I | [operand[1]];
          PSTATE.F = PSTATE.F | [operand[0]]
      },
      PSTATEField_DAIFClr => {
          PSTATE.D = PSTATE.D & ~([operand[3]]);
          PSTATE.A = PSTATE.A & ~([operand[2]]);
          PSTATE.I = PSTATE.I & ~([operand[1]]);
          PSTATE.F = PSTATE.F & ~([operand[0]])
      },
      PSTATEField_PAN => {
          PSTATE.PAN = [operand[0]]
      },
      PSTATEField_UAO => {
          PSTATE.UAO = [operand[0]]
      },
      PSTATEField_DIT => {
          PSTATE.DIT = [operand[0]]
      }
    }
}

val integer_flags_xaflag : unit -> unit effect {rreg, wreg}

function integer_flags_xaflag () = {
    let N = ~(PSTATE.C) & ~(PSTATE.Z);
    let Z = PSTATE.Z & PSTATE.C;
    let C = PSTATE.C | PSTATE.Z;
    let V = ~(PSTATE.C) & PSTATE.Z;
    PSTATE.N = N;
    PSTATE.Z = Z;
    PSTATE.C = C;
    PSTATE.V = V
}

val integer_flags_axflag : unit -> unit effect {rreg, wreg}

function integer_flags_axflag () = {
    let N = 0b0;
    let Z = PSTATE.Z | PSTATE.V;
    let C = PSTATE.C & ~(PSTATE.V);
    let V = 0b0;
    PSTATE.N = N;
    PSTATE.Z = Z;
    PSTATE.C = C;
    PSTATE.V = V
}

register AMAIR_EL3 : bits(64)

register AMAIR_EL2 : bits(64)

register AMAIR_EL1 : bits(64)

register AIDR_EL1 : bits(32)

register AFSR1_EL3 : bits(32)

register AFSR1_EL2 : bits(32)

register AFSR1_EL1 : bits(32)

register AFSR0_EL3 : bits(32)

register AFSR0_EL2 : bits(32)

register AFSR0_EL1 : bits(32)

register ACTLR_EL3 : bits(64)

register ACTLR_EL2 : bits(64)

register ACTLR_EL1 : bits(64)

val AArch64_ReportDeferredSError : bits(25) -> bits(64) effect {undef}

function AArch64_ReportDeferredSError syndrome = {
    target : bits(64) = undefined : bits(64);
    target = __SetSlice_bits(64, 1, target, 31, 0b1);
    target = __SetSlice_bits(64, 1, target, 24, [syndrome[24]]);
    let target = __SetSlice_bits(64, 24, target, 0, slice(syndrome, 0, 24));
    target
}

val AArch64_MarkExclusiveVA : forall ('processorid : Int) ('size : Int).
  (bits(64), int('processorid), int('size)) -> unit

function AArch64_MarkExclusiveVA (address, processorid, size) = {
    return()
}

val AArch64_IsExclusiveVA : forall ('processorid : Int) ('size : Int).
  (bits(64), int('processorid), int('size)) -> bool

function AArch64_IsExclusiveVA (address, processorid, size) = {
    true
}

val AArch32_CurrentCond : unit -> bits(4) effect {rreg}

function AArch32_CurrentCond () = {
    __currentCond
}

val aget_SP : forall ('width : Int).
  implicit('width) -> bits('width) effect {escape, rreg}

function aget_SP width = {
    assert('width == 8 | 'width == 16 | 'width == 32 | 'width == 64);
    if PSTATE.SP == 0b0 then {
        return(slice(SP_EL0, 0, 'width))
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              return(slice(SP_EL0, 0, 'width))
          },
          ? if ? == EL1 => {
              return(slice(SP_EL1, 0, 'width))
          },
          ? if ? == EL2 => {
              return(slice(SP_EL2, 0, 'width))
          },
          ? if ? == EL3 => {
              return(slice(SP_EL3, 0, 'width))
          }
        }
    }
}

overload SP = {aget_SP}

val VAMax : unit -> int effect {escape}

function VAMax () = {
    __IMPDEF_integer("Maximum Virtual Address Size")
}

val set_HTCR : bits(32) -> unit effect {rreg, wreg}

function set_HTCR val_name = {
    let r : bits(32) = val_name;
    TCR_EL2 = __SetSlice_bits(64, 32, TCR_EL2, 0, slice(r, 0, 32));
    return()
}

val RoundTowardsZero : real -> int

function RoundTowardsZero x = {
    if x == 0.0 then 0 else if x >= 0.0 then RoundDown(x) else RoundUp(x)
}

val Restarting : unit -> bool effect {rreg}

function Restarting () = {
    slice(EDSCR, 0, 6) == 0b000001
}

val PtrHasUpperAndLowerAddRanges : unit -> bool effect {rreg}

function PtrHasUpperAndLowerAddRanges () = {
    (PSTATE.EL == EL1 | PSTATE.EL == EL0) | PSTATE.EL == EL2 & [HCR_EL2[34]] == 0b1
}

val PARShareabilityDecode : MemoryAttributes -> bits(2) effect {undef}

function PARShareabilityDecode memattrs = {
    result : bits(2) = undefined : bits(2);
    if memattrs.outer.attrs == MemAttr_NC & memattrs.inner.attrs == MemAttr_NC | memattrs.outershareable then {
        result = 0b10
    } else {
        if memattrs.shareable then {
            result = 0b11
        } else {
            result = 0b00
        }
    };
    result
}

val PARAttrsDecode : MemoryAttributes -> bits(8) effect {undef}

function PARAttrsDecode memattrs = {
    result : bits(8) = undefined : bits(8);
    if memattrs.typ == MemType_Device then {
        result = __SetSlice_bits(8, 4, result, 4, 0x0);
        if memattrs.device == DeviceType_nGnRnE then {
            result = __SetSlice_bits(8, 4, result, 0, 0x0)
        } else {
            if memattrs.device == DeviceType_nGnRE then {
                result = __SetSlice_bits(8, 4, result, 0, 0x4)
            } else {
                if memattrs.device == DeviceType_nGRE then {
                    result = __SetSlice_bits(8, 4, result, 0, 0x8)
                } else {
                    result = __SetSlice_bits(8, 4, result, 0, 0xC)
                }
            }
        }
    } else {
        if memattrs.outer.attrs == MemAttr_WT then {
            result = __SetSlice_bits(8, 2, result, 6, if memattrs.outer.transient then 0b00 else 0b10);
            result = __SetSlice_bits(8, 2, result, 4, memattrs.outer.hints)
        } else {
            if memattrs.outer.attrs == MemAttr_WB then {
                result = __SetSlice_bits(8, 2, result, 6, if memattrs.outer.transient then 0b01 else 0b11);
                result = __SetSlice_bits(8, 2, result, 4, memattrs.outer.hints)
            } else {
                result = __SetSlice_bits(8, 4, result, 4, 0x4)
            }
        };
        if memattrs.inner.attrs == MemAttr_WT then {
            result = __SetSlice_bits(8, 2, result, 2, if memattrs.inner.transient then 0b00 else 0b10);
            result = __SetSlice_bits(8, 2, result, 0, memattrs.inner.hints)
        } else {
            if memattrs.inner.attrs == MemAttr_WB then {
                result = __SetSlice_bits(8, 2, result, 2, if memattrs.inner.transient then 0b01 else 0b11);
                result = __SetSlice_bits(8, 2, result, 0, memattrs.inner.hints)
            } else {
                result = __SetSlice_bits(8, 4, result, 0, 0x4)
            }
        }
    };
    result
}

val IsEventRegisterSet : unit -> bool effect {rreg}

function IsEventRegisterSet () = {
    EventRegister == 0b1
}

val HaveUA16Ext : unit -> bool

function HaveUA16Ext () = {
    HasArchVersion(ARMv8p4)
}

val HaveStatisticalProfiling : unit -> bool

function HaveStatisticalProfiling () = {
    HasArchVersion(ARMv8p2)
}

val HaveSelfHostedTrace : unit -> bool

function HaveSelfHostedTrace () = {
    HasArchVersion(ARMv8p4)
}

val HaveFlagManipulateExt : unit -> bool

function HaveFlagManipulateExt () = {
    HasArchVersion(ARMv8p4)
}

val HaveFlagFormatExt : unit -> bool

function HaveFlagFormatExt () = {
    HasArchVersion(ARMv8p5)
}

val HaveExtendedCacheSets : unit -> bool

function HaveExtendedCacheSets () = {
    HasArchVersion(ARMv8p3)
}

register CCSIDR_EL1 : bits(64)

val set_CCSIDR : bits(32) -> unit effect {rreg, wreg}

function set_CCSIDR val_name = {
    let r : bits(32) = val_name;
    CCSIDR_EL1 = __SetSlice_bits(64, 32, CCSIDR_EL1, 0, slice(r, 0, 32));
    return()
}

val get_CCSIDR : unit -> bits(32) effect {rreg, undef}

function get_CCSIDR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CCSIDR_EL1, 0, 32));
    r
}

val HaveCRCExt : unit -> bool effect {escape}

function HaveCRCExt () = {
    HasArchVersion(ARMv8p1) | __IMPDEF_boolean("Have CRC extension")
}

val HaveAtomicExt : unit -> bool

function HaveAtomicExt () = {
    HasArchVersion(ARMv8p1)
}

register CPTR_EL2 : bits(32)

val set_HCPTR : bits(32) -> unit effect {rreg, wreg}

function set_HCPTR val_name = {
    let r : bits(32) = val_name;
    CPTR_EL2 = __SetSlice_bits(32, 32, CPTR_EL2, 0, slice(r, 0, 32));
    return()
}

val get_HCPTR : unit -> bits(32) effect {rreg, undef}

function get_HCPTR () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CPTR_EL2, 0, 32));
    r
}

register CNTHCTL_EL2 : bits(32)

val set_CNTHCTL : bits(32) -> unit effect {rreg, wreg}

function set_CNTHCTL val_name = {
    let r : bits(32) = val_name;
    CNTHCTL_EL2 = __SetSlice_bits(32, 32, CNTHCTL_EL2, 0, slice(r, 0, 32));
    return()
}

val get_CNTHCTL : unit -> bits(32) effect {rreg, undef}

function get_CNTHCTL () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(CNTHCTL_EL2, 0, 32));
    r
}

val aset_Q : forall ('n : Int), ('n >= 0 & 'n <= 15).
  (int('n), bits(128)) -> unit effect {escape, wreg}

function aset_Q (n, value_name) = {
    assert(n >= 0 & n <= 15);
    _V[n] = value_name;
    return()
}

overload Q = {aset_Q}

val AArch32_ResetSIMDFPRegisters : unit -> unit effect {escape, undef, wreg}

function AArch32_ResetSIMDFPRegisters () = {
    foreach (i from 0 to 15 by 1 in inc) {
        Q(i) = undefined : bits(128)
    };
    return()
}

val aget_V : forall ('width : Int) ('n : Int), ('n >= 0 & 'n <= 31).
  (implicit('width), int('n)) -> bits('width) effect {escape, rreg}

function aget_V (width, n) = {
    assert(n >= 0 & n <= 31);
    assert('width == 8 | 'width == 16 | 'width == 32 | 'width == 64 | 'width == 128);
    slice(_V[n], 0, 'width)
}

overload V = {aget_V}

val HighestSetBit : forall ('N : Int), 'N >= 0.
  bits('N) -> {'n, (-1 <= 'n & 'n <= 'N - 1). int('n)}

function HighestSetBit x = {
    foreach (i from ('N - 1) to 0 by 1 in dec) {
        if [x[i]] == 0b1 then {
            return(i)
        }
    };
    negate(1)
}

val BitReverse : forall ('N : Int), 'N >= 0. bits('N) -> bits('N) effect {undef}

function BitReverse data = {
    result : bits('N) = undefined : bits('N);
    foreach (i from 0 to ('N - 1) by 1 in inc) {
        result = __SetSlice_bits('N, 1, result, 'N - i - 1, [data[i]])
    };
    result
}

val Hint_Prefetch : forall ('target : Int) ('stream : Bool).
  (bits(64), PrefetchHint, int('target), bool('stream)) -> unit effect {undef}

function Hint_Prefetch (address, hint, target, stream) = {
    op : string = undefined : string;
    match hint {
      Prefetch_READ => {
          op = "READ"
      },
      Prefetch_WRITE => {
          op = "WRITE"
      },
      Prefetch_EXEC => {
          op = "EXEC"
      },
      _ => {
          op = "UNKNOWN"
      }
    };
    let op = op;
    let msg : string = "Prefetch" ++ " address=0x" ++ HexStr(UInt(address)) ++ " op=" ++ op ++ " target=" ++ target ++ " stream=" ++ stream;
    __tarmacEvent(msg);
    return()
}

val NextInstrAddr : forall ('N : Int), (0 <= 'N & 'N <= 64).
  implicit('N) -> bits('N) effect {rreg}

function NextInstrAddr N = slice(_PC + __currentInstrLength, 0, N)

val CountLeadingZeroBits : forall ('N : Int), 'N >= 0. bits('N) -> int

function CountLeadingZeroBits x = {
    'N - (HighestSetBit(x) + 1)
}

val CountLeadingSignBits : forall ('N : Int), 'N >= 1. bits('N) -> int

function CountLeadingSignBits x = CountLeadingZeroBits(slice(x, 1, 'N - 1) ^ slice(x, 0, 'N - 1))

val RotCell : forall ('amount : Int).
  (bits(4), int('amount)) -> bits(4) effect {undef}

function RotCell (incell_name, amount) = {
    tmp : bits(8) = undefined : bits(8);
    outcell : bits(4) = undefined : bits(4);
    let tmp = __SetSlice_bits(8, 8, tmp, 0, slice(incell_name, 0, 4) @ slice(incell_name, 0, 4));
    let outcell = slice(tmp, 4 - amount, 4);
    outcell
}

val ProcessorID : unit -> int effect {rreg}

function ProcessorID () = {
    UInt(((slice(MPIDR_EL1, 32, 8) @ slice(MPIDR_EL1, 16, 8)) @ slice(MPIDR_EL1, 8, 8)) @ slice(MPIDR_EL1, 0, 8))
}

val system_monitors : unit -> unit effect {rreg, undef, wreg}

function system_monitors () = {
    ClearExclusiveLocal(ProcessorID())
}

val NextRandomTagBit : unit -> bits(1) effect {rreg, wreg}

function NextRandomTagBit () = {
    let lfsr = slice(RGSR_EL1, 8, 16);
    let top : bits(1) = (([lfsr[5]] ^ [lfsr[3]]) ^ [lfsr[2]]) ^ [lfsr[0]];
    RGSR_EL1 = __SetSlice_bits(32, 16, RGSR_EL1, 8, top @ slice(lfsr, 1, 15));
    top
}

val RandomTag : unit -> bits(4) effect {rreg, undef, wreg}

function RandomTag () = {
    tag : bits(4) = undefined : bits(4);
    foreach (i from 0 to 3 by 1 in inc) {
        tag = __SetSlice_bits(4, 1, tag, i, NextRandomTagBit())
    };
    tag
}

val MakeLSInstructionSyndrome : forall 'size ('sign_extend : Bool) 'Rt ('sixty_four : Bool) ('acq_rel : Bool),
  ('size in {1, 2, 4, 8} & 0 <= 'Rt & 'Rt <= 31).
  (int('size), bool('sign_extend), int('Rt), bool('sixty_four), bool('acq_rel)) -> bits(11) effect {escape, undef}

function MakeLSInstructionSyndrome (size, sign_extend, Rt, sixty_four, acq_rel) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8);
    assert(0 <= Rt & Rt <= 31);
    sz : bits(2) = undefined : bits(2);
    match size {
      1 => {
          sz = 0b00
      },
      2 => {
          sz = 0b01
      },
      4 => {
          sz = 0b10
      },
      8 => {
          sz = 0b11
      }
    };
    let sz = sz;
    let ext = if sign_extend then 0b1 else 0b0;
    let sf = if sixty_four then 0b1 else 0b0;
    let ar = if acq_rel then 0b1 else 0b0;
    ((((0b1 @ sz) @ ext) @ __GetSlice_int(5, Rt, 0)) @ sf) @ ar
}

val AArch64_SetLSInstructionSyndrome : forall 'size 'Rt,
  ('size in {1, 2, 4, 8} & 0 <= 'Rt & 'Rt <= 31).
  (int('size), bool, int('Rt), bool, bool) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SetLSInstructionSyndrome (size, sign_extend, Rt, sixty_four, acq_rel) = {
    if PSTATE.EL == EL0 | PSTATE.EL == EL1 then {
        __LSISyndrome = MakeLSInstructionSyndrome(size, sign_extend, Rt, sixty_four, acq_rel)
    }
}

val AArch64_PARFaultStatus : FaultRecord -> bits(6) effect {escape, undef}

function AArch64_PARFaultStatus fault = {
    fst : bits(6) = undefined : bits(6);
    if fault.typ == Fault_Domain then {
        assert(fault.level == 1 | fault.level == 2);
        fst = __SetSlice_bits(6, 2, fst, 0, if fault.level == 1 then 0b01 else 0b10);
        fst = __SetSlice_bits(6, 4, fst, 2, 0xF)
    } else {
        fst = EncodeLDFSC(fault.typ, fault.level)
    };
    fst
}

val AllocationTagFromAddress : bits(64) -> bits(4)

function AllocationTagFromAddress tagged_address = {
    let logical_tag : bits(4) = slice(tagged_address, 56, 4);
    let tag : bits(4) = logical_tag + (0b000 @ [tagged_address[55]]);
    tag
}

val AddressWithAllocationTag : (bits(64), bits(4)) -> bits(64)

function AddressWithAllocationTag (address, allocation_tag) = {
    result : bits(64) = address;
    let tag = allocation_tag - (0b000 @ [address[55]]);
    let result = __SetSlice_bits(64, 4, result, 56, tag);
    result
}

val aset_Elem__0 : forall 'N 'size 'e,
  ('N >= 0 & 'size >= 0).
  (bits('N), int('e), bits('size)) -> bits('N) effect {escape}

val aset_Elem__1 : forall 'N 'size 'e,
  ('N >= 0 & 'size >= 0).
  (bits('N), int('e), int('size), bits('size)) -> bits('N) effect {escape}

overload aset_Elem = {aset_Elem__0, aset_Elem__1}

overload Elem = {aset_Elem__0, aset_Elem__1}

function aset_Elem__0 (vector_name, e, value_name) = {
    let vector_name = aset_Elem(vector_name, e, 'size, value_name);
    vector_name
}

function aset_Elem__1 (vector_name, e, size, value_name) = {
    assert(e >= 0 & (e + 1) * size <= 'N);
    let vector_name = __SetSlice_bits('N, size, vector_name, e * size, value_name);
    vector_name
}

val aget_Elem__0 : forall 'N 'e 'size,
  ('N >= 0 & 'size >= 0).
  (implicit('size), bits('N), int('e)) -> bits('size)

val aget_Elem__1 : forall 'N 'e 'size,
  ('N >= 0 & 'size >= 0).
  (bits('N), int('e), int('size)) -> bits('size)

overload aget_Elem = {aget_Elem__0, aget_Elem__1}

function aget_Elem__0 (size, vector_name, e) = aget_Elem__1(vector_name, e, size)

function aget_Elem__1 (vector_name, e, size) = {
    slice(vector_name, e * size, size)
}

val TLBReset : unit -> unit effect {rreg, wreg}

function TLBReset () = {
    if TLBHits + TLBMisses > 0 then {
        prerr("TLB reset, so far hit rate is ");
        prerr(TLBHits);
        prerr("/");
        prerr(TLBHits + TLBMisses);
        prerr(" == ");
        prerr(100 * TLBHits / (TLBHits + TLBMisses));
        println()
    } else {
        prerr("TLB reset (no requests were made)");
        println()
    };
    TLBHits = 0;
    TLBMisses = 0;
    foreach (i from 0 to (shl_int(1, 10) - 1) by 1 in inc) {
        __tc1 : TLBLine = _TLB[i];
        __tc1.valid_name = false;
        _TLB[i] = __tc1
    }
}

val _TLB_Invalidate : unit -> unit effect {rreg, wreg}

function _TLB_Invalidate () = {
    TLBReset();
    return()
}

val TLBI_VMALLS12E1OS : unit -> unit effect {rreg, wreg}

function TLBI_VMALLS12E1OS () = {
    _TLB_Invalidate()
}

val TLBI_VMALLS12E1IS : unit -> unit effect {rreg, wreg}

function TLBI_VMALLS12E1IS () = {
    _TLB_Invalidate()
}

val TLBI_VMALLS12E1 : unit -> unit effect {rreg, wreg}

function TLBI_VMALLS12E1 () = {
    _TLB_Invalidate()
}

val TLBI_VMALLE1OS : unit -> unit effect {rreg, wreg}

function TLBI_VMALLE1OS () = {
    _TLB_Invalidate()
}

val TLBI_VMALLE1IS : unit -> unit effect {rreg, wreg}

function TLBI_VMALLE1IS () = {
    _TLB_Invalidate()
}

val TLBI_VMALLE1 : unit -> unit effect {rreg, wreg}

function TLBI_VMALLE1 () = {
    _TLB_Invalidate()
}

val TLBI_VALE3OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE3OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VALE3IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE3IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VALE3 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE3 val_name = {
    _TLB_Invalidate()
}

val TLBI_VALE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VALE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VALE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VALE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE3OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE3OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE3IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE3IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE3 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE3 val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_VAALE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAALE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAALE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAALE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAALE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAALE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_VAAE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAAE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAAE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAAE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_VAAE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_VAAE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVALE3IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVALE3IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVALE3 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVALE3 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVALE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVALE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVALE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVALE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVALE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVALE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE3OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE3OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE3IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE3IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE3 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE3 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAALE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAALE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAALE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAALE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAALE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAALE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAAE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAAE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAAE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAAE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RVAAE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RVAAE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2LE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2LE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2LE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2LE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2LE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2LE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2E1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2E1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2E1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2E1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_RIPAS2E1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_RIPAS2E1 val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2LE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2LE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2LE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2LE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2LE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2LE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2E1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2E1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2E1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2E1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_IPAS2E1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_IPAS2E1 val_name = {
    _TLB_Invalidate()
}

val TLBI_ASIDE1OS : bits(64) -> unit effect {rreg, wreg}

function TLBI_ASIDE1OS val_name = {
    _TLB_Invalidate()
}

val TLBI_ASIDE1IS : bits(64) -> unit effect {rreg, wreg}

function TLBI_ASIDE1IS val_name = {
    _TLB_Invalidate()
}

val TLBI_ASIDE1 : bits(64) -> unit effect {rreg, wreg}

function TLBI_ASIDE1 val_name = {
    _TLB_Invalidate()
}

val TLBI_ALLE3OS : unit -> unit effect {rreg, wreg}

function TLBI_ALLE3OS () = {
    _TLB_Invalidate()
}

val TLBI_ALLE3IS : unit -> unit effect {rreg, wreg}

function TLBI_ALLE3IS () = {
    _TLB_Invalidate()
}

val TLBI_ALLE3 : unit -> unit effect {rreg, wreg}

function TLBI_ALLE3 () = {
    _TLB_Invalidate()
}

val TLBI_ALLE1OS : unit -> unit effect {rreg, wreg}

function TLBI_ALLE1OS () = {
    _TLB_Invalidate()
}

val TLBI_ALLE1IS : unit -> unit effect {rreg, wreg}

function TLBI_ALLE1IS () = {
    _TLB_Invalidate()
}

val TLBI_ALLE1 : unit -> unit effect {rreg, wreg}

function TLBI_ALLE1 () = {
    _TLB_Invalidate()
}

val aset_V : forall ('width : Int) ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits('width)) -> unit effect {escape, wreg}

function aset_V (n, value_name) = {
    assert('width == 8 | 'width == 16 | 'width == 32 | 'width == 64 | 'width == 128);
    _V[n] = ZeroExtend(value_name, 128)
}

overload V = {aset_V}

val AArch64_ResetSIMDFPRegisters : unit -> unit effect {escape, undef, wreg}

function AArch64_ResetSIMDFPRegisters () = {
    foreach (i from 0 to 31 by 1 in inc) {
        V(i) = undefined : bits(128)
    };
    return()
}

val aset_SP : forall ('width : Int), 'width >= 0.
  bits('width) -> unit effect {escape, rreg, wreg}

function aset_SP value_name = {
    assert('width == 32 | 'width == 64);
    if PSTATE.SP == 0b0 then {
        SP_EL0 = ZeroExtend(value_name)
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              SP_EL0 = ZeroExtend(value_name)
          },
          ? if ? == EL1 => {
              SP_EL1 = ZeroExtend(value_name)
          },
          ? if ? == EL2 => {
              SP_EL2 = ZeroExtend(value_name)
          },
          ? if ? == EL3 => {
              SP_EL3 = ZeroExtend(value_name)
          }
        }
    };
    return()
}

overload SP = {aset_SP}

val aset__MemTag : (AddressDescriptor, bits(4)) -> unit effect {escape, rreg, undef, wmem}

function aset__MemTag (desc, value_name) = {
    let offset : bits(64) = ZeroExtend(desc.paddress.address);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let tag_index : bits(64) = LSR(offset, log2_tag_granule);
    let tagaddress : bits(56) = TAG_STORE_AREA + slice(tag_index, 0, 56);
    // CHECK: Is it AccType_NORMAL though?
    __WriteMemory(AccType_NORMAL, 1, ZeroExtend(tagaddress), 0x0 @ value_name)
}

overload _MemTag = {aset__MemTag}

val Poly32Mod2 : forall ('N : Int), 'N >= 0.
  (bits('N), bits(32)) -> bits(32) effect {escape}

function Poly32Mod2 (data__arg, poly) = {
    data = data__arg;
    assert('N > 32);
    foreach (i from ('N - 1) to 32 by 1 in dec) {
        if [data[i]] == 0b1 then {
            data = __SetSlice_bits('N, i, data, 0, slice(data, 0, i) ^ (poly @ Zeros(i - 32)))
        }
    };
    slice(data, 0, 32)
}

val LSL_C : forall ('N : Int) ('shift : Int), 'N >= 0.
  (bits('N), int('shift)) -> (bits('N), bits(1)) effect {escape}

function LSL_C (x, shift) = {
    assert(shift > 0);
    let (shift as 'S) : {'n, (0 <= 'n & 'n <= 'N). int('n)} = if shift > 'N then 'N else shift;
    let extended_x : bits('N + 'S) = x @ Zeros(shift);
    let result : bits('N) = slice(extended_x, 0, 'N);
    let carry_out : bits(1) = [extended_x['N]];
    return((result, carry_out))
}

val LSL : forall ('N : Int) ('shift : Int), ('shift >= 0 & 'N >= 0).
  (bits('N), int('shift)) -> bits('N) effect {escape, undef}

function LSL (x, shift) = {
    assert(shift >= 0);
    __anon1 : bits(1) = undefined : bits(1);
    result : bits('N) = undefined : bits('N);
    if shift == 0 then result = x
    else (result, __anon1) = LSL_C(x, shift);
    result
}

val AArch32_ITAdvance : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_ITAdvance () = {
    if slice(PSTATE.IT, 0, 3) == 0b000 then {
        PSTATE.IT = 0x00
    } else {
        __tc1 : bits(8) = PSTATE.IT;
        __tc1 = __SetSlice_bits(8, 5, __tc1, 0, LSL(slice(PSTATE.IT, 0, 5), 1));
        PSTATE.IT = __tc1
    };
    return()
}

val IsZeroBit : forall ('N : Int), 'N >= 0. bits('N) -> bits(1)

function IsZeroBit x = {
    if IsZero(x) then 0b1 else 0b0
}

val AddWithCarry : forall ('N : Int), ('N >= 0 & 'N >= 0).
  (bits('N), bits('N), bits(1)) -> (bits('N), bits(4))

function AddWithCarry (x, y, carry_in) = {
    let 'unsigned_sum = UInt(x) + UInt(y) + UInt(carry_in);
    let 'signed_sum = SInt(x) + SInt(y) + UInt(carry_in);
    let result : bits('N) = __GetSlice_int('N, unsigned_sum, 0);
    let n : bits(1) = [result['N - 1]];
    let z : bits(1) = one_if(IsZero(result));
    let c : bits(1) = zero_if(UInt(result) == unsigned_sum);
    let v : bits(1) = zero_if(SInt(result) == signed_sum);
    return((result, ((n @ z) @ c) @ v))
}

val GetExclusiveBlockAddress : bits(52) -> bits(52)

function GetExclusiveBlockAddress address = {
    let a = UInt(__exclusive_granule_size);
    let a : {'n, (4 <= 'n & 'n <= 11). int('n)} = if a < 4 | a > 11 then 11 else a;
    slice(address, a, negate(a) + 52) @ Zeros(a)
}

val MarkExclusiveLocal : forall ('processorid : Int) ('size : Int).
  (FullAddress, int('processorid), int('size)) -> unit effect {wreg}

function MarkExclusiveLocal (paddress, processorid, size) = {
    /*
    __exclusive_block_address = GetExclusiveBlockAddress(paddress.address);
    return()
    */
    ()
}

val IsExclusiveLocal : forall ('processorid : Int) ('size : Int).
  (FullAddress, int('processorid), int('size)) -> bool effect {rreg}

function IsExclusiveLocal (paddress, processorid, size) = {
    /*
    __exclusive_block_address == GetExclusiveBlockAddress(paddress.address)
    */
    false
}

val ClearExclusiveByAddress : forall ('processorid : Int) ('size : Int).
  (FullAddress, int('processorid), int('size)) -> unit effect {rreg, undef, wreg}

function ClearExclusiveByAddress (paddress, processorid, size) = {
    /*
    if __exclusive_block_address == GetExclusiveBlockAddress(paddress.address) then {
        __exclusive_block_address = undefined : bits(52)
    };
    return()
    */
    ()
}

val Extend__0 : forall ('M : Int) ('N : Int), 'M >= 0.
  (bits('M), int('N), bool) -> bits('N) effect {escape}

val Extend__1 : forall ('M : Int) ('N : Int), 'M >= 0.
  (implicit('N), bits('M), bool) -> bits('N) effect {escape}

overload Extend = {Extend__0, Extend__1}

function Extend__0 (x, N, unsigned) = {
    if unsigned then ZeroExtend(x, N) else SignExtend(x, N)
}

function Extend__1 (N, x, unsigned) = Extend__0(x, 'N, unsigned)

val ASR_C : forall ('N : Int) ('shift : Int), 'N >= 0.
  (bits('N), int('shift)) -> (bits('N), bits(1)) effect {escape}

function ASR_C (x, shift) = {
    assert(shift > 0);
    let (shift as 'S) : {'n, (0 <= 'n & 'n <= 'N). int('n)} = if shift > 'N then 'N else shift;
    let extended_x : bits('S + 'N) = SignExtend(x, shift + 'N);
    let result : bits('N) = slice(extended_x, shift, 'N);
    let carry_out : bits(1) = [extended_x[shift - 1]];
    return((result, carry_out))
}

val ASR : forall ('N : Int) ('shift : Int), ('shift >= 0 & 'N >= 0).
  (bits('N), int('shift)) -> bits('N) effect {escape, undef}

function ASR (x, shift) = {
    assert(shift >= 0);
    __anon1 : bits(1) = undefined : bits(1);
    result : bits('N) = undefined : bits('N);
    if shift == 0 then result = x
    else (result, __anon1) = ASR_C(x, shift);
    result
}

val _ChooseRandomNonExcludedTag : bits(16) -> bits(4) effect {rreg}

function _ChooseRandomNonExcludedTag exclude = {
    let exclude = exclude | slice(GCR_EL1, 0, 16);
    if exclude == Ones(16) then {
        return(0x0)
    };
    tag : bits(4) = 0x0;
    while [exclude[UInt(tag)]] == 0b1 do {
        tag = tag + 0x1
    };
    tag
}

val PACSub : bits(64) -> bits(64) effect {undef}

function PACSub Tinput = {
    Toutput : bits(64) = undefined : bits(64);
    foreach (i from 0 to 15 by 1 in inc) {
        match slice(Tinput, 4 * i, 4) {
          0x0 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xB)
          },
          0x1 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x6)
          },
          0x2 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x8)
          },
          0x3 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xF)
          },
          0x4 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xC)
          },
          0x5 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x0)
          },
          0x6 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x9)
          },
          0x7 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xE)
          },
          0x8 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x3)
          },
          0x9 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x7)
          },
          0xA => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x4)
          },
          0xB => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x5)
          },
          0xC => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xD)
          },
          0xD => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x2)
          },
          0xE => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x1)
          },
          0xF => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xA)
          }
        }
    };
    Toutput
}

val PACMult : bits(64) -> bits(64) effect {undef}

function PACMult Sinput = {
    t0 : bits(4) = undefined : bits(4);
    t1 : bits(4) = undefined : bits(4);
    t2 : bits(4) = undefined : bits(4);
    t3 : bits(4) = undefined : bits(4);
    Soutput : bits(64) = undefined : bits(64);
    foreach (i from 0 to 3 by 1 in inc) {
        t0 = __SetSlice_bits(4, 4, t0, 0, RotCell(slice(Sinput, 4 * (i + 8), 4), 1) ^ RotCell(slice(Sinput, 4 * (i + 4), 4), 2));
        t0 = __SetSlice_bits(4, 4, t0, 0, slice(t0, 0, 4) ^ RotCell(slice(Sinput, 4 * i, 4), 1));
        t1 = __SetSlice_bits(4, 4, t1, 0, RotCell(slice(Sinput, 4 * (i + 12), 4), 1) ^ RotCell(slice(Sinput, 4 * (i + 4), 4), 1));
        t1 = __SetSlice_bits(4, 4, t1, 0, slice(t1, 0, 4) ^ RotCell(slice(Sinput, 4 * i, 4), 2));
        t2 = __SetSlice_bits(4, 4, t2, 0, RotCell(slice(Sinput, 4 * (i + 12), 4), 2) ^ RotCell(slice(Sinput, 4 * (i + 8), 4), 1));
        t2 = __SetSlice_bits(4, 4, t2, 0, slice(t2, 0, 4) ^ RotCell(slice(Sinput, 4 * i, 4), 1));
        t3 = __SetSlice_bits(4, 4, t3, 0, RotCell(slice(Sinput, 4 * (i + 12), 4), 1) ^ RotCell(slice(Sinput, 4 * (i + 8), 4), 2));
        t3 = __SetSlice_bits(4, 4, t3, 0, slice(t3, 0, 4) ^ RotCell(slice(Sinput, 4 * (i + 4), 4), 1));
        Soutput = __SetSlice_bits(64, 4, Soutput, 4 * i, slice(t3, 0, 4));
        Soutput = __SetSlice_bits(64, 4, Soutput, 4 * (i + 4), slice(t2, 0, 4));
        Soutput = __SetSlice_bits(64, 4, Soutput, 4 * (i + 8), slice(t1, 0, 4));
        Soutput = __SetSlice_bits(64, 4, Soutput, 4 * (i + 12), slice(t0, 0, 4))
    };
    Soutput
}

val PACInvSub : bits(64) -> bits(64) effect {undef}

function PACInvSub Tinput = {
    Toutput : bits(64) = undefined : bits(64);
    foreach (i from 0 to 15 by 1 in inc) {
        match slice(Tinput, 4 * i, 4) {
          0x0 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x5)
          },
          0x1 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xE)
          },
          0x2 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xD)
          },
          0x3 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x8)
          },
          0x4 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xA)
          },
          0x5 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xB)
          },
          0x6 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x1)
          },
          0x7 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x9)
          },
          0x8 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x2)
          },
          0x9 => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x6)
          },
          0xA => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xF)
          },
          0xB => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x0)
          },
          0xC => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x4)
          },
          0xD => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0xC)
          },
          0xE => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x7)
          },
          0xF => {
              Toutput = __SetSlice_bits(64, 4, Toutput, 4 * i, 0x3)
          }
        }
    };
    Toutput
}

val ComputePAC : (bits(64), bits(64), bits(64), bits(64)) -> bits(64) effect {rreg, undef, wreg}

function ComputePAC (data, modifier, key0, key1) = {
    workingval : bits(64) = undefined : bits(64);
    runningmod : bits(64) = undefined : bits(64);
    roundkey : bits(64) = undefined : bits(64);
    modk0 : bits(64) = undefined : bits(64);
    let 'Alpha : bits(64) = __GetSlice_int(64, 13883517620612518109, 0);
    RC[0] = __GetSlice_int(64, 0, 0);
    RC[1] = __GetSlice_int(64, 1376283091369227076, 0);
    RC[2] = __GetSlice_int(64, 11820040416388919760, 0);
    RC[3] = __GetSlice_int(64, 589684135938649225, 0);
    RC[4] = __GetSlice_int(64, 4983270260364809079, 0);
    let modk0 = ([key0[0]] @ slice(key0, 2, 62)) @ ([key0[63]] ^ [key0[1]]);
    runningmod = modifier;
    workingval = data ^ key0;
    foreach (i from 0 to 4 by 1 in inc) {
        roundkey = key1 ^ runningmod;
        workingval = workingval ^ roundkey;
        workingval = workingval ^ RC[i];
        if i > 0 then {
            workingval = PACCellShuffle(workingval);
            workingval = PACMult(workingval)
        };
        workingval = PACSub(workingval);
        runningmod = TweakShuffle(slice(runningmod, 0, 64))
    };
    roundkey = modk0 ^ runningmod;
    workingval = workingval ^ roundkey;
    workingval = PACCellShuffle(workingval);
    workingval = PACMult(workingval);
    workingval = PACSub(workingval);
    workingval = PACCellShuffle(workingval);
    workingval = PACMult(workingval);
    workingval = key1 ^ workingval;
    workingval = PACCellInvShuffle(workingval);
    workingval = PACInvSub(workingval);
    workingval = PACMult(workingval);
    workingval = PACCellInvShuffle(workingval);
    workingval = workingval ^ key0;
    workingval = workingval ^ runningmod;
    foreach (i from 0 to 4 by 1 in inc) {
        workingval = PACInvSub(workingval);
        if i < 4 then {
            workingval = PACMult(workingval);
            workingval = PACCellInvShuffle(workingval)
        };
        runningmod = TweakInvShuffle(slice(runningmod, 0, 64));
        roundkey = key1 ^ runningmod;
        workingval = workingval ^ RC[4 - i];
        workingval = workingval ^ roundkey;
        workingval = workingval ^ Alpha
    };
    let workingval = workingval ^ modk0;
    workingval
}

val __Reset : bool -> unit effect {escape, rreg, wreg}

function __Reset cold = {
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 8, val_name, 0, Zeros(8));
        set_TUBE(get_TUBE() & ~(__GetSlice_int(32, 255, 0)) | val_name)
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 1, val_name, 3, __GetSlice_int(1, 1, 0));
        val_name = __SetSlice_bits(32, 1, val_name, 2, __GetSlice_int(1, 1, 0));
        val_name = __SetSlice_bits(32, 1, val_name, 1, __GetSlice_int(1, 1, 0));
        val_name = __SetSlice_bits(32, 1, val_name, 0, __GetSlice_int(1, 1, 0));
        set_TargetCPU(get_TargetCPU() & ~(__GetSlice_int(32, 15, 0)) | val_name)
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 1073741824, 0));
        AbortRgn64Lo1 = AbortRgn64Lo1 & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 0, 0));
        AbortRgn64Lo1_Hi = AbortRgn64Lo1_Hi & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 1342177280, 0));
        AbortRgn64Hi1 = AbortRgn64Hi1 & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 0, 0));
        AbortRgn64Hi1_Hi = AbortRgn64Hi1_Hi & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 1056964608, 0));
        AbortRgn64Lo2 = AbortRgn64Lo2 & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 0, 0));
        AbortRgn64Lo2_Hi = AbortRgn64Lo2_Hi & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 1057423360, 0));
        AbortRgn64Hi2 = AbortRgn64Hi2 & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 32, val_name, 0, __GetSlice_int(32, 0, 0));
        AbortRgn64Hi2_Hi = AbortRgn64Hi2_Hi & ~(__GetSlice_int(32, 4294967295, 0)) | val_name
    } until true;
    repeat {
        val_name : bits(32) = __GetSlice_int(32, 0, 0);
        val_name = __SetSlice_bits(32, 2, val_name, 26, Zeros(2));
        val_name = __SetSlice_bits(32, 1, val_name, 25, Zeros(1));
        val_name = __SetSlice_bits(32, 1, val_name, 24, Zeros(1));
        val_name = __SetSlice_bits(32, 2, val_name, 22, Zeros(2));
        val_name = __SetSlice_bits(32, 1, val_name, 21, Zeros(1));
        val_name = __SetSlice_bits(32, 1, val_name, 20, Zeros(1));
        set_AXIAbortCtl(get_AXIAbortCtl() & ~(__GetSlice_int(32, 267386880, 0)) | val_name)
    } until true;
    repeat {
        _ScheduleIRQ = Zeros();
        _ClearIRQ = Zeros();
        ScheduledIRQ = false;
        _IRQPending = false
    } until true;
    repeat {
        _ScheduleFIQ = Zeros();
        _ClearIRQ = Zeros();
        ScheduledFIQ = false;
        _FIQPending = false
    } until true;
    repeat {
        _GTEActive = false;
        _GTEStatus = Zeros();
        _GTEParamLo = Zeros();
        _PPURBAR = Zeros();
        _PPURSER = Zeros();
        _PPURACR = Zeros();
        foreach (i from 0 to (NUM_GTE_REGIONS - 1) by 1 in inc) {
            _GTE_PPU_SizeEn[i] = Zeros(32);
            _GTE_PPU_Address[i] = Zeros(64);
            _GTE_PPU_Access[i] = Zeros(32)
        }
    } until true;
    repeat {
        foreach (i from 0 to (NUM_GTE_EXT_OBS_OBSERVERS - 1) by 1 in inc) {
            _GTEExtObsActive[i] = if i == 0 then true else false;
            _GTEExtObsIndex[i] = 0;
            _GTEExtObsCount[i] = 0;
            _GTEExtObsResultIndex[i] = 0;
            _GTEExtObsResultIsAddress[i] = true
        };
        foreach (i from 0 to (NUM_GTE_EXT_OBS_OBSERVATIONS - 1) by 1 in inc) {
            _GTEExtObsAccess[i] = Zeros(16);
            _GTEExtObsAddress[i] = Zeros(64);
            _GTEExtObsData[i] = Zeros(64);
            _GTEExtObsResult[i] = Zeros(64)
        }
    } until true;
    repeat {
        _GTE_AS_Address = Zeros();
        _GTE_AS_Size = Zeros();
        _GTE_AS_Access = Zeros();
        _GTE_AS_AccessCount = 0
    } until true;
    return()
}

val ImpDefTagArrayStartAndCount : bits(64) -> (bits(64), int) effect {escape, rreg}

function ImpDefTagArrayStartAndCount address__arg = {
    address = address__arg;
    let block_bitspan : int = UInt(slice(DCZID_EL0, 0, 4)) + 2;
    let block_bitspan = if block_bitspan < LOG2_TAG_GRANULE then LOG2_TAG_GRANULE else block_bitspan;
    if block_bitspan < 8 then {
        address = __SetSlice_bits(64, block_bitspan, address, 0, Zeros(block_bitspan));
        let first_block : bits(4) = ZeroExtend(slice(address, block_bitspan, negate(block_bitspan) + 8), 4);
        let 'first_tag : int = UInt(first_block) * 4;
        return((address, 4))
    } else {
        address = __SetSlice_bits(64, 8, address, 0, Zeros(8));
        return((address, 16))
    }
}

val aset_X : forall ('width : Int) ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits('width)) -> unit effect {escape, wreg}

function aset_X (n, value_name) = {
    assert('width == 32 | 'width == 64);
    if n != 31 then _R(n) = ZeroExtend(value_name, 64)
    else ();
    return()
}

overload X = {aset_X}

val semihost_ret : bits(64) -> unit effect {escape, wreg}

function semihost_ret value_name = {
    X(0) = value_name
}

val integer_arithmetic_address_pcrel : forall ('d : Int), (0 <= 'd & 'd <= 31).
  (int('d), bits(64), bool) -> unit effect {escape, rreg, wreg}

function integer_arithmetic_address_pcrel (d, imm, page) = {
    base : bits(64) = aget_PC();
    if page then base = __SetSlice_bits(64, 12, base, 0, Zeros(12))
    else ();
    X(d) = base + imm
}

val AArch64_ResetGeneralRegisters : unit -> unit effect {escape, undef, wreg}

function AArch64_ResetGeneralRegisters () = {
    foreach (i from 0 to 30 by 1 in inc) {
        X(i) = undefined : bits(64)
    };
    return()
}

val aget_X : forall 'width 'n,
  ('n >= 0 & 'n <= 31 & 'width in {8, 16, 32, 64}).
  (implicit('width), int('n)) -> bits('width) effect {rreg}

function aget_X (width, n) = if n != 31 then slice(_R(n), 0, width) else Zeros(width)

overload X = {aget_X}

val semihost_arg : forall ('n : Int), ('n >= 0 & 'n <= 31).
  int('n) -> bits(64) effect {rreg}

function semihost_arg n = {
    X(n)
}

val integer_tags_mcinserttagmask : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, wreg}

function integer_tags_mcinserttagmask (d, m, n) = {
    let address : bits(64) = if n == 31 then SP() else X(n);
    mask : bits(64) = X(m);
    let tag : bits(4) = AllocationTagFromAddress(address);
    let mask = __SetSlice_bits(64, 1, mask, UInt(tag), 0b1);
    X(d) = mask
}

val integer_insext_insert_movewide : forall 'd 'datasize 'pos,
  ('d >= 0 & 'd <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('d), int('datasize), bits(16), MoveWideOp, int('pos)) -> unit effect {escape, rreg, undef, wreg}

function integer_insext_insert_movewide (d, datasize, imm, opcode, pos) = {
    result : bits('datasize) = undefined : bits('datasize);
    if opcode == MoveWideOp_K then {
        result = X(d)
    } else {
        result = Zeros()
    };
    result = __SetSlice_bits(datasize, 16, result, pos, imm);
    if opcode == MoveWideOp_N then {
        result = ~(result)
    };
    X(d) = result
}

val integer_insext_extract_immediate : forall 'd 'datasize 'lsb 'm 'n,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('lsb), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function integer_insext_extract_immediate (d, datasize, lsb, m, n) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    let concat : bits(2 * 'datasize) = operand1 @ operand2;
    let result = slice(concat, lsb, datasize);
    X(d) = result
}

val integer_flags_setf : forall 'msb 'n,
  ('n >= 0 & 'n <= 31) & 'msb + 1 >= 0.
  (int('msb), int('n)) -> unit effect {rreg, wreg}

function integer_flags_setf (msb, n) = {
    let tmpreg : bits(32) = X(n);
    PSTATE.N = [tmpreg[msb]];
    PSTATE.Z = if slice(tmpreg, 0, msb + 1) == Zeros(msb + 1) then 0b1 else 0b0;
    PSTATE.V = [tmpreg[msb + 1]] ^ [tmpreg[msb]]
}

val integer_flags_rmif : forall ('lsb : Int) ('n : Int), ('n >= 0 & 'n <= 31).
  (int('lsb), bits(4), int('n)) -> unit effect {rreg, undef, wreg}

function integer_flags_rmif (lsb, mask, n) = {
    tmp : bits(4) = undefined : bits(4);
    let tmpreg : bits(64) = X(n);
    let tmp = slice(tmpreg @ tmpreg, lsb, 4);
    if [mask[3]] == 0b1 then {
        PSTATE.N = [tmp[3]]
    };
    if [mask[2]] == 0b1 then {
        PSTATE.Z = [tmp[2]]
    };
    if [mask[1]] == 0b1 then {
        PSTATE.C = [tmp[1]]
    };
    if [mask[0]] == 0b1 then {
        PSTATE.V = [tmp[0]]
    }
}

val integer_crc : forall ('crc32c : Bool) 'd 'm 'n 'size,
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31 & 'size in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (bool('crc32c), int('d), int('m), int('n), int('size)) -> unit effect {escape, rreg, undef, wreg}

function integer_crc (crc32c, d, m, n, size) = {
    let acc : bits(32) = X(n);
    let val_name : bits('size) = X(m);
    let poly = __GetSlice_int(32, if crc32c then 517762881 else 79764919, 0);
    let tempacc : bits('size + 32) = BitReverse(acc) @ Zeros(size);
    let tempval : bits('size + 32) = BitReverse(val_name) @ Zeros(32);
    X(d) = BitReverse(Poly32Mod2(tempacc ^ tempval, poly))
}

val integer_arithmetic_rev : forall 'container_size 'd 'datasize 'n,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (int('container_size), int('d), int('datasize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_rev (container_size, d, datasize, n) = {
    let operand : bits('datasize) = X(n);
    result : bits('datasize) = undefined : bits('datasize);
    let 'containers = datasize / container_size;
    let 'elements_per_container = container_size / 8;
    index : int = 0;
    rev_index : int = undefined : int;
    foreach (c from 0 to (containers - 1) by 1 in inc) {
        rev_index = index + (elements_per_container - 1) * 8;
        foreach (e from 0 to (elements_per_container - 1) by 1 in inc) {
            result = __SetSlice_bits(datasize, 8, result, rev_index, slice(operand, index, 8));
            index = index + 8;
            rev_index = rev_index - 8
        }
    };
    X(d) = result
}

val integer_arithmetic_rbit : forall 'd 'datasize 'n,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_rbit (d, datasize, n) = {
    let operand : bits('datasize) = X(n);
    result : bits('datasize) = undefined : bits('datasize);
    foreach (i from 0 to (datasize - 1) by 1 in inc) {
        result = __SetSlice_bits(datasize, 1, result, datasize - 1 - i, [operand[i]])
    };
    X(d) = result
}

val integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags : forall 'd 'm 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('m >= 0 & 'm <= 31 | not(not('m == 31))) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags (d, m, n, setflags) = {
    operand1 : bits(64) = if n == 31 then SP() else X(n);
    operand2 : bits(64) = if m == 31 then SP() else X(m);
    let operand1 = SignExtend(slice(operand1, 0, 56), 64);
    operand2 = SignExtend(slice(operand2, 0, 56), 64);
    result : bits(64) = undefined : bits(64);
    nzcv : bits(4) = undefined : bits(4);
    let operand2 = ~(operand2);
    (result, nzcv) = AddWithCarry(operand1, operand2, 0b1);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X(d) = result
}

val integer_arithmetic_pointer_mcsubtracttaggedaddress : forall 'd 'm 'n ('setflags : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('m >= 0 & 'm <= 31 | not(not('m == 31))) & ('d >= 0 & 'd <= 31).
  (int('d), int('m), int('n), bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_pointer_mcsubtracttaggedaddress (d, m, n, setflags) = {
    operand1 : bits(64) = if n == 31 then SP() else X(n);
    operand2 : bits(64) = if m == 31 then SP() else X(m);
    let operand1 = SignExtend(slice(operand1, 0, 56), 64);
    operand2 = SignExtend(slice(operand2, 0, 56), 64);
    result : bits(64) = undefined : bits(64);
    nzcv : bits(4) = undefined : bits(4);
    let operand2 = ~(operand2);
    (result, nzcv) = AddWithCarry(operand1, operand2, 0b1);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X(d) = result
}

val integer_arithmetic_mul_widening_64128hi : forall 'd 'datasize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, wreg}

function integer_arithmetic_mul_widening_64128hi (d, datasize, m, n, unsigned) = {
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    let result : int = asl_Int(operand1, unsigned) * asl_Int(operand2, unsigned);
    X(d) = __GetSlice_int(64, result, 64)
}

val integer_arithmetic_mul_widening_3264 : forall 'a 'd 'datasize 'destsize 'm 'n ('sub_op : Bool) ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('a >= 0 & 'a <= 31 & 'destsize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (int('a), int('d), int('datasize), int('destsize), int('m), int('n), bool('sub_op), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_mul_widening_3264 (a, d, datasize, destsize, m, n, sub_op, unsigned) = {
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    let operand3 : bits('destsize) = X(a);
    result : int = undefined : int;
    if sub_op then {
        result = asl_Int(operand3, unsigned) - asl_Int(operand1, unsigned) * asl_Int(operand2, unsigned)
    } else {
        result = asl_Int(operand3, unsigned) + asl_Int(operand1, unsigned) * asl_Int(operand2, unsigned)
    };
    X(d) = __GetSlice_int(64, result, 0)
}

val integer_arithmetic_mul_uniform_addsub : forall 'a 'd 'datasize 'destsize 'm 'n ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('a >= 0 & 'a <= 31 & 'destsize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (int('a), int('d), int('datasize), int('destsize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_mul_uniform_addsub (a, d, datasize, destsize, m, n, sub_op) = {
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    let operand3 : bits('destsize) = X(a);
    result : int = undefined : int;
    if sub_op then {
        result = UInt(operand3) - UInt(operand1) * UInt(operand2)
    } else {
        result = UInt(operand3) + UInt(operand1) * UInt(operand2)
    };
    X(d) = __GetSlice_int(destsize, result, 0)
}

val integer_arithmetic_div : forall 'd 'datasize 'm 'n ('unsigned : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('unsigned)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_div (d, datasize, m, n, unsigned) = {
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    result : int = undefined : int;
    if IsZero(operand2) then {
        result = 0
    } else {
        result = RoundTowardsZero(Real(asl_Int(operand1, unsigned)) / Real(asl_Int(operand2, unsigned)))
    };
    X(d) = __GetSlice_int(datasize, result, 0)
}

val integer_arithmetic_cnt : forall 'd 'datasize 'n,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('n), CountOp) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_cnt (d, datasize, n, opcode) = {
    result : int = undefined : int;
    let operand1 : bits('datasize) = X(n);
    if opcode == CountOp_CLZ then {
        result = CountLeadingZeroBits(operand1)
    } else {
        result = CountLeadingSignBits(operand1)
    };
    X(d) = __GetSlice_int(datasize, result, 0)
}

val integer_arithmetic_addsub_carry : forall 'd 'datasize 'm 'n ('setflags : Bool) ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('setflags), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_carry (d, datasize, m, n, setflags, sub_op) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = X(n);
    operand2 : bits('datasize) = X(m);
    nzcv : bits(4) = undefined : bits(4);
    if sub_op then {
        operand2 = ~(operand2)
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X(d) = result
}

val ExtendReg : forall 'N 'reg 'shift,
  ('shift >= 0 & 'shift <= 4) & ('reg >= 0 & 'reg <= 31 & 'N in {8, 16, 32, 64}).
  (implicit('N), int('reg), ExtendType, int('shift)) -> bits('N) effect {escape, rreg, undef}

function ExtendReg (N, reg, typ, shift) = {
    assert(shift >= 0 & shift <= 4);
    let val_name : bits('N) = X(reg);
    unsigned : bool = undefined : bool;
    len : int = undefined : int;
    match typ {
      ExtendType_SXTB => {
          unsigned = false;
          len = 8
      },
      ExtendType_SXTH => {
          unsigned = false;
          len = 16
      },
      ExtendType_SXTW => {
          unsigned = false;
          len = 32
      },
      ExtendType_SXTX => {
          unsigned = false;
          len = 64
      },
      ExtendType_UXTB => {
          unsigned = true;
          len = 8
      },
      ExtendType_UXTH => {
          unsigned = true;
          len = 16
      },
      ExtendType_UXTW => {
          unsigned = true;
          len = 32
      },
      ExtendType_UXTX => {
          unsigned = true;
          len = 64
      }
    };
    let len = len;
    let unsigned = unsigned;
    let len = min(len, 'N - shift);
    assert(constraint('_len >= 0));
    Extend(slice(val_name, 0, len) @ Zeros(shift), 'N, unsigned)
}

val aget_ELR__0 : bits(2) -> bits(64) effect {escape, rreg, undef}

val aget_ELR__1 : unit -> bits(64) effect {escape, rreg, undef}

overload aget_ELR = {aget_ELR__0, aget_ELR__1}

overload ELR = {aget_ELR__0, aget_ELR__1}

function aget_ELR__0 el = {
    r : bits(64) = undefined : bits(64);
    match el {
      ? if ? == EL1 => {
          r = ELR_EL1
      },
      ? if ? == EL2 => {
          r = ELR_EL2
      },
      ? if ? == EL3 => {
          r = ELR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    r
}

function aget_ELR__1 () = {
    assert(PSTATE.EL != EL0);
    ELR(PSTATE.EL)
}

val ROR_C : forall ('N : Int) ('shift : Int), 'N >= 0.
  (bits('N), int('shift)) -> (bits('N), bits(1)) effect {escape, undef}

function ROR_C (x, shift) = {
    let m : int = shift % 'N;
    assert('N - m >= 0 & m >= 0);
    let result : bits('N) = LSR(x, m) | LSL(x, 'N - m);
    let carry_out : bits(1) = [result['N - 1]];
    return((result, carry_out))
}

val ROR : forall ('N : Int) ('shift : Int), ('N >= 0 & 'shift >= 0).
  (bits('N), int('shift)) -> bits('N) effect {escape, undef}

function ROR (x, shift) = {
    assert(shift >= 0);
    __anon1 : bits(1) = undefined : bits(1);
    result : bits('N) = undefined : bits('N);
    if shift == 0 then {
        result = x
    } else {
        (result, __anon1) = ROR_C(x, shift)
    };
    result
}

val integer_bitfield : forall 'R 'S 'd 'datasize 'n,
  ('R >= 0 & 'datasize >= 0 & 'datasize >= 0 & 'd >= 0 & 'd <= 31 & 'datasize in {8, 16, 32, 64} & 'n >= 0 & 'n <= 31).
  (int('R), int('S), int('d), int('datasize), bool, bool, int('n), bits('datasize), bits('datasize)) -> unit effect {escape, rreg, undef, wreg}

function integer_bitfield (R, S, d, datasize, extend, inzero, n, tmask, wmask) = {
    let dst : bits('datasize) = if inzero then Zeros() else X(d);
    let src : bits('datasize) = X(n);
    let bot : bits('datasize) = dst & ~(wmask) | ROR(src, R) & wmask;
    let top : bits('datasize) = if extend then Replicate([src[S]]) else dst;
    X(d) = top & ~(tmask) | bot & tmask
}

val ShiftReg : forall 'N 'reg 'amount,
  ('reg >= 0 & 'reg <= 31 & 'N in {8, 16, 32, 64}) & 'amount >= 0.
  (implicit('N), int('reg), ShiftType, int('amount)) -> bits('N) effect {escape, rreg, undef}

function ShiftReg (N, reg, typ, amount) = {
    result : bits('N) = X(reg);
    match typ {
      ShiftType_LSL => {
          result = LSL(result, amount)
      },
      ShiftType_LSR => {
          result = LSR(result, amount)
      },
      ShiftType_ASR => {
          result = ASR(result, amount)
      },
      ShiftType_ROR => {
          result = ROR(result, amount)
      }
    };
    result
}

val integer_shift_variable : forall 'd 'datasize 'm 'n,
  ('m >= 0 & 'm <= 31 & 'datasize in {8, 16, 32, 64} & 'n >= 0 & 'n <= 31 & 'd >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), ShiftType) -> unit effect {escape, rreg, undef, wreg}

function integer_shift_variable (d, datasize, m, n, shift_type) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand2 : bits('datasize) = aget_X(m);
    let amount = UInt(operand2) % datasize;
    let result : bits('datasize) = ShiftReg(n, shift_type, amount);
    aset_X(d, result)
}

val integer_logical_shiftedreg : forall 'd 'datasize ('invert : Bool) 'm 'n ('setflags : Bool) 'shift_amount,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & 'shift_amount >= 0 & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), bool('invert), int('m), int('n), LogicalOp, bool('setflags), int('shift_amount), ShiftType) -> unit effect {escape, rreg, undef, wreg}

function integer_logical_shiftedreg (d, datasize, invert, m, n, op, setflags, shift_amount, shift_type) = {
    let operand1 : bits('datasize) = X(n);
    operand2 : bits('datasize) = ShiftReg(m, shift_type, shift_amount);
    if invert then {
        operand2 = ~(operand2)
    };
    result : bits('datasize) = undefined : bits('datasize);
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      },
      LogicalOp_EOR => {
          result = operand1 ^ operand2
      }
    };
    let result = result;
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = ([result[datasize - 1]] @ IsZeroBit(result)) @ 0b00
    };
    X(d) = result
}

val integer_arithmetic_addsub_shiftedreg : forall 'd 'datasize 'm 'n ('setflags : Bool) 'shift_amount ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & 'shift_amount >= 0 & ('d >= 0 & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('setflags), int('shift_amount), ShiftType, bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_shiftedreg (d, datasize, m, n, setflags, shift_amount, shift_type, sub_op) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = X(n);
    operand2 : bits('datasize) = ShiftReg(m, shift_type, shift_amount);
    nzcv : bits(4) = undefined : bits(4);
    carry_in : bits(1) = undefined : bits(1);
    if sub_op then {
        operand2 = ~(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    X(d) = result
}

val Prefetch : (bits(64), bits(5)) -> unit effect {undef}

function Prefetch (address, prfop) = {
    hint : PrefetchHint = undefined : PrefetchHint;
    target : int = undefined : int;
    stream : bool = undefined : bool;
    match slice(prfop, 3, 2) {
      0b00 => {
          hint = Prefetch_READ
      },
      0b01 => {
          hint = Prefetch_EXEC
      },
      0b10 => {
          hint = Prefetch_WRITE
      },
      0b11 => {
          return()
      }
    };
    let target = UInt(slice(prfop, 1, 2));
    let stream = [prfop[0]] != 0b0;
    Hint_Prefetch(address, hint, target, stream);
    return()
}

val SetResetVector : bits(64) -> unit effect {escape, rreg, wreg}

function SetResetVector value_name = {
    if HighestELUsingAArch32() then {
        if HaveEL(EL3) then {
            MVBAR = slice(value_name, 0, 32)
        } else {
            RVBAR = slice(value_name, 0, 32)
        }
    } else {
        if HighestEL() == EL3 then {
            RVBAR_EL3 = value_name
        } else {
            if HighestEL() == EL2 then {
                RVBAR_EL2 = value_name
            } else {
                RVBAR_EL1 = value_name
            }
        }
    };
    return()
}

val IsHighestEL : bits(2) -> bool effect {escape}

function IsHighestEL el = {
    HighestEL() == el
}

val AArch64_AutoGen_SysRegAlloc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1)) -> bool effect {escape, rreg, undef}

function AArch64_AutoGen_SysRegAlloc (el, op0, op1, CRn, op2, CRm, read) = {
    let __HCR_EL2_NV1 : bits(1) = [HCR_EL2[43]];
    let __HCR_EL2_FMO : bits(1) = [HCR_EL2[3]];
    let __HCR_EL2_NV2 : bits(1) = [HCR_EL2[45]];
    let __HCR_EL2_E2H : bits(1) = [HCR_EL2[34]];
    let __HCR_EL2_TGE : bits(1) = [HCR_EL2[27]];
    let __SCTLR_EL1_EE0E : bits(1) = [SCTLR_EL1[34]];
    let __SPSel_SP : bits(1) = [get_SPSel()[0]];
    let __SCTLR_EL2_EE0E : bits(1) = [SCTLR_EL2[34]];
    let __IsHighestEL_EL1_ : bool = IsHighestEL(EL1);
    let __SCR_EL3_EEL2 : bits(1) = [SCR_EL3[18]];
    let __SCR_EL3_NS : bits(1) = [SCR_EL3[0]];
    let __HCR_EL2_IMO : bits(1) = [HCR_EL2[4]];
    let __IsHighestEL_EL2_ : bool = IsHighestEL(EL2);
    let __IsHighestEL_EL3_ : bool = IsHighestEL(EL3);
    let __HCR_EL2_NV : bits(1) = [HCR_EL2[42]];
    __cond0 : bool = undefined : bool;
    if (CRm & 0x0) == 0x0 then {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b101 then {
                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    } else {
                        if op2 == 0b111 then {
                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0)
                        } else {
                            if op2 == 0b100 then {
                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if op2 == 0b110 then {
                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    }
                }
            }
        }
    };
    __cond1 : bool = undefined : bool;
    if (op2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if op1 == 0b000 then {
                    if op0 == 0b11 then {
                        __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        __cond1 = ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0 | __cond1)
                    }
                }
            }
        }
    };
    __cond2 : bool = undefined : bool;
    __cond3 : bool = undefined : bool;
    if (op2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if op0 == 0b11 then {
                if op1 == 0b100 then {
                    if CRm == 0x8 then {
                        __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                        return(__cond0)
                    } else {
                        if CRm == 0x9 then {
                            __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0)
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x9 then {
                            __cond0 = (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                            __cond1 = ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1 | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1;
                            __cond2 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1;
                            __cond3 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(((__cond0 | __cond1) | __cond2) | __cond3)
                        }
                    }
                }
            }
        }
    };
    if op0 == 0b11 then {
        if op1 == 0b000 then {
            if CRn == 0x0 then {
                if CRm == 0x1 then {
                    if op2 == 0b010 then {
                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                        return(__cond0)
                    } else {
                        if op2 == 0b011 then {
                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                            return(__cond0)
                        } else {
                            if op2 == 0b000 then {
                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if op2 == 0b101 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if op2 == 0b111 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b001 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b100 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b110 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x2 then {
                        if op2 == 0b010 then {
                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                            return(__cond0)
                        } else {
                            if op2 == 0b011 then {
                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if op2 == 0b000 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if op2 == 0b101 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b111 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b000 then {
                            if CRm == 0x0 then {
                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if CRm == 0x5 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x4 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x6 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b001 then {
                                if CRm == 0x5 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x4 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x6 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b010 then {
                                    if CRm == 0x7 then {
                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x3 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if op2 == 0b101 then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b110 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if op2 == 0b101 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                if CRm == 0x3 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0 | __cond1)
                        } else {
                            if CRn == 0x1 then {
                                __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0 | __cond1)
                            } else {
                                if CRn == 0x6 then {
                                    __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRn == 0x4 then {
                                        __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0 | __cond1)
                                    } else {
                                        if CRn == 0x2 then {
                                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xC then {
                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if CRn == 0xE then {
                                    __cond0 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond1 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL3 | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRn == 0x4 then {
                                        __cond0 = ((((el == EL3 | el == EL1) & __SPSel_SP == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __SPSel_SP == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __SPSel_SP == 1) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x5 then {
                                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRn == 0x2 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0x5 then {
                                    __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRn == 0x4 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0xA then {
                                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRn == 0x2 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x5 then {
                                        __cond0 = (((((((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0 | __cond1)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0x8 then {
                                            __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRm == 0xC then {
                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x7 then {
                                            if CRm == 0x4 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if CRm == 0x6 then {
                                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0 | __cond1)
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                } else {
                                                    if CRn == 0x2 then {
                                                        if CRm == 0x3 then {
                                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0xC then {
                        if CRm == 0xC then {
                            if op2 == 0b010 then {
                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0 | __cond1)
                            } else {
                                if op2 == 0b011 then {
                                    __cond0 = (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                                    __cond1 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1;
                                    __cond2 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return((__cond0 | __cond1) | __cond2)
                                } else {
                                    if op2 == 0b101 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __SCR_EL3_EEL2 == 1;
                                        __cond1 = (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1;
                                        return(__cond0 | __cond1)
                                    } else {
                                        if op2 == 0b111 then {
                                            __cond0 = (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                                            __cond1 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1;
                                            __cond2 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return((__cond0 | __cond1) | __cond2)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = read == 0b0 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b0 & ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & (__HCR_EL2_FMO == 1 | __HCR_EL2_IMO == 1)) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1;
                                                    __cond1 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & (__HCR_EL2_FMO == 1 | __HCR_EL2_IMO == 1)) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1;
                                                    __cond2 = ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return((__cond0 | __cond1) | __cond2)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        __cond1 = ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0 | __cond1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0xB then {
                                if op2 == 0b101 then {
                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if op2 == 0b011 then {
                                        __cond0 = read == 0b1 & ((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        __cond1 = read == 0b1 & (((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0 | __cond1)
                                    } else {
                                        if op2 == 0b111 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = read == 0b0 & ((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b0 & (((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0 | __cond1)
                                            } else {
                                                if op2 == 0b110 then {
                                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x8 then {
                                    if op2 == 0b010 then {
                                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        __cond1 = read == 0b1 & ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0 | __cond1)
                                    } else {
                                        if op2 == 0b011 then {
                                            __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = read == 0b0 & (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b0 & ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if op2 == 0b010 then {
                                            __cond0 = el == EL1 & __IsHighestEL_EL1_;
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = read == 0b1 & el == EL1 & __IsHighestEL_EL1_;
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b001 then {
                            if CRm == 0x0 then {
                                if CRn == 0x2 then {
                                    __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRn == 0xD then {
                                        __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0 | __cond1)
                                    } else {
                                        if CRn == 0x1 then {
                                            __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x4 then {
                                                __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x1 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x5 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x4 then {
                                                __cond0 = (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x5 then {
                                                __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0 | __cond1)
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if CRn == 0x9 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x2 then {
                                                    if CRn == 0x1 then {
                                                        __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0 | __cond1)
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0x6 then {
                                                            __cond0 = true;
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b010 then {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x0 then {
                                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRm == 0x1 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0x1 then {
                                            __cond0 = (((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x2 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRn == 0x9 then {
                                                if CRm == 0xE then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x4 then {
                                                    if CRn == 0xA then {
                                                        __cond0 = (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0xD then {
                                        if op2 == 0b111 then {
                                            __cond0 = (((((((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | (((((el == EL2 | el == EL3) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0 | __cond1)
                                        } else {
                                            if op2 == 0b100 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if op2 == 0b101 then {
                                                __cond0 = true;
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b110 then {
                                                    __cond0 = true;
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if CRm == 0x2 then {
                                            if CRn == 0x4 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if CRn == 0xA then {
                                                    __cond0 = (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x1 then {
                                                    if CRn == 0x2 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x4 then {
                                                if op2 == 0b111 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b100 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if CRm == 0x2 then {
                                                    if op2 == 0b100 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x9 then {
                                                    if CRm == 0xE then {
                                                        if op2 == 0b110 then {
                                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op1 == 0b100 then {
                if op2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0)
                        } else {
                            if CRn == 0x4 then {
                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRn == 0x3 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRn == 0x6 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x1 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x0 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xE then {
                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRn == 0x1 then {
                                    __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRn == 0x4 then {
                                        __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x5 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x2 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xA then {
                                if CRm == 0x2 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x6 then {
                                                __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xE then {
                                    if CRm == 0x2 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x5 then {
                                            __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x4 then {
                                                __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        if CRm == 0x2 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if CRm == 0x2 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x6 then {
                                                    __cond0 = ((((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) | ((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) | (el == EL3 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1;
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0xB then {
                                                    __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        __cond0 = ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                } else {
                                                    if CRn == 0x4 then {
                                                        if CRm == 0x3 then {
                                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            if CRn == 0xC then {
                                __cond0 = read == 0b1 & (((el == EL2 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if CRn == 0x5 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRn == 0x1 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0xD then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x4 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if CRm == 0x2 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x1 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | (el == EL3 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) | (el == EL3 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1;
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x6 then {
                                                __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                __cond0 = read == 0b1 & (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x5 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b010 then {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = (((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((el == EL3 & __SCR_EL3_NS == 1) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1;
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        __cond0 = ((el == EL2 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x2 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xD then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x2 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if CRn == 0xA then {
                                                __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = ((((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) | (((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) | ((el == EL3 & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) | ((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0) | (el == EL3 & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 1;
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0xB then {
                                                    __cond0 = read == 0b1 & (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b011 then {
                                if CRn == 0xC then {
                                    if CRm == 0xB then {
                                        __cond0 = read == 0b1 & (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0xE then {
                                            __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if CRn == 0xA then {
                                                    __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if CRn == 0xC then {
                                        if CRm == 0xB then {
                                            __cond0 = read == 0b1 & (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x9 then {
                                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0x0 then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if CRn == 0xA then {
                                                    __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b111 then {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                __cond0 = (((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if CRn == 0xD then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x1 then {
                                                    if CRn == 0x1 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0xA then {
                                                            __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x6 then {
                                                if op2 == 0b100 then {
                                                    __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = ((((((((el == EL3 & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL3 | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & (__HCR_EL2_NV2 == 0 | __HCR_EL2_NV == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if CRn == 0x6 then {
                                                    if op2 == 0b100 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if op1 == 0b011 then {
                        if CRn == 0xF then {
                            if CRm == 0x0 then {
                                __cond0 = (((((((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 0 | ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 1) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0x2 then {
                                    __cond0 = (((((((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 0 | ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 1) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = (((((((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 0 | ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 1) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x1 then {
                                                __cond0 = (((((((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 0 | ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 1) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = (((((((((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 0 | ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCTLR_EL1_EE0E == 1) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCTLR_EL1_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCTLR_EL2_EE0E == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x4 then {
                                if CRm == 0x2 then {
                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x9 then {
                                    if CRm == 0xD then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0xE then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRm == 0xC then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            __cond1 = ((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRm == 0x0 then {
                                                __cond0 = read == 0b0 & (((((el == EL1 & __IsHighestEL_EL1_ | ((el == EL2 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) | ((el == EL3 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b1 & ((((((el == EL0 | el == EL1) & __IsHighestEL_EL1_ | ((((el == EL2 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __IsHighestEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL3 | el == EL0) | el == EL1) & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0 | __cond1)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = ((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCR_EL3_NS == 1) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_NS == 1) | ((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                                    return(__cond0 | __cond1)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if CRn == 0x2 then {
                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                __cond1 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0 | __cond1)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b101 then {
                            if CRm == 0x0 then {
                                if CRn == 0xC then {
                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRn == 0x4 then {
                                        __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x6 then {
                                            __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x1 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        __cond0 = ((((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1 | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x5 then {
                                            __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xA then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0xE then {
                                            __cond0 = (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x5 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if CRn == 0x6 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0xA then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if CRn == 0xE then {
                                                    __cond0 = ((((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1 | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRn == 0xA then {
                                                        __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b110 then {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x1 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x6 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x4 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRn == 0x2 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x4 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x1 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x5 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x2 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x5 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x5 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0x0 then {
                                        if op1 == 0b010 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op1 == 0b001 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if op1 == 0b111 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if CRn == 0x9 then {
                            if CRm == 0xC then {
                                if op2 == 0b010 then {
                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if op2 == 0b011 then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b101 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b001 then {
                                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b110 then {
                                                            __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xD then {
                                    if op2 == 0b010 then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b001 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if CRm == 0xE then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if op2 == 0b010 then {
                                    if CRn == 0xE then {
                                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRn == 0xF then {
                                            __cond0 = (((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & __SCR_EL3_NS == 1) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_NS == 1) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xD then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if op2 == 0b011 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0 | __cond1)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x0 then {
                                            if op2 == 0b111 then {
                                                __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b001 then {
                                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if op2 == 0b001 then {
                                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0x4 then {
                                        if op2 == 0b101 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = true;
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b001 then {
                                                    __cond0 = (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_E2H == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b010 then {
                                            if CRn == 0xE then {
                                                __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                __cond1 = ((((((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | (((((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                                return(__cond0 | __cond1)
                                            } else {
                                                if CRn == 0xF then {
                                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if op2 == 0b001 then {
                                                    __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = ((((((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | (((((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                                    return(__cond0 | __cond1)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b001 then {
                                        if CRn == 0x4 then {
                                            if CRm == 0x5 then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x4 then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if CRm == 0x3 then {
                                                    __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = (((((((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                                    return(__cond0 | __cond1)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if op2 == 0b010 then {
                                                if CRm == 0x3 then {
                                                    __cond0 = (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    __cond1 = (((((((((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL2 | el == EL3) | el == EL0) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & __SCR_EL3_EEL2 == 1) | (((((el == EL3 | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((((el == EL3 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL3 | el == EL0) | el == EL1) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | (((((((el == EL3 | el == EL0) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1;
                                                    return(__cond0 | __cond1)
                                                }
                                            } else {
                                                if op2 == 0b111 then {
                                                    if CRm == 0xF then {
                                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x0 then {
                            if op1 == 0b110 then {
                                if op2 == 0b010 then {
                                    if CRn == 0xC then {
                                        __cond0 = ((el == EL3 & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRn == 0x2 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0xD then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b001 then {
                                        if CRn == 0xC then {
                                            __cond0 = read == 0b1 & (((el == EL3 & __IsHighestEL_EL3_) & __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __IsHighestEL_EL3_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x4 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x1 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if CRn == 0xD then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b101 then {
                                    if op2 == 0b001 then {
                                        if CRn == 0x2 then {
                                            __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRn == 0x4 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0xD then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b010 then {
                                            if CRn == 0x1 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x2 then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if CRn == 0xD then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b001 then {
                                        if CRn == 0x0 then {
                                            if op2 == 0b010 then {
                                                __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b111 then {
                                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b001 then {
                                                        __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b001 then {
                                if op1 == 0b101 then {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            __cond0 = read == 0b1 & (((((((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((el == EL2 & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((((el == EL2 | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((el == EL2 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            __cond1 = read == 0b0 & (((((((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | (((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0 | __cond1)
                                        } else {
                                            if CRn == 0x1 then {
                                                __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if CRm == 0x3 then {
                                                __cond0 = ((((((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | (((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x5 then {
                                                    __cond0 = (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b110 then {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRn == 0x5 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x2 then {
                                            if CRn == 0xE then {
                                                if op1 == 0b111 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b010 then {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            if op1 == 0b101 then {
                                                __cond0 = ((((((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | (((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op1 == 0b111 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if op1 == 0b101 then {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((((((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | (((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | ((((el == EL2 | el == EL3) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) & ((__HCR_EL2_NV == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if op1 == 0b110 then {
                                                if CRn == 0x1 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if op1 == 0b110 then {
                                            if CRm == 0xC then {
                                                if op2 == 0b101 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b111 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b100 then {
                                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if op0 == 0b01 then {
            if CRn == 0x8 then {
                if op1 == 0b100 then {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                            return(__cond0)
                        } else {
                            if CRm == 0x1 then {
                                __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0x2 then {
                                    __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x5 then {
                                        __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x6 then {
                                                __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x7 then {
                                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b101 then {
                            if CRm == 0x0 then {
                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0x1 then {
                                    __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x2 then {
                                        __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x5 then {
                                            __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x4 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x6 then {
                                                    __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x7 then {
                                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if CRm == 0x3 then {
                                                            __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x4 then {
                                if op2 == 0b010 then {
                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if op2 == 0b000 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b011 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b110 then {
                                    if CRm == 0x0 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x1 then {
                                            __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if CRm == 0x1 then {
                                            __cond0 = (((((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b100 then {
                                            if CRm == 0x1 then {
                                                __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x7 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b010 then {
                                                if CRm == 0x0 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x1 then {
                            if op2 == 0b010 then {
                                __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if op2 == 0b101 then {
                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if op2 == 0b000 then {
                                        __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b011 then {
                                            __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b001 then {
                                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x3 then {
                                if op2 == 0b010 then {
                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if op2 == 0b000 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b101 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b011 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b111 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b001 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x7 then {
                                    if op2 == 0b010 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b101 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b000 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b011 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b111 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if op2 == 0b101 then {
                                            __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b011 then {
                                                __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b111 then {
                                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b001 then {
                                                        __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if op2 == 0b101 then {
                                                __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b011 then {
                                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b111 then {
                                                        __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if op2 == 0b101 then {
                                                    __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b011 then {
                                                        __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b111 then {
                                                            __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        } else {
                                                            if op2 == 0b001 then {
                                                                __cond0 = (((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                                return(__cond0)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b110 then {
                            if op2 == 0b001 then {
                                if CRm == 0x1 then {
                                    __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x2 then {
                                        __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x5 then {
                                            __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x6 then {
                                                __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x7 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if CRm == 0x1 then {
                                        __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x2 then {
                                            __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x5 then {
                                                __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x6 then {
                                                    __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0x7 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if CRm == 0x3 then {
                                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if CRm == 0x1 then {
                                            __cond0 = ((((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL3 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x7 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRn == 0x7 then {
                    if op1 == 0b011 then {
                        if op2 == 0b001 then {
                            if CRm == 0xE then {
                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                return(__cond0)
                            } else {
                                if CRm == 0xA then {
                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0xD then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x5 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0xB then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x4 then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0xC then {
                                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b011 then {
                                if CRm == 0xD then {
                                    __cond0 = true;
                                    return(__cond0)
                                } else {
                                    if CRm == 0xA then {
                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0xE then {
                                                __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0xC then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if CRm == 0xD then {
                                        __cond0 = true;
                                        return(__cond0)
                                    } else {
                                        if CRm == 0xA then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0xE then {
                                                    __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if CRm == 0xC then {
                                                        __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b100 then {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if CRm == 0x3 then {
                                                __cond0 = ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b000 then {
                            if CRm == 0x6 then {
                                if op2 == 0b010 then {
                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if op2 == 0b101 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b011 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b100 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b000 then {
                                    if CRm == 0x8 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x5 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x1 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0x9 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b010 then {
                                        if CRm == 0x8 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0xA then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if CRm == 0xE then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0xE then {
                                            if op2 == 0b100 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b110 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                }
                                            }
                                        } else {
                                            if CRm == 0xA then {
                                                if op2 == 0b100 then {
                                                    __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b110 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x8 then {
                                                    if op2 == 0b011 then {
                                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                } else {
                                                    if op2 == 0b001 then {
                                                        if CRm == 0x9 then {
                                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x8 then {
                                if op1 == 0b100 then {
                                    if op2 == 0b000 then {
                                        __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b101 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b111 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            } else {
                                                if op2 == 0b001 then {
                                                    __cond0 = ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                    return(__cond0)
                                                } else {
                                                    if op2 == 0b100 then {
                                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                        return(__cond0)
                                                    } else {
                                                        if op2 == 0b110 then {
                                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                            return(__cond0)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b110 then {
                                        if op2 == 0b000 then {
                                            __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b001 then {
                                                __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (el == EL3 & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (el == EL3 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op0 == 0b10 then {
                if op1 == 0b000 then {
                    if CRn == 0x1 then {
                        if op2 == 0b100 then {
                            if CRm == 0x0 then {
                                __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if CRm == 0x1 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if CRm == 0x4 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x3 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if op2 == 0b000 then {
                                    __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                }
                            }
                        }
                    } else {
                        if CRn == 0x0 then {
                            if op2 == 0b010 then {
                                if CRm == 0x2 then {
                                    __cond0 = ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL1) & (__HCR_EL2_NV == 0 | __HCR_EL2_NV2 == 0)) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                    return(__cond0)
                                } else {
                                    if CRm == 0x0 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x6 then {
                                            __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x3 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if op2 == 0b000 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x7 then {
                                if op2 == 0b110 then {
                                    if CRm == 0x8 then {
                                        __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    } else {
                                        if CRm == 0xE then {
                                            __cond0 = read == 0b1 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        } else {
                                            if CRm == 0x9 then {
                                                __cond0 = (((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b000 then {
                        if CRn == 0x0 then {
                            if op1 == 0b011 then {
                                if CRm == 0x5 then {
                                    __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    __cond1 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0 | __cond1)
                                } else {
                                    if CRm == 0x1 then {
                                        __cond0 = read == 0b1 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if CRm == 0x4 then {
                                            __cond0 = ((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                            return(__cond0)
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b100 then {
                                    if CRm == 0x7 then {
                                        __cond0 = ((el == EL3 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1);
                                        return(__cond0)
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRn == 0x4 then {
                    if op0 == 0b00 then {
                        if op1 == 0b011 then {
                            if op2 == 0b010 then {
                                __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                return(__cond0)
                            } else {
                                if op2 == 0b111 then {
                                    __cond0 = read == 0b0 & ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_E2H == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if op2 == 0b001 then {
                                        __cond0 = read == 0b0 & (((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b100 then {
                                            __cond0 = read == 0b0 & true;
                                            return(__cond0)
                                        } else {
                                            if op2 == 0b110 then {
                                                __cond0 = read == 0b0 & ((((((el == EL3 | el == EL0) | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL2 | el == EL3) | el == EL0) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL2 | el == EL3) | el == EL0) & __HCR_EL2_E2H == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((el == EL2 | el == EL3) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                                return(__cond0)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b000 then {
                                if op2 == 0b101 then {
                                    __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                    return(__cond0)
                                } else {
                                    if op2 == 0b011 then {
                                        __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                        return(__cond0)
                                    } else {
                                        if op2 == 0b100 then {
                                            __cond0 = read == 0b0 & ((((el == EL3 | el == EL1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1));
                                            return(__cond0)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    false
}

val AArch32_ResetSpecialRegisters : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_ResetSpecialRegisters () = {
    SPSR_fiq = undefined : bits(32);
    SPSR_irq = undefined : bits(32);
    set_SPSR_svc(undefined : bits(32));
    SPSR_abt = undefined : bits(32);
    SPSR_und = undefined : bits(32);
    if HaveEL(EL2) then {
        set_SPSR_hyp(undefined : bits(32));
        set_ELR_hyp(undefined : bits(32))
    };
    if HaveEL(EL3) then {
        set_SPSR_mon(undefined : bits(32))
    };
    set_DLR(undefined : bits(32));
    set_DSPSR(undefined : bits(32));
    return()
}

val DecodeBitMasks : forall ('M : Int), 'M >= 0.
  (implicit('M), bits(1), bits(6), bits(6), bool) -> (bits('M), bits('M)) effect {escape, undef}

function DecodeBitMasks (M, immN, imms, immr, immediate) = {
    tmask : bits(64) = undefined : bits(64);
    wmask : bits(64) = undefined : bits(64);
    tmask_and : bits(6) = undefined : bits(6);
    wmask_and : bits(6) = undefined : bits(6);
    tmask_or : bits(6) = undefined : bits(6);
    wmask_or : bits(6) = undefined : bits(6);
    levels : bits(6) = undefined : bits(6);
    let len : int = HighestSetBit(immN @ ~(imms));
    if len < 1 then {
        throw(Error_Undefined())
    };
    assert(len >= 1);
    assert('M >= shl_int(1, len));
    let levels = ZeroExtend(Ones(len), 6);
    if immediate & (imms & levels) == levels then {
        throw(Error_Undefined())
    };
    let S : int = UInt(imms & levels);
    let R : int = UInt(immr & levels);
    let diff : int = S - R;
    let tmask_and = __GetSlice_int(6, diff, 0) | ~(levels);
    let tmask_or = __GetSlice_int(6, diff, 0) & levels;
    tmask = Ones(64);
    tmask = tmask & replicate_bits(replicate_bits([tmask_and[0]], 1) @ Ones(1), 32) | replicate_bits(Zeros(1) @ replicate_bits([tmask_or[0]], 1), 32);
    tmask = tmask & replicate_bits(replicate_bits([tmask_and[1]], 2) @ Ones(2), 16) | replicate_bits(Zeros(2) @ replicate_bits([tmask_or[1]], 2), 16);
    tmask = tmask & replicate_bits(replicate_bits([tmask_and[2]], 4) @ Ones(4), 8) | replicate_bits(Zeros(4) @ replicate_bits([tmask_or[2]], 4), 8);
    tmask = tmask & replicate_bits(replicate_bits([tmask_and[3]], 8) @ Ones(8), 4) | replicate_bits(Zeros(8) @ replicate_bits([tmask_or[3]], 8), 4);
    tmask = tmask & replicate_bits(replicate_bits([tmask_and[4]], 16) @ Ones(16), 2) | replicate_bits(Zeros(16) @ replicate_bits([tmask_or[4]], 16), 2);
    let tmask = tmask & replicate_bits(replicate_bits([tmask_and[5]], 32) @ Ones(32), 1) | replicate_bits(Zeros(32) @ replicate_bits([tmask_or[5]], 32), 1);
    let wmask_and = immr | ~(levels);
    let wmask_or = immr & levels;
    wmask = Zeros(64);
    wmask = wmask & replicate_bits(Ones(1) @ replicate_bits([wmask_and[0]], 1), 32) | replicate_bits(replicate_bits([wmask_or[0]], 1) @ Zeros(1), 32);
    wmask = wmask & replicate_bits(Ones(2) @ replicate_bits([wmask_and[1]], 2), 16) | replicate_bits(replicate_bits([wmask_or[1]], 2) @ Zeros(2), 16);
    wmask = wmask & replicate_bits(Ones(4) @ replicate_bits([wmask_and[2]], 4), 8) | replicate_bits(replicate_bits([wmask_or[2]], 4) @ Zeros(4), 8);
    wmask = wmask & replicate_bits(Ones(8) @ replicate_bits([wmask_and[3]], 8), 4) | replicate_bits(replicate_bits([wmask_or[3]], 8) @ Zeros(8), 4);
    wmask = wmask & replicate_bits(Ones(16) @ replicate_bits([wmask_and[4]], 16), 2) | replicate_bits(replicate_bits([wmask_or[4]], 16) @ Zeros(16), 2);
    wmask = wmask & replicate_bits(Ones(32) @ replicate_bits([wmask_and[5]], 32), 1) | replicate_bits(replicate_bits([wmask_or[5]], 32) @ Zeros(32), 1);
    if __GetSlice_int(1, diff, 6) != 0b0 then {
        wmask = wmask & tmask
    } else {
        wmask = wmask | tmask
    };
    return((slice(wmask, 0, 'M), slice(tmask, 0, 'M)))
}

val ChooseNonExcludedTag : (bits(4), bits(4), bits(16)) -> bits(4)

function ChooseNonExcludedTag (tag__arg, offset__arg, exclude) = {
    offset = offset__arg;
    tag = tag__arg;
    if exclude == Ones(16) then {
        return(tag)
    };
    while offset != 0x0 do {
        offset = offset - 0x1;
        tag = tag + 0x1;
        while [exclude[UInt(tag)]] == 0b1 do {
            tag = tag + 0x1
        }
    };
    tag
}

val BTypeCompatible_BTI : bits(2) -> bool effect {rreg}

function BTypeCompatible_BTI hintcode = {
    match hintcode {
      0b00 => {
          return(false)
      },
      0b01 => {
          return(PSTATE.BTYPE != 0b11)
      },
      0b10 => {
          return(PSTATE.BTYPE != 0b10)
      },
      0b11 => {
          return(true)
      }
    }
}

val integer_tags_mcsubtag : forall ('ADD : Bool) 'd 'n,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('d >= 0 & 'd <= 31 | not(not('d == 31))).
  (bool('ADD), int('d), int('n), bits(64), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcsubtag (ADD, d, n, offset, tag_offset) = {
    let operand1 : bits(64) = if n == 31 then SP() else X(n);
    let start_tag : bits(4) = AllocationTagFromAddress(operand1);
    let exclude = slice(GCR_EL1, 0, 16);
    result : bits(64) = undefined : bits(64);
    rtag : bits(4) = undefined : bits(4);
    if AllocationTagAccessIsEnabled() then {
        rtag = ChooseNonExcludedTag(start_tag, tag_offset, exclude)
    } else {
        rtag = 0x0
    };
    __anon1 : bits(4) = undefined : bits(4);
    __anon2 : bits(4) = undefined : bits(4);
    if ADD then {
        (result, __anon1) = AddWithCarry(operand1, offset, 0b0)
    } else {
        (result, __anon2) = AddWithCarry(operand1, ~(offset), 0b1)
    };
    let result = AddressWithAllocationTag(result, rtag);
    if d == 31 then {
        SP() = result
    } else {
        X(d) = result
    }
}

val integer_tags_mcinsertrandomtag : forall 'd 'm 'n,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31 | not(not('d == 31))).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcinsertrandomtag (d, m, n) = {
    let operand : bits(64) = if n == 31 then SP() else X(n);
    let xm : bits(64) = X(m);
    let exclude : bits(16) = slice(xm, 0, 16) | slice(GCR_EL1, 0, 16);
    rtag : bits(4) = undefined : bits(4);
    if AllocationTagAccessIsEnabled() then {
        if [GCR_EL1[16]] == 0b1 then {
            RGSR_EL1 = undefined : bits(32);
            rtag = _ChooseRandomNonExcludedTag(exclude)
        } else {
            let start = slice(RGSR_EL1, 0, 4);
            let offset = RandomTag();
            rtag = ChooseNonExcludedTag(start, offset, exclude);
            RGSR_EL1 = __SetSlice_bits(32, 4, RGSR_EL1, 0, rtag)
        }
    } else {
        rtag = 0x0
    };
    let result : bits(64) = AddressWithAllocationTag(operand, rtag);
    if d == 31 then {
        SP() = result
    } else {
        X(d) = result
    }
}

val integer_tags_mcaddtag : forall ('ADD : Bool) 'd 'n,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('d >= 0 & 'd <= 31 | not(not('d == 31))).
  (bool('ADD), int('d), int('n), bits(64), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcaddtag (ADD, d, n, offset, tag_offset) = {
    let operand1 : bits(64) = if n == 31 then SP() else X(n);
    let start_tag : bits(4) = AllocationTagFromAddress(operand1);
    let exclude = slice(GCR_EL1, 0, 16);
    result : bits(64) = undefined : bits(64);
    rtag : bits(4) = undefined : bits(4);
    if AllocationTagAccessIsEnabled() then {
        rtag = ChooseNonExcludedTag(start_tag, tag_offset, exclude)
    } else {
        rtag = 0x0
    };
    __anon1 : bits(4) = undefined : bits(4);
    __anon2 : bits(4) = undefined : bits(4);
    if ADD then {
        (result, __anon1) = AddWithCarry(operand1, offset, 0b0)
    } else {
        (result, __anon2) = AddWithCarry(operand1, ~(offset), 0b1)
    };
    let result = AddressWithAllocationTag(result, rtag);
    if d == 31 then {
        SP() = result
    } else {
        X(d) = result
    }
}

val integer_logical_immediate : forall 'd 'datasize 'n ('setflags : Bool),
  'datasize >= 0 & ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31 | not(not(('d == 31 & not('setflags))))).
  (int('d), int('datasize), bits('datasize), int('n), LogicalOp, bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function integer_logical_immediate (d, datasize, imm, n, op, setflags) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = X(n);
    let operand2 = imm;
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      },
      LogicalOp_EOR => {
          result = operand1 ^ operand2
      }
    };
    let result = result;
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = ([result[datasize - 1]] @ IsZeroBit(result)) @ 0b00
    };
    if d == 31 & ~(setflags) then {
        SP() = result
    } else {
        X(d) = result
    }
}

val integer_arithmetic_addsub_immediate : forall 'd 'datasize 'n ('setflags : Bool) ('sub_op : Bool),
  'datasize >= 0 & ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64} | not(not('n == 31))) & ('d >= 0 & 'd <= 31 | not(not(('d == 31 & not('setflags))))).
  (int('d), int('datasize), bits('datasize), int('n), bool('setflags), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_immediate (d, datasize, imm, n, setflags, sub_op) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = if n == 31 then SP() else X(n);
    operand2 : bits('datasize) = imm;
    nzcv : bits(4) = undefined : bits(4);
    carry_in : bits(1) = undefined : bits(1);
    if sub_op then {
        operand2 = ~(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    if d == 31 & ~(setflags) then {
        SP() = result
    } else {
        X(d) = result
    }
}

val integer_arithmetic_addsub_extendedreg : forall 'd 'datasize 'm 'n ('setflags : Bool) 'shift ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64} | not(not('n == 31))) & ('shift >= 0 & 'shift <= 4) & ('m >= 0 & 'm <= 31 & 'datasize in {8, 16, 32, 64}) & ('d >= 0 & 'd <= 31 | not(not(('d == 31 & not('setflags))))).
  (int('d), int('datasize), ExtendType, int('m), int('n), bool('setflags), int('shift), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_extendedreg (d, datasize, extend_type, m, n, setflags, shift, sub_op) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = if n == 31 then SP() else X(n);
    operand2 : bits('datasize) = ExtendReg(m, extend_type, shift);
    nzcv : bits(4) = undefined : bits(4);
    carry_in : bits(1) = undefined : bits(1);
    if sub_op then {
        operand2 = ~(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    };
    if d == 31 & ~(setflags) then {
        SP() = result
    } else {
        X(d) = result
    }
}

val aget_SPSR : unit -> bits(32) effect {escape, rreg, undef}

function aget_SPSR () = {
    result : bits(32) = undefined : bits(32);
    if UsingAArch32() then {
        match PSTATE.M {
          ? if ? == M32_FIQ => {
              result = SPSR_fiq
          },
          ? if ? == M32_IRQ => {
              result = SPSR_irq
          },
          ? if ? == M32_Svc => {
              result = get_SPSR_svc()
          },
          ? if ? == M32_Monitor => {
              result = get_SPSR_mon()
          },
          ? if ? == M32_Abort => {
              result = SPSR_abt
          },
          ? if ? == M32_Hyp => {
              result = get_SPSR_hyp()
          },
          ? if ? == M32_Undef => {
              result = SPSR_und
          },
          _ => {
              Unreachable()
          }
        }
    } else {
        match PSTATE.EL {
          ? if ? == EL1 => {
              result = SPSR_EL1
          },
          ? if ? == EL2 => {
              result = SPSR_EL2
          },
          ? if ? == EL3 => {
              result = SPSR_EL3
          },
          _ => {
              Unreachable()
          }
        }
    };
    result
}

overload SPSR = {aget_SPSR}

val SetNotTagCheckedInstruction : forall ('unchecked : Bool).
  bool('unchecked) -> unit effect {configuration, escape, rreg}

function SetNotTagCheckedInstruction unchecked = {
    if unchecked then {
        sp_rel_access_pc = ThisInstrAddr()
    }
}

val AArch32_ExecutingCP10or11Instr : unit -> bool effect {escape, rreg, undef}

function AArch32_ExecutingCP10or11Instr () = {
    let instr = ThisInstr();
    let instr_set = CurrentInstrSet();
    assert(instr_set == InstrSet_A32 | instr_set == InstrSet_T32);
    if instr_set == InstrSet_A32 then {
        return((slice(instr, 24, 4) == 0xE | slice(instr, 25, 3) == 0b110) & (slice(instr, 8, 4) & 0xE) == 0xA)
    } else {
        return(((slice(instr, 28, 4) & 0xE) == 0xE & (slice(instr, 24, 4) == 0xE | slice(instr, 25, 3) == 0b110)) & (slice(instr, 8, 4) & 0xE) == 0xA)
    }
}

val HaveAnyAArch64 : unit -> bool effect {rreg}

function HaveAnyAArch64 () = {
    ~(HighestELUsingAArch32())
}

val AArch64_ResetSpecialRegisters : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_ResetSpecialRegisters () = {
    SP_EL0 = undefined : bits(64);
    SP_EL1 = undefined : bits(64);
    SPSR_EL1 = undefined : bits(32);
    ELR_EL1 = undefined : bits(64);
    if HaveEL(EL2) then {
        SP_EL2 = undefined : bits(64);
        SPSR_EL2 = undefined : bits(32);
        ELR_EL2 = undefined : bits(64)
    };
    if HaveEL(EL3) then {
        SP_EL3 = undefined : bits(64);
        SPSR_EL3 = undefined : bits(32);
        ELR_EL3 = undefined : bits(64)
    };
    if HaveAArch32EL(EL1) then {
        SPSR_fiq = undefined : bits(32);
        SPSR_irq = undefined : bits(32);
        SPSR_abt = undefined : bits(32);
        SPSR_und = undefined : bits(32)
    };
    DLR_EL0 = undefined : bits(64);
    DSPSR_EL0 = undefined : bits(32);
    return()
}

val ExternalDebugInterruptsDisabled : bits(2) -> bool effect {escape, rreg, undef}

function ExternalDebugInterruptsDisabled target = {
    int_dis : bool = undefined : bool;
    match target {
      ? if ? == EL3 => {
          int_dis = slice(EDSCR, 22, 2) == 0b11 & ExternalSecureDebugEnabled()
      },
      ? if ? == EL2 => {
          int_dis = (slice(EDSCR, 22, 2) & 0b10) == 0b10 & ExternalDebugEnabled()
      },
      ? if ? == EL1 => {
          if IsSecure() then {
              int_dis = (slice(EDSCR, 22, 2) & 0b10) == 0b10 & ExternalSecureDebugEnabled()
          } else {
              int_dis = slice(EDSCR, 22, 2) != 0b00 & ExternalDebugEnabled()
          }
      }
    };
    int_dis
}

val ELUsingAArch32K : bits(2) -> (bool, bool) effect {escape, rreg, undef}

function ELUsingAArch32K el = {
    ELStateUsingAArch32K(el, IsSecureBelowEL3())
}

val set_VBAR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_VBAR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        VBAR_S = r
    } else {
        set_VBAR_NS(r)
    };
    return()
}

val set_TTBR1 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function set_TTBR1 val_name = {
    let r : bits(64) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        TTBR1_S = r
    } else {
        set_TTBR1_NS(r)
    };
    return()
}

val set_TTBR0 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function set_TTBR0 val_name = {
    let r : bits(64) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        TTBR0_S = r
    } else {
        set_TTBR0_NS(r)
    };
    return()
}

val set_TTBCR2 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_TTBCR2 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        TTBCR2_S = r
    } else {
        set_TTBCR2_NS(r)
    };
    return()
}

val set_TTBCR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_TTBCR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        TTBCR_S = r
    } else {
        set_TTBCR_NS(r)
    };
    return()
}

val set_SCTLR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_SCTLR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        SCTLR_S = r
    } else {
        set_SCTLR_NS(r)
    };
    return()
}

val set_PRRR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_PRRR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        PRRR_S = r
    } else {
        set_PRRR_NS(r)
    };
    return()
}

val set_PAR : bits(64) -> unit effect {escape, rreg, undef, wreg}

function set_PAR val_name = {
    let r : bits(64) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        PAR_S = r
    } else {
        set_PAR_NS(r)
    };
    return()
}

val set_NMRR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_NMRR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        NMRR_S = r
    } else {
        set_NMRR_NS(r)
    };
    return()
}

val set_ICC_SRE_EL1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_SRE_EL1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_SRE_EL1_S = r
    } else {
        ICC_SRE_EL1_NS = r
    };
    return()
}

val set_ICC_IGRPEN1_EL1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_IGRPEN1_EL1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_IGRPEN1_EL1_S = r
    } else {
        ICC_IGRPEN1_EL1_NS = r
    };
    return()
}

val set_ICC_CTLR_EL1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_CTLR_EL1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_CTLR_EL1_S = r
    } else {
        ICC_CTLR_EL1_NS = r
    };
    return()
}

val set_ICC_BPR1_EL1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_BPR1_EL1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_BPR1_EL1_S = r
    } else {
        ICC_BPR1_EL1_NS = r
    };
    return()
}

val set_CSSELR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_CSSELR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        CSSELR_S = r
    } else {
        set_CSSELR_NS(r)
    };
    return()
}

val set_CNTP_CTL : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_CNTP_CTL val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        CNTP_CTL_S = r
    } else {
        set_CNTP_CTL_NS(r)
    };
    return()
}

val AArch32_ReportDeferredSError : (bits(2), bits(1)) -> bits(32) effect {escape, rreg, undef}

function AArch32_ReportDeferredSError (AET, ExT) = {
    target : bits(32) = undefined : bits(32);
    target = __SetSlice_bits(32, 1, target, 31, 0b1);
    syndrome : bits(16) = undefined : bits(16);
    syndrome = Zeros(16);
    if PSTATE.EL == EL2 then {
        syndrome = __SetSlice_bits(16, 2, syndrome, 10, AET);
        syndrome = __SetSlice_bits(16, 1, syndrome, 9, ExT);
        syndrome = __SetSlice_bits(16, 6, syndrome, 0, 0b010001)
    } else {
        syndrome = __SetSlice_bits(16, 2, syndrome, 14, AET);
        syndrome = __SetSlice_bits(16, 1, syndrome, 12, ExT);
        syndrome = __SetSlice_bits(16, 1, syndrome, 9, [get_TTBCR()[31]]);
        if [get_TTBCR()[31]] == 0b1 then {
            syndrome = __SetSlice_bits(16, 6, syndrome, 0, 0b010001)
        } else {
            (syndrome[10 .. 10] @ syndrome[3 .. 0]) = 0b10110
        }
    };
    if HaveAnyAArch64() then {
        target = __SetSlice_bits(32, 25, target, 0, ZeroExtend(syndrome))
    } else {
        target = __SetSlice_bits(32, 16, target, 0, syndrome)
    };
    target
}

val RestoredITBits : bits(32) -> bits(8) effect {escape, rreg, undef}

function RestoredITBits spsr = {
    let it : bits(8) = spsr[10 .. 5] @ spsr[25 .. 24];
    if PSTATE.IL == 0b1 then {
        if ConstrainUnpredictableBool(Unpredictable_ILZEROIT) then {
            return(0x00)
        } else {
            return(it)
        }
    };
    if ~(IsZero(slice(it, 4, 4))) & IsZero(slice(it, 0, 4)) then {
        return(0x00)
    };
    let itd = if PSTATE.EL == EL2 then [get_HSCTLR()[7]] else [get_SCTLR()[7]];
    if [spsr[5]] == 0b0 & ~(IsZero(it)) | itd == 0b1 & ~(IsZero(slice(it, 0, 3))) then {
        return(0x00)
    } else {
        return(it)
    }
}

val get_PAR : unit -> bits(64) effect {escape, rreg, undef}

function get_PAR () = {
    r : bits(64) = undefined : bits(64);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = PAR_S
    } else {
        r = get_PAR_NS()
    };
    r
}

val AArch32_IMPDEFResets : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_IMPDEFResets () = {
    set_PMCEID0(0x7FFF0F3F);
    __tc1 : bits(32) = get_PMCR();
    let __tc1 = __SetSlice_bits(32, 8, __tc1, 24, 0x41);
    set_PMCR(__tc1);
    __tc2 : bits(32) = get_PMCR();
    let __tc2 = __SetSlice_bits(32, 8, __tc2, 16, 0x01);
    set_PMCR(__tc2);
    __tc3 : bits(32) = get_PMCR();
    let __tc3 = __SetSlice_bits(32, 5, __tc3, 11, 0b00110);
    set_PMCR(__tc3);
    __tc4 : bits(32) = get_PMCR();
    let __tc4 = __SetSlice_bits(32, 1, __tc4, 2, 0b0);
    set_PMCR(__tc4);
    __tc5 : bits(32) = get_PMCR();
    let __tc5 = __SetSlice_bits(32, 1, __tc5, 1, 0b0);
    set_PMCR(__tc5);
    __tc6 : bits(32) = get_CCSIDR();
    let __tc6 = __SetSlice_bits(32, 15, __tc6, 13, 0b000000011111111);
    set_CCSIDR(__tc6);
    __tc7 : bits(32) = get_CCSIDR();
    let __tc7 = __SetSlice_bits(32, 21, __tc7, 3, ZeroExtend(0b1));
    set_CCSIDR(__tc7);
    __tc8 : bits(32) = get_CCSIDR();
    let __tc8 = __SetSlice_bits(32, 3, __tc8, 0, 0b010);
    set_CCSIDR(__tc8);
    __tc9 : bits(32) = get_CCSIDR();
    let __tc9 = __SetSlice_bits(32, 21, __tc9, 3, 0b111111110000000001010);
    set_CCSIDR(__tc9);
    __tc10 : bits(32) = get_CCSIDR();
    let __tc10 = __SetSlice_bits(32, 3, __tc10, 0, 0b010);
    set_CCSIDR(__tc10);
    __tc11 : bits(32) = get_CLIDR();
    let __tc11 = __SetSlice_bits(32, 2, __tc11, 30, 0b00);
    set_CLIDR(__tc11);
    __tc12 : bits(32) = get_CLIDR();
    let __tc12 = __SetSlice_bits(32, 3, __tc12, 27, 0b001);
    set_CLIDR(__tc12);
    __tc13 : bits(32) = get_CLIDR();
    let __tc13 = __SetSlice_bits(32, 3, __tc13, 24, 0b010);
    set_CLIDR(__tc13);
    __tc14 : bits(32) = get_CLIDR();
    let __tc14 = __SetSlice_bits(32, 3, __tc14, 21, 0b001);
    set_CLIDR(__tc14);
    __tc15 : bits(32) = get_CLIDR();
    let __tc15 = __SetSlice_bits(32, 21, __tc15, 0, 0b000000000000000100011);
    set_CLIDR(__tc15);
    __tc16 : bits(32) = get_CTR();
    let __tc16 = __SetSlice_bits(32, 1, __tc16, 29, 0b0);
    set_CTR(__tc16);
    __tc17 : bits(32) = get_CTR();
    let __tc17 = __SetSlice_bits(32, 1, __tc17, 28, 0b0);
    set_CTR(__tc17);
    __tc18 : bits(32) = get_CTR();
    let __tc18 = __SetSlice_bits(32, 4, __tc18, 24, 0x4);
    set_CTR(__tc18);
    __tc19 : bits(32) = get_CTR();
    let __tc19 = __SetSlice_bits(32, 4, __tc19, 20, 0x4);
    set_CTR(__tc19);
    __tc20 : bits(32) = get_CTR();
    let __tc20 = __SetSlice_bits(32, 4, __tc20, 16, 0x4);
    set_CTR(__tc20);
    __tc21 : bits(32) = get_CTR();
    let __tc21 = __SetSlice_bits(32, 2, __tc21, 14, 0b11);
    set_CTR(__tc21);
    __tc22 : bits(32) = get_CTR();
    let __tc22 = __SetSlice_bits(32, 4, __tc22, 0, 0x4);
    set_CTR(__tc22);
    FPSID = __SetSlice_bits(32, 8, FPSID, 24, 0x41);
    FPSID = __SetSlice_bits(32, 1, FPSID, 23, 0b0);
    FPSID = __SetSlice_bits(32, 7, FPSID, 16, 0b0000100);
    FPSID = __SetSlice_bits(32, 8, FPSID, 8, 0x30);
    FPSID = __SetSlice_bits(32, 4, FPSID, 4, 0x7);
    FPSID = __SetSlice_bits(32, 4, FPSID, 0, 0x0);
    __tc23 : bits(32) = get_ID_DFR0();
    let __tc23 = __SetSlice_bits(32, 4, __tc23, 24, 0x3);
    set_ID_DFR0(__tc23);
    __tc24 : bits(32) = get_ID_DFR0();
    let __tc24 = __SetSlice_bits(32, 4, __tc24, 20, 0x0);
    set_ID_DFR0(__tc24);
    __tc25 : bits(32) = get_ID_DFR0();
    let __tc25 = __SetSlice_bits(32, 4, __tc25, 16, 0x1);
    set_ID_DFR0(__tc25);
    __tc26 : bits(32) = get_ID_DFR0();
    let __tc26 = __SetSlice_bits(32, 4, __tc26, 12, 0x0);
    set_ID_DFR0(__tc26);
    __tc27 : bits(32) = get_ID_DFR0();
    let __tc27 = __SetSlice_bits(32, 4, __tc27, 8, 0x0);
    set_ID_DFR0(__tc27);
    __tc28 : bits(32) = get_ID_DFR0();
    let __tc28 = __SetSlice_bits(32, 4, __tc28, 4, 0x6);
    set_ID_DFR0(__tc28);
    __tc29 : bits(32) = get_ID_DFR0();
    let __tc29 = __SetSlice_bits(32, 4, __tc29, 0, 0x6);
    set_ID_DFR0(__tc29);
    __tc30 : bits(32) = get_ID_ISAR0();
    let __tc30 = __SetSlice_bits(32, 4, __tc30, 24, 0x2);
    set_ID_ISAR0(__tc30);
    __tc31 : bits(32) = get_ID_ISAR0();
    let __tc31 = __SetSlice_bits(32, 4, __tc31, 20, 0x1);
    set_ID_ISAR0(__tc31);
    __tc32 : bits(32) = get_ID_ISAR0();
    let __tc32 = __SetSlice_bits(32, 4, __tc32, 16, 0x0);
    set_ID_ISAR0(__tc32);
    __tc33 : bits(32) = get_ID_ISAR0();
    let __tc33 = __SetSlice_bits(32, 4, __tc33, 12, 0x1);
    set_ID_ISAR0(__tc33);
    __tc34 : bits(32) = get_ID_ISAR0();
    let __tc34 = __SetSlice_bits(32, 4, __tc34, 8, 0x1);
    set_ID_ISAR0(__tc34);
    __tc35 : bits(32) = get_ID_ISAR0();
    let __tc35 = __SetSlice_bits(32, 4, __tc35, 4, 0x1);
    set_ID_ISAR0(__tc35);
    __tc36 : bits(32) = get_ID_ISAR0();
    let __tc36 = __SetSlice_bits(32, 4, __tc36, 0, 0x0);
    set_ID_ISAR0(__tc36);
    __tc37 : bits(32) = get_ID_ISAR1();
    let __tc37 = __SetSlice_bits(32, 4, __tc37, 28, 0x1);
    set_ID_ISAR1(__tc37);
    __tc38 : bits(32) = get_ID_ISAR1();
    let __tc38 = __SetSlice_bits(32, 4, __tc38, 24, 0x3);
    set_ID_ISAR1(__tc38);
    __tc39 : bits(32) = get_ID_ISAR1();
    let __tc39 = __SetSlice_bits(32, 4, __tc39, 20, 0x1);
    set_ID_ISAR1(__tc39);
    __tc40 : bits(32) = get_ID_ISAR1();
    let __tc40 = __SetSlice_bits(32, 4, __tc40, 16, 0x1);
    set_ID_ISAR1(__tc40);
    __tc41 : bits(32) = get_ID_ISAR1();
    let __tc41 = __SetSlice_bits(32, 4, __tc41, 12, 0x2);
    set_ID_ISAR1(__tc41);
    __tc42 : bits(32) = get_ID_ISAR1();
    let __tc42 = __SetSlice_bits(32, 4, __tc42, 8, 0x1);
    set_ID_ISAR1(__tc42);
    __tc43 : bits(32) = get_ID_ISAR1();
    let __tc43 = __SetSlice_bits(32, 4, __tc43, 4, 0x1);
    set_ID_ISAR1(__tc43);
    __tc44 : bits(32) = get_ID_ISAR1();
    let __tc44 = __SetSlice_bits(32, 4, __tc44, 0, 0x1);
    set_ID_ISAR1(__tc44);
    __tc45 : bits(32) = get_ID_ISAR2();
    let __tc45 = __SetSlice_bits(32, 4, __tc45, 28, 0x2);
    set_ID_ISAR2(__tc45);
    __tc46 : bits(32) = get_ID_ISAR2();
    let __tc46 = __SetSlice_bits(32, 4, __tc46, 24, 0x1);
    set_ID_ISAR2(__tc46);
    __tc47 : bits(32) = get_ID_ISAR2();
    let __tc47 = __SetSlice_bits(32, 4, __tc47, 20, 0x2);
    set_ID_ISAR2(__tc47);
    __tc48 : bits(32) = get_ID_ISAR2();
    let __tc48 = __SetSlice_bits(32, 4, __tc48, 16, 0x3);
    set_ID_ISAR2(__tc48);
    __tc49 : bits(32) = get_ID_ISAR2();
    let __tc49 = __SetSlice_bits(32, 4, __tc49, 12, 0x2);
    set_ID_ISAR2(__tc49);
    __tc50 : bits(32) = get_ID_ISAR2();
    let __tc50 = __SetSlice_bits(32, 4, __tc50, 8, 0x0);
    set_ID_ISAR2(__tc50);
    __tc51 : bits(32) = get_ID_ISAR2();
    let __tc51 = __SetSlice_bits(32, 4, __tc51, 4, 0x4);
    set_ID_ISAR2(__tc51);
    __tc52 : bits(32) = get_ID_ISAR2();
    let __tc52 = __SetSlice_bits(32, 4, __tc52, 0, 0x2);
    set_ID_ISAR2(__tc52);
    __tc53 : bits(32) = get_ID_ISAR3();
    let __tc53 = __SetSlice_bits(32, 4, __tc53, 28, 0x0);
    set_ID_ISAR3(__tc53);
    __tc54 : bits(32) = get_ID_ISAR3();
    let __tc54 = __SetSlice_bits(32, 4, __tc54, 24, 0x1);
    set_ID_ISAR3(__tc54);
    __tc55 : bits(32) = get_ID_ISAR3();
    let __tc55 = __SetSlice_bits(32, 4, __tc55, 20, 0x1);
    set_ID_ISAR3(__tc55);
    __tc56 : bits(32) = get_ID_ISAR3();
    let __tc56 = __SetSlice_bits(32, 4, __tc56, 16, 0x1);
    set_ID_ISAR3(__tc56);
    __tc57 : bits(32) = get_ID_ISAR3();
    let __tc57 = __SetSlice_bits(32, 4, __tc57, 12, 0x2);
    set_ID_ISAR3(__tc57);
    __tc58 : bits(32) = get_ID_ISAR3();
    let __tc58 = __SetSlice_bits(32, 4, __tc58, 8, 0x1);
    set_ID_ISAR3(__tc58);
    __tc59 : bits(32) = get_ID_ISAR3();
    let __tc59 = __SetSlice_bits(32, 4, __tc59, 4, 0x3);
    set_ID_ISAR3(__tc59);
    __tc60 : bits(32) = get_ID_ISAR3();
    let __tc60 = __SetSlice_bits(32, 4, __tc60, 0, 0x1);
    set_ID_ISAR3(__tc60);
    __tc61 : bits(32) = get_ID_ISAR4();
    let __tc61 = __SetSlice_bits(32, 4, __tc61, 28, 0x0);
    set_ID_ISAR4(__tc61);
    __tc62 : bits(32) = get_ID_ISAR4();
    let __tc62 = __SetSlice_bits(32, 4, __tc62, 24, 0x0);
    set_ID_ISAR4(__tc62);
    __tc63 : bits(32) = get_ID_ISAR4();
    let __tc63 = __SetSlice_bits(32, 4, __tc63, 20, 0x0);
    set_ID_ISAR4(__tc63);
    __tc64 : bits(32) = get_ID_ISAR4();
    let __tc64 = __SetSlice_bits(32, 4, __tc64, 16, 0x1);
    set_ID_ISAR4(__tc64);
    __tc65 : bits(32) = get_ID_ISAR4();
    let __tc65 = __SetSlice_bits(32, 4, __tc65, 12, 0x1);
    set_ID_ISAR4(__tc65);
    __tc66 : bits(32) = get_ID_ISAR4();
    let __tc66 = __SetSlice_bits(32, 4, __tc66, 8, 0x1);
    set_ID_ISAR4(__tc66);
    __tc67 : bits(32) = get_ID_ISAR4();
    let __tc67 = __SetSlice_bits(32, 4, __tc67, 4, 0x4);
    set_ID_ISAR4(__tc67);
    __tc68 : bits(32) = get_ID_ISAR4();
    let __tc68 = __SetSlice_bits(32, 4, __tc68, 0, 0x2);
    set_ID_ISAR4(__tc68);
    __tc69 : bits(32) = get_ID_ISAR5();
    let __tc69 = __SetSlice_bits(32, 4, __tc69, 28, 0x1);
    set_ID_ISAR5(__tc69);
    __tc70 : bits(32) = get_ID_ISAR5();
    let __tc70 = __SetSlice_bits(32, 4, __tc70, 24, 0x1);
    set_ID_ISAR5(__tc70);
    __tc71 : bits(32) = get_ID_ISAR5();
    let __tc71 = __SetSlice_bits(32, 4, __tc71, 16, 0x0);
    set_ID_ISAR5(__tc71);
    __tc72 : bits(32) = get_ID_ISAR5();
    let __tc72 = __SetSlice_bits(32, 4, __tc72, 12, 0x1);
    set_ID_ISAR5(__tc72);
    __tc73 : bits(32) = get_ID_ISAR5();
    let __tc73 = __SetSlice_bits(32, 4, __tc73, 8, 0x1);
    set_ID_ISAR5(__tc73);
    __tc74 : bits(32) = get_ID_ISAR5();
    let __tc74 = __SetSlice_bits(32, 4, __tc74, 4, 0x2);
    set_ID_ISAR5(__tc74);
    __tc75 : bits(32) = get_ID_ISAR5();
    let __tc75 = __SetSlice_bits(32, 4, __tc75, 0, 0x1);
    set_ID_ISAR5(__tc75);
    __tc76 : bits(32) = get_ID_ISAR6();
    let __tc76 = __SetSlice_bits(32, 4, __tc76, 4, 0x1);
    set_ID_ISAR6(__tc76);
    if __fp16_implemented then {
        __tc77 : bits(32) = get_MVFR1();
        __tc77 = __SetSlice_bits(32, 4, __tc77, 24, 0x3);
        set_MVFR1(__tc77);
        __tc78 : bits(32) = get_MVFR1();
        __tc78 = __SetSlice_bits(32, 4, __tc78, 20, 0x2);
        set_MVFR1(__tc78)
    } else {
        __tc79 : bits(32) = get_MVFR1();
        __tc79 = __SetSlice_bits(32, 4, __tc79, 24, 0x2);
        set_MVFR1(__tc79);
        __tc80 : bits(32) = get_MVFR1();
        __tc80 = __SetSlice_bits(32, 4, __tc80, 20, 0x1);
        set_MVFR1(__tc80)
    };
    if HasArchVersion(ARMv8p3) then {
        __tc81 : bits(32) = get_ID_MMFR4();
        __tc81 = __SetSlice_bits(32, 4, __tc81, 24, 0x1);
        set_ID_MMFR4(__tc81);
        __tc82 : bits(32) = get_ID_ISAR6();
        __tc82 = __SetSlice_bits(32, 4, __tc82, 0, 0x1);
        set_ID_ISAR6(__tc82)
    };
    if HasArchVersion(ARMv8p4) then {
        EDPFR = __SetSlice_bits(64, 4, EDPFR, 36, 0x1);
        __tc83 : bits(32) = get_ID_ISAR6();
        __tc83 = __SetSlice_bits(32, 4, __tc83, 8, 0x1);
        set_ID_ISAR6(__tc83)
    };
    __tc84 : bits(32) = get_ID_MMFR0();
    let __tc84 = __SetSlice_bits(32, 4, __tc84, 28, 0x1);
    set_ID_MMFR0(__tc84);
    __tc85 : bits(32) = get_ID_MMFR0();
    let __tc85 = __SetSlice_bits(32, 4, __tc85, 24, 0x0);
    set_ID_MMFR0(__tc85);
    __tc86 : bits(32) = get_ID_MMFR0();
    let __tc86 = __SetSlice_bits(32, 4, __tc86, 20, 0x1);
    set_ID_MMFR0(__tc86);
    __tc87 : bits(32) = get_ID_MMFR0();
    let __tc87 = __SetSlice_bits(32, 4, __tc87, 16, 0x0);
    set_ID_MMFR0(__tc87);
    __tc88 : bits(32) = get_ID_MMFR0();
    let __tc88 = __SetSlice_bits(32, 4, __tc88, 12, 0x1);
    set_ID_MMFR0(__tc88);
    __tc89 : bits(32) = get_ID_MMFR0();
    let __tc89 = __SetSlice_bits(32, 4, __tc89, 8, 0x1);
    set_ID_MMFR0(__tc89);
    __tc90 : bits(32) = get_ID_MMFR0();
    let __tc90 = __SetSlice_bits(32, 4, __tc90, 4, 0x0);
    set_ID_MMFR0(__tc90);
    __tc91 : bits(32) = get_ID_MMFR0();
    let __tc91 = __SetSlice_bits(32, 4, __tc91, 0, 0x5);
    set_ID_MMFR0(__tc91);
    __tc92 : bits(32) = get_ID_MMFR1();
    let __tc92 = __SetSlice_bits(32, 4, __tc92, 28, 0x4);
    set_ID_MMFR1(__tc92);
    __tc93 : bits(32) = get_ID_MMFR1();
    let __tc93 = __SetSlice_bits(32, 4, __tc93, 24, 0x0);
    set_ID_MMFR1(__tc93);
    __tc94 : bits(32) = get_ID_MMFR1();
    let __tc94 = __SetSlice_bits(32, 4, __tc94, 20, 0x0);
    set_ID_MMFR1(__tc94);
    __tc95 : bits(32) = get_ID_MMFR1();
    let __tc95 = __SetSlice_bits(32, 4, __tc95, 16, 0x0);
    set_ID_MMFR1(__tc95);
    __tc96 : bits(32) = get_ID_MMFR1();
    let __tc96 = __SetSlice_bits(32, 4, __tc96, 12, 0x0);
    set_ID_MMFR1(__tc96);
    __tc97 : bits(32) = get_ID_MMFR1();
    let __tc97 = __SetSlice_bits(32, 4, __tc97, 8, 0x0);
    set_ID_MMFR1(__tc97);
    __tc98 : bits(32) = get_ID_MMFR1();
    let __tc98 = __SetSlice_bits(32, 4, __tc98, 4, 0x0);
    set_ID_MMFR1(__tc98);
    __tc99 : bits(32) = get_ID_MMFR1();
    let __tc99 = __SetSlice_bits(32, 4, __tc99, 0, 0x0);
    set_ID_MMFR1(__tc99);
    __tc100 : bits(32) = get_ID_MMFR2();
    let __tc100 = __SetSlice_bits(32, 4, __tc100, 28, 0x0);
    set_ID_MMFR2(__tc100);
    __tc101 : bits(32) = get_ID_MMFR2();
    let __tc101 = __SetSlice_bits(32, 4, __tc101, 24, 0x1);
    set_ID_MMFR2(__tc101);
    __tc102 : bits(32) = get_ID_MMFR2();
    let __tc102 = __SetSlice_bits(32, 4, __tc102, 20, 0x2);
    set_ID_MMFR2(__tc102);
    __tc103 : bits(32) = get_ID_MMFR2();
    let __tc103 = __SetSlice_bits(32, 4, __tc103, 16, 0x6);
    set_ID_MMFR2(__tc103);
    __tc104 : bits(32) = get_ID_MMFR2();
    let __tc104 = __SetSlice_bits(32, 4, __tc104, 12, 0x0);
    set_ID_MMFR2(__tc104);
    __tc105 : bits(32) = get_ID_MMFR2();
    let __tc105 = __SetSlice_bits(32, 4, __tc105, 8, 0x0);
    set_ID_MMFR2(__tc105);
    __tc106 : bits(32) = get_ID_MMFR2();
    let __tc106 = __SetSlice_bits(32, 4, __tc106, 4, 0x0);
    set_ID_MMFR2(__tc106);
    __tc107 : bits(32) = get_ID_MMFR2();
    let __tc107 = __SetSlice_bits(32, 4, __tc107, 0, 0x0);
    set_ID_MMFR2(__tc107);
    __tc108 : bits(32) = get_ID_MMFR3();
    let __tc108 = __SetSlice_bits(32, 4, __tc108, 28, 0x0);
    set_ID_MMFR3(__tc108);
    __tc109 : bits(32) = get_ID_MMFR3();
    let __tc109 = __SetSlice_bits(32, 4, __tc109, 24, 0x2);
    set_ID_MMFR3(__tc109);
    __tc110 : bits(32) = get_ID_MMFR3();
    let __tc110 = __SetSlice_bits(32, 4, __tc110, 20, 0x1);
    set_ID_MMFR3(__tc110);
    __tc111 : bits(32) = get_ID_MMFR3();
    let __tc111 = __SetSlice_bits(32, 4, __tc111, 16, 0x1);
    set_ID_MMFR3(__tc111);
    __tc112 : bits(32) = get_ID_MMFR3();
    let __tc112 = __SetSlice_bits(32, 4, __tc112, 12, 0x2);
    set_ID_MMFR3(__tc112);
    __tc113 : bits(32) = get_ID_MMFR3();
    let __tc113 = __SetSlice_bits(32, 4, __tc113, 8, 0x2);
    set_ID_MMFR3(__tc113);
    __tc114 : bits(32) = get_ID_MMFR3();
    let __tc114 = __SetSlice_bits(32, 4, __tc114, 4, 0x1);
    set_ID_MMFR3(__tc114);
    __tc115 : bits(32) = get_ID_MMFR3();
    let __tc115 = __SetSlice_bits(32, 4, __tc115, 0, 0x1);
    set_ID_MMFR3(__tc115);
    __tc116 : bits(32) = get_ID_PFR0();
    let __tc116 = __SetSlice_bits(32, 4, __tc116, 28, 0x0);
    set_ID_PFR0(__tc116);
    __tc117 : bits(32) = get_ID_PFR0();
    let __tc117 = __SetSlice_bits(32, 4, __tc117, 12, 0x0);
    set_ID_PFR0(__tc117);
    __tc118 : bits(32) = get_ID_PFR0();
    let __tc118 = __SetSlice_bits(32, 4, __tc118, 8, 0x1);
    set_ID_PFR0(__tc118);
    __tc119 : bits(32) = get_ID_PFR0();
    let __tc119 = __SetSlice_bits(32, 4, __tc119, 4, 0x3);
    set_ID_PFR0(__tc119);
    __tc120 : bits(32) = get_ID_PFR0();
    let __tc120 = __SetSlice_bits(32, 4, __tc120, 0, 0x1);
    set_ID_PFR0(__tc120);
    __tc121 : bits(32) = get_ID_PFR1();
    let __tc121 = __SetSlice_bits(32, 4, __tc121, 28, 0x0);
    set_ID_PFR1(__tc121);
    __tc122 : bits(32) = get_ID_PFR1();
    let __tc122 = __SetSlice_bits(32, 4, __tc122, 24, 0x0);
    set_ID_PFR1(__tc122);
    __tc123 : bits(32) = get_ID_PFR1();
    let __tc123 = __SetSlice_bits(32, 4, __tc123, 20, 0x0);
    set_ID_PFR1(__tc123);
    __tc124 : bits(32) = get_ID_PFR1();
    let __tc124 = __SetSlice_bits(32, 4, __tc124, 16, 0x1);
    set_ID_PFR1(__tc124);
    __tc125 : bits(32) = get_ID_PFR1();
    let __tc125 = __SetSlice_bits(32, 4, __tc125, 12, 0x1);
    set_ID_PFR1(__tc125);
    __tc126 : bits(32) = get_ID_PFR1();
    let __tc126 = __SetSlice_bits(32, 4, __tc126, 8, 0x0);
    set_ID_PFR1(__tc126);
    __tc127 : bits(32) = get_ID_PFR1();
    let __tc127 = __SetSlice_bits(32, 4, __tc127, 4, 0x1);
    set_ID_PFR1(__tc127);
    __tc128 : bits(32) = get_ID_PFR1();
    let __tc128 = __SetSlice_bits(32, 4, __tc128, 0, 0x1);
    set_ID_PFR1(__tc128);
    __tc129 : bits(32) = get_MIDR();
    let __tc129 = __SetSlice_bits(32, 8, __tc129, 24, 0x41);
    set_MIDR(__tc129);
    __tc130 : bits(32) = get_MIDR();
    let __tc130 = __SetSlice_bits(32, 4, __tc130, 20, 0x0);
    set_MIDR(__tc130);
    __tc131 : bits(32) = get_MIDR();
    let __tc131 = __SetSlice_bits(32, 4, __tc131, 16, 0xF);
    set_MIDR(__tc131);
    __tc132 : bits(32) = get_MIDR();
    let __tc132 = __SetSlice_bits(32, 12, __tc132, 4, 0xD0F);
    set_MIDR(__tc132);
    __tc133 : bits(32) = get_MIDR();
    let __tc133 = __SetSlice_bits(32, 4, __tc133, 0, 0x0);
    set_MIDR(__tc133);
    __tc134 : bits(32) = get_MPIDR();
    let __tc134 = __SetSlice_bits(32, 1, __tc134, 31, 0b1);
    set_MPIDR(__tc134);
    __tc135 : bits(32) = get_MPIDR();
    let __tc135 = __SetSlice_bits(32, 1, __tc135, 30, 0b0);
    set_MPIDR(__tc135);
    __tc136 : bits(32) = get_MPIDR();
    let __tc136 = __SetSlice_bits(32, 1, __tc136, 24, 0b0);
    set_MPIDR(__tc136);
    __tc137 : bits(32) = get_MPIDR();
    let __tc137 = __SetSlice_bits(32, 8, __tc137, 16, 0x00);
    set_MPIDR(__tc137);
    __tc138 : bits(32) = get_MPIDR();
    let __tc138 = __SetSlice_bits(32, 8, __tc138, 8, 0x00);
    set_MPIDR(__tc138);
    __tc139 : bits(32) = get_MPIDR();
    let __tc139 = __SetSlice_bits(32, 8, __tc139, 0, 0x00);
    set_MPIDR(__tc139);
    __tc140 : bits(32) = get_MVFR0();
    let __tc140 = __SetSlice_bits(32, 4, __tc140, 28, 0x1);
    set_MVFR0(__tc140);
    __tc141 : bits(32) = get_MVFR0();
    let __tc141 = __SetSlice_bits(32, 4, __tc141, 24, 0x0);
    set_MVFR0(__tc141);
    __tc142 : bits(32) = get_MVFR0();
    let __tc142 = __SetSlice_bits(32, 4, __tc142, 20, 0x1);
    set_MVFR0(__tc142);
    __tc143 : bits(32) = get_MVFR0();
    let __tc143 = __SetSlice_bits(32, 4, __tc143, 16, 0x1);
    set_MVFR0(__tc143);
    __tc144 : bits(32) = get_MVFR0();
    let __tc144 = __SetSlice_bits(32, 4, __tc144, 12, 0x1);
    set_MVFR0(__tc144);
    __tc145 : bits(32) = get_MVFR0();
    let __tc145 = __SetSlice_bits(32, 4, __tc145, 8, 0x2);
    set_MVFR0(__tc145);
    __tc146 : bits(32) = get_MVFR0();
    let __tc146 = __SetSlice_bits(32, 4, __tc146, 4, 0x2);
    set_MVFR0(__tc146);
    __tc147 : bits(32) = get_MVFR0();
    let __tc147 = __SetSlice_bits(32, 4, __tc147, 0, 0x2);
    set_MVFR0(__tc147);
    __tc148 : bits(32) = get_MVFR1();
    let __tc148 = __SetSlice_bits(32, 4, __tc148, 28, 0x1);
    set_MVFR1(__tc148);
    __tc149 : bits(32) = get_MVFR1();
    let __tc149 = __SetSlice_bits(32, 4, __tc149, 16, 0x1);
    set_MVFR1(__tc149);
    __tc150 : bits(32) = get_MVFR1();
    let __tc150 = __SetSlice_bits(32, 4, __tc150, 12, 0x1);
    set_MVFR1(__tc150);
    __tc151 : bits(32) = get_MVFR1();
    let __tc151 = __SetSlice_bits(32, 4, __tc151, 8, 0x1);
    set_MVFR1(__tc151);
    __tc152 : bits(32) = get_MVFR1();
    let __tc152 = __SetSlice_bits(32, 4, __tc152, 4, 0x1);
    set_MVFR1(__tc152);
    __tc153 : bits(32) = get_MVFR1();
    let __tc153 = __SetSlice_bits(32, 4, __tc153, 0, 0x1);
    set_MVFR1(__tc153);
    __tc154 : bits(32) = get_MVFR2();
    let __tc154 = __SetSlice_bits(32, 4, __tc154, 4, 0x4);
    set_MVFR2(__tc154);
    __tc155 : bits(32) = get_MVFR2();
    let __tc155 = __SetSlice_bits(32, 4, __tc155, 0, 0x3);
    set_MVFR2(__tc155);
    TLBTR = __SetSlice_bits(32, 1, TLBTR, 0, 0b0);
    __tc156 : bits(32) = get_HSCTLR();
    let __tc156 = __SetSlice_bits(32, 1, __tc156, 25, 0b0);
    set_HSCTLR(__tc156);
    __tc157 : bits(32) = get_SCTLR();
    let __tc157 = __SetSlice_bits(32, 1, __tc157, 30, 0b0);
    set_SCTLR(__tc157);
    __tc158 : bits(32) = get_SCTLR();
    let __tc158 = __SetSlice_bits(32, 1, __tc158, 25, 0b0);
    set_SCTLR(__tc158);
    __tc159 : bits(32) = get_SCTLR();
    let __tc159 = __SetSlice_bits(32, 1, __tc159, 23, 0b0);
    set_SCTLR(__tc159);
    __tc160 : bits(32) = get_SCTLR();
    let __tc160 = __SetSlice_bits(32, 1, __tc160, 13, 0b0);
    set_SCTLR(__tc160);
    __tc161 : bits(32) = get_SCTLR();
    let __tc161 = __SetSlice_bits(32, 1, __tc161, 6, 0b0);
    set_SCTLR(__tc161);
    __tc162 : bits(32) = get_FPEXC();
    let __tc162 = __SetSlice_bits(32, 1, __tc162, 31, 0b0);
    set_FPEXC(__tc162);
    __tc163 : bits(32) = get_FPEXC();
    let __tc163 = __SetSlice_bits(32, 1, __tc163, 28, 0b0);
    set_FPEXC(__tc163);
    __tc164 : bits(32) = get_FPEXC();
    let __tc164 = __SetSlice_bits(32, 1, __tc164, 27, 0b0);
    set_FPEXC(__tc164);
    __tc165 : bits(32) = get_FPEXC();
    let __tc165 = __SetSlice_bits(32, 1, __tc165, 26, 0b0);
    set_FPEXC(__tc165);
    __tc166 : bits(32) = get_FPEXC();
    let __tc166 = __SetSlice_bits(32, 3, __tc166, 8, 0b111);
    set_FPEXC(__tc166);
    __tc167 : bits(32) = get_HTCR();
    let __tc167 = __SetSlice_bits(32, 1, __tc167, 28, 0b0);
    set_HTCR(__tc167);
    __tc168 : bits(32) = get_HTCR();
    let __tc168 = __SetSlice_bits(32, 1, __tc168, 27, 0b0);
    set_HTCR(__tc168);
    __tc169 : bits(32) = get_HTCR();
    let __tc169 = __SetSlice_bits(32, 1, __tc169, 26, 0b0);
    set_HTCR(__tc169);
    __tc170 : bits(32) = get_HTCR();
    let __tc170 = __SetSlice_bits(32, 1, __tc170, 25, 0b0);
    set_HTCR(__tc170);
    __tc171 : bits(32) = get_HTCR();
    let __tc171 = __SetSlice_bits(32, 1, __tc171, 24, 0b0);
    set_HTCR(__tc171);
    __tc172 : bits(32) = get_HTCR();
    let __tc172 = __SetSlice_bits(32, 2, __tc172, 12, 0b00);
    set_HTCR(__tc172);
    __tc173 : bits(32) = get_HTCR();
    let __tc173 = __SetSlice_bits(32, 2, __tc173, 10, 0b00);
    set_HTCR(__tc173);
    __tc174 : bits(32) = get_HTCR();
    let __tc174 = __SetSlice_bits(32, 2, __tc174, 8, 0b00);
    set_HTCR(__tc174);
    __tc175 : bits(32) = get_HTCR();
    let __tc175 = __SetSlice_bits(32, 3, __tc175, 0, 0b000);
    set_HTCR(__tc175);
    __tc176 : bits(32) = get_NMRR();
    let __tc176 = __SetSlice_bits(32, 16, __tc176, 16, 0x44E0);
    set_NMRR(__tc176);
    __tc177 : bits(32) = get_NMRR();
    let __tc177 = __SetSlice_bits(32, 16, __tc177, 0, 0x48E0);
    set_NMRR(__tc177);
    NSACR = __SetSlice_bits(32, 1, NSACR, 11, 0b0);
    NSACR = __SetSlice_bits(32, 1, NSACR, 10, 0b0);
    __tc178 : bits(32) = get_PRRR();
    let __tc178 = __SetSlice_bits(32, 8, __tc178, 24, Zeros());
    set_PRRR(__tc178);
    __tc179 : bits(32) = get_PRRR();
    let __tc179 = __SetSlice_bits(32, 1, __tc179, 19, 0b1);
    set_PRRR(__tc179);
    __tc180 : bits(32) = get_PRRR();
    let __tc180 = __SetSlice_bits(32, 1, __tc180, 18, 0b0);
    set_PRRR(__tc180);
    __tc181 : bits(32) = get_PRRR();
    let __tc181 = __SetSlice_bits(32, 1, __tc181, 17, 0b0);
    set_PRRR(__tc181);
    __tc182 : bits(32) = get_PRRR();
    let __tc182 = __SetSlice_bits(32, 1, __tc182, 16, 0b1);
    set_PRRR(__tc182);
    __tc183 : bits(32) = get_PRRR();
    let __tc183 = __SetSlice_bits(32, 16, __tc183, 0, 0x8AA4);
    set_PRRR(__tc183);
    DBGDIDR = __SetSlice_bits(32, 4, DBGDIDR, 28, 0x1);
    DBGDIDR = __SetSlice_bits(32, 4, DBGDIDR, 24, 0x1);
    DBGDIDR = __SetSlice_bits(32, 4, DBGDIDR, 20, 0x1);
    DBGDIDR = __SetSlice_bits(32, 4, DBGDIDR, 16, 0x6);
    DBGDIDR = __SetSlice_bits(32, 1, DBGDIDR, 14, 0b0);
    DBGDIDR = __SetSlice_bits(32, 1, DBGDIDR, 12, 0b1);
    __tc184 : bits(32) = get_ICC_MSRE();
    let __tc184 = __SetSlice_bits(32, 1, __tc184, 0, 0b1);
    set_ICC_MSRE(__tc184);
    __tc185 : bits(32) = get_ICC_HSRE();
    let __tc185 = __SetSlice_bits(32, 1, __tc185, 0, 0b1);
    set_ICC_HSRE(__tc185);
    return()
}

val get_IFSR : unit -> bits(32) effect {escape, rreg, undef}

function get_IFSR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = IFSR_S
    } else {
        r = get_IFSR_NS()
    };
    r
}

val get_ICC_SRE_EL1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_SRE_EL1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_SRE_EL1_S
    } else {
        r = ICC_SRE_EL1_NS
    };
    r
}

val set_ICC_SRE_S : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_SRE_S val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_SRE_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_SRE_EL1(__tc1);
    return()
}

val set_ICC_SRE_NS : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_SRE_NS val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_SRE_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_SRE_EL1(__tc1);
    return()
}

val set_ICC_SRE : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_SRE val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        set_ICC_SRE_S(r)
    } else {
        set_ICC_SRE_NS(r)
    };
    return()
}

val get_ICC_SRE_S : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_SRE_S () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_SRE_EL1(), 0, 32));
    r
}

val get_ICC_SRE_NS : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_SRE_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_SRE_EL1(), 0, 32));
    r
}

val get_ICC_SRE : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_SRE () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = get_ICC_SRE_S()
    } else {
        r = get_ICC_SRE_NS()
    };
    r
}

val get_ICC_IGRPEN1_EL1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_IGRPEN1_EL1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_IGRPEN1_EL1_S
    } else {
        r = ICC_IGRPEN1_EL1_NS
    };
    r
}

val set_ICC_IGRPEN1_S : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_IGRPEN1_S val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_IGRPEN1_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_IGRPEN1_EL1(__tc1);
    return()
}

val set_ICC_IGRPEN1_NS : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_IGRPEN1_NS val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_IGRPEN1_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_IGRPEN1_EL1(__tc1);
    return()
}

val set_ICC_IGRPEN1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_IGRPEN1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        set_ICC_IGRPEN1_S(r)
    } else {
        set_ICC_IGRPEN1_NS(r)
    };
    return()
}

val get_ICC_IGRPEN1_S : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_IGRPEN1_S () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_IGRPEN1_EL1(), 0, 32));
    r
}

val get_ICC_IGRPEN1_NS : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_IGRPEN1_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_IGRPEN1_EL1(), 0, 32));
    r
}

val get_ICC_IGRPEN1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_IGRPEN1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = get_ICC_IGRPEN1_S()
    } else {
        r = get_ICC_IGRPEN1_NS()
    };
    r
}

val get_ICC_CTLR_EL1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_CTLR_EL1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_CTLR_EL1_S
    } else {
        r = ICC_CTLR_EL1_NS
    };
    r
}

val set_ICC_CTLR_S : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_CTLR_S val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_CTLR_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_CTLR_EL1(__tc1);
    return()
}

val set_ICC_CTLR_NS : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_CTLR_NS val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_CTLR_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_CTLR_EL1(__tc1);
    return()
}

val set_ICC_CTLR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_CTLR val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        set_ICC_CTLR_S(r)
    } else {
        set_ICC_CTLR_NS(r)
    };
    return()
}

val get_ICC_CTLR_S : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_CTLR_S () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_CTLR_EL1(), 0, 32));
    r
}

val get_ICC_CTLR_NS : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_CTLR_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_CTLR_EL1(), 0, 32));
    r
}

val AArch64_AutoGen_ArchitectureReset : forall ('cold : Bool).
  bool('cold) -> unit effect {escape, rreg, undef, wreg}

function AArch64_AutoGen_ArchitectureReset cold = {
    HCR_EL2 = __SetSlice_bits(64, 6, HCR_EL2, 58, 0b000000);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 37, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 36, 0b0);
    ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 44, 0x0);
    PAR_EL1 = __SetSlice_bits(64, 4, PAR_EL1, 52, 0x0);
    PAR_EL1 = __SetSlice_bits(64, 1, PAR_EL1, 11, 0b1);
    PAR_EL1 = __SetSlice_bits(64, 6, PAR_EL1, 1, 0b000000);
    PAR_EL1 = __SetSlice_bits(64, 36, PAR_EL1, 12, 0x000000000);
    PAR_EL1 = __SetSlice_bits(64, 1, PAR_EL1, 11, 0b1);
    PAR_EL1 = __SetSlice_bits(64, 1, PAR_EL1, 10, 0b0);
    PAR_EL1 = __SetSlice_bits(64, 1, PAR_EL1, 7, 0b0);
    CCSIDR_EL1 = __SetSlice_bits(64, 32, CCSIDR_EL1, 32, 0x00000000);
    CCSIDR_EL1 = __SetSlice_bits(64, 4, CCSIDR_EL1, 28, 0x0);
    CCSIDR_EL1 = __SetSlice_bits(64, 8, CCSIDR_EL1, 56, 0x00);
    CCSIDR_EL1 = __SetSlice_bits(64, 8, CCSIDR_EL1, 24, 0x00);
    CLIDR_EL1 = __SetSlice_bits(64, 17, CLIDR_EL1, 47, 0b00000000000000000);
    CPACR_EL1 = __SetSlice_bits(32, 6, CPACR_EL1, 22, 0b000000);
    CPACR_EL1 = __SetSlice_bits(32, 2, CPACR_EL1, 18, 0b00);
    CPACR_EL1 = __SetSlice_bits(32, 16, CPACR_EL1, 0, 0x0000);
    CPTR_EL2 = __SetSlice_bits(32, 9, CPTR_EL2, 21, 0b000000000);
    CPTR_EL2 = __SetSlice_bits(32, 6, CPTR_EL2, 14, 0b000000);
    CPTR_EL2 = __SetSlice_bits(32, 2, CPTR_EL2, 12, 0b01);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 11, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 9, 0b1);
    CPTR_EL2 = __SetSlice_bits(32, 8, CPTR_EL2, 0, 0x01);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 29, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 6, CPTR_EL2, 22, 0b000000);
    CPTR_EL2 = __SetSlice_bits(32, 2, CPTR_EL2, 18, 0b00);
    CPTR_EL2 = __SetSlice_bits(32, 16, CPTR_EL2, 0, 0x0000);
    CPTR_EL3 = __SetSlice_bits(32, 9, CPTR_EL3, 21, 0b000000000);
    CPTR_EL3 = __SetSlice_bits(32, 9, CPTR_EL3, 11, 0b000000000);
    CPTR_EL3 = __SetSlice_bits(32, 1, CPTR_EL3, 9, 0b0);
    CPTR_EL3 = __SetSlice_bits(32, 8, CPTR_EL3, 0, 0x00);
    CTR_EL0 = __SetSlice_bits(64, 26, CTR_EL0, 38, 0b00000000000000000000000000);
    CTR_EL0 = __SetSlice_bits(64, 1, CTR_EL0, 31, 0b1);
    CTR_EL0 = __SetSlice_bits(64, 1, CTR_EL0, 30, 0b0);
    CTR_EL0 = __SetSlice_bits(64, 10, CTR_EL0, 4, 0b0000000000);
    DBGCLAIMCLR_EL1 = __SetSlice_bits(32, 24, DBGCLAIMCLR_EL1, 8, 0x000000);
    if cold then {
        DBGCLAIMCLR_EL1 = __SetSlice_bits(32, 8, DBGCLAIMCLR_EL1, 0, 0x00)
    };
    DBGCLAIMSET_EL1 = __SetSlice_bits(32, 24, DBGCLAIMSET_EL1, 8, 0x000000);
    DBGVCR32_EL2 = __SetSlice_bits(32, 1, DBGVCR32_EL2, 29, 0b0);
    DBGVCR32_EL2 = __SetSlice_bits(32, 17, DBGVCR32_EL2, 8, 0b00000000000000000);
    DBGVCR32_EL2 = __SetSlice_bits(32, 1, DBGVCR32_EL2, 5, 0b0);
    DBGVCR32_EL2 = __SetSlice_bits(32, 1, DBGVCR32_EL2, 0, 0b0);
    DBGVCR32_EL2 = __SetSlice_bits(32, 1, DBGVCR32_EL2, 5, 0b0);
    DBGVCR32_EL2 = __SetSlice_bits(32, 1, DBGVCR32_EL2, 0, 0b0);
    DSPSR_EL0 = __SetSlice_bits(32, 2, DSPSR_EL0, 26, 0b00);
    DSPSR_EL0 = __SetSlice_bits(32, 7, DSPSR_EL0, 13, 0b0000000);
    DSPSR_EL0 = __SetSlice_bits(32, 1, DSPSR_EL0, 5, 0b0);
    FPCR = __SetSlice_bits(32, 2, FPCR, 13, 0b00);
    FPCR = __SetSlice_bits(32, 8, FPCR, 0, 0x00);
    FPEXC32_EL2 = __SetSlice_bits(32, 15, FPEXC32_EL2, 11, 0b000000000000000);
    FPEXC32_EL2 = __SetSlice_bits(32, 2, FPEXC32_EL2, 5, 0b00);
    FPSR = __SetSlice_bits(32, 19, FPSR, 8, 0b0000000000000000000);
    FPSR = __SetSlice_bits(32, 2, FPSR, 5, 0b00);
    HPFAR_EL2 = __SetSlice_bits(64, 19, HPFAR_EL2, 44, 0b0000000000000000000);
    HPFAR_EL2 = __SetSlice_bits(64, 4, HPFAR_EL2, 0, 0x0);
    ICC_ASGI1R_EL1 = __SetSlice_bits(64, 8, ICC_ASGI1R_EL1, 56, 0x00);
    ICC_ASGI1R_EL1 = __SetSlice_bits(64, 3, ICC_ASGI1R_EL1, 41, 0b000);
    ICC_ASGI1R_EL1 = __SetSlice_bits(64, 4, ICC_ASGI1R_EL1, 28, 0x0);
    __tc1 : bits(32) = get_ICC_CTLR_EL1();
    let __tc1 = __SetSlice_bits(32, 2, __tc1, 16, 0b00);
    set_ICC_CTLR_EL1(__tc1);
    __tc2 : bits(32) = get_ICC_CTLR_EL1();
    let __tc2 = __SetSlice_bits(32, 1, __tc2, 7, 0b0);
    set_ICC_CTLR_EL1(__tc2);
    __tc3 : bits(32) = get_ICC_CTLR_EL1();
    let __tc3 = __SetSlice_bits(32, 4, __tc3, 2, 0x0);
    set_ICC_CTLR_EL1(__tc3);
    ICC_CTLR_EL3 = __SetSlice_bits(32, 1, ICC_CTLR_EL3, 16, 0b0);
    ICC_CTLR_EL3 = __SetSlice_bits(32, 1, ICC_CTLR_EL3, 7, 0b0);
    ICC_CTLR_EL3 = __SetSlice_bits(32, 1, ICC_CTLR_EL3, 6, 0b0);
    ICC_IGRPEN0_EL1 = __SetSlice_bits(32, 1, ICC_IGRPEN0_EL1, 0, 0b0);
    __tc4 : bits(32) = get_ICC_IGRPEN1_EL1();
    let __tc4 = __SetSlice_bits(32, 1, __tc4, 0, 0b0);
    set_ICC_IGRPEN1_EL1(__tc4);
    ICC_IGRPEN1_EL3 = __SetSlice_bits(32, 1, ICC_IGRPEN1_EL3, 1, 0b0);
    ICC_IGRPEN1_EL3 = __SetSlice_bits(32, 1, ICC_IGRPEN1_EL3, 0, 0b0);
    ICC_PMR_EL1 = __SetSlice_bits(32, 8, ICC_PMR_EL1, 0, 0x00);
    ICC_SGI0R_EL1 = __SetSlice_bits(64, 8, ICC_SGI0R_EL1, 56, 0x00);
    ICC_SGI0R_EL1 = __SetSlice_bits(64, 3, ICC_SGI0R_EL1, 41, 0b000);
    ICC_SGI0R_EL1 = __SetSlice_bits(64, 4, ICC_SGI0R_EL1, 28, 0x0);
    ICC_SGI1R_EL1 = __SetSlice_bits(64, 8, ICC_SGI1R_EL1, 56, 0x00);
    ICC_SGI1R_EL1 = __SetSlice_bits(64, 3, ICC_SGI1R_EL1, 41, 0b000);
    ICC_SGI1R_EL1 = __SetSlice_bits(64, 4, ICC_SGI1R_EL1, 28, 0x0);
    __tc5 : bits(32) = get_ICC_SRE_EL1();
    let __tc5 = __SetSlice_bits(32, 1, __tc5, 2, 0b0);
    set_ICC_SRE_EL1(__tc5);
    __tc6 : bits(32) = get_ICC_SRE_EL1();
    let __tc6 = __SetSlice_bits(32, 1, __tc6, 1, 0b0);
    set_ICC_SRE_EL1(__tc6);
    __tc7 : bits(32) = get_ICC_SRE_EL1();
    let __tc7 = __SetSlice_bits(32, 1, __tc7, 0, 0b0);
    set_ICC_SRE_EL1(__tc7);
    ICC_SRE_EL2 = __SetSlice_bits(32, 1, ICC_SRE_EL2, 2, 0b0);
    ICC_SRE_EL2 = __SetSlice_bits(32, 1, ICC_SRE_EL2, 1, 0b0);
    ICC_SRE_EL2 = __SetSlice_bits(32, 1, ICC_SRE_EL2, 0, 0b0);
    ICC_SRE_EL3 = __SetSlice_bits(32, 1, ICC_SRE_EL3, 2, 0b0);
    ICC_SRE_EL3 = __SetSlice_bits(32, 1, ICC_SRE_EL3, 1, 0b0);
    ICC_SRE_EL3 = __SetSlice_bits(32, 1, ICC_SRE_EL3, 0, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 5, ICH_HCR_EL2, 27, 0b00000);
    ICH_HCR_EL2 = __SetSlice_bits(32, 12, ICH_HCR_EL2, 15, 0x000);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 14, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 13, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 12, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 11, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 10, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 2, ICH_HCR_EL2, 8, 0b00);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 7, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 6, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 5, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 4, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 3, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 2, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 1, 0b0);
    ICH_HCR_EL2 = __SetSlice_bits(32, 1, ICH_HCR_EL2, 0, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 7, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 6, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 5, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 4, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 3, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 2, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 1, 0b0);
    ICH_MISR_EL2 = __SetSlice_bits(32, 1, ICH_MISR_EL2, 0, 0b0);
    ICH_VMCR_EL2 = __SetSlice_bits(32, 8, ICH_VMCR_EL2, 10, 0x00);
    ICH_VMCR_EL2 = __SetSlice_bits(32, 4, ICH_VMCR_EL2, 5, 0x0);
    ICH_VTR_EL2 = __SetSlice_bits(32, 14, ICH_VTR_EL2, 5, 0b00000000000000);
    ICV_CTLR_EL1 = __SetSlice_bits(32, 2, ICV_CTLR_EL1, 16, 0b00);
    ICV_CTLR_EL1 = __SetSlice_bits(32, 6, ICV_CTLR_EL1, 2, 0b000000);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 16, ID_AA64DFR0_EL1, 48, 0x0000);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 44, 0x0);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 24, 0x0);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 16, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 0, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 20, ID_AA64ISAR1_EL1, 44, 0x00000);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 8, ID_AA64MMFR0_EL1, 56, 0x00);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 52, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 48, 0x0);
    ID_AA64PFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64PFR1_EL1, 12, 0x0);
    ID_ISAR5_EL1 = __SetSlice_bits(32, 4, ID_ISAR5_EL1, 20, 0x0);
    ID_PFR2_EL1 = __SetSlice_bits(32, 4, ID_PFR2_EL1, 8, 0x0);
    IFSR32_EL2 = __SetSlice_bits(32, 3, IFSR32_EL2, 13, 0b000);
    IFSR32_EL2 = __SetSlice_bits(32, 1, IFSR32_EL2, 11, 0b0);
    IFSR32_EL2 = __SetSlice_bits(32, 5, IFSR32_EL2, 4, 0b00000);
    IFSR32_EL2 = __SetSlice_bits(32, 3, IFSR32_EL2, 13, 0b000);
    IFSR32_EL2 = __SetSlice_bits(32, 2, IFSR32_EL2, 10, 0b00);
    IFSR32_EL2 = __SetSlice_bits(32, 3, IFSR32_EL2, 6, 0b000);
    ISR_EL1 = __SetSlice_bits(32, 6, ISR_EL1, 0, 0b000000);
    LORC_EL1 = __SetSlice_bits(32, 1, LORC_EL1, 1, 0b0);
    LORC_EL1 = __SetSlice_bits(32, 1, LORC_EL1, 0, 0b0);
    LOREA_EL1 = __SetSlice_bits(64, 12, LOREA_EL1, 52, 0x000);
    LOREA_EL1 = __SetSlice_bits(64, 16, LOREA_EL1, 0, 0x0000);
    LORID_EL1 = __SetSlice_bits(32, 8, LORID_EL1, 8, 0x00);
    LORSA_EL1 = __SetSlice_bits(64, 12, LORSA_EL1, 52, 0x000);
    LORSA_EL1 = __SetSlice_bits(64, 15, LORSA_EL1, 1, 0b000000000000000);
    LORSA_EL1 = __SetSlice_bits(64, 1, LORSA_EL1, 0, 0b0);
    MDCCINT_EL1 = __SetSlice_bits(32, 1, MDCCINT_EL1, 30, 0b0);
    MDCCINT_EL1 = __SetSlice_bits(32, 1, MDCCINT_EL1, 29, 0b0);
    MDCCINT_EL1 = __SetSlice_bits(32, 29, MDCCINT_EL1, 0, 0b00000000000000000000000000000);
    MDCCSR_EL0 = __SetSlice_bits(32, 10, MDCCSR_EL0, 19, 0b0000000000);
    MDCCSR_EL0 = __SetSlice_bits(32, 4, MDCCSR_EL0, 15, 0x0);
    MDCCSR_EL0 = __SetSlice_bits(32, 2, MDCCSR_EL0, 13, 0b00);
    MDCCSR_EL0 = __SetSlice_bits(32, 1, MDCCSR_EL0, 12, 0b0);
    MDCCSR_EL0 = __SetSlice_bits(32, 6, MDCCSR_EL0, 6, 0b000000);
    MDCCSR_EL0 = __SetSlice_bits(32, 4, MDCCSR_EL0, 2, 0x0);
    MDCCSR_EL0 = __SetSlice_bits(32, 2, MDCCSR_EL0, 0, 0b00);
    MDCR_EL2 = __SetSlice_bits(32, 1, MDCR_EL2, 26, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 2, MDCR_EL2, 24, 0b00);
    MDCR_EL2 = __SetSlice_bits(32, 1, MDCR_EL2, 23, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 3, MDCR_EL2, 20, 0b000);
    MDCR_EL2 = __SetSlice_bits(32, 1, MDCR_EL2, 18, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 1, MDCR_EL2, 17, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 2, MDCR_EL2, 15, 0b00);
    MDCR_EL3 = __SetSlice_bits(32, 2, MDCR_EL3, 24, 0b00);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 23, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 22, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 21, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 20, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 18, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 17, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 1, MDCR_EL3, 11, 0b0);
    MDCR_EL3 = __SetSlice_bits(32, 2, MDCR_EL3, 7, 0b00);
    MDCR_EL3 = __SetSlice_bits(32, 6, MDCR_EL3, 0, 0b000000);
    MDRAR_EL1 = __SetSlice_bits(64, 12, MDRAR_EL1, 52, 0x000);
    MDRAR_EL1 = __SetSlice_bits(64, 10, MDRAR_EL1, 2, 0b0000000000);
    MDSCR_EL1 = __SetSlice_bits(32, 1, MDSCR_EL1, 28, 0b0);
    MDSCR_EL1 = __SetSlice_bits(32, 2, MDSCR_EL1, 24, 0b00);
    MDSCR_EL1 = __SetSlice_bits(32, 1, MDSCR_EL1, 20, 0b0);
    MDSCR_EL1 = __SetSlice_bits(32, 5, MDSCR_EL1, 7, 0b00000);
    MDSCR_EL1 = __SetSlice_bits(32, 5, MDSCR_EL1, 1, 0b00000);
    MPIDR_EL1 = __SetSlice_bits(64, 24, MPIDR_EL1, 40, 0x000000);
    MPIDR_EL1 = __SetSlice_bits(64, 1, MPIDR_EL1, 31, 0b1);
    MPIDR_EL1 = __SetSlice_bits(64, 5, MPIDR_EL1, 25, 0b00000);
    OSDLR_EL1 = __SetSlice_bits(32, 1, OSDLR_EL1, 0, 0b0);
    if cold then {
        OSLSR_EL1 = __SetSlice_bits(32, 1, OSLSR_EL1, 1, 0b1)
    };
    PMCCFILTR_EL0 = __SetSlice_bits(32, 1, PMCCFILTR_EL0, 25, 0b0);
    PMCCFILTR_EL0 = __SetSlice_bits(32, 24, PMCCFILTR_EL0, 0, 0x000000);
    PMCR_EL0 = __SetSlice_bits(32, 3, PMCR_EL0, 8, 0b000);
    PMCR_EL0 = __SetSlice_bits(32, 1, PMCR_EL0, 7, 0b0);
    PMCR_EL0 = __SetSlice_bits(32, 1, PMCR_EL0, 0, 0b0);
    RMR_EL1 = __SetSlice_bits(32, 1, RMR_EL1, 1, 0b0);
    RMR_EL2 = __SetSlice_bits(32, 1, RMR_EL2, 1, 0b0);
    RMR_EL3 = __SetSlice_bits(32, 1, RMR_EL3, 1, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 20, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 19, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 15, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 6, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 2, SCR_EL3, 4, 0b01);
    SCTLR_EL1 = __SetSlice_bits(64, 18, SCTLR_EL1, 46, 0b000000000000000000);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 17, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 12, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 2, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 0, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 19, SCTLR_EL2, 45, 0b0000000000000000000);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 42, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 2, SCTLR_EL2, 38, 0b00);
    SCTLR_EL2 = __SetSlice_bits(64, 4, SCTLR_EL2, 32, 0x0);
    SCTLR_EL2 = __SetSlice_bits(64, 2, SCTLR_EL2, 28, 0b01);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 26, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 24, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 23, 0b1);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 20, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 18, 0b1);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 17, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 16, 0b1);
    SCTLR_EL2 = __SetSlice_bits(64, 2, SCTLR_EL2, 14, 0b00);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 12, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 4, SCTLR_EL2, 7, 0x0);
    SCTLR_EL2 = __SetSlice_bits(64, 2, SCTLR_EL2, 4, 0b01);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 2, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 0, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 18, SCTLR_EL2, 46, 0b000000000000000000);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 17, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 12, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 9, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 2, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 0, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 19, SCTLR_EL3, 45, 0b0000000000000000000);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 42, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 2, SCTLR_EL3, 38, 0b00);
    SCTLR_EL3 = __SetSlice_bits(64, 4, SCTLR_EL3, 32, 0x0);
    SCTLR_EL3 = __SetSlice_bits(64, 2, SCTLR_EL3, 28, 0b01);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 26, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 24, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 23, 0b1);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 20, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 18, 0b1);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 17, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 16, 0b1);
    SCTLR_EL3 = __SetSlice_bits(64, 2, SCTLR_EL3, 14, 0b00);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 12, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 4, SCTLR_EL3, 7, 0x0);
    SCTLR_EL3 = __SetSlice_bits(64, 2, SCTLR_EL3, 4, 0b01);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 2, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 0, 0b0);
    SPSR_abt = __SetSlice_bits(32, 1, SPSR_abt, 23, 0b0);
    SPSR_EL0 = __SetSlice_bits(32, 4, SPSR_EL0, 24, 0x0);
    SPSR_EL0 = __SetSlice_bits(32, 10, SPSR_EL0, 10, 0b0000000000);
    SPSR_EL0 = __SetSlice_bits(32, 12, SPSR_EL0, 6, 0x000);
    SPSR_EL0 = __SetSlice_bits(32, 1, SPSR_EL0, 0, 0b0);
    SPSR_EL1 = __SetSlice_bits(32, 2, SPSR_EL1, 26, 0b00);
    SPSR_EL1 = __SetSlice_bits(32, 7, SPSR_EL1, 13, 0b0000000);
    SPSR_EL1 = __SetSlice_bits(32, 12, SPSR_EL1, 6, 0x000);
    SPSR_EL1 = __SetSlice_bits(32, 1, SPSR_EL1, 0, 0b0);
    SPSR_EL2 = __SetSlice_bits(32, 2, SPSR_EL2, 26, 0b00);
    SPSR_EL2 = __SetSlice_bits(32, 7, SPSR_EL2, 13, 0b0000000);
    SPSR_EL2 = __SetSlice_bits(32, 12, SPSR_EL2, 6, 0x000);
    SPSR_EL2 = __SetSlice_bits(32, 1, SPSR_EL2, 0, 0b0);
    SPSR_EL3 = __SetSlice_bits(32, 2, SPSR_EL3, 26, 0b00);
    SPSR_EL3 = __SetSlice_bits(32, 7, SPSR_EL3, 13, 0b0000000);
    SPSR_EL3 = __SetSlice_bits(32, 12, SPSR_EL3, 6, 0x000);
    SPSR_EL3 = __SetSlice_bits(32, 1, SPSR_EL3, 0, 0b0);
    SPSR_fiq = __SetSlice_bits(32, 1, SPSR_fiq, 23, 0b0);
    SPSR_irq = __SetSlice_bits(32, 1, SPSR_irq, 23, 0b0);
    SPSR_und = __SetSlice_bits(32, 1, SPSR_und, 23, 0b0);
    TCR_EL1 = __SetSlice_bits(64, 5, TCR_EL1, 59, 0b00000);
    TCR_EL1 = __SetSlice_bits(64, 1, TCR_EL1, 35, 0b0);
    TCR_EL1 = __SetSlice_bits(64, 1, TCR_EL1, 6, 0b0);
    TCR_EL2 = __SetSlice_bits(64, 32, TCR_EL2, 32, 0x00000000);
    TCR_EL2 = __SetSlice_bits(64, 1, TCR_EL2, 31, 0b1);
    TCR_EL2 = __SetSlice_bits(64, 1, TCR_EL2, 23, 0b1);
    TCR_EL2 = __SetSlice_bits(64, 1, TCR_EL2, 19, 0b0);
    TCR_EL2 = __SetSlice_bits(64, 2, TCR_EL2, 6, 0b00);
    TCR_EL2 = __SetSlice_bits(64, 5, TCR_EL2, 59, 0b00000);
    TCR_EL2 = __SetSlice_bits(64, 1, TCR_EL2, 35, 0b0);
    TCR_EL2 = __SetSlice_bits(64, 1, TCR_EL2, 6, 0b0);
    TCR_EL3 = __SetSlice_bits(32, 1, TCR_EL3, 31, 0b1);
    TCR_EL3 = __SetSlice_bits(32, 1, TCR_EL3, 23, 0b1);
    TCR_EL3 = __SetSlice_bits(32, 1, TCR_EL3, 19, 0b0);
    TCR_EL3 = __SetSlice_bits(32, 2, TCR_EL3, 6, 0b00);
    TRFCR_EL1 = __SetSlice_bits(32, 3, TRFCR_EL1, 2, 0b000);
    TRFCR_EL1 = __SetSlice_bits(32, 1, TRFCR_EL1, 1, 0b0);
    TRFCR_EL1 = __SetSlice_bits(32, 1, TRFCR_EL1, 0, 0b0);
    TRFCR_EL2 = __SetSlice_bits(32, 2, TRFCR_EL2, 5, 0b00);
    TRFCR_EL2 = __SetSlice_bits(32, 1, TRFCR_EL2, 4, 0b0);
    TRFCR_EL2 = __SetSlice_bits(32, 1, TRFCR_EL2, 3, 0b0);
    TRFCR_EL2 = __SetSlice_bits(32, 1, TRFCR_EL2, 2, 0b0);
    TRFCR_EL2 = __SetSlice_bits(32, 1, TRFCR_EL2, 1, 0b0);
    TRFCR_EL2 = __SetSlice_bits(32, 1, TRFCR_EL2, 0, 0b0);
    TTBR0_EL3 = __SetSlice_bits(64, 16, TTBR0_EL3, 48, 0x0000);
    VBAR_EL0 = __SetSlice_bits(64, 11, VBAR_EL0, 0, 0b00000000000);
    VBAR_EL1 = __SetSlice_bits(64, 11, VBAR_EL1, 0, 0b00000000000);
    VBAR_EL2 = __SetSlice_bits(64, 11, VBAR_EL2, 0, 0b00000000000);
    VBAR_EL3 = __SetSlice_bits(64, 11, VBAR_EL3, 0, 0b00000000000);
    VMPIDR_EL2 = __SetSlice_bits(64, 24, VMPIDR_EL2, 40, 0x000000);
    VMPIDR_EL2 = __SetSlice_bits(64, 1, VMPIDR_EL2, 31, 0b1);
    VMPIDR_EL2 = __SetSlice_bits(64, 5, VMPIDR_EL2, 25, 0b00000);
    VNCR_EL2 = __SetSlice_bits(64, 12, VNCR_EL2, 0, 0x000);
    VSTCR_EL2 = __SetSlice_bits(32, 1, VSTCR_EL2, 31, 0b1);
    VSTCR_EL2 = __SetSlice_bits(32, 13, VSTCR_EL2, 16, 0b0000000000000);
    VSTCR_EL2 = __SetSlice_bits(32, 6, VSTCR_EL2, 8, 0b000000);
    VSTTBR_EL2 = __SetSlice_bits(64, 16, VSTTBR_EL2, 48, 0x0000);
    VTCR_EL2 = __SetSlice_bits(32, 1, VTCR_EL2, 31, 0b1);
    VTCR_EL2 = __SetSlice_bits(32, 2, VTCR_EL2, 23, 0b00);
    VTCR_EL2 = __SetSlice_bits(32, 1, VTCR_EL2, 20, 0b0);
    MPAM0_EL1 = __SetSlice_bits(64, 16, MPAM0_EL1, 48, 0x0000);
    if cold then {
        MPAM1_EL1 = __SetSlice_bits(64, 1, MPAM1_EL1, 63, 0b0)
    };
    MPAM1_EL1 = __SetSlice_bits(64, 15, MPAM1_EL1, 48, 0b000000000000000);
    MPAM2_EL2 = __SetSlice_bits(64, 13, MPAM2_EL2, 50, 0b0000000000000);
    if cold then {
        MPAM2_EL2 = __SetSlice_bits(64, 1, MPAM2_EL2, 63, 0b0)
    };
    if cold then {
        MPAM3_EL3 = __SetSlice_bits(64, 1, MPAM3_EL3, 63, 0b0)
    };
    if cold then {
        MPAM3_EL3 = __SetSlice_bits(64, 1, MPAM3_EL3, 62, 0b1)
    };
    MPAM3_EL3 = __SetSlice_bits(64, 14, MPAM3_EL3, 48, 0b00000000000000);
    MPAMHCR_EL2 = __SetSlice_bits(32, 22, MPAMHCR_EL2, 9, 0b0000000000000000000000);
    MPAMHCR_EL2 = __SetSlice_bits(32, 6, MPAMHCR_EL2, 2, 0b000000);
    MPAMIDR_EL1 = __SetSlice_bits(64, 24, MPAMIDR_EL1, 40, 0x000000);
    MPAMIDR_EL1 = __SetSlice_bits(64, 11, MPAMIDR_EL1, 21, 0b00000000000);
    MPAMIDR_EL1 = __SetSlice_bits(64, 1, MPAMIDR_EL1, 16, 0b0);
    RGSR_EL1 = __SetSlice_bits(32, 4, RGSR_EL1, 4, 0x0)
}

val get_ICC_CTLR : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_CTLR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = get_ICC_CTLR_S()
    } else {
        r = get_ICC_CTLR_NS()
    };
    r
}

val get_ICC_BPR1_EL1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_BPR1_EL1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_BPR1_EL1_S
    } else {
        r = ICC_BPR1_EL1_NS
    };
    r
}

val set_ICC_BPR1_S : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_BPR1_S val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_BPR1_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_BPR1_EL1(__tc1);
    return()
}

val set_ICC_BPR1_NS : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_BPR1_NS val_name = {
    let r : bits(32) = val_name;
    __tc1 : bits(32) = get_ICC_BPR1_EL1();
    let __tc1 = __SetSlice_bits(32, 32, __tc1, 0, slice(r, 0, 32));
    set_ICC_BPR1_EL1(__tc1);
    return()
}

val set_ICC_BPR1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_ICC_BPR1 val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        set_ICC_BPR1_S(r)
    } else {
        set_ICC_BPR1_NS(r)
    };
    return()
}

val get_ICC_BPR1_S : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_BPR1_S () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_BPR1_EL1(), 0, 32));
    r
}

val get_ICC_BPR1_NS : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_BPR1_NS () = {
    r : bits(32) = undefined : bits(32);
    let r = __SetSlice_bits(32, 32, r, 0, slice(get_ICC_BPR1_EL1(), 0, 32));
    r
}

val get_ICC_BPR1 : unit -> bits(32) effect {escape, rreg, undef}

function get_ICC_BPR1 () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = get_ICC_BPR1_S()
    } else {
        r = get_ICC_BPR1_NS()
    };
    r
}

val get_DFSR : unit -> bits(32) effect {escape, rreg, undef}

function get_DFSR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = DFSR_S
    } else {
        r = get_DFSR_NS()
    };
    r
}

val get_CSSELR : unit -> bits(32) effect {escape, rreg, undef}

function get_CSSELR () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = CSSELR_S
    } else {
        r = get_CSSELR_NS()
    };
    r
}

val get_CNTP_CTL : unit -> bits(32) effect {escape, rreg, undef}

function get_CNTP_CTL () = {
    r : bits(32) = undefined : bits(32);
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = CNTP_CTL_S
    } else {
        r = get_CNTP_CTL_NS()
    };
    r
}

val AArch32_AutoGen_ArchitectureReset : forall ('cold : Bool).
  bool('cold) -> unit effect {escape, rreg, undef, wreg}

function AArch32_AutoGen_ArchitectureReset cold = {
    __tc1 : bits(32) = get_TTBCR();
    let __tc1 = __SetSlice_bits(32, 1, __tc1, 31, 0b0);
    set_TTBCR(__tc1);
    __tc2 : bits(32) = get_TTBCR();
    let __tc2 = __SetSlice_bits(32, 25, __tc2, 6, 0b0000000000000000000000000);
    set_TTBCR(__tc2);
    __tc3 : bits(32) = get_TTBCR();
    let __tc3 = __SetSlice_bits(32, 1, __tc3, 5, 0b0);
    set_TTBCR(__tc3);
    __tc4 : bits(32) = get_TTBCR();
    let __tc4 = __SetSlice_bits(32, 1, __tc4, 4, 0b0);
    set_TTBCR(__tc4);
    __tc5 : bits(32) = get_TTBCR();
    let __tc5 = __SetSlice_bits(32, 1, __tc5, 3, 0b0);
    set_TTBCR(__tc5);
    __tc6 : bits(32) = get_TTBCR();
    let __tc6 = __SetSlice_bits(32, 3, __tc6, 0, 0b000);
    set_TTBCR(__tc6);
    __tc7 : bits(32) = get_TTBCR();
    let __tc7 = __SetSlice_bits(32, 1, __tc7, 31, 0b0);
    set_TTBCR(__tc7);
    __tc8 : bits(32) = get_TTBCR();
    let __tc8 = __SetSlice_bits(32, 1, __tc8, 30, 0b0);
    set_TTBCR(__tc8);
    __tc9 : bits(32) = get_TTBCR();
    let __tc9 = __SetSlice_bits(32, 2, __tc9, 28, 0b00);
    set_TTBCR(__tc9);
    __tc10 : bits(32) = get_TTBCR();
    let __tc10 = __SetSlice_bits(32, 2, __tc10, 26, 0b00);
    set_TTBCR(__tc10);
    __tc11 : bits(32) = get_TTBCR();
    let __tc11 = __SetSlice_bits(32, 2, __tc11, 24, 0b00);
    set_TTBCR(__tc11);
    __tc12 : bits(32) = get_TTBCR();
    let __tc12 = __SetSlice_bits(32, 1, __tc12, 23, 0b0);
    set_TTBCR(__tc12);
    __tc13 : bits(32) = get_TTBCR();
    let __tc13 = __SetSlice_bits(32, 1, __tc13, 22, 0b0);
    set_TTBCR(__tc13);
    __tc14 : bits(32) = get_TTBCR();
    let __tc14 = __SetSlice_bits(32, 3, __tc14, 19, 0b000);
    set_TTBCR(__tc14);
    __tc15 : bits(32) = get_TTBCR();
    let __tc15 = __SetSlice_bits(32, 3, __tc15, 16, 0b000);
    set_TTBCR(__tc15);
    __tc16 : bits(32) = get_TTBCR();
    let __tc16 = __SetSlice_bits(32, 2, __tc16, 14, 0b00);
    set_TTBCR(__tc16);
    __tc17 : bits(32) = get_TTBCR();
    let __tc17 = __SetSlice_bits(32, 2, __tc17, 12, 0b00);
    set_TTBCR(__tc17);
    __tc18 : bits(32) = get_TTBCR();
    let __tc18 = __SetSlice_bits(32, 2, __tc18, 10, 0b00);
    set_TTBCR(__tc18);
    __tc19 : bits(32) = get_TTBCR();
    let __tc19 = __SetSlice_bits(32, 2, __tc19, 8, 0b00);
    set_TTBCR(__tc19);
    __tc20 : bits(32) = get_TTBCR();
    let __tc20 = __SetSlice_bits(32, 1, __tc20, 7, 0b0);
    set_TTBCR(__tc20);
    __tc21 : bits(32) = get_TTBCR();
    let __tc21 = __SetSlice_bits(32, 3, __tc21, 3, 0b000);
    set_TTBCR(__tc21);
    __tc22 : bits(32) = get_TTBCR();
    let __tc22 = __SetSlice_bits(32, 3, __tc22, 0, 0b000);
    set_TTBCR(__tc22);
    __tc23 : bits(32) = get_CCSIDR();
    let __tc23 = __SetSlice_bits(32, 4, __tc23, 28, 0x0);
    set_CCSIDR(__tc23);
    __tc24 : bits(32) = get_CCSIDR();
    let __tc24 = __SetSlice_bits(32, 8, __tc24, 24, 0x00);
    set_CCSIDR(__tc24);
    __tc25 : bits(32) = get_CCSIDR2();
    let __tc25 = __SetSlice_bits(32, 8, __tc25, 24, 0x00);
    set_CCSIDR2(__tc25);
    __tc26 : bits(32) = get_CNTHCTL();
    let __tc26 = __SetSlice_bits(32, 24, __tc26, 8, 0x000000);
    set_CNTHCTL(__tc26);
    __tc27 : bits(32) = get_CNTHP_CTL();
    let __tc27 = __SetSlice_bits(32, 29, __tc27, 3, 0b00000000000000000000000000000);
    set_CNTHP_CTL(__tc27);
    __tc28 : bits(32) = get_CNTHP_CTL();
    let __tc28 = __SetSlice_bits(32, 1, __tc28, 0, 0b0);
    set_CNTHP_CTL(__tc28);
    __tc29 : bits(32) = get_CNTHPS_CTL();
    let __tc29 = __SetSlice_bits(32, 29, __tc29, 3, 0b00000000000000000000000000000);
    set_CNTHPS_CTL(__tc29);
    __tc30 : bits(32) = get_CNTHV_CTL();
    let __tc30 = __SetSlice_bits(32, 29, __tc30, 3, 0b00000000000000000000000000000);
    set_CNTHV_CTL(__tc30);
    __tc31 : bits(32) = get_CNTHVS_CTL();
    let __tc31 = __SetSlice_bits(32, 29, __tc31, 3, 0b00000000000000000000000000000);
    set_CNTHVS_CTL(__tc31);
    __tc32 : bits(32) = get_CNTKCTL();
    let __tc32 = __SetSlice_bits(32, 22, __tc32, 10, 0b0000000000000000000000);
    set_CNTKCTL(__tc32);
    __tc33 : bits(32) = get_CNTP_CTL();
    let __tc33 = __SetSlice_bits(32, 29, __tc33, 3, 0b00000000000000000000000000000);
    set_CNTP_CTL(__tc33);
    __tc34 : bits(32) = get_CNTP_CTL();
    let __tc34 = __SetSlice_bits(32, 1, __tc34, 0, 0b0);
    set_CNTP_CTL(__tc34);
    __tc35 : bits(32) = get_CNTV_CTL();
    let __tc35 = __SetSlice_bits(32, 29, __tc35, 3, 0b00000000000000000000000000000);
    set_CNTV_CTL(__tc35);
    __tc36 : bits(32) = get_CNTV_CTL();
    let __tc36 = __SetSlice_bits(32, 1, __tc36, 0, 0b0);
    set_CNTV_CTL(__tc36);
    __tc37 : bits(32) = get_CPACR();
    let __tc37 = __SetSlice_bits(32, 1, __tc37, 31, 0b0);
    set_CPACR(__tc37);
    __tc38 : bits(32) = get_CPACR();
    let __tc38 = __SetSlice_bits(32, 2, __tc38, 29, 0b00);
    set_CPACR(__tc38);
    __tc39 : bits(32) = get_CPACR();
    let __tc39 = __SetSlice_bits(32, 4, __tc39, 24, 0x0);
    set_CPACR(__tc39);
    __tc40 : bits(32) = get_CPACR();
    let __tc40 = __SetSlice_bits(32, 2, __tc40, 22, 0b00);
    set_CPACR(__tc40);
    __tc41 : bits(32) = get_CPACR();
    let __tc41 = __SetSlice_bits(32, 2, __tc41, 20, 0b00);
    set_CPACR(__tc41);
    __tc42 : bits(32) = get_CPACR();
    let __tc42 = __SetSlice_bits(32, 20, __tc42, 0, 0x00000);
    set_CPACR(__tc42);
    __tc43 : bits(32) = get_CSSELR();
    let __tc43 = __SetSlice_bits(32, 28, __tc43, 4, 0x0000000);
    set_CSSELR(__tc43);
    __tc44 : bits(32) = get_CTR();
    let __tc44 = __SetSlice_bits(32, 1, __tc44, 31, 0b1);
    set_CTR(__tc44);
    __tc45 : bits(32) = get_CTR();
    let __tc45 = __SetSlice_bits(32, 1, __tc45, 30, 0b0);
    set_CTR(__tc45);
    __tc46 : bits(32) = get_CTR();
    let __tc46 = __SetSlice_bits(32, 10, __tc46, 4, 0b0000000000);
    set_CTR(__tc46);
    __tc47 : bits(32) = get_DBGAUTHSTATUS();
    let __tc47 = __SetSlice_bits(32, 24, __tc47, 8, 0x000000);
    set_DBGAUTHSTATUS(__tc47);
    __tc48 : bits(32) = get_DBGCLAIMCLR();
    let __tc48 = __SetSlice_bits(32, 24, __tc48, 8, 0x000000);
    set_DBGCLAIMCLR(__tc48);
    if cold then {
        __tc49 : bits(32) = get_DBGCLAIMCLR();
        __tc49 = __SetSlice_bits(32, 8, __tc49, 0, 0x00);
        set_DBGCLAIMCLR(__tc49)
    };
    __tc50 : bits(32) = get_DBGCLAIMSET();
    let __tc50 = __SetSlice_bits(32, 24, __tc50, 8, 0x000000);
    set_DBGCLAIMSET(__tc50);
    if cold then {
        __tc51 : bits(32) = get_DBGCLAIMSET();
        __tc51 = __SetSlice_bits(32, 8, __tc51, 0, 0x00);
        set_DBGCLAIMSET(__tc51)
    };
    __tc52 : bits(32) = get_DBGDCCINT();
    let __tc52 = __SetSlice_bits(32, 1, __tc52, 31, 0b0);
    set_DBGDCCINT(__tc52);
    __tc53 : bits(32) = get_DBGDCCINT();
    let __tc53 = __SetSlice_bits(32, 1, __tc53, 30, 0b0);
    set_DBGDCCINT(__tc53);
    __tc54 : bits(32) = get_DBGDCCINT();
    let __tc54 = __SetSlice_bits(32, 1, __tc54, 29, 0b0);
    set_DBGDCCINT(__tc54);
    __tc55 : bits(32) = get_DBGDCCINT();
    let __tc55 = __SetSlice_bits(32, 29, __tc55, 0, 0b00000000000000000000000000000);
    set_DBGDCCINT(__tc55);
    DBGDEVID1 = __SetSlice_bits(32, 28, DBGDEVID1, 4, 0x0000000);
    DBGDEVID2 = __SetSlice_bits(32, 32, DBGDEVID2, 0, 0x00000000);
    DBGDIDR = __SetSlice_bits(32, 1, DBGDIDR, 15, 0b1);
    DBGDIDR = __SetSlice_bits(32, 1, DBGDIDR, 13, 0b0);
    DBGDIDR = __SetSlice_bits(32, 12, DBGDIDR, 0, 0x000);
    __tc56 : bits(64) = get_DBGDRAR();
    let __tc56 = __SetSlice_bits(64, 10, __tc56, 2, 0b0000000000);
    set_DBGDRAR(__tc56);
    __tc57 : bits(64) = get_DBGDRAR();
    let __tc57 = __SetSlice_bits(64, 16, __tc57, 48, 0x0000);
    set_DBGDRAR(__tc57);
    __tc58 : bits(64) = get_DBGDRAR();
    let __tc58 = __SetSlice_bits(64, 10, __tc58, 2, 0b0000000000);
    set_DBGDRAR(__tc58);
    __tc59 : bits(32) = get_DBGDSCRext();
    let __tc59 = __SetSlice_bits(32, 1, __tc59, 28, 0b0);
    set_DBGDSCRext(__tc59);
    __tc60 : bits(32) = get_DBGDSCRext();
    let __tc60 = __SetSlice_bits(32, 2, __tc60, 24, 0b00);
    set_DBGDSCRext(__tc60);
    __tc61 : bits(32) = get_DBGDSCRext();
    let __tc61 = __SetSlice_bits(32, 1, __tc61, 20, 0b0);
    set_DBGDSCRext(__tc61);
    __tc62 : bits(32) = get_DBGDSCRext();
    let __tc62 = __SetSlice_bits(32, 1, __tc62, 15, 0b0);
    set_DBGDSCRext(__tc62);
    __tc63 : bits(32) = get_DBGDSCRext();
    let __tc63 = __SetSlice_bits(32, 1, __tc63, 13, 0b0);
    set_DBGDSCRext(__tc63);
    __tc64 : bits(32) = get_DBGDSCRext();
    let __tc64 = __SetSlice_bits(32, 1, __tc64, 12, 0b0);
    set_DBGDSCRext(__tc64);
    __tc65 : bits(32) = get_DBGDSCRext();
    let __tc65 = __SetSlice_bits(32, 5, __tc65, 7, 0b00000);
    set_DBGDSCRext(__tc65);
    __tc66 : bits(32) = get_DBGDSCRext();
    let __tc66 = __SetSlice_bits(32, 2, __tc66, 0, 0b00);
    set_DBGDSCRext(__tc66);
    DBGDSCRint = __SetSlice_bits(32, 1, DBGDSCRint, 31, 0b0);
    DBGDSCRint = __SetSlice_bits(32, 10, DBGDSCRint, 19, 0b0000000000);
    DBGDSCRint = __SetSlice_bits(32, 2, DBGDSCRint, 13, 0b00);
    DBGDSCRint = __SetSlice_bits(32, 6, DBGDSCRint, 6, 0b000000);
    DBGDSCRint = __SetSlice_bits(32, 2, DBGDSCRint, 0, 0b00);
    __tc67 : bits(32) = get_DBGOSDLR();
    let __tc67 = __SetSlice_bits(32, 31, __tc67, 1, 0b0000000000000000000000000000000);
    set_DBGOSDLR(__tc67);
    __tc68 : bits(32) = get_DBGOSDLR();
    let __tc68 = __SetSlice_bits(32, 1, __tc68, 0, 0b0);
    set_DBGOSDLR(__tc68);
    __tc69 : bits(32) = get_DBGOSLSR();
    let __tc69 = __SetSlice_bits(32, 28, __tc69, 4, 0x0000000);
    set_DBGOSLSR(__tc69);
    if cold then {
        __tc70 : bits(32) = get_DBGOSLSR();
        __tc70 = __SetSlice_bits(32, 1, __tc70, 1, 0b1);
        set_DBGOSLSR(__tc70)
    };
    __tc71 : bits(32) = get_DBGPRCR();
    let __tc71 = __SetSlice_bits(32, 31, __tc71, 1, 0b0000000000000000000000000000000);
    set_DBGPRCR(__tc71);
    __tc72 : bits(32) = get_DBGVCR();
    let __tc72 = __SetSlice_bits(32, 1, __tc72, 29, 0b0);
    set_DBGVCR(__tc72);
    __tc73 : bits(32) = get_DBGVCR();
    let __tc73 = __SetSlice_bits(32, 9, __tc73, 16, 0b000000000);
    set_DBGVCR(__tc73);
    __tc74 : bits(32) = get_DBGVCR();
    let __tc74 = __SetSlice_bits(32, 1, __tc74, 13, 0b0);
    set_DBGVCR(__tc74);
    __tc75 : bits(32) = get_DBGVCR();
    let __tc75 = __SetSlice_bits(32, 2, __tc75, 8, 0b00);
    set_DBGVCR(__tc75);
    __tc76 : bits(32) = get_DBGVCR();
    let __tc76 = __SetSlice_bits(32, 1, __tc76, 5, 0b0);
    set_DBGVCR(__tc76);
    __tc77 : bits(32) = get_DBGVCR();
    let __tc77 = __SetSlice_bits(32, 1, __tc77, 0, 0b0);
    set_DBGVCR(__tc77);
    __tc78 : bits(32) = get_DBGVCR();
    let __tc78 = __SetSlice_bits(32, 1, __tc78, 29, 0b0);
    set_DBGVCR(__tc78);
    __tc79 : bits(32) = get_DBGVCR();
    let __tc79 = __SetSlice_bits(32, 17, __tc79, 8, 0b00000000000000000);
    set_DBGVCR(__tc79);
    __tc80 : bits(32) = get_DBGVCR();
    let __tc80 = __SetSlice_bits(32, 1, __tc80, 5, 0b0);
    set_DBGVCR(__tc80);
    __tc81 : bits(32) = get_DBGVCR();
    let __tc81 = __SetSlice_bits(32, 1, __tc81, 0, 0b0);
    set_DBGVCR(__tc81);
    __tc82 : bits(32) = get_DBGVCR();
    let __tc82 = __SetSlice_bits(32, 24, __tc82, 8, 0x000000);
    set_DBGVCR(__tc82);
    __tc83 : bits(32) = get_DBGVCR();
    let __tc83 = __SetSlice_bits(32, 1, __tc83, 5, 0b0);
    set_DBGVCR(__tc83);
    __tc84 : bits(32) = get_DBGVCR();
    let __tc84 = __SetSlice_bits(32, 1, __tc84, 0, 0b0);
    set_DBGVCR(__tc84);
    DBGWFAR = __SetSlice_bits(32, 32, DBGWFAR, 0, 0x00000000);
    __tc85 : bits(32) = get_DFSR();
    let __tc85 = __SetSlice_bits(32, 15, __tc85, 17, 0b000000000000000);
    set_DFSR(__tc85);
    __tc86 : bits(32) = get_DFSR();
    let __tc86 = __SetSlice_bits(32, 1, __tc86, 8, 0b0);
    set_DFSR(__tc86);
    __tc87 : bits(32) = get_DFSR();
    let __tc87 = __SetSlice_bits(32, 15, __tc87, 17, 0b000000000000000);
    set_DFSR(__tc87);
    __tc88 : bits(32) = get_DFSR();
    let __tc88 = __SetSlice_bits(32, 1, __tc88, 10, 0b0);
    set_DFSR(__tc88);
    __tc89 : bits(32) = get_DFSR();
    let __tc89 = __SetSlice_bits(32, 3, __tc89, 6, 0b000);
    set_DFSR(__tc89);
    __tc90 : bits(32) = get_DSPSR();
    let __tc90 = __SetSlice_bits(32, 1, __tc90, 23, 0b0);
    set_DSPSR(__tc90);
    FCSEIDR = __SetSlice_bits(32, 32, FCSEIDR, 0, 0x00000000);
    __tc91 : bits(32) = get_FPEXC();
    let __tc91 = __SetSlice_bits(32, 1, __tc91, 30, 0b0);
    set_FPEXC(__tc91);
    __tc92 : bits(32) = get_FPEXC();
    let __tc92 = __SetSlice_bits(32, 15, __tc92, 11, 0b000000000000000);
    set_FPEXC(__tc92);
    __tc93 : bits(32) = get_FPEXC();
    let __tc93 = __SetSlice_bits(32, 2, __tc93, 5, 0b00);
    set_FPEXC(__tc93);
    FPSCR = __SetSlice_bits(32, 2, FPSCR, 13, 0b00);
    FPSCR = __SetSlice_bits(32, 2, FPSCR, 5, 0b00);
    __tc94 : bits(32) = get_HCPTR();
    let __tc94 = __SetSlice_bits(32, 1, __tc94, 31, 0b0);
    set_HCPTR(__tc94);
    __tc95 : bits(32) = get_HCPTR();
    let __tc95 = __SetSlice_bits(32, 9, __tc95, 21, 0b000000000);
    set_HCPTR(__tc95);
    __tc96 : bits(32) = get_HCPTR();
    let __tc96 = __SetSlice_bits(32, 1, __tc96, 20, 0b0);
    set_HCPTR(__tc96);
    __tc97 : bits(32) = get_HCPTR();
    let __tc97 = __SetSlice_bits(32, 4, __tc97, 16, 0x0);
    set_HCPTR(__tc97);
    __tc98 : bits(32) = get_HCPTR();
    let __tc98 = __SetSlice_bits(32, 1, __tc98, 15, 0b0);
    set_HCPTR(__tc98);
    __tc99 : bits(32) = get_HCPTR();
    let __tc99 = __SetSlice_bits(32, 1, __tc99, 14, 0b0);
    set_HCPTR(__tc99);
    __tc100 : bits(32) = get_HCPTR();
    let __tc100 = __SetSlice_bits(32, 2, __tc100, 12, 0b01);
    set_HCPTR(__tc100);
    __tc101 : bits(32) = get_HCPTR();
    let __tc101 = __SetSlice_bits(32, 1, __tc101, 11, 0b0);
    set_HCPTR(__tc101);
    __tc102 : bits(32) = get_HCPTR();
    let __tc102 = __SetSlice_bits(32, 1, __tc102, 10, 0b0);
    set_HCPTR(__tc102);
    __tc103 : bits(32) = get_HCPTR();
    let __tc103 = __SetSlice_bits(32, 10, __tc103, 0, 0b0000000001);
    set_HCPTR(__tc103);
    __tc104 : bits(32) = get_HCR();
    let __tc104 = __SetSlice_bits(32, 1, __tc104, 31, 0b0);
    set_HCR(__tc104);
    __tc105 : bits(32) = get_HCR();
    let __tc105 = __SetSlice_bits(32, 1, __tc105, 30, 0b0);
    set_HCR(__tc105);
    __tc106 : bits(32) = get_HCR();
    let __tc106 = __SetSlice_bits(32, 1, __tc106, 29, 0b0);
    set_HCR(__tc106);
    __tc107 : bits(32) = get_HCR();
    let __tc107 = __SetSlice_bits(32, 1, __tc107, 28, 0b0);
    set_HCR(__tc107);
    __tc108 : bits(32) = get_HCR();
    let __tc108 = __SetSlice_bits(32, 1, __tc108, 27, 0b0);
    set_HCR(__tc108);
    __tc109 : bits(32) = get_HCR();
    let __tc109 = __SetSlice_bits(32, 1, __tc109, 26, 0b0);
    set_HCR(__tc109);
    __tc110 : bits(32) = get_HCR();
    let __tc110 = __SetSlice_bits(32, 1, __tc110, 25, 0b0);
    set_HCR(__tc110);
    __tc111 : bits(32) = get_HCR();
    let __tc111 = __SetSlice_bits(32, 1, __tc111, 24, 0b0);
    set_HCR(__tc111);
    __tc112 : bits(32) = get_HCR();
    let __tc112 = __SetSlice_bits(32, 1, __tc112, 23, 0b0);
    set_HCR(__tc112);
    __tc113 : bits(32) = get_HCR();
    let __tc113 = __SetSlice_bits(32, 1, __tc113, 22, 0b0);
    set_HCR(__tc113);
    __tc114 : bits(32) = get_HCR();
    let __tc114 = __SetSlice_bits(32, 1, __tc114, 21, 0b0);
    set_HCR(__tc114);
    __tc115 : bits(32) = get_HCR();
    let __tc115 = __SetSlice_bits(32, 1, __tc115, 20, 0b0);
    set_HCR(__tc115);
    __tc116 : bits(32) = get_HCR();
    let __tc116 = __SetSlice_bits(32, 1, __tc116, 19, 0b0);
    set_HCR(__tc116);
    __tc117 : bits(32) = get_HCR();
    let __tc117 = __SetSlice_bits(32, 1, __tc117, 18, 0b0);
    set_HCR(__tc117);
    __tc118 : bits(32) = get_HCR();
    let __tc118 = __SetSlice_bits(32, 1, __tc118, 17, 0b0);
    set_HCR(__tc118);
    __tc119 : bits(32) = get_HCR();
    let __tc119 = __SetSlice_bits(32, 1, __tc119, 16, 0b0);
    set_HCR(__tc119);
    __tc120 : bits(32) = get_HCR();
    let __tc120 = __SetSlice_bits(32, 1, __tc120, 15, 0b0);
    set_HCR(__tc120);
    __tc121 : bits(32) = get_HCR();
    let __tc121 = __SetSlice_bits(32, 1, __tc121, 14, 0b0);
    set_HCR(__tc121);
    __tc122 : bits(32) = get_HCR();
    let __tc122 = __SetSlice_bits(32, 1, __tc122, 13, 0b0);
    set_HCR(__tc122);
    __tc123 : bits(32) = get_HCR();
    let __tc123 = __SetSlice_bits(32, 1, __tc123, 12, 0b0);
    set_HCR(__tc123);
    __tc124 : bits(32) = get_HCR();
    let __tc124 = __SetSlice_bits(32, 2, __tc124, 10, 0b00);
    set_HCR(__tc124);
    __tc125 : bits(32) = get_HCR();
    let __tc125 = __SetSlice_bits(32, 1, __tc125, 9, 0b0);
    set_HCR(__tc125);
    __tc126 : bits(32) = get_HCR();
    let __tc126 = __SetSlice_bits(32, 1, __tc126, 8, 0b0);
    set_HCR(__tc126);
    __tc127 : bits(32) = get_HCR();
    let __tc127 = __SetSlice_bits(32, 1, __tc127, 7, 0b0);
    set_HCR(__tc127);
    __tc128 : bits(32) = get_HCR();
    let __tc128 = __SetSlice_bits(32, 1, __tc128, 6, 0b0);
    set_HCR(__tc128);
    __tc129 : bits(32) = get_HCR();
    let __tc129 = __SetSlice_bits(32, 1, __tc129, 5, 0b0);
    set_HCR(__tc129);
    __tc130 : bits(32) = get_HCR();
    let __tc130 = __SetSlice_bits(32, 1, __tc130, 4, 0b0);
    set_HCR(__tc130);
    __tc131 : bits(32) = get_HCR();
    let __tc131 = __SetSlice_bits(32, 1, __tc131, 3, 0b0);
    set_HCR(__tc131);
    __tc132 : bits(32) = get_HCR();
    let __tc132 = __SetSlice_bits(32, 1, __tc132, 2, 0b0);
    set_HCR(__tc132);
    __tc133 : bits(32) = get_HCR();
    let __tc133 = __SetSlice_bits(32, 1, __tc133, 1, 0b0);
    set_HCR(__tc133);
    __tc134 : bits(32) = get_HCR();
    let __tc134 = __SetSlice_bits(32, 1, __tc134, 0, 0b0);
    set_HCR(__tc134);
    __tc135 : bits(32) = get_HCR2();
    let __tc135 = __SetSlice_bits(32, 9, __tc135, 23, 0b000000000);
    set_HCR2(__tc135);
    __tc136 : bits(32) = get_HCR2();
    let __tc136 = __SetSlice_bits(32, 3, __tc136, 19, 0b000);
    set_HCR2(__tc136);
    __tc137 : bits(32) = get_HCR2();
    let __tc137 = __SetSlice_bits(32, 9, __tc137, 7, 0b000000000);
    set_HCR2(__tc137);
    __tc138 : bits(32) = get_HCR2();
    let __tc138 = __SetSlice_bits(32, 1, __tc138, 5, 0b0);
    set_HCR2(__tc138);
    __tc139 : bits(32) = get_HCR2();
    let __tc139 = __SetSlice_bits(32, 1, __tc139, 4, 0b0);
    set_HCR2(__tc139);
    __tc140 : bits(32) = get_HCR2();
    let __tc140 = __SetSlice_bits(32, 2, __tc140, 2, 0b00);
    set_HCR2(__tc140);
    __tc141 : bits(32) = get_HCR2();
    let __tc141 = __SetSlice_bits(32, 1, __tc141, 1, 0b0);
    set_HCR2(__tc141);
    __tc142 : bits(32) = get_HCR2();
    let __tc142 = __SetSlice_bits(32, 1, __tc142, 0, 0b0);
    set_HCR2(__tc142);
    __tc143 : bits(32) = get_HDCR();
    let __tc143 = __SetSlice_bits(32, 5, __tc143, 27, 0b00000);
    set_HDCR(__tc143);
    __tc144 : bits(32) = get_HDCR();
    let __tc144 = __SetSlice_bits(32, 1, __tc144, 26, 0b0);
    set_HDCR(__tc144);
    __tc145 : bits(32) = get_HDCR();
    let __tc145 = __SetSlice_bits(32, 2, __tc145, 24, 0b00);
    set_HDCR(__tc145);
    __tc146 : bits(32) = get_HDCR();
    let __tc146 = __SetSlice_bits(32, 1, __tc146, 23, 0b0);
    set_HDCR(__tc146);
    __tc147 : bits(32) = get_HDCR();
    let __tc147 = __SetSlice_bits(32, 3, __tc147, 20, 0b000);
    set_HDCR(__tc147);
    __tc148 : bits(32) = get_HDCR();
    let __tc148 = __SetSlice_bits(32, 1, __tc148, 18, 0b0);
    set_HDCR(__tc148);
    __tc149 : bits(32) = get_HDCR();
    let __tc149 = __SetSlice_bits(32, 1, __tc149, 17, 0b0);
    set_HDCR(__tc149);
    __tc150 : bits(32) = get_HDCR();
    let __tc150 = __SetSlice_bits(32, 5, __tc150, 12, 0b00000);
    set_HDCR(__tc150);
    __tc151 : bits(32) = get_HDCR();
    let __tc151 = __SetSlice_bits(32, 1, __tc151, 11, 0b0);
    set_HDCR(__tc151);
    __tc152 : bits(32) = get_HDCR();
    let __tc152 = __SetSlice_bits(32, 1, __tc152, 10, 0b0);
    set_HDCR(__tc152);
    __tc153 : bits(32) = get_HDCR();
    let __tc153 = __SetSlice_bits(32, 1, __tc153, 9, 0b0);
    set_HDCR(__tc153);
    __tc154 : bits(32) = get_HDCR();
    let __tc154 = __SetSlice_bits(32, 1, __tc154, 8, 0b0);
    set_HDCR(__tc154);
    __tc155 : bits(32) = get_HDCR();
    let __tc155 = __SetSlice_bits(32, 1, __tc155, 6, 0b0);
    set_HDCR(__tc155);
    __tc156 : bits(32) = get_HDCR();
    let __tc156 = __SetSlice_bits(32, 1, __tc156, 5, 0b0);
    set_HDCR(__tc156);
    __tc157 : bits(32) = get_HPFAR();
    let __tc157 = __SetSlice_bits(32, 4, __tc157, 0, 0x0);
    set_HPFAR(__tc157);
    __tc158 : bits(32) = get_HRMR();
    let __tc158 = __SetSlice_bits(32, 30, __tc158, 2, 0b000000000000000000000000000000);
    set_HRMR(__tc158);
    __tc159 : bits(32) = get_HRMR();
    let __tc159 = __SetSlice_bits(32, 1, __tc159, 1, 0b0);
    set_HRMR(__tc159);
    __tc160 : bits(32) = get_HSCTLR();
    let __tc160 = __SetSlice_bits(32, 2, __tc160, 28, 0b01);
    set_HSCTLR(__tc160);
    __tc161 : bits(32) = get_HSCTLR();
    let __tc161 = __SetSlice_bits(32, 2, __tc161, 26, 0b00);
    set_HSCTLR(__tc161);
    __tc162 : bits(32) = get_HSCTLR();
    let __tc162 = __SetSlice_bits(32, 1, __tc162, 24, 0b0);
    set_HSCTLR(__tc162);
    __tc163 : bits(32) = get_HSCTLR();
    let __tc163 = __SetSlice_bits(32, 2, __tc163, 22, 0b01);
    set_HSCTLR(__tc163);
    __tc164 : bits(32) = get_HSCTLR();
    let __tc164 = __SetSlice_bits(32, 2, __tc164, 20, 0b00);
    set_HSCTLR(__tc164);
    __tc165 : bits(32) = get_HSCTLR();
    let __tc165 = __SetSlice_bits(32, 1, __tc165, 18, 0b1);
    set_HSCTLR(__tc165);
    __tc166 : bits(32) = get_HSCTLR();
    let __tc166 = __SetSlice_bits(32, 1, __tc166, 17, 0b0);
    set_HSCTLR(__tc166);
    __tc167 : bits(32) = get_HSCTLR();
    let __tc167 = __SetSlice_bits(32, 1, __tc167, 16, 0b1);
    set_HSCTLR(__tc167);
    __tc168 : bits(32) = get_HSCTLR();
    let __tc168 = __SetSlice_bits(32, 3, __tc168, 13, 0b000);
    set_HSCTLR(__tc168);
    __tc169 : bits(32) = get_HSCTLR();
    let __tc169 = __SetSlice_bits(32, 1, __tc169, 12, 0b0);
    set_HSCTLR(__tc169);
    __tc170 : bits(32) = get_HSCTLR();
    let __tc170 = __SetSlice_bits(32, 1, __tc170, 11, 0b1);
    set_HSCTLR(__tc170);
    __tc171 : bits(32) = get_HSCTLR();
    let __tc171 = __SetSlice_bits(32, 2, __tc171, 9, 0b00);
    set_HSCTLR(__tc171);
    __tc172 : bits(32) = get_HSCTLR();
    let __tc172 = __SetSlice_bits(32, 1, __tc172, 6, 0b0);
    set_HSCTLR(__tc172);
    __tc173 : bits(32) = get_HSCTLR();
    let __tc173 = __SetSlice_bits(32, 1, __tc173, 4, 0b1);
    set_HSCTLR(__tc173);
    __tc174 : bits(32) = get_HSCTLR();
    let __tc174 = __SetSlice_bits(32, 1, __tc174, 3, 0b1);
    set_HSCTLR(__tc174);
    __tc175 : bits(32) = get_HSCTLR();
    let __tc175 = __SetSlice_bits(32, 1, __tc175, 2, 0b0);
    set_HSCTLR(__tc175);
    __tc176 : bits(32) = get_HSCTLR();
    let __tc176 = __SetSlice_bits(32, 1, __tc176, 0, 0b0);
    set_HSCTLR(__tc176);
    __tc177 : bits(32) = get_HSTR();
    let __tc177 = __SetSlice_bits(32, 16, __tc177, 16, 0x0000);
    set_HSTR(__tc177);
    __tc178 : bits(32) = get_HSTR();
    let __tc178 = __SetSlice_bits(32, 16, __tc178, 0, 0x0000);
    set_HSTR(__tc178);
    __tc179 : bits(32) = get_HTCR();
    let __tc179 = __SetSlice_bits(32, 1, __tc179, 31, 0b1);
    set_HTCR(__tc179);
    __tc180 : bits(32) = get_HTCR();
    let __tc180 = __SetSlice_bits(32, 1, __tc180, 29, 0b0);
    set_HTCR(__tc180);
    __tc181 : bits(32) = get_HTCR();
    let __tc181 = __SetSlice_bits(32, 1, __tc181, 23, 0b1);
    set_HTCR(__tc181);
    __tc182 : bits(32) = get_HTCR();
    let __tc182 = __SetSlice_bits(32, 9, __tc182, 14, 0b000000000);
    set_HTCR(__tc182);
    __tc183 : bits(32) = get_HTCR();
    let __tc183 = __SetSlice_bits(32, 5, __tc183, 3, 0b00000);
    set_HTCR(__tc183);
    __tc184 : bits(32) = get_HTRFCR();
    let __tc184 = __SetSlice_bits(32, 25, __tc184, 7, 0b0000000000000000000000000);
    set_HTRFCR(__tc184);
    __tc185 : bits(32) = get_HTRFCR();
    let __tc185 = __SetSlice_bits(32, 2, __tc185, 5, 0b00);
    set_HTRFCR(__tc185);
    __tc186 : bits(32) = get_HTRFCR();
    let __tc186 = __SetSlice_bits(32, 1, __tc186, 4, 0b0);
    set_HTRFCR(__tc186);
    __tc187 : bits(32) = get_HTRFCR();
    let __tc187 = __SetSlice_bits(32, 1, __tc187, 3, 0b0);
    set_HTRFCR(__tc187);
    __tc188 : bits(32) = get_HTRFCR();
    let __tc188 = __SetSlice_bits(32, 1, __tc188, 2, 0b0);
    set_HTRFCR(__tc188);
    __tc189 : bits(32) = get_HTRFCR();
    let __tc189 = __SetSlice_bits(32, 1, __tc189, 1, 0b0);
    set_HTRFCR(__tc189);
    __tc190 : bits(32) = get_HTRFCR();
    let __tc190 = __SetSlice_bits(32, 1, __tc190, 0, 0b0);
    set_HTRFCR(__tc190);
    __tc191 : bits(64) = get_HTTBR();
    let __tc191 = __SetSlice_bits(64, 16, __tc191, 48, 0x0000);
    set_HTTBR(__tc191);
    __tc192 : bits(32) = get_HVBAR();
    let __tc192 = __SetSlice_bits(32, 5, __tc192, 0, 0b00000);
    set_HVBAR(__tc192);
    __tc193 : bits(64) = get_ICC_ASGI1R();
    let __tc193 = __SetSlice_bits(64, 8, __tc193, 56, 0x00);
    set_ICC_ASGI1R(__tc193);
    __tc194 : bits(64) = get_ICC_ASGI1R();
    let __tc194 = __SetSlice_bits(64, 3, __tc194, 41, 0b000);
    set_ICC_ASGI1R(__tc194);
    __tc195 : bits(64) = get_ICC_ASGI1R();
    let __tc195 = __SetSlice_bits(64, 4, __tc195, 28, 0x0);
    set_ICC_ASGI1R(__tc195);
    __tc196 : bits(32) = get_ICC_BPR0();
    let __tc196 = __SetSlice_bits(32, 29, __tc196, 3, 0b00000000000000000000000000000);
    set_ICC_BPR0(__tc196);
    __tc197 : bits(32) = get_ICC_BPR1();
    let __tc197 = __SetSlice_bits(32, 29, __tc197, 3, 0b00000000000000000000000000000);
    set_ICC_BPR1(__tc197);
    __tc198 : bits(32) = get_ICC_CTLR();
    let __tc198 = __SetSlice_bits(32, 13, __tc198, 19, 0b0000000000000);
    set_ICC_CTLR(__tc198);
    __tc199 : bits(32) = get_ICC_CTLR();
    let __tc199 = __SetSlice_bits(32, 2, __tc199, 16, 0b00);
    set_ICC_CTLR(__tc199);
    __tc200 : bits(32) = get_ICC_CTLR();
    let __tc200 = __SetSlice_bits(32, 1, __tc200, 7, 0b0);
    set_ICC_CTLR(__tc200);
    __tc201 : bits(32) = get_ICC_CTLR();
    let __tc201 = __SetSlice_bits(32, 4, __tc201, 2, 0x0);
    set_ICC_CTLR(__tc201);
    __tc202 : bits(32) = get_ICC_DIR();
    let __tc202 = __SetSlice_bits(32, 8, __tc202, 24, 0x00);
    set_ICC_DIR(__tc202);
    __tc203 : bits(32) = get_ICC_EOIR0();
    let __tc203 = __SetSlice_bits(32, 8, __tc203, 24, 0x00);
    set_ICC_EOIR0(__tc203);
    __tc204 : bits(32) = get_ICC_EOIR1();
    let __tc204 = __SetSlice_bits(32, 8, __tc204, 24, 0x00);
    set_ICC_EOIR1(__tc204);
    __tc205 : bits(32) = get_ICC_HPPIR0();
    let __tc205 = __SetSlice_bits(32, 8, __tc205, 24, 0x00);
    set_ICC_HPPIR0(__tc205);
    __tc206 : bits(32) = get_ICC_HPPIR1();
    let __tc206 = __SetSlice_bits(32, 8, __tc206, 24, 0x00);
    set_ICC_HPPIR1(__tc206);
    __tc207 : bits(32) = get_ICC_HSRE();
    let __tc207 = __SetSlice_bits(32, 28, __tc207, 4, 0x0000000);
    set_ICC_HSRE(__tc207);
    __tc208 : bits(32) = get_ICC_HSRE();
    let __tc208 = __SetSlice_bits(32, 1, __tc208, 2, 0b0);
    set_ICC_HSRE(__tc208);
    __tc209 : bits(32) = get_ICC_HSRE();
    let __tc209 = __SetSlice_bits(32, 1, __tc209, 1, 0b0);
    set_ICC_HSRE(__tc209);
    __tc210 : bits(32) = get_ICC_HSRE();
    let __tc210 = __SetSlice_bits(32, 1, __tc210, 0, 0b0);
    set_ICC_HSRE(__tc210);
    __tc211 : bits(32) = get_ICC_IAR0();
    let __tc211 = __SetSlice_bits(32, 8, __tc211, 24, 0x00);
    set_ICC_IAR0(__tc211);
    __tc212 : bits(32) = get_ICC_IAR1();
    let __tc212 = __SetSlice_bits(32, 8, __tc212, 24, 0x00);
    set_ICC_IAR1(__tc212);
    __tc213 : bits(32) = get_ICC_IGRPEN0();
    let __tc213 = __SetSlice_bits(32, 31, __tc213, 1, 0b0000000000000000000000000000000);
    set_ICC_IGRPEN0(__tc213);
    __tc214 : bits(32) = get_ICC_IGRPEN0();
    let __tc214 = __SetSlice_bits(32, 1, __tc214, 0, 0b0);
    set_ICC_IGRPEN0(__tc214);
    __tc215 : bits(32) = get_ICC_IGRPEN1();
    let __tc215 = __SetSlice_bits(32, 31, __tc215, 1, 0b0000000000000000000000000000000);
    set_ICC_IGRPEN1(__tc215);
    __tc216 : bits(32) = get_ICC_IGRPEN1();
    let __tc216 = __SetSlice_bits(32, 1, __tc216, 0, 0b0);
    set_ICC_IGRPEN1(__tc216);
    __tc217 : bits(32) = get_ICC_MCTLR();
    let __tc217 = __SetSlice_bits(32, 13, __tc217, 19, 0b0000000000000);
    set_ICC_MCTLR(__tc217);
    __tc218 : bits(32) = get_ICC_MCTLR();
    let __tc218 = __SetSlice_bits(32, 1, __tc218, 16, 0b0);
    set_ICC_MCTLR(__tc218);
    __tc219 : bits(32) = get_ICC_MCTLR();
    let __tc219 = __SetSlice_bits(32, 1, __tc219, 7, 0b0);
    set_ICC_MCTLR(__tc219);
    __tc220 : bits(32) = get_ICC_MCTLR();
    let __tc220 = __SetSlice_bits(32, 1, __tc220, 6, 0b0);
    set_ICC_MCTLR(__tc220);
    __tc221 : bits(32) = get_ICC_MGRPEN1();
    let __tc221 = __SetSlice_bits(32, 30, __tc221, 2, 0b000000000000000000000000000000);
    set_ICC_MGRPEN1(__tc221);
    __tc222 : bits(32) = get_ICC_MGRPEN1();
    let __tc222 = __SetSlice_bits(32, 1, __tc222, 1, 0b0);
    set_ICC_MGRPEN1(__tc222);
    __tc223 : bits(32) = get_ICC_MGRPEN1();
    let __tc223 = __SetSlice_bits(32, 1, __tc223, 0, 0b0);
    set_ICC_MGRPEN1(__tc223);
    __tc224 : bits(32) = get_ICC_MSRE();
    let __tc224 = __SetSlice_bits(32, 28, __tc224, 4, 0x0000000);
    set_ICC_MSRE(__tc224);
    __tc225 : bits(32) = get_ICC_MSRE();
    let __tc225 = __SetSlice_bits(32, 1, __tc225, 2, 0b0);
    set_ICC_MSRE(__tc225);
    __tc226 : bits(32) = get_ICC_MSRE();
    let __tc226 = __SetSlice_bits(32, 1, __tc226, 1, 0b0);
    set_ICC_MSRE(__tc226);
    __tc227 : bits(32) = get_ICC_MSRE();
    let __tc227 = __SetSlice_bits(32, 1, __tc227, 0, 0b0);
    set_ICC_MSRE(__tc227);
    __tc228 : bits(32) = get_ICC_PMR();
    let __tc228 = __SetSlice_bits(32, 24, __tc228, 8, 0x000000);
    set_ICC_PMR(__tc228);
    __tc229 : bits(32) = get_ICC_PMR();
    let __tc229 = __SetSlice_bits(32, 8, __tc229, 0, 0x00);
    set_ICC_PMR(__tc229);
    __tc230 : bits(32) = get_ICC_RPR();
    let __tc230 = __SetSlice_bits(32, 24, __tc230, 8, 0x000000);
    set_ICC_RPR(__tc230);
    __tc231 : bits(64) = get_ICC_SGI0R();
    let __tc231 = __SetSlice_bits(64, 8, __tc231, 56, 0x00);
    set_ICC_SGI0R(__tc231);
    __tc232 : bits(64) = get_ICC_SGI0R();
    let __tc232 = __SetSlice_bits(64, 3, __tc232, 41, 0b000);
    set_ICC_SGI0R(__tc232);
    __tc233 : bits(64) = get_ICC_SGI0R();
    let __tc233 = __SetSlice_bits(64, 4, __tc233, 28, 0x0);
    set_ICC_SGI0R(__tc233);
    __tc234 : bits(64) = get_ICC_SGI1R();
    let __tc234 = __SetSlice_bits(64, 8, __tc234, 56, 0x00);
    set_ICC_SGI1R(__tc234);
    __tc235 : bits(64) = get_ICC_SGI1R();
    let __tc235 = __SetSlice_bits(64, 3, __tc235, 41, 0b000);
    set_ICC_SGI1R(__tc235);
    __tc236 : bits(64) = get_ICC_SGI1R();
    let __tc236 = __SetSlice_bits(64, 4, __tc236, 28, 0x0);
    set_ICC_SGI1R(__tc236);
    __tc237 : bits(32) = get_ICC_SRE();
    let __tc237 = __SetSlice_bits(32, 29, __tc237, 3, 0b00000000000000000000000000000);
    set_ICC_SRE(__tc237);
    __tc238 : bits(32) = get_ICC_SRE();
    let __tc238 = __SetSlice_bits(32, 1, __tc238, 2, 0b0);
    set_ICC_SRE(__tc238);
    __tc239 : bits(32) = get_ICC_SRE();
    let __tc239 = __SetSlice_bits(32, 1, __tc239, 1, 0b0);
    set_ICC_SRE(__tc239);
    __tc240 : bits(32) = get_ICC_SRE();
    let __tc240 = __SetSlice_bits(32, 1, __tc240, 0, 0b0);
    set_ICC_SRE(__tc240);
    __tc241 : bits(32) = get_ICH_EISR();
    let __tc241 = __SetSlice_bits(32, 16, __tc241, 16, 0x0000);
    set_ICH_EISR(__tc241);
    __tc242 : bits(32) = get_ICH_EISR();
    let __tc242 = __SetSlice_bits(32, 16, __tc242, 0, 0x0000);
    set_ICH_EISR(__tc242);
    __tc243 : bits(32) = get_ICH_ELRSR();
    let __tc243 = __SetSlice_bits(32, 16, __tc243, 16, 0x0000);
    set_ICH_ELRSR(__tc243);
    __tc244 : bits(32) = get_ICH_HCR();
    let __tc244 = __SetSlice_bits(32, 5, __tc244, 27, 0b00000);
    set_ICH_HCR(__tc244);
    __tc245 : bits(32) = get_ICH_HCR();
    let __tc245 = __SetSlice_bits(32, 12, __tc245, 15, 0x000);
    set_ICH_HCR(__tc245);
    __tc246 : bits(32) = get_ICH_HCR();
    let __tc246 = __SetSlice_bits(32, 1, __tc246, 14, 0b0);
    set_ICH_HCR(__tc246);
    __tc247 : bits(32) = get_ICH_HCR();
    let __tc247 = __SetSlice_bits(32, 1, __tc247, 13, 0b0);
    set_ICH_HCR(__tc247);
    __tc248 : bits(32) = get_ICH_HCR();
    let __tc248 = __SetSlice_bits(32, 1, __tc248, 12, 0b0);
    set_ICH_HCR(__tc248);
    __tc249 : bits(32) = get_ICH_HCR();
    let __tc249 = __SetSlice_bits(32, 1, __tc249, 11, 0b0);
    set_ICH_HCR(__tc249);
    __tc250 : bits(32) = get_ICH_HCR();
    let __tc250 = __SetSlice_bits(32, 1, __tc250, 10, 0b0);
    set_ICH_HCR(__tc250);
    __tc251 : bits(32) = get_ICH_HCR();
    let __tc251 = __SetSlice_bits(32, 2, __tc251, 8, 0b00);
    set_ICH_HCR(__tc251);
    __tc252 : bits(32) = get_ICH_HCR();
    let __tc252 = __SetSlice_bits(32, 1, __tc252, 7, 0b0);
    set_ICH_HCR(__tc252);
    __tc253 : bits(32) = get_ICH_HCR();
    let __tc253 = __SetSlice_bits(32, 1, __tc253, 6, 0b0);
    set_ICH_HCR(__tc253);
    __tc254 : bits(32) = get_ICH_HCR();
    let __tc254 = __SetSlice_bits(32, 1, __tc254, 5, 0b0);
    set_ICH_HCR(__tc254);
    __tc255 : bits(32) = get_ICH_HCR();
    let __tc255 = __SetSlice_bits(32, 1, __tc255, 4, 0b0);
    set_ICH_HCR(__tc255);
    __tc256 : bits(32) = get_ICH_HCR();
    let __tc256 = __SetSlice_bits(32, 1, __tc256, 3, 0b0);
    set_ICH_HCR(__tc256);
    __tc257 : bits(32) = get_ICH_HCR();
    let __tc257 = __SetSlice_bits(32, 1, __tc257, 2, 0b0);
    set_ICH_HCR(__tc257);
    __tc258 : bits(32) = get_ICH_HCR();
    let __tc258 = __SetSlice_bits(32, 1, __tc258, 1, 0b0);
    set_ICH_HCR(__tc258);
    __tc259 : bits(32) = get_ICH_HCR();
    let __tc259 = __SetSlice_bits(32, 1, __tc259, 0, 0b0);
    set_ICH_HCR(__tc259);
    __tc260 : bits(32) = get_ICH_MISR();
    let __tc260 = __SetSlice_bits(32, 24, __tc260, 8, 0x000000);
    set_ICH_MISR(__tc260);
    __tc261 : bits(32) = get_ICH_MISR();
    let __tc261 = __SetSlice_bits(32, 1, __tc261, 7, 0b0);
    set_ICH_MISR(__tc261);
    __tc262 : bits(32) = get_ICH_MISR();
    let __tc262 = __SetSlice_bits(32, 1, __tc262, 6, 0b0);
    set_ICH_MISR(__tc262);
    __tc263 : bits(32) = get_ICH_MISR();
    let __tc263 = __SetSlice_bits(32, 1, __tc263, 5, 0b0);
    set_ICH_MISR(__tc263);
    __tc264 : bits(32) = get_ICH_MISR();
    let __tc264 = __SetSlice_bits(32, 1, __tc264, 4, 0b0);
    set_ICH_MISR(__tc264);
    __tc265 : bits(32) = get_ICH_MISR();
    let __tc265 = __SetSlice_bits(32, 1, __tc265, 3, 0b0);
    set_ICH_MISR(__tc265);
    __tc266 : bits(32) = get_ICH_MISR();
    let __tc266 = __SetSlice_bits(32, 1, __tc266, 2, 0b0);
    set_ICH_MISR(__tc266);
    __tc267 : bits(32) = get_ICH_MISR();
    let __tc267 = __SetSlice_bits(32, 1, __tc267, 1, 0b0);
    set_ICH_MISR(__tc267);
    __tc268 : bits(32) = get_ICH_MISR();
    let __tc268 = __SetSlice_bits(32, 1, __tc268, 0, 0b0);
    set_ICH_MISR(__tc268);
    __tc269 : bits(32) = get_ICH_VMCR();
    let __tc269 = __SetSlice_bits(32, 8, __tc269, 10, 0x00);
    set_ICH_VMCR(__tc269);
    __tc270 : bits(32) = get_ICH_VMCR();
    let __tc270 = __SetSlice_bits(32, 4, __tc270, 5, 0x0);
    set_ICH_VMCR(__tc270);
    __tc271 : bits(32) = get_ICH_VTR();
    let __tc271 = __SetSlice_bits(32, 14, __tc271, 5, 0b00000000000000);
    set_ICH_VTR(__tc271);
    __tc272 : bits(32) = get_ICV_BPR0();
    let __tc272 = __SetSlice_bits(32, 29, __tc272, 3, 0b00000000000000000000000000000);
    set_ICV_BPR0(__tc272);
    __tc273 : bits(32) = get_ICV_BPR1();
    let __tc273 = __SetSlice_bits(32, 29, __tc273, 3, 0b00000000000000000000000000000);
    set_ICV_BPR1(__tc273);
    __tc274 : bits(32) = get_ICV_CTLR();
    let __tc274 = __SetSlice_bits(32, 13, __tc274, 19, 0b0000000000000);
    set_ICV_CTLR(__tc274);
    __tc275 : bits(32) = get_ICV_CTLR();
    let __tc275 = __SetSlice_bits(32, 2, __tc275, 16, 0b00);
    set_ICV_CTLR(__tc275);
    __tc276 : bits(32) = get_ICV_CTLR();
    let __tc276 = __SetSlice_bits(32, 6, __tc276, 2, 0b000000);
    set_ICV_CTLR(__tc276);
    __tc277 : bits(32) = get_ICV_DIR();
    let __tc277 = __SetSlice_bits(32, 8, __tc277, 24, 0x00);
    set_ICV_DIR(__tc277);
    __tc278 : bits(32) = get_ICV_EOIR0();
    let __tc278 = __SetSlice_bits(32, 8, __tc278, 24, 0x00);
    set_ICV_EOIR0(__tc278);
    __tc279 : bits(32) = get_ICV_EOIR1();
    let __tc279 = __SetSlice_bits(32, 8, __tc279, 24, 0x00);
    set_ICV_EOIR1(__tc279);
    __tc280 : bits(32) = get_ICV_HPPIR0();
    let __tc280 = __SetSlice_bits(32, 8, __tc280, 24, 0x00);
    set_ICV_HPPIR0(__tc280);
    __tc281 : bits(32) = get_ICV_HPPIR1();
    let __tc281 = __SetSlice_bits(32, 8, __tc281, 24, 0x00);
    set_ICV_HPPIR1(__tc281);
    __tc282 : bits(32) = get_ICV_IAR0();
    let __tc282 = __SetSlice_bits(32, 8, __tc282, 24, 0x00);
    set_ICV_IAR0(__tc282);
    __tc283 : bits(32) = get_ICV_IAR1();
    let __tc283 = __SetSlice_bits(32, 8, __tc283, 24, 0x00);
    set_ICV_IAR1(__tc283);
    __tc284 : bits(32) = get_ICV_IGRPEN0();
    let __tc284 = __SetSlice_bits(32, 31, __tc284, 1, 0b0000000000000000000000000000000);
    set_ICV_IGRPEN0(__tc284);
    __tc285 : bits(32) = get_ICV_IGRPEN0();
    let __tc285 = __SetSlice_bits(32, 1, __tc285, 0, 0b0);
    set_ICV_IGRPEN0(__tc285);
    __tc286 : bits(32) = get_ICV_IGRPEN1();
    let __tc286 = __SetSlice_bits(32, 31, __tc286, 1, 0b0000000000000000000000000000000);
    set_ICV_IGRPEN1(__tc286);
    __tc287 : bits(32) = get_ICV_IGRPEN1();
    let __tc287 = __SetSlice_bits(32, 1, __tc287, 0, 0b0);
    set_ICV_IGRPEN1(__tc287);
    __tc288 : bits(32) = get_ICV_PMR();
    let __tc288 = __SetSlice_bits(32, 24, __tc288, 8, 0x000000);
    set_ICV_PMR(__tc288);
    __tc289 : bits(32) = get_ICV_PMR();
    let __tc289 = __SetSlice_bits(32, 8, __tc289, 0, 0x00);
    set_ICV_PMR(__tc289);
    __tc290 : bits(32) = get_ICV_RPR();
    let __tc290 = __SetSlice_bits(32, 24, __tc290, 8, 0x000000);
    set_ICV_RPR(__tc290);
    __tc291 : bits(32) = get_ID_AFR0();
    let __tc291 = __SetSlice_bits(32, 16, __tc291, 16, 0x0000);
    set_ID_AFR0(__tc291);
    __tc292 : bits(32) = get_ID_ISAR0();
    let __tc292 = __SetSlice_bits(32, 4, __tc292, 28, 0x0);
    set_ID_ISAR0(__tc292);
    __tc293 : bits(32) = get_ID_ISAR5();
    let __tc293 = __SetSlice_bits(32, 4, __tc293, 20, 0x0);
    set_ID_ISAR5(__tc293);
    __tc294 : bits(32) = get_ID_ISAR6();
    let __tc294 = __SetSlice_bits(32, 12, __tc294, 20, 0x000);
    set_ID_ISAR6(__tc294);
    __tc295 : bits(32) = get_ID_PFR2();
    let __tc295 = __SetSlice_bits(32, 20, __tc295, 12, 0x00000);
    set_ID_PFR2(__tc295);
    __tc296 : bits(32) = get_ID_PFR2();
    let __tc296 = __SetSlice_bits(32, 4, __tc296, 8, 0x0);
    set_ID_PFR2(__tc296);
    __tc297 : bits(32) = get_IFSR();
    let __tc297 = __SetSlice_bits(32, 15, __tc297, 17, 0b000000000000000);
    set_IFSR(__tc297);
    __tc298 : bits(32) = get_IFSR();
    let __tc298 = __SetSlice_bits(32, 3, __tc298, 13, 0b000);
    set_IFSR(__tc298);
    __tc299 : bits(32) = get_IFSR();
    let __tc299 = __SetSlice_bits(32, 1, __tc299, 11, 0b0);
    set_IFSR(__tc299);
    __tc300 : bits(32) = get_IFSR();
    let __tc300 = __SetSlice_bits(32, 5, __tc300, 4, 0b00000);
    set_IFSR(__tc300);
    __tc301 : bits(32) = get_IFSR();
    let __tc301 = __SetSlice_bits(32, 15, __tc301, 17, 0b000000000000000);
    set_IFSR(__tc301);
    __tc302 : bits(32) = get_IFSR();
    let __tc302 = __SetSlice_bits(32, 3, __tc302, 13, 0b000);
    set_IFSR(__tc302);
    __tc303 : bits(32) = get_IFSR();
    let __tc303 = __SetSlice_bits(32, 2, __tc303, 10, 0b00);
    set_IFSR(__tc303);
    __tc304 : bits(32) = get_IFSR();
    let __tc304 = __SetSlice_bits(32, 3, __tc304, 6, 0b000);
    set_IFSR(__tc304);
    __tc305 : bits(32) = get_ISR();
    let __tc305 = __SetSlice_bits(32, 23, __tc305, 9, 0b00000000000000000000000);
    set_ISR(__tc305);
    __tc306 : bits(32) = get_ISR();
    let __tc306 = __SetSlice_bits(32, 6, __tc306, 0, 0b000000);
    set_ISR(__tc306);
    __tc307 : bits(32) = get_MPIDR();
    let __tc307 = __SetSlice_bits(32, 5, __tc307, 25, 0b00000);
    set_MPIDR(__tc307);
    __tc308 : bits(32) = get_MVFR2();
    let __tc308 = __SetSlice_bits(32, 24, __tc308, 8, 0x000000);
    set_MVFR2(__tc308);
    NSACR = __SetSlice_bits(32, 11, NSACR, 21, 0b00000000000);
    NSACR = __SetSlice_bits(32, 1, NSACR, 20, 0b0);
    NSACR = __SetSlice_bits(32, 1, NSACR, 19, 0b0);
    NSACR = __SetSlice_bits(32, 1, NSACR, 15, 0b0);
    NSACR = __SetSlice_bits(32, 3, NSACR, 12, 0b000);
    NSACR = __SetSlice_bits(32, 10, NSACR, 0, 0b0000000000);
    __tc309 : bits(64) = get_PAR();
    let __tc309 = __SetSlice_bits(64, 4, __tc309, 12, 0x0);
    set_PAR(__tc309);
    __tc310 : bits(64) = get_PAR();
    let __tc310 = __SetSlice_bits(64, 4, __tc310, 7, 0x0);
    set_PAR(__tc310);
    __tc311 : bits(64) = get_PAR();
    let __tc311 = __SetSlice_bits(64, 16, __tc311, 40, 0x0000);
    set_PAR(__tc311);
    __tc312 : bits(64) = get_PAR();
    let __tc312 = __SetSlice_bits(64, 6, __tc312, 1, 0b000000);
    set_PAR(__tc312);
    __tc313 : bits(64) = get_PAR();
    let __tc313 = __SetSlice_bits(64, 36, __tc313, 12, 0x000000000);
    set_PAR(__tc313);
    __tc314 : bits(64) = get_PAR();
    let __tc314 = __SetSlice_bits(64, 1, __tc314, 10, 0b0);
    set_PAR(__tc314);
    __tc315 : bits(64) = get_PAR();
    let __tc315 = __SetSlice_bits(64, 1, __tc315, 7, 0b0);
    set_PAR(__tc315);
    __tc316 : bits(32) = get_PMCCFILTR();
    let __tc316 = __SetSlice_bits(32, 1, __tc316, 31, 0b0);
    set_PMCCFILTR(__tc316);
    __tc317 : bits(32) = get_PMCCFILTR();
    let __tc317 = __SetSlice_bits(32, 1, __tc317, 30, 0b0);
    set_PMCCFILTR(__tc317);
    __tc318 : bits(32) = get_PMCCFILTR();
    let __tc318 = __SetSlice_bits(32, 1, __tc318, 29, 0b0);
    set_PMCCFILTR(__tc318);
    __tc319 : bits(32) = get_PMCCFILTR();
    let __tc319 = __SetSlice_bits(32, 1, __tc319, 28, 0b0);
    set_PMCCFILTR(__tc319);
    __tc320 : bits(32) = get_PMCCFILTR();
    let __tc320 = __SetSlice_bits(32, 1, __tc320, 27, 0b0);
    set_PMCCFILTR(__tc320);
    __tc321 : bits(32) = get_PMCCFILTR();
    let __tc321 = __SetSlice_bits(32, 27, __tc321, 0, 0b000000000000000000000000000);
    set_PMCCFILTR(__tc321);
    __tc322 : bits(32) = get_PMCR();
    let __tc322 = __SetSlice_bits(32, 3, __tc322, 8, 0b000);
    set_PMCR(__tc322);
    __tc323 : bits(32) = get_PMCR();
    let __tc323 = __SetSlice_bits(32, 1, __tc323, 7, 0b0);
    set_PMCR(__tc323);
    __tc324 : bits(32) = get_PMCR();
    let __tc324 = __SetSlice_bits(32, 1, __tc324, 5, 0b0);
    set_PMCR(__tc324);
    __tc325 : bits(32) = get_PMCR();
    let __tc325 = __SetSlice_bits(32, 1, __tc325, 4, 0b0);
    set_PMCR(__tc325);
    __tc326 : bits(32) = get_PMCR();
    let __tc326 = __SetSlice_bits(32, 1, __tc326, 3, 0b0);
    set_PMCR(__tc326);
    __tc327 : bits(32) = get_PMCR();
    let __tc327 = __SetSlice_bits(32, 1, __tc327, 0, 0b0);
    set_PMCR(__tc327);
    PMMIR = __SetSlice_bits(32, 24, PMMIR, 8, 0x000000);
    __tc328 : bits(32) = get_PMSELR();
    let __tc328 = __SetSlice_bits(32, 27, __tc328, 5, 0b000000000000000000000000000);
    set_PMSELR(__tc328);
    __tc329 : bits(32) = get_PMSWINC();
    let __tc329 = __SetSlice_bits(32, 1, __tc329, 31, 0b0);
    set_PMSWINC(__tc329);
    __tc330 : bits(32) = get_PMUSERENR();
    let __tc330 = __SetSlice_bits(32, 28, __tc330, 4, 0x0000000);
    set_PMUSERENR(__tc330);
    __tc331 : bits(32) = get_PMUSERENR();
    let __tc331 = __SetSlice_bits(32, 1, __tc331, 3, 0b0);
    set_PMUSERENR(__tc331);
    __tc332 : bits(32) = get_PMUSERENR();
    let __tc332 = __SetSlice_bits(32, 1, __tc332, 2, 0b0);
    set_PMUSERENR(__tc332);
    __tc333 : bits(32) = get_PMUSERENR();
    let __tc333 = __SetSlice_bits(32, 1, __tc333, 1, 0b0);
    set_PMUSERENR(__tc333);
    __tc334 : bits(32) = get_PMUSERENR();
    let __tc334 = __SetSlice_bits(32, 1, __tc334, 0, 0b0);
    set_PMUSERENR(__tc334);
    __tc335 : bits(32) = get_PRRR();
    let __tc335 = __SetSlice_bits(32, 4, __tc335, 20, 0x0);
    set_PRRR(__tc335);
    __tc336 : bits(32) = get_RMR();
    let __tc336 = __SetSlice_bits(32, 30, __tc336, 2, 0b000000000000000000000000000000);
    set_RMR(__tc336);
    __tc337 : bits(32) = get_RMR();
    let __tc337 = __SetSlice_bits(32, 1, __tc337, 1, 0b0);
    set_RMR(__tc337);
    RVBAR = __SetSlice_bits(32, 1, RVBAR, 0, 0b1);
    __tc338 : bits(32) = get_SCR();
    let __tc338 = __SetSlice_bits(32, 16, __tc338, 16, 0x0000);
    set_SCR(__tc338);
    __tc339 : bits(32) = get_SCR();
    let __tc339 = __SetSlice_bits(32, 1, __tc339, 15, 0b0);
    set_SCR(__tc339);
    __tc340 : bits(32) = get_SCR();
    let __tc340 = __SetSlice_bits(32, 1, __tc340, 14, 0b0);
    set_SCR(__tc340);
    __tc341 : bits(32) = get_SCR();
    let __tc341 = __SetSlice_bits(32, 1, __tc341, 13, 0b0);
    set_SCR(__tc341);
    __tc342 : bits(32) = get_SCR();
    let __tc342 = __SetSlice_bits(32, 1, __tc342, 12, 0b0);
    set_SCR(__tc342);
    __tc343 : bits(32) = get_SCR();
    let __tc343 = __SetSlice_bits(32, 2, __tc343, 10, 0b00);
    set_SCR(__tc343);
    __tc344 : bits(32) = get_SCR();
    let __tc344 = __SetSlice_bits(32, 1, __tc344, 9, 0b0);
    set_SCR(__tc344);
    __tc345 : bits(32) = get_SCR();
    let __tc345 = __SetSlice_bits(32, 1, __tc345, 8, 0b0);
    set_SCR(__tc345);
    __tc346 : bits(32) = get_SCR();
    let __tc346 = __SetSlice_bits(32, 1, __tc346, 7, 0b0);
    set_SCR(__tc346);
    __tc347 : bits(32) = get_SCR();
    let __tc347 = __SetSlice_bits(32, 1, __tc347, 6, 0b0);
    set_SCR(__tc347);
    __tc348 : bits(32) = get_SCR();
    let __tc348 = __SetSlice_bits(32, 1, __tc348, 5, 0b0);
    set_SCR(__tc348);
    __tc349 : bits(32) = get_SCR();
    let __tc349 = __SetSlice_bits(32, 1, __tc349, 4, 0b0);
    set_SCR(__tc349);
    __tc350 : bits(32) = get_SCR();
    let __tc350 = __SetSlice_bits(32, 1, __tc350, 3, 0b0);
    set_SCR(__tc350);
    __tc351 : bits(32) = get_SCR();
    let __tc351 = __SetSlice_bits(32, 1, __tc351, 2, 0b0);
    set_SCR(__tc351);
    __tc352 : bits(32) = get_SCR();
    let __tc352 = __SetSlice_bits(32, 1, __tc352, 1, 0b0);
    set_SCR(__tc352);
    __tc353 : bits(32) = get_SCR();
    let __tc353 = __SetSlice_bits(32, 1, __tc353, 0, 0b0);
    set_SCR(__tc353);
    __tc354 : bits(32) = get_SCTLR();
    let __tc354 = __SetSlice_bits(32, 1, __tc354, 29, 0b0);
    set_SCTLR(__tc354);
    __tc355 : bits(32) = get_SCTLR();
    let __tc355 = __SetSlice_bits(32, 1, __tc355, 28, 0b0);
    set_SCTLR(__tc355);
    __tc356 : bits(32) = get_SCTLR();
    let __tc356 = __SetSlice_bits(32, 2, __tc356, 26, 0b00);
    set_SCTLR(__tc356);
    __tc357 : bits(32) = get_SCTLR();
    let __tc357 = __SetSlice_bits(32, 1, __tc357, 24, 0b0);
    set_SCTLR(__tc357);
    __tc358 : bits(32) = get_SCTLR();
    let __tc358 = __SetSlice_bits(32, 1, __tc358, 22, 0b1);
    set_SCTLR(__tc358);
    __tc359 : bits(32) = get_SCTLR();
    let __tc359 = __SetSlice_bits(32, 1, __tc359, 21, 0b0);
    set_SCTLR(__tc359);
    __tc360 : bits(32) = get_SCTLR();
    let __tc360 = __SetSlice_bits(32, 1, __tc360, 20, 0b0);
    set_SCTLR(__tc360);
    __tc361 : bits(32) = get_SCTLR();
    let __tc361 = __SetSlice_bits(32, 1, __tc361, 19, 0b0);
    set_SCTLR(__tc361);
    __tc362 : bits(32) = get_SCTLR();
    let __tc362 = __SetSlice_bits(32, 1, __tc362, 18, 0b1);
    set_SCTLR(__tc362);
    __tc363 : bits(32) = get_SCTLR();
    let __tc363 = __SetSlice_bits(32, 1, __tc363, 17, 0b0);
    set_SCTLR(__tc363);
    __tc364 : bits(32) = get_SCTLR();
    let __tc364 = __SetSlice_bits(32, 1, __tc364, 16, 0b1);
    set_SCTLR(__tc364);
    __tc365 : bits(32) = get_SCTLR();
    let __tc365 = __SetSlice_bits(32, 2, __tc365, 14, 0b00);
    set_SCTLR(__tc365);
    __tc366 : bits(32) = get_SCTLR();
    let __tc366 = __SetSlice_bits(32, 1, __tc366, 12, 0b0);
    set_SCTLR(__tc366);
    __tc367 : bits(32) = get_SCTLR();
    let __tc367 = __SetSlice_bits(32, 1, __tc367, 11, 0b1);
    set_SCTLR(__tc367);
    __tc368 : bits(32) = get_SCTLR();
    let __tc368 = __SetSlice_bits(32, 1, __tc368, 9, 0b0);
    set_SCTLR(__tc368);
    __tc369 : bits(32) = get_SCTLR();
    let __tc369 = __SetSlice_bits(32, 1, __tc369, 8, 0b0);
    set_SCTLR(__tc369);
    __tc370 : bits(32) = get_SCTLR();
    let __tc370 = __SetSlice_bits(32, 1, __tc370, 7, 0b0);
    set_SCTLR(__tc370);
    __tc371 : bits(32) = get_SCTLR();
    let __tc371 = __SetSlice_bits(32, 1, __tc371, 5, 0b1);
    set_SCTLR(__tc371);
    __tc372 : bits(32) = get_SCTLR();
    let __tc372 = __SetSlice_bits(32, 1, __tc372, 4, 0b1);
    set_SCTLR(__tc372);
    __tc373 : bits(32) = get_SCTLR();
    let __tc373 = __SetSlice_bits(32, 1, __tc373, 3, 0b1);
    set_SCTLR(__tc373);
    __tc374 : bits(32) = get_SCTLR();
    let __tc374 = __SetSlice_bits(32, 1, __tc374, 2, 0b0);
    set_SCTLR(__tc374);
    __tc375 : bits(32) = get_SCTLR();
    let __tc375 = __SetSlice_bits(32, 1, __tc375, 1, 0b0);
    set_SCTLR(__tc375);
    __tc376 : bits(32) = get_SCTLR();
    let __tc376 = __SetSlice_bits(32, 1, __tc376, 0, 0b0);
    set_SCTLR(__tc376);
    __tc377 : bits(32) = get_SDCR();
    let __tc377 = __SetSlice_bits(32, 8, __tc377, 24, 0x00);
    set_SDCR(__tc377);
    __tc378 : bits(32) = get_SDCR();
    let __tc378 = __SetSlice_bits(32, 1, __tc378, 23, 0b0);
    set_SDCR(__tc378);
    __tc379 : bits(32) = get_SDCR();
    let __tc379 = __SetSlice_bits(32, 1, __tc379, 22, 0b0);
    set_SDCR(__tc379);
    __tc380 : bits(32) = get_SDCR();
    let __tc380 = __SetSlice_bits(32, 1, __tc380, 21, 0b0);
    set_SDCR(__tc380);
    __tc381 : bits(32) = get_SDCR();
    let __tc381 = __SetSlice_bits(32, 1, __tc381, 20, 0b0);
    set_SDCR(__tc381);
    __tc382 : bits(32) = get_SDCR();
    let __tc382 = __SetSlice_bits(32, 1, __tc382, 19, 0b0);
    set_SDCR(__tc382);
    __tc383 : bits(32) = get_SDCR();
    let __tc383 = __SetSlice_bits(32, 1, __tc383, 18, 0b0);
    set_SDCR(__tc383);
    __tc384 : bits(32) = get_SDCR();
    let __tc384 = __SetSlice_bits(32, 1, __tc384, 17, 0b0);
    set_SDCR(__tc384);
    __tc385 : bits(32) = get_SDCR();
    let __tc385 = __SetSlice_bits(32, 1, __tc385, 16, 0b0);
    set_SDCR(__tc385);
    __tc386 : bits(32) = get_SDCR();
    let __tc386 = __SetSlice_bits(32, 2, __tc386, 14, 0b00);
    set_SDCR(__tc386);
    __tc387 : bits(32) = get_SDCR();
    let __tc387 = __SetSlice_bits(32, 14, __tc387, 0, 0b00000000000000);
    set_SDCR(__tc387);
    __tc388 : bits(32) = get_SDER();
    let __tc388 = __SetSlice_bits(32, 30, __tc388, 2, 0b000000000000000000000000000000);
    set_SDER(__tc388);
    __tc389 : bits(32) = get_SDER();
    let __tc389 = __SetSlice_bits(32, 1, __tc389, 1, 0b0);
    set_SDER(__tc389);
    __tc390 : bits(32) = get_SDER();
    let __tc390 = __SetSlice_bits(32, 1, __tc390, 0, 0b0);
    set_SDER(__tc390);
    __tc391 : bits(32) = get_TRFCR();
    let __tc391 = __SetSlice_bits(32, 25, __tc391, 7, 0b0000000000000000000000000);
    set_TRFCR(__tc391);
    __tc392 : bits(32) = get_TRFCR();
    let __tc392 = __SetSlice_bits(32, 3, __tc392, 2, 0b000);
    set_TRFCR(__tc392);
    __tc393 : bits(32) = get_TRFCR();
    let __tc393 = __SetSlice_bits(32, 1, __tc393, 1, 0b0);
    set_TRFCR(__tc393);
    __tc394 : bits(32) = get_TRFCR();
    let __tc394 = __SetSlice_bits(32, 1, __tc394, 0, 0b0);
    set_TRFCR(__tc394);
    __tc395 : bits(32) = get_TTBCR2();
    let __tc395 = __SetSlice_bits(32, 13, __tc395, 19, 0b0000000000000);
    set_TTBCR2(__tc395);
    __tc396 : bits(32) = get_TTBCR2();
    let __tc396 = __SetSlice_bits(32, 9, __tc396, 0, 0b000000000);
    set_TTBCR2(__tc396);
    __tc397 : bits(64) = get_TTBR0();
    let __tc397 = __SetSlice_bits(64, 8, __tc397, 56, 0x00);
    set_TTBR0(__tc397);
    __tc398 : bits(64) = get_TTBR1();
    let __tc398 = __SetSlice_bits(64, 8, __tc398, 56, 0x00);
    set_TTBR1(__tc398);
    __tc399 : bits(32) = get_VBAR();
    let __tc399 = __SetSlice_bits(32, 5, __tc399, 0, 0b00000);
    set_VBAR(__tc399);
    __tc400 : bits(32) = get_VMPIDR();
    let __tc400 = __SetSlice_bits(32, 5, __tc400, 25, 0b00000);
    set_VMPIDR(__tc400);
    __tc401 : bits(32) = get_VTCR();
    let __tc401 = __SetSlice_bits(32, 1, __tc401, 31, 0b1);
    set_VTCR(__tc401);
    __tc402 : bits(32) = get_VTCR();
    let __tc402 = __SetSlice_bits(32, 2, __tc402, 29, 0b00);
    set_VTCR(__tc402);
    __tc403 : bits(32) = get_VTCR();
    let __tc403 = __SetSlice_bits(32, 11, __tc403, 14, 0b00000000000);
    set_VTCR(__tc403);
    __tc404 : bits(32) = get_VTCR();
    let __tc404 = __SetSlice_bits(32, 1, __tc404, 5, 0b0);
    set_VTCR(__tc404);
    __tc405 : bits(64) = get_VTTBR();
    let __tc405 = __SetSlice_bits(64, 8, __tc405, 56, 0x00);
    set_VTTBR(__tc405);
    __tc406 : bits(64) = get_VTTBR();
    let __tc406 = __SetSlice_bits(64, 8, __tc406, 48, 0x00);
    set_VTTBR(__tc406);
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 31, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 30, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 29, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 27, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 26, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 2, EDSCR, 22, 0b00)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 21, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 19, 0b0)
    };
    EDSCR = __SetSlice_bits(32, 1, EDSCR, 17, 0b0);
    EDSCR = __SetSlice_bits(32, 1, EDSCR, 15, 0b0);
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 14, 0b0)
    };
    if cold then {
        EDSCR = __SetSlice_bits(32, 1, EDSCR, 6, 0b0)
    };
    EDPCSR = __SetSlice_bits(64, 5, EDPCSR, 56, 0b00000);
    EDPCSR = __SetSlice_bits(64, 64, EDPCSR, 0, 0x0000000000000000);
    EDPRSR = __SetSlice_bits(32, 20, EDPRSR, 12, 0x00000);
    if cold then {
        EDPRSR = __SetSlice_bits(32, 1, EDPRSR, 10, 0b0)
    };
    if cold then {
        EDPRSR = __SetSlice_bits(32, 1, EDPRSR, 8, 0b0)
    };
    EDPRSR = __SetSlice_bits(32, 1, EDPRSR, 3, 0b1);
    if cold then {
        EDPRSR = __SetSlice_bits(32, 1, EDPRSR, 1, 0b1)
    };
    EDLSR = __SetSlice_bits(32, 29, EDLSR, 3, 0b00000000000000000000000000000);
    EDLSR = __SetSlice_bits(32, 1, EDLSR, 1, 0b1);
    EDESR = __SetSlice_bits(32, 29, EDESR, 3, 0b00000000000000000000000000000);
    EDESR = __SetSlice_bits(32, 1, EDESR, 0, 0b0);
    EDECCR = __SetSlice_bits(32, 16, EDECCR, 16, 0x0000);
    if cold then {
        EDECCR = __SetSlice_bits(32, 4, EDECCR, 12, 0x0)
    };
    if cold then {
        EDECCR = __SetSlice_bits(32, 4, EDECCR, 8, 0x0)
    };
    if cold then {
        EDECCR = __SetSlice_bits(32, 4, EDECCR, 4, 0x0)
    };
    if cold then {
        EDECCR = __SetSlice_bits(32, 4, EDECCR, 0, 0x0)
    };
    EDECCR = __SetSlice_bits(32, 24, EDECCR, 8, 0x000000);
    EDECR = __SetSlice_bits(32, 29, EDECR, 3, 0b00000000000000000000000000000);
    EDECR = __SetSlice_bits(32, 1, EDECR, 2, 0b0);
    EDECR = __SetSlice_bits(32, 1, EDECR, 1, 0b0);
    EDECR = __SetSlice_bits(32, 1, EDECR, 0, 0b0);
    EDPRCR = __SetSlice_bits(32, 28, EDPRCR, 4, 0x0000000);
    EDPRCR = __SetSlice_bits(32, 1, EDPRCR, 3, 0b0);
    EDPRCR = __SetSlice_bits(32, 1, EDPRCR, 2, 0b0);
    EDPRCR = __SetSlice_bits(32, 1, EDPRCR, 1, 0b0);
    EDVIDSR = __SetSlice_bits(32, 32, EDVIDSR, 0, 0x00000000);
    EDVIDSR = __SetSlice_bits(32, 20, EDVIDSR, 8, 0x00000);
    EDVIDSR = __SetSlice_bits(32, 12, EDVIDSR, 16, 0x000);
    CNTSR = __SetSlice_bits(32, 24, CNTSR, 8, 0x000000);
    CNTSR = __SetSlice_bits(32, 6, CNTSR, 2, 0b000000);
    CNTSR = __SetSlice_bits(32, 1, CNTSR, 0, 0b0);
    CNTCR = __SetSlice_bits(32, 14, CNTCR, 18, 0b00000000000000);
    CNTCR = __SetSlice_bits(32, 10, CNTCR, 8, 0b0000000000);
    CNTCR = __SetSlice_bits(32, 5, CNTCR, 3, 0b00000);
    CNTCR = __SetSlice_bits(32, 1, CNTCR, 0, 0b0);
    EDPFR = __SetSlice_bits(64, 12, EDPFR, 52, 0x000);
    EDPFR = __SetSlice_bits(64, 4, EDPFR, 48, 0x0);
    PMPCSR = __SetSlice_bits(64, 4, PMPCSR, 56, 0x0);
    PMLSR = __SetSlice_bits(32, 29, PMLSR, 3, 0b00000000000000000000000000000);
    PMLSR = __SetSlice_bits(32, 1, PMLSR, 1, 0b1);
    PMVIDSR = __SetSlice_bits(32, 16, PMVIDSR, 16, 0x0000)
}

val system_exceptions_debug_halt : unit -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_debug_halt () = {
    Halt(DebugHalt_HaltInstruction)
}

val BigEndian : unit -> bool effect {escape, rreg, undef}

function BigEndian () = {
    bigend : bool = undefined : bool;
    if UsingAArch32() then {
        bigend = PSTATE.E != 0b0
    } else {
        if PSTATE.EL == EL0 then {
            bigend = [SCTLR()[24]] != 0b0
        } else {
            bigend = [SCTLR()[25]] != 0b0
        }
    };
    bigend
}

val BTypeCompatible_PACIXSP : unit -> bool effect {rreg, undef, escape}

function BTypeCompatible_PACIXSP () = {
    index : int = undefined : int;
    if PSTATE.BTYPE == 0b01 | PSTATE.BTYPE == 0b10 then {
        return(true)
    } else {
        if PSTATE.BTYPE == 0b11 then {
            index = if PSTATE.EL == EL0 then 35 else 36;
            return([aget_SCTLR()[index]] == 0b0)
        } else {
            return(false)
        }
    }
}

val CalculateTBI : (bits(64), bool) -> bool effect {escape, rreg, undef}

function CalculateTBI (ptr, data) = {
    tbi : bool = false;
    if PtrHasUpperAndLowerAddRanges() then {
        assert(S1TranslationRegime() == EL1 | S1TranslationRegime() == EL2);
        if S1TranslationRegime() == EL1 then {
            if data then {
                tbi = if [ptr[55]] == 0b1 then [TCR_EL1[38]] == 0b1 else [TCR_EL1[37]] == 0b1
            } else {
                if [ptr[55]] == 0b1 then {
                    tbi = [TCR_EL1[38]] == 0b1 & [TCR_EL1[52]] == 0b0
                } else {
                    tbi = [TCR_EL1[37]] == 0b1 & [TCR_EL1[51]] == 0b0
                }
            }
        } else {
            if data then {
                tbi = if [ptr[55]] == 0b1 then [TCR_EL2[38]] == 0b1 else [TCR_EL2[37]] == 0b1
            } else {
                if [ptr[55]] == 0b1 then {
                    tbi = [TCR_EL2[38]] == 0b1 & [TCR_EL2[52]] == 0b0
                } else {
                    tbi = [TCR_EL2[37]] == 0b1 & [TCR_EL2[51]] == 0b0
                }
            }
        }
    } else {
        if PSTATE.EL == EL2 then {
            tbi = if data then [TCR_EL2[20]] == 0b1 else [TCR_EL2[20]] == 0b1 & [TCR_EL2[29]] == 0b0
        } else {
            if PSTATE.EL == EL3 then {
                tbi = if data then [TCR_EL3[20]] == 0b1 else [TCR_EL3[20]] == 0b1 & [TCR_EL3[29]] == 0b0
            }
        }
    };
    tbi
}

val aget_CPACR : unit -> bits(32) effect {escape, rreg, undef}

function aget_CPACR () = {
    r : bits(32) = undefined : bits(32);
    if IsInHost() then {
        r = CPTR_EL2;
        return(r)
    };
    let r = CPACR_EL1;
    r
}

overload CPACR = {aget_CPACR}

val InterruptPending : unit -> bool effect {escape, rreg, undef}

function InterruptPending () = {
    let pending_physical_interrupt = (IsPhysicalSErrorPending() | IRQPending()) | FIQPending();
    let pending_virtual_interrupt = ~(IsInHost()) & ((HCR_EL2[8 .. 8] @ (HCR_EL2[7 .. 7] @ HCR_EL2[6 .. 6])) & (HCR_EL2[5 .. 5] @ (HCR_EL2[4 .. 4] @ HCR_EL2[3 .. 3]))) != 0b000;
    pending_physical_interrupt | pending_virtual_interrupt
}

val EnterLowPowerState : unit -> unit effect {escape, rreg, undef}

function EnterLowPowerState () = {
    if ~(InterruptPending()) then {
        __SleepRequest()
    };
    return()
}

val WaitForInterrupt : unit -> unit effect {escape, rreg, undef}

function WaitForInterrupt () = {
    EnterLowPowerState();
    return()
}

val WaitForEvent : unit -> unit effect {escape, rreg, undef}

function WaitForEvent () = {
    if EventRegister == 0b0 then {
        EnterLowPowerState()
    };
    return()
}

val getISR : unit -> bits(32) effect {escape, rreg, undef}

function getISR () = {
    value_name : bits(32) = Zeros();
    value_name = __SetSlice_bits(32, 1, value_name, 8, if IsPhysicalSErrorPending() then 0b1 else 0b0);
    value_name = __SetSlice_bits(32, 1, value_name, 7, if IRQPending() then 0b1 else 0b0);
    value_name = __SetSlice_bits(32, 1, value_name, 6, if FIQPending() then 0b1 else 0b0);
    if (PSTATE.EL == EL1 & EL2Enabled()) & [HCR_EL2[27]] == 0b0 then {
        if [HCR_EL2[5]] == 0b1 then {
            value_name = __SetSlice_bits(32, 1, value_name, 8, [value_name[8]] | [HCR_EL2[8]])
        };
        if [HCR_EL2[4]] == 0b1 then {
            value_name = __SetSlice_bits(32, 1, value_name, 7, [HCR_EL2[7]])
        };
        if [HCR_EL2[3]] == 0b1 then {
            value_name = __SetSlice_bits(32, 1, value_name, 6, [HCR_EL2[6]])
        }
    };
    value_name
}

val AArch64_vESBOperation : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_vESBOperation () = {
    assert(EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1));
    let vSEI_enabled = [HCR_EL2[27]] == 0b0 & [HCR_EL2[5]] == 0b1;
    let vSEI_pending : bool = vSEI_enabled & [HCR_EL2[8]] == 0b1;
    let vintdis = Halted() | ExternalDebugInterruptsDisabled(EL1);
    let vmasked : bool = vintdis | PSTATE.A == 0b1;
    if vSEI_pending & vmasked then {
        if ELUsingAArch32(EL1) then {
            set_VDISR(AArch32_ReportDeferredSError(slice(get_VDFSR(), 14, 2), [get_VDFSR()[12]]))
        } else {
            VDISR_EL2 = AArch64_ReportDeferredSError(slice(VSESR_EL2, 0, 25))
        };
        HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 8, 0b0)
    };
    return()
}

val AArch64_CheckNVCondsIfCurrentEL : forall 'op0 'op1 'crn 'crm 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bool effect {escape, rreg, undef}

function AArch64_CheckNVCondsIfCurrentEL (op0, op1, crn, crm, op2) = {
    let is_reg_current_el : bool = (((op0 == 3 & op1 == 0) & crn == 4) & crm == 2) & op2 == 2;
    let have_nv_trap_conds : bool = ((HaveNVExt() & EL2Enabled()) & PSTATE.EL == EL1) & [HCR_EL2[42]] == 0b1;
    is_reg_current_el & have_nv_trap_conds
}

val SSAdvance : unit -> unit effect {escape, rreg, undef, wreg}

function SSAdvance () = {
    let target = DebugTarget();
    let step_enabled : bool = ~(ELUsingAArch32(target)) & [MDSCR_EL1[0]] == 0b1;
    let active_not_pending : bool = step_enabled & PSTATE.SS == 0b1;
    if active_not_pending then {
        PSTATE.SS = 0b0
    };
    return()
}

val ConditionHolds : bits(4) -> bool effect {rreg, undef}

function ConditionHolds cond = {
    result : bool = undefined : bool;
    match slice(cond, 1, 3) {
      0b000 => {
          result = PSTATE.Z == 0b1
      },
      0b001 => {
          result = PSTATE.C == 0b1
      },
      0b010 => {
          result = PSTATE.N == 0b1
      },
      0b011 => {
          result = PSTATE.V == 0b1
      },
      0b100 => {
          result = PSTATE.C == 0b1 & PSTATE.Z == 0b0
      },
      0b101 => {
          result = PSTATE.N == PSTATE.V
      },
      0b110 => {
          result = PSTATE.N == PSTATE.V & PSTATE.Z == 0b0
      },
      0b111 => {
          result = true
      }
    };
    if [cond[0]] == 0b1 & cond != 0xF then {
        result = ~(result)
    };
    result
}

val integer_conditional_select : forall 'd 'datasize ('else_inc : Bool) ('else_inv : Bool) 'm 'n,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31) & ('d >= 0 & 'd <= 31).
  (bits(4), int('d), int('datasize), bool('else_inc), bool('else_inv), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function integer_conditional_select (condition, d, datasize, else_inc, else_inv, m, n) = {
    result : bits('datasize) = undefined : bits('datasize);
    let operand1 : bits('datasize) = X(n);
    let operand2 : bits('datasize) = X(m);
    if ConditionHolds(condition) then {
        result = operand1
    } else {
        result = operand2;
        if else_inv then {
            result = ~(result)
        };
        if else_inc then {
            result = result + 1
        }
    };
    X(d) = result
}

val integer_conditional_compare_register : forall 'datasize 'm 'n ('sub_op : Bool),
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}) & ('m >= 0 & 'm <= 31).
  (bits(4), int('datasize), bits(4), int('m), int('n), bool('sub_op)) -> unit effect {rreg, undef, wreg}

function integer_conditional_compare_register (condition, datasize, flags__arg, m, n, sub_op) = {
    flags = flags__arg;
    let operand1 : bits('datasize) = X(n);
    operand2 : bits('datasize) = X(m);
    carry_in : bits(1) = 0b0;
    __anon1 : bits('datasize) = undefined : bits('datasize);
    if ConditionHolds(condition) then {
        if sub_op then {
            operand2 = ~(operand2);
            carry_in = 0b1
        };
        (__anon1, flags) = AddWithCarry(operand1, operand2, carry_in)
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags
}

val integer_conditional_compare_immediate : forall 'datasize 'n ('sub_op : Bool),
  'datasize >= 0 & ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (bits(4), int('datasize), bits(4), bits('datasize), int('n), bool('sub_op)) -> unit effect {rreg, undef, wreg}

function integer_conditional_compare_immediate (condition, datasize, flags__arg, imm, n, sub_op) = {
    flags = flags__arg;
    let operand1 : bits('datasize) = X(n);
    operand2 : bits('datasize) = imm;
    carry_in : bits(1) = 0b0;
    __anon1 : bits('datasize) = undefined : bits('datasize);
    if ConditionHolds(condition) then {
        if sub_op then {
            operand2 = ~(operand2);
            carry_in = 0b1
        };
        (__anon1, flags) = AddWithCarry(operand1, operand2, carry_in)
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags
}

val ConditionSyndrome : unit -> bits(5) effect {escape, rreg, undef}

function ConditionSyndrome () = {
    syndrome : bits(5) = undefined : bits(5);
    cond : bits(4) = undefined : bits(4);
    if UsingAArch32() then {
        cond = AArch32_CurrentCond();
        if PSTATE.T == 0b0 then {
            syndrome = __SetSlice_bits(5, 1, syndrome, 4, 0b1);
            if ConditionHolds(cond) & ConstrainUnpredictableBool(Unpredictable_ESRCONDPASS) then {
                syndrome = __SetSlice_bits(5, 4, syndrome, 0, 0xE)
            } else {
                syndrome = __SetSlice_bits(5, 4, syndrome, 0, cond)
            }
        } else {
            if __IMPDEF_boolean("Condition valid for trapped T32") then {
                syndrome = __SetSlice_bits(5, 1, syndrome, 4, 0b1);
                syndrome = __SetSlice_bits(5, 4, syndrome, 0, cond)
            } else {
                syndrome = __SetSlice_bits(5, 1, syndrome, 4, 0b0);
                syndrome = __SetSlice_bits(5, 4, syndrome, 0, undefined : bits(4))
            }
        }
    } else {
        syndrome = __SetSlice_bits(5, 1, syndrome, 4, 0b1);
        syndrome = __SetSlice_bits(5, 4, syndrome, 0, 0xE)
    };
    syndrome
}

val CalculateBottomPACBit : bits(1) -> int effect {escape, rreg, undef}

function CalculateBottomPACBit top_bit = {
    tsz_field : int = undefined : int;
    using64k : bool = undefined : bool;
    if PtrHasUpperAndLowerAddRanges() then {
        assert(S1TranslationRegime() == EL1 | S1TranslationRegime() == EL2);
        if S1TranslationRegime() == EL1 then {
            tsz_field = if top_bit == 0b1 then UInt(slice(TCR_EL1, 16, 6)) else UInt(slice(TCR_EL1, 0, 6));
            using64k = if top_bit == 0b1 then slice(TCR_EL1, 30, 2) == 0b11 else slice(TCR_EL1, 14, 2) == 0b01
        } else {
            assert(HaveEL(EL2));
            tsz_field = if top_bit == 0b1 then UInt(slice(TCR_EL2, 16, 6)) else UInt(slice(TCR_EL2, 0, 6));
            using64k = if top_bit == 0b1 then slice(TCR_EL2, 30, 2) == 0b11 else slice(TCR_EL2, 14, 2) == 0b01
        }
    } else {
        tsz_field = if PSTATE.EL == EL2 then UInt(slice(TCR_EL2, 0, 6)) else UInt(slice(TCR_EL3, 0, 6));
        using64k = if PSTATE.EL == EL2 then slice(TCR_EL2, 14, 2) == 0b01 else slice(TCR_EL3, 14, 2) == 0b01
    };
    let max_limit_tsz_field : int = if ~(HaveSmallPageTblExt()) then 39 else if using64k then 47 else 48;
    c : Constraint = undefined : Constraint;
    if tsz_field > max_limit_tsz_field then {
        c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
        assert(c == Constraint_FORCE | c == Constraint_NONE);
        if c == Constraint_FORCE then {
            tsz_field = max_limit_tsz_field
        }
    };
    let tszmin : int = if using64k & VAMax() == 52 then 12 else 16;
    if tsz_field < tszmin then {
        c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
        assert(c == Constraint_FORCE | c == Constraint_NONE);
        if c == Constraint_FORCE then {
            tsz_field = tszmin
        }
    };
    64 - tsz_field
}

val Auth : (bits(64), bits(64), bits(128), bool, bits(1)) -> bits(64) effect {escape, rreg, undef, wreg}

function Auth (ptr, modifier, K, data, keynumber) = {
    PAC : bits(64) = undefined : bits(64);
    result : bits(64) = undefined : bits(64);
    original_ptr : bits(64) = undefined : bits(64);
    error_code : bits(2) = undefined : bits(2);
    extfield : bits(64) = undefined : bits(64);
    let tbi : bool = CalculateTBI(ptr, data);
    let 'bottom_PAC_bit : int = CalculateBottomPACBit([ptr[55]]);
    assert(constraint((- 'bottom_PAC_bit + 55 >= 0 & 'bottom_PAC_bit >= 0)));
    let extfield = replicate_bits([ptr[55]], 64);
    if tbi then {
        original_ptr = (slice(ptr, 56, 8) @ slice(extfield, 0, negate(bottom_PAC_bit) + 56)) @ slice(ptr, 0, bottom_PAC_bit)
    } else {
        original_ptr = slice(extfield, 0, negate(bottom_PAC_bit) + 64) @ slice(ptr, 0, bottom_PAC_bit)
    };
    let PAC = ComputePAC(original_ptr, modifier, slice(K, 64, 64), slice(K, 0, 64));
    if tbi then {
        if slice(PAC, bottom_PAC_bit, negate(bottom_PAC_bit) + 55) == slice(ptr, bottom_PAC_bit, negate(bottom_PAC_bit) + 55) then {
            result = original_ptr
        } else {
            error_code = keynumber @ ~(keynumber);
            result = (slice(original_ptr, 55, 9) @ error_code) @ slice(original_ptr, 0, 53)
        }
    } else {
        if slice(PAC, bottom_PAC_bit, negate(bottom_PAC_bit) + 55) == slice(ptr, bottom_PAC_bit, negate(bottom_PAC_bit) + 55) & slice(PAC, 56, 8) == slice(ptr, 56, 8) then {
            result = original_ptr
        } else {
            error_code = keynumber @ ~(keynumber);
            result = ([original_ptr[63]] @ error_code) @ slice(original_ptr, 0, 61)
        }
    };
    result
}

val BranchToAddr : forall ('N : Int), 'N >= 0.
  (bits('N), BranchType) -> unit effect {escape, rreg, wreg}

function BranchToAddr (target, branch_type) = {
    Hint_Branch(branch_type);
    if 'N == 32 then {
        assert(UsingAArch32());
        __branch_announce(64, ZeroExtend(64, target));
        _PC = ZeroExtend(target)
    } else {
        assert('N == 64 & ~(UsingAArch32()));
        __branch_announce(64, slice(target, 0, 64));
        _PC = slice(target, 0, 64)
    };
    __PC_changed = true;
    return()
}

val set_LR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function set_LR value_name = {
    R(14) = value_name;
    return()
}

val AArch32_ResetGeneralRegisters : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_ResetGeneralRegisters () = {
    foreach (i from 0 to 7 by 1 in inc) {
        R(i) = undefined : bits(32)
    };
    foreach (i from 8 to 12 by 1 in inc) {
        Rmode(i, M32_User) = undefined : bits(32);
        Rmode(i, M32_FIQ) = undefined : bits(32)
    };
    if HaveEL(EL2) then {
        Rmode(13, M32_Hyp) = undefined : bits(32)
    };
    foreach (i from 13 to 14 by 1 in inc) {
        Rmode(i, M32_User) = undefined : bits(32);
        Rmode(i, M32_FIQ) = undefined : bits(32);
        Rmode(i, M32_IRQ) = undefined : bits(32);
        Rmode(i, M32_Svc) = undefined : bits(32);
        Rmode(i, M32_Abort) = undefined : bits(32);
        Rmode(i, M32_Undef) = undefined : bits(32);
        if HaveEL(EL3) then {
            Rmode(i, M32_Monitor) = undefined : bits(32)
        }
    };
    return()
}

val ELFromSPSR : bits(32) -> (bool, bits(2)) effect {escape, rreg, undef}

function ELFromSPSR spsr = {
    el : bits(2) = undefined : bits(2);
    valid_name : bool = undefined : bool;
    if [spsr[4]] == 0b0 then {
        el = slice(spsr, 2, 2);
        if HighestELUsingAArch32() then {
            valid_name = false
        } else {
            if ~(HaveEL(el)) then {
                valid_name = false
            } else {
                if [spsr[1]] == 0b1 then {
                    valid_name = false
                } else {
                    if el == EL0 & [spsr[0]] == 0b1 then {
                        valid_name = false
                    } else {
                        if ((el == EL2 & HaveEL(EL3)) & ~(IsSecureEL2Enabled())) & [SCR_EL3[0]] == 0b0 then {
                            valid_name = false
                        } else {
                            valid_name = true
                        }
                    }
                }
            }
        }
    } else {
        if ~(HaveAnyAArch32()) then {
            valid_name = false
        } else {
            (valid_name, el) = ELFromM32(slice(spsr, 0, 5))
        }
    };
    if ~(valid_name) then {
        el = undefined : bits(2)
    };
    return((valid_name, el))
}

val IllegalExceptionReturn : bits(32) -> bool effect {escape, rreg, undef}

function IllegalExceptionReturn spsr = {
    target : bits(2) = undefined : bits(2);
    valid_name : bool = undefined : bool;
    (valid_name, target) = ELFromSPSR(spsr);
    if ~(valid_name) then {
        return(true)
    };
    if UInt(target) > UInt(PSTATE.EL) then {
        return(true)
    };
    let spsr_mode_is_aarch32 : bool = [spsr[4]] == 0b1;
    known : bool = undefined : bool;
    target_el_is_aarch32 : bool = undefined : bool;
    (known, target_el_is_aarch32) = ELUsingAArch32K(target);
    assert(known | target == EL0 & ~(ELUsingAArch32(EL1)));
    if known & spsr_mode_is_aarch32 != target_el_is_aarch32 then {
        return(true)
    };
    if UsingAArch32() & ~(spsr_mode_is_aarch32) then {
        return(true)
    };
    if (HaveEL(EL2) & target == EL1) & [HCR_EL2[27]] == 0b1 then {
        if ~(IsSecureBelowEL3()) | IsSecureEL2Enabled() then {
            return(true)
        }
    };
    false
}

val AddPAC : (bits(64), bits(64), bits(128), bool) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPAC (ptr, modifier, K, data) = {
    PAC : bits(64) = undefined : bits(64);
    result : bits(64) = undefined : bits(64);
    ext_ptr : bits(64) = undefined : bits(64);
    extfield : bits(64) = undefined : bits(64);
    selbit : bits(1) = undefined : bits(1);
    let tbi : bool = CalculateTBI(ptr, data);
    let 'top_bit : {|55, 63|} = if tbi then 55 else 63;
    if PtrHasUpperAndLowerAddRanges() then {
        assert(S1TranslationRegime() == EL1 | S1TranslationRegime() == EL2);
        if S1TranslationRegime() == EL1 then {
            if data then {
                selbit = if [TCR_EL1[38]] == 0b1 | [TCR_EL1[37]] == 0b1 then [ptr[55]] else [ptr[63]]
            } else {
                if [TCR_EL1[38]] == 0b1 & [TCR_EL1[52]] == 0b0 | [TCR_EL1[37]] == 0b1 & [TCR_EL1[51]] == 0b0 then {
                    selbit = [ptr[55]]
                } else {
                    selbit = [ptr[63]]
                }
            }
        } else {
            if data then {
                selbit = if HaveEL(EL2) & [TCR_EL2[38]] == 0b1 | HaveEL(EL2) & [TCR_EL2[37]] == 0b1 then [ptr[55]] else [ptr[63]]
            } else {
                selbit = if (HaveEL(EL2) & [TCR_EL2[38]] == 0b1) & [TCR_EL1[52]] == 0b0 | (HaveEL(EL2) & [TCR_EL2[37]] == 0b1) & [TCR_EL1[51]] == 0b0 then [ptr[55]] else [ptr[63]]
            }
        }
    } else {
        selbit = if tbi then [ptr[55]] else [ptr[63]]
    };
    let 'bottom_PAC_bit : int = CalculateBottomPACBit(selbit);
    assert(constraint((- 'bottom_PAC_bit + 55 >= 0 & 'bottom_PAC_bit >= 0)));
    let extfield = replicate_bits(selbit, 64);
    if tbi then {
        ext_ptr = (slice(ptr, 56, 8) @ slice(extfield, 0, negate(bottom_PAC_bit) + 56)) @ slice(ptr, 0, bottom_PAC_bit)
    } else {
        ext_ptr = slice(extfield, 0, negate(bottom_PAC_bit) + 64) @ slice(ptr, 0, bottom_PAC_bit)
    };
    PAC = ComputePAC(ext_ptr, modifier, slice(K, 64, 64), slice(K, 0, 64));
    if ~(IsZero(slice(ptr, bottom_PAC_bit, top_bit - bottom_PAC_bit + 1))) & ~(IsOnes(slice(ptr, bottom_PAC_bit, top_bit - bottom_PAC_bit + 1))) then {
        PAC = __SetSlice_bits(64, 1, PAC, top_bit - 1, ~([PAC[top_bit - 1]]))
    };
    if tbi then {
        result = ((slice(ptr, 56, 8) @ selbit) @ slice(PAC, bottom_PAC_bit, negate(bottom_PAC_bit) + 55)) @ slice(ptr, 0, bottom_PAC_bit)
    } else {
        result = ((slice(PAC, 56, 8) @ selbit) @ slice(PAC, bottom_PAC_bit, negate(bottom_PAC_bit) + 55)) @ slice(ptr, 0, bottom_PAC_bit)
    };
    result
}

val AArch64_IMPDEFResets : unit -> unit effect {rreg, wreg}

function AArch64_IMPDEFResets () = {
    DCZID_EL0 = __SetSlice_bits(32, 1, DCZID_EL0, 4, 0b0);
    DCZID_EL0 = __SetSlice_bits(32, 4, DCZID_EL0, 0, 0x4);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 32, 0x6);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 28, 0x1);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 20, 0x1);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 12, 0x1);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 8, 0x1);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 4, 0x0);
    ID_AA64DFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64DFR0_EL1, 0, 0x6);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 60, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 44, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 40, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 36, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 32, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 28, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 20, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 16, 0x0);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 12, 0x1);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 8, 0x1);
    ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 4, 0x2);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 28, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 24, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 20, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 16, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 12, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 8, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 4, 0x0);
    ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 0, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 28, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 24, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 20, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 16, 0x0);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 12, 0x1);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 8, 0x1);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 4, 0x2);
    ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 0, 0x5);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 28, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 24, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 20, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 16, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 12, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 8, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 4, 0x0);
    ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 0, 0x0);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 36, 0x2);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 32, 0x2);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 28, 0x0);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 24, 0x0);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 20, 0x0);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 16, 0x0);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 12, 0x2);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 8, 0x2);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 4, 0x2);
    ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 0, 0x2);
    VMPIDR_EL2 = __SetSlice_bits(64, 8, VMPIDR_EL2, 32, 0x00);
    VMPIDR_EL2 = __SetSlice_bits(64, 1, VMPIDR_EL2, 30, 0b0);
    VMPIDR_EL2 = __SetSlice_bits(64, 1, VMPIDR_EL2, 24, 0b0);
    VMPIDR_EL2 = __SetSlice_bits(64, 8, VMPIDR_EL2, 16, 0x00);
    VMPIDR_EL2 = __SetSlice_bits(64, 8, VMPIDR_EL2, 8, 0x00);
    VMPIDR_EL2 = __SetSlice_bits(64, 8, VMPIDR_EL2, 0, 0x00);
    if HasArchVersion(ARMv8p1) then {
        ID_ISAR5_EL1 = __SetSlice_bits(32, 4, ID_ISAR5_EL1, 24, 0x1);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 20, 0x2);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 28, 0x1);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 16, 0x1);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 12, 0x1);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 8, 0x1);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 0, 0x2)
    };
    if __crc32_implemented then {
        ID_ISAR5_EL1 = __SetSlice_bits(32, 4, ID_ISAR5_EL1, 16, 0x1);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 16, 0x1)
    };
    if __vmid16_implemented then {
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 4, 0x2)
    };
    if __pan_implemented then {
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 20, 0x1);
        ID_MMFR3_EL1 = __SetSlice_bits(32, 4, ID_MMFR3_EL1, 16, 0x1)
    };
    if __crypto_aes_implemented == 0 then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 4, 0x0)
    };
    if __crypto_aes_implemented == 1 then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 4, 0x1)
    };
    if ~(__crypto_sha1_implemented) then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 8, 0x0)
    };
    if ~(__crypto_sha256_implemented) then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 12, 0x0)
    };
    if HasArchVersion(ARMv8p2) then {
        ID_AA64MMFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR0_EL1, 0, 0x6);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 28, 0x1);
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 20, 0x2);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 0, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 4, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 8, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 16, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 12, 0x1);
        ID_MMFR3_EL1 = __SetSlice_bits(32, 4, ID_MMFR3_EL1, 16, 0x2);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 8, 0x1);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 12, 0x1);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 20, 0x1);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 4, 0x1);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 0, 0x1);
        ID_ISAR6_EL1 = __SetSlice_bits(32, 4, ID_ISAR6_EL1, 4, 0x1)
    };
    if __dot_product_implemented then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 44, 0x1)
    };
    if __fp16_implemented then {
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 16, 0x1);
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 20, 0x1)
    };
    if __aa32_hpd_implemented then {
        ID_AA64MMFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64MMFR1_EL1, 12, 0x2);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 16, 0x2)
    };
    if __mpam_implemented then {
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 40, CFG_ID_AA64PFR0_EL1_MPAM);
        MPAMIDR_EL1 = __SetSlice_bits(64, 16, MPAMIDR_EL1, 0, __mpam_partid_max);
        MPAMIDR_EL1 = __SetSlice_bits(64, 8, MPAMIDR_EL1, 32, __mpam_pmg_max);
        MPAMIDR_EL1 = __SetSlice_bits(64, 1, MPAMIDR_EL1, 17, if __mpam_has_hcr then 0b1 else 0b0);
        MPAMIDR_EL1 = __SetSlice_bits(64, 3, MPAMIDR_EL1, 18, __mpam_vpmr_max)
    };
    if HasArchVersion(ARMv8p3) then {
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 4, 0x1);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 8, 0x0);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 24, 0x1);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 28, 0x0);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 12, 0x1);
        ID_ISAR6_EL1 = __SetSlice_bits(32, 4, ID_ISAR6_EL1, 0, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 20, 0x1);
        ID_MMFR4_EL1 = __SetSlice_bits(32, 4, ID_MMFR4_EL1, 24, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 24, 0x1);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 20, 0x1);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 16, 0x1)
    };
    if HasArchVersion(ARMv8p4) then {
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 20, 0x2);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 24, 0x2);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 28, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 32, 0x1);
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 36, 0x1);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 56, 0x2);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 52, 0x0);
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 48, 0x1);
        ID_ISAR6_EL1 = __SetSlice_bits(32, 4, ID_ISAR6_EL1, 8, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 52, __GetSlice_int(4, __block_bbm_implemented, 0));
        if __crypto_sha512_implemented then {
            ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 12, 0x2)
        };
        if __crypto_sha3_implemented then {
            ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 32, 0x1)
        };
        if __crypto_sm3_implemented then {
            ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 36, 0x1)
        };
        if __crypto_sm4_implemented then {
            ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 40, 0x1)
        }
    };
    if HasArchVersion(ARMv8p5) then {
        ID_AA64ISAR0_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR0_EL1, 52, 0x2);
        ID_AA64ISAR1_EL1 = __SetSlice_bits(64, 4, ID_AA64ISAR1_EL1, 32, 0x1);
        ID_AA64PFR1_EL1 = __SetSlice_bits(32, 4, ID_AA64PFR1_EL1, 0, 0x1);
        ID_AA64MMFR2_EL1 = __SetSlice_bits(64, 4, ID_AA64MMFR2_EL1, 60, 0x1)
    };
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 18, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 17, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 16, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 15, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 14, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 13, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 12, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 11, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 10, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 9, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 8, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 7, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 3, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 2, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 1, 0b0);
    SCR_EL3 = __SetSlice_bits(32, 1, SCR_EL3, 0, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 31, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, if [HCR_EL2[34]] == 0 then 20 else 28, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 10, 0b0);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 8, 0b1);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, 31, 0b1);
    CPTR_EL2 = __SetSlice_bits(32, 1, CPTR_EL2, if [HCR_EL2[34]] == 0 then 20 else 28, 0b1);
    CPTR_EL2 = __SetSlice_bits(32, 2, CPTR_EL2, 20, 0b11);
    CPTR_EL2 = __SetSlice_bits(32, 2, CPTR_EL2, 16, 0b11);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 49, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 52, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 50, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 44, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 43, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 42, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 41, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 40, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 38, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 37, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 36, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 35, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 34, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 33, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 32, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 31, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 30, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 29, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 28, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 27, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 26, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 25, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 24, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 23, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 22, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 21, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 20, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 19, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 18, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 17, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 16, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 15, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 14, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 13, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 12, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 2, HCR_EL2, 10, 0b00);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 9, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 8, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 7, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 6, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 5, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 4, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 3, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 2, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 1, 0b0);
    HCR_EL2 = __SetSlice_bits(64, 1, HCR_EL2, 0, 0b0);
    HSTR_EL2 = __SetSlice_bits(32, 16, HSTR_EL2, 0, Zeros());
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 31, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 30, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 27, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 25, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 13, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 31, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 30, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 27, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 25, 0b0);
    SCTLR_EL2 = __SetSlice_bits(64, 1, SCTLR_EL2, 13, 0b0);
    CPACR_EL1 = __SetSlice_bits(32, 1, CPACR_EL1, 28, 0b0);
    CPACR_EL1 = __SetSlice_bits(32, 2, CPACR_EL1, 20, 0b00);
    CPACR_EL1 = __SetSlice_bits(32, 2, CPACR_EL1, 16, 0b00);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 31, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 30, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 27, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 25, 0b0);
    SCTLR_EL1 = __SetSlice_bits(64, 1, SCTLR_EL1, 13, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 31, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 30, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 27, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 25, 0b0);
    SCTLR_EL3 = __SetSlice_bits(64, 1, SCTLR_EL3, 13, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 1, MDCR_EL2, 14, 0b0);
    MDCR_EL2 = __SetSlice_bits(32, 2, MDCR_EL2, 12, 0b10);
    ICC_SRE_EL3 = __SetSlice_bits(32, 1, ICC_SRE_EL3, 0, 0b1);
    ICC_SRE_EL2 = __SetSlice_bits(32, 1, ICC_SRE_EL2, 0, 0b1);
    ICC_SRE_EL1_S = __SetSlice_bits(32, 1, ICC_SRE_EL1_S, 0, 0b1);
    ICC_SRE_EL1_NS = __SetSlice_bits(32, 1, ICC_SRE_EL1_NS, 0, 0b1);
    CTR_EL0 = __SetSlice_bits(64, 4, CTR_EL0, 20, __exclusive_granule_size);
    return()
}

val ResetControlRegisters : forall ('cold : Bool).
  bool('cold) -> unit effect {escape, rreg, undef, wreg}

function ResetControlRegisters cold = {
    if ~(HighestELUsingAArch32()) then {
        AArch64_AutoGen_ArchitectureReset(cold)
    } else {
        AArch32_AutoGen_ArchitectureReset(cold)
    };
    AArch32_IMPDEFResets();
    AArch64_IMPDEFResets();
    __Reset(cold);
    return()
}

val AArch64_ResetControlRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit effect {escape, rreg, undef, wreg}

function AArch64_ResetControlRegisters cold_reset = {
    ResetControlRegisters(cold_reset);
    //_TLB_Invalidate()
}

val AArch32_ResetControlRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit effect {escape, rreg, undef, wreg}

function AArch32_ResetControlRegisters cold_reset = {
    PSTATE.SS = 0b0;
    ResetControlRegisters(cold_reset);
    //_TLB_Invalidate()
}

val AArch64_ExecutingBTIInstr : unit -> bool effect {rreg, undef}

function AArch64_ExecutingBTIInstr () = {
    if ~(HaveBTIExt()) then {
        return(false)
    };
    let instr = ThisInstr();
    CRm : bits(4) = undefined : bits(4);
    op2 : bits(3) = undefined : bits(3);
    if (slice(instr, 22, 10) == 0b1101010100 & slice(instr, 12, 10) == 0b0000110010) & slice(instr, 0, 5) == 0b11111 then {
        CRm = slice(instr, 8, 4);
        op2 = slice(instr, 5, 3);
        return(CRm == 0x4 & [op2[0]] == 0b0)
    } else {
        return(false)
    }
}

val AArch64_ExecutingBROrBLROrRetInstr : unit -> bool effect {rreg, undef}

function AArch64_ExecutingBROrBLROrRetInstr () = {
    if ~(HaveBTIExt()) then {
        return(false)
    };
    let instr = ThisInstr();
    opc : bits(4) = undefined : bits(4);
    if slice(instr, 25, 7) == 0b1101011 & slice(instr, 16, 5) == 0b11111 then {
        opc = slice(instr, 21, 4);
        return(opc != 0x5)
    } else {
        return(false)
    }
}

val AArch64_EncodePAR : AddressDescriptor -> unit effect {escape, rreg, undef, wreg}

function AArch64_EncodePAR addrdesc = {
    par : bits(64) = undefined : bits(64);
    par = __GetSlice_int(64, 2048, 0);
    if ~(IsFault(addrdesc)) then {
        par = __SetSlice_bits(64, 1, par, 0, 0b0);
        par = __SetSlice_bits(64, 2, par, 7, PARShareabilityDecode(addrdesc.memattrs));
        par = __SetSlice_bits(64, 1, par, 9, addrdesc.paddress.NS);
        par = __SetSlice_bits(64, 40, par, 12, slice(addrdesc.paddress.address, 12, 40));
        par = __SetSlice_bits(64, 8, par, 56, PARAttrsDecode(addrdesc.memattrs))
    } else {
        par = __SetSlice_bits(64, 1, par, 0, 0b1);
        par = __SetSlice_bits(64, 6, par, 1, AArch64_PARFaultStatus(addrdesc.fault));
        par = __SetSlice_bits(64, 1, par, 8, if addrdesc.fault.s2fs1walk then 0b1 else 0b0);
        par = __SetSlice_bits(64, 1, par, 9, if addrdesc.fault.secondstage then 0b1 else 0b0)
    };
    PAR_EL1 = __SetSlice_bits(64, 64, PAR_EL1, 0, par)
}

val AArch64_ESBOperation : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_ESBOperation () = {
    let route_to_el3 = HaveEL(EL3) & [SCR_EL3[3]] == 0b1;
    let route_to_el2 = EL2Enabled() & ([HCR_EL2[27]] == 0b1 | [HCR_EL2[5]] == 0b1);
    let target : bits(2) = if route_to_el3 then EL3 else if route_to_el2 then EL2 else EL1;
    mask_active : bool = undefined : bool;
    if target == EL1 then {
        mask_active = PSTATE.EL == EL0 | PSTATE.EL == EL1
    } else {
        if (HaveVirtHostExt() & target == EL2) & (HCR_EL2[34 .. 34] @ HCR_EL2[27 .. 27]) == 0b11 then {
            mask_active = PSTATE.EL == EL0 | PSTATE.EL == EL2
        } else {
            mask_active = PSTATE.EL == target
        }
    };
    let mask_set = PSTATE.A == 0b1 & (((~(HaveDoubleFaultExt()) | [SCR_EL3[3]] == 0b0) | PSTATE.EL != EL3) | [SCR_EL3[20]] == 0b0);
    let intdis : bool = Halted() | ExternalDebugInterruptsDisabled(target);
    let masked : bool = (UInt(target) < UInt(PSTATE.EL) | intdis) | mask_active & mask_set;
    implicit_esb : bool = undefined : bool;
    syndrome32 : AArch32_SErrorSyndrome = undefined : AArch32_SErrorSyndrome;
    syndrome64 : bits(25) = undefined : bits(25);
    if IsPhysicalSErrorPending() & masked then {
        if ELUsingAArch32(S1TranslationRegime()) then {
            syndrome32 = AArch32_PhysicalSErrorSyndrome();
            set_DISR(AArch32_ReportDeferredSError(syndrome32.AET, syndrome32.ExT))
        } else {
            implicit_esb = false;
            syndrome64 = AArch64_PhysicalSErrorSyndrome(implicit_esb);
            DISR_EL1 = AArch64_ReportDeferredSError(syndrome64)
        };
        ClearPendingPhysicalSError()
    };
    return()
}

val AArch64_CheckUnallocatedSystemAccess : (bits(2), bits(2), bits(3), bits(4), bits(4), bits(3), bits(1)) -> bool effect {escape, rreg, undef}

function AArch64_CheckUnallocatedSystemAccess (el, op0, op1, crn, crm, op2, read) = {
    if (((((((op0 == 0b11 & crn == 0x4) & op1 == 0b011) & op2 == 0b001) & crm == 0x2) & PSTATE.EL == EL0) & ~(IsSecure())) & [HCR_EL2[34]] == 1) & [HCR_EL2[27]] == 1 then {
        return(false)
    };
    let allocated = AArch64_AutoGen_SysRegAlloc(el, op0, op1, crn, op2, crm, read);
    ~(allocated)
}

val branch_unconditional_immediate : (BranchType, bits(64)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_immediate (branch_type, offset) = {
    if branch_type == BranchType_DIRCALL then {
        X(30) = PC() + 4
    };
    BranchTo(PC() + offset, branch_type)
}

val branch_conditional_test : forall 'bit_pos 'datasize 't,
  ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('bit_pos), bits(1), int('datasize), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_test (bit_pos, bit_val, datasize, offset, t) = {
    let operand : bits('datasize) = X(t);
    if [operand[bit_pos]] == bit_val then {
        BranchTo(PC() + offset, BranchType_DIR)
    }
}

val branch_conditional_cond : (bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_cond (condition, offset) = {
    if ConditionHolds(condition) then {
        BranchTo(PC() + offset, BranchType_DIR)
    }
}

val branch_conditional_compare : forall 'datasize ('iszero : Bool) 't,
  ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), bool('iszero), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_compare (datasize, iszero, offset, t) = {
    let operand1 : bits('datasize) = X(t);
    if IsZero(operand1) == iszero then {
        BranchTo(PC() + offset, BranchType_DIR)
    }
}

val AArch64_TakeReset : bool -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakeReset cold_reset = {
    assert(~(HighestELUsingAArch32()));
    PSTATE.nRW = 0b0;
    if HaveEL(EL3) then {
        PSTATE.EL = EL3
    } else {
        if HaveEL(EL2) then {
            PSTATE.EL = EL2
        } else {
            PSTATE.EL = EL1
        }
    };
    AArch64_ResetControlRegisters(cold_reset);
    PSTATE.SP = 0b1;
    (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = 0xF;
    PSTATE.SS = 0b0;
    PSTATE.DIT = 0b0;
    PSTATE.IL = 0b0;
    //AArch64_ResetGeneralRegisters();
    AArch64_ResetSIMDFPRegisters();
    AArch64_ResetSpecialRegisters();
    ResetExternalDebugRegisters(cold_reset);
    rv : bits(64) = undefined : bits(64);
    if HaveEL(EL3) then {
        rv = RVBAR_EL3
    } else {
        if HaveEL(EL2) then {
            rv = RVBAR_EL2
        } else {
            rv = RVBAR_EL1
        }
    };
    let pa_max = PAMax();
    assert(64 - pa_max >= 0);
    assert(IsZero(slice(rv, pa_max, 64 - pa_max)) & IsZero(slice(rv, 0, 2)));
    BranchTo(rv, BranchType_RESET)
}

val TrapPACUse : bits(2) -> unit effect {escape, rreg, undef, wreg}

function TrapPACUse target_el = {
    assert((HaveEL(target_el) & target_el != EL0) & UInt(target_el) >= UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    exception : ExceptionRecord = undefined : ExceptionRecord;
    let vect_offset = 0;
    let exception = ExceptionSyndrome(Exception_PACTrap);
    AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
}

val Strip : (bits(64), bool) -> bits(64) effect {escape, rreg, undef, wreg}

function Strip (A, data) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    original_ptr : bits(64) = undefined : bits(64);
    extfield : bits(64) = undefined : bits(64);
    let tbi : bool = CalculateTBI(A, data);
    let bottom_PAC_bit : int = CalculateBottomPACBit([A[55]]);
    assert(negate(bottom_PAC_bit) + 56 >= 0 & bottom_PAC_bit >= 0);
    let extfield = replicate_bits([A[55]], 64);
    if tbi then {
        original_ptr = (slice(A, 56, 8) @ slice(extfield, 0, negate(bottom_PAC_bit) + 56)) @ slice(A, 0, bottom_PAC_bit)
    } else {
        original_ptr = slice(extfield, 0, negate(bottom_PAC_bit) + 64) @ slice(A, 0, bottom_PAC_bit)
    };
    match PSTATE.EL {
      ? if ? == EL0 => {
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if TrapEL2 then {
        TrapPACUse(EL2);
        Zeros()
    } else {
        if TrapEL3 then {
            TrapPACUse(EL3);
            Zeros()
        } else {
            return(original_ptr)
        }
    }
}

val integer_pac_strip_dp_1src : forall ('d : Int) ('data : Bool), ('d >= 0 & 'd <= 31).
  (int('d), bool('data)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_strip_dp_1src (d, data) = {
    if HavePACExt() then {
        X(d) = Strip(X(d), data)
    }
}

val AuthIB : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AuthIB (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APIBKey_EL1 : bits(128) = slice(APIBKeyHi_EL1, 0, 64) @ slice(APIBKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[30]] else [SCTLR_EL2[30]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[30]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[30]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[30]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros(64)
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros(64)
            } else {
                return(Auth(X, Y, APIBKey_EL1, false, 0b1))
            }
        }
    }
}

val integer_pac_autib_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autib_dp_1src (d, n, source_is_sp) = {
    if HavePACExt() then {
        if source_is_sp then {
            X(d) = AuthIB(X(d), SP())
        } else {
            X(d) = AuthIB(X(d), X(n))
        }
    }
}

val AuthIA : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AuthIA (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APIAKey_EL1 : bits(128) = slice(APIAKeyHi_EL1, 0, 64) @ slice(APIAKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[31]] else [SCTLR_EL2[31]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[31]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[31]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[31]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros(64)
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros(64)
            } else {
                return(Auth(X, Y, APIAKey_EL1, false, 0b0))
            }
        }
    }
}

val integer_pac_autia_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autia_dp_1src (d, n, source_is_sp) = {
    if HavePACExt() then {
        if source_is_sp then {
            X(d) = AuthIA(X(d), SP())
        } else {
            X(d) = AuthIA(X(d), X(n))
        }
    }
}

val branch_unconditional_register : forall 'm 'n ('pac : Bool) ('source_is_sp : Bool) ('use_key_a : Bool),
  ('n >= 0 & 'n <= 31) & ('m >= 0 & 'm <= 31 | not(not('source_is_sp)) | not('pac)).
  (BranchType, int('m), int('n), bool('pac), bool('source_is_sp), bool('use_key_a)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_register (branch_type, m, n, pac, source_is_sp, use_key_a) = {
    target : bits(64) = X(n);
    match branch_type {
      BranchType_INDIR => {
          if InGuardedPage then {
              if n == 16 | n == 17 then {
                  BTypeNext = 0b01
              } else {
                  BTypeNext = 0b11
              }
          } else {
              BTypeNext = 0b01
          }
      },
      BranchType_INDCALL => {
          BTypeNext = 0b10
      },
      BranchType_RET => {
          BTypeNext = 0b00
      }
    };
    if pac then {
        let modifier : bits(64) = if source_is_sp then SP() else X(m);
        if use_key_a then {
            target = AuthIA(target, modifier)
        } else {
            target = AuthIB(target, modifier)
        }
    };
    if branch_type == BranchType_INDCALL then {
        X(30) = PC() + 4
    };
    BranchTo(target, branch_type)
}

val AuthDB : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AuthDB (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APDBKey_EL1 : bits(128) = slice(APDBKeyHi_EL1, 0, 64) @ slice(APDBKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[13]] else [SCTLR_EL2[13]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[13]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[13]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[13]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros(64)
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros(64)
            } else {
                return(Auth(X, Y, APDBKey_EL1, true, 0b1))
            }
        }
    }
}

val integer_pac_autdb_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autdb_dp_1src (d, n, source_is_sp) = {
    if source_is_sp then {
        X(d) = AuthDB(X(d), SP())
    } else {
        X(d) = AuthDB(X(d), X(n))
    }
}

val AuthDA : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AuthDA (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APDAKey_EL1 : bits(128) = slice(APDAKeyHi_EL1, 0, 64) @ slice(APDAKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[27]] else [SCTLR_EL2[27]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[27]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[27]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[27]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros(64)
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros(64)
            } else {
                return(Auth(X, Y, APDAKey_EL1, true, 0b0))
            }
        }
    }
}

val integer_pac_autda_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autda_dp_1src (d, n, source_is_sp) = {
    if source_is_sp then {
        X(d) = AuthDA(X(d), SP())
    } else {
        X(d) = AuthDA(X(d), X(n))
    }
}

val AddPACIB : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPACIB (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APIBKey_EL1 : bits(128) = slice(APIBKeyHi_EL1, 0, 64) @ slice(APIBKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[30]] else [SCTLR_EL2[30]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[30]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[30]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[30]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros(64)
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros(64)
            } else {
                return(AddPAC(X, Y, APIBKey_EL1, false))
            }
        }
    }
}

val integer_pac_pacib_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacib_dp_1src (d, n, source_is_sp) = {
    if HavePACExt() then {
        if source_is_sp then {
            X(d) = AddPACIB(X(d), SP())
        } else {
            X(d) = AddPACIB(X(d), X(n))
        }
    }
}

val AddPACIA : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPACIA (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APIAKey_EL1 : bits(128) = slice(APIAKeyHi_EL1, 0, 64) @ slice(APIAKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[31]] else [SCTLR_EL2[31]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[31]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[31]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[31]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros()
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros()
            } else {
                return(AddPAC(X, Y, APIAKey_EL1, false))
            }
        }
    }
}

val integer_pac_pacia_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacia_dp_1src (d, n, source_is_sp) = {
    if HavePACExt() then {
        if source_is_sp then {
            X(d) = AddPACIA(X(d), SP())
        } else {
            X(d) = AddPACIA(X(d), X(n))
        }
    }
}

val AddPACGA : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPACGA (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    let APGAKey_EL1 : bits(128) = slice(APGAKeyHi_EL1, 0, 64) @ slice(APGAKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if TrapEL2 then {
        TrapPACUse(EL2);
        Zeros()
    } else {
        if TrapEL3 then {
            TrapPACUse(EL3);
            Zeros()
        } else {
            return(slice(ComputePAC(X, Y, slice(APGAKey_EL1, 64, 64), slice(APGAKey_EL1, 0, 64)), 32, 32) @ Zeros(32))
        }
    }
}

val integer_pac_pacga_dp_2src : forall 'd 'm 'n ('source_is_sp : Bool),
  ('n >= 0 & 'n <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))) & ('m >= 0 & 'm <= 31 | not(not('source_is_sp))) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))).
  (int('d), int('m), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacga_dp_2src (d, m, n, source_is_sp) = {
    if source_is_sp then {
        X(d) = AddPACGA(X(n), SP())
    } else {
        X(d) = AddPACGA(X(n), X(m))
    }
}

val AddPACDB : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPACDB (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APDBKey_EL1 : bits(128) = slice(APDBKeyHi_EL1, 0, 64) @ slice(APDBKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[13]] else [SCTLR_EL2[13]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[13]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[13]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[13]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros()
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros()
            } else {
                return(AddPAC(X, Y, APDBKey_EL1, true))
            }
        }
    }
}

val integer_pac_pacdb_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacdb_dp_1src (d, n, source_is_sp) = {
    if source_is_sp then {
        X(d) = AddPACDB(X(d), SP())
    } else {
        X(d) = AddPACDB(X(d), X(n))
    }
}

val AddPACDA : (bits(64), bits(64)) -> bits(64) effect {escape, rreg, undef, wreg}

function AddPACDA (X, Y) = {
    TrapEL2 : bool = undefined : bool;
    TrapEL3 : bool = undefined : bool;
    Enable : bits(1) = undefined : bits(1);
    let APDAKey_EL1 : bits(128) = slice(APDAKeyHi_EL1, 0, 64) @ slice(APDAKeyLo_EL1, 0, 64);
    match PSTATE.EL {
      ? if ? == EL0 => {
          let IsEL1Regime : bool = S1TranslationRegime() == EL1;
          Enable = if IsEL1Regime then [SCTLR_EL1[27]] else [SCTLR_EL2[27]];
          TrapEL2 = (EL2Enabled() & [HCR_EL2[41]] == 0b0) & ([HCR_EL2[27]] == 0b0 | [HCR_EL2[34]] == 0b0);
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL1 => {
          Enable = [SCTLR_EL1[27]];
          TrapEL2 = EL2Enabled() & [HCR_EL2[41]] == 0b0;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL2 => {
          Enable = [SCTLR_EL2[27]];
          TrapEL2 = false;
          TrapEL3 = HaveEL(EL3) & [SCR_EL3[17]] == 0b0
      },
      ? if ? == EL3 => {
          Enable = [SCTLR_EL3[27]];
          TrapEL2 = false;
          TrapEL3 = false
      }
    };
    if Enable == 0b0 then {
        return(X)
    } else {
        if TrapEL2 then {
            TrapPACUse(EL2);
            Zeros()
        } else {
            if TrapEL3 then {
                TrapPACUse(EL3);
                Zeros()
            } else {
                return(AddPAC(X, Y, APDAKey_EL1, true))
            }
        }
    }
}

val integer_pac_pacda_dp_1src : forall 'd 'n ('source_is_sp : Bool),
  ('d >= 0 & 'd <= 31 | not('source_is_sp)) & ('d >= 0 & 'd <= 31 | not(not('source_is_sp))) & ('n >= 0 & 'n <= 31 | not(not('source_is_sp))).
  (int('d), int('n), bool('source_is_sp)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacda_dp_1src (d, n, source_is_sp) = {
    if source_is_sp then {
        X(d) = AddPACDA(X(d), SP())
    } else {
        X(d) = AddPACDA(X(d), X(n))
    }
}

val AArch64_WFxTrap : forall ('is_wfe : Bool).
  (bits(2), bool('is_wfe)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_WFxTrap (target_el, is_wfe) = {
    assert(UInt(target_el) > UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_WFxTrap);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 5, __tc1, 20, ConditionSyndrome());
    exception.syndrome = __tc1;
    __tc2 : bits(25) = exception.syndrome;
    let __tc2 = __SetSlice_bits(25, 1, __tc2, 0, if is_wfe then 0b1 else 0b0);
    exception.syndrome = __tc2;
    if (target_el == EL1 & EL2Enabled()) & [HCR_EL2[27]] == 0b1 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CheckForWFxTrap : forall ('is_wfe : Bool).
  (bits(2), bool('is_wfe)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckForWFxTrap (target_el, is_wfe) = {
    assert(HaveEL(target_el));
    trap : bool = undefined : bool;
    match target_el {
      ? if ? == EL1 => {
          trap = (if is_wfe then [SCTLR()[18]] else [SCTLR()[16]]) == 0b0
      },
      ? if ? == EL2 => {
          trap = (if is_wfe then [HCR_EL2[14]] else [HCR_EL2[13]]) == 0b1
      },
      ? if ? == EL3 => {
          trap = (if is_wfe then [SCR_EL3[13]] else [SCR_EL3[12]]) == 0b1
      }
    };
    let trap = trap;
    if trap then {
        AArch64_WFxTrap(target_el, is_wfe)
    }
}

val system_hints : SystemHintOp -> unit effect {escape, rreg, undef, wreg}

function system_hints op = {
    match op {
      SystemHintOp_YIELD => {
          Hint_Yield()
      },
      SystemHintOp_WFE => {
          if IsEventRegisterSet() then {
              ClearEventRegister()
          } else {
              if PSTATE.EL == EL0 then {
                  AArch64_CheckForWFxTrap(EL1, true)
              };
              if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ~(IsInHost()) then {
                  AArch64_CheckForWFxTrap(EL2, true)
              };
              if HaveEL(EL3) & PSTATE.EL != EL3 then {
                  AArch64_CheckForWFxTrap(EL3, true)
              };
              WaitForEvent()
          }
      },
      SystemHintOp_WFI => {
          if ~(InterruptPending()) then {
              if PSTATE.EL == EL0 then {
                  AArch64_CheckForWFxTrap(EL1, false)
              };
              if (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ~(IsInHost()) then {
                  AArch64_CheckForWFxTrap(EL2, false)
              };
              if HaveEL(EL3) & PSTATE.EL != EL3 then {
                  AArch64_CheckForWFxTrap(EL3, false)
              };
              WaitForInterrupt()
          }
      },
      SystemHintOp_SEV => {
          SendEvent()
      },
      SystemHintOp_SEVL => {
          SendEventLocal()
      },
      SystemHintOp_ESB => {
          SynchronizeErrors();
          AArch64_ESBOperation();
          if EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1) then {
              AArch64_vESBOperation()
          };
          TakeUnmaskedSErrorInterrupts()
      },
      SystemHintOp_PSB => {
          ProfilingSynchronizationBarrier()
      },
      SystemHintOp_TSB => {
          TraceSynchronizationBarrier()
      },
      SystemHintOp_CSDB => {
          ConsumptionOfSpeculativeDataBarrier()
      },
      SystemHintOp_BTI => {
          BTypeNext = 0b00
      },
      _ => ()
    }
}

val AArch64_UndefinedFault : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_UndefinedFault () = {
    let route_to_el2 = (EL2Enabled() & PSTATE.EL == EL0) & [HCR_EL2[27]] == 0b1;
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset = 0;
    let exception = ExceptionSyndrome(Exception_Uncategorized);
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val AArch64_SystemRegisterTrap : (bits(2), bits(2), bits(3), bits(3), bits(4), bits(5), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SystemRegisterTrap (target_el, op0, op2, op1, crn, rt, crm, dir) = {
    assert(UInt(target_el) >= UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_SystemRegisterTrap);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 2, __tc1, 20, op0);
    exception.syndrome = __tc1;
    __tc2 : bits(25) = exception.syndrome;
    let __tc2 = __SetSlice_bits(25, 3, __tc2, 17, op2);
    exception.syndrome = __tc2;
    __tc3 : bits(25) = exception.syndrome;
    let __tc3 = __SetSlice_bits(25, 3, __tc3, 14, op1);
    exception.syndrome = __tc3;
    __tc4 : bits(25) = exception.syndrome;
    let __tc4 = __SetSlice_bits(25, 4, __tc4, 10, crn);
    exception.syndrome = __tc4;
    __tc5 : bits(25) = exception.syndrome;
    let __tc5 = __SetSlice_bits(25, 5, __tc5, 5, rt);
    exception.syndrome = __tc5;
    __tc6 : bits(25) = exception.syndrome;
    let __tc6 = __SetSlice_bits(25, 4, __tc6, 1, crm);
    exception.syndrome = __tc6;
    __tc7 : bits(25) = exception.syndrome;
    let __tc7 = __SetSlice_bits(25, 1, __tc7, 0, dir);
    exception.syndrome = __tc7;
    if (target_el == EL1 & EL2Enabled()) & [HCR_EL2[27]] == 0b1 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_SoftwareBreakpoint : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SoftwareBreakpoint immediate = {
    let route_to_el2 = (EL2Enabled() & (PSTATE.EL == EL0 | PSTATE.EL == EL1)) & ([HCR_EL2[27]] == 0b1 | [MDCR_EL2[8]] == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_SoftwareBreakpoint);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 16, __tc1, 0, immediate);
    exception.syndrome = __tc1;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val system_exceptions_debug_breakpoint : bits(16) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_debug_breakpoint comment = {
    AArch64_SoftwareBreakpoint(comment)
}

val AArch64_SPAlignmentFault : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_SPAlignmentFault () = {
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset = 0;
    let exception = ExceptionSyndrome(Exception_SPAlignment);
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if EL2Enabled() & [HCR_EL2[27]] == 0b1 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val CheckSPAlignment : unit -> unit effect {escape, rreg, undef, wreg}

function CheckSPAlignment () = {
    let sp : bits(64) = SP();
    stack_align_check : bool = undefined : bool;
    if PSTATE.EL == EL0 then {
        stack_align_check = [SCTLR()[4]] != 0b0
    } else {
        stack_align_check = [SCTLR()[3]] != 0b0
    };
    if stack_align_check & sp != Align(sp, 16) then {
        AArch64_SPAlignmentFault()
    };
    return()
}

val AArch64_CheckForSMCUndefOrTrap : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckForSMCUndefOrTrap imm = {
    route_to_el2 : bool = undefined : bool;
    route_to_el2 = (EL2Enabled() & PSTATE.EL == EL1) & [HCR_EL2[19]] == 0b1;
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    if ~(HaveEL(EL3)) then {
        if EL2Enabled() & PSTATE.EL == EL1 then {
            if (HaveNVExt() & [HCR_EL2[42]] == 0b1) & [HCR_EL2[19]] == 0b1 then {
                route_to_el2 = true
            } else {
                throw(Error_Undefined())
            }
        } else {
            throw(Error_Undefined())
        }
    } else {
        route_to_el2 = (EL2Enabled() & PSTATE.EL == EL1) & [HCR_EL2[19]] == 0b1
    };
    exception : ExceptionRecord = undefined : ExceptionRecord;
    vect_offset : int = undefined : int;
    if route_to_el2 then {
        let preferred_exception_return : bits(64) = ThisInstrAddr();
        vect_offset = 0;
        exception = ExceptionSyndrome(Exception_MonitorCall);
        __tc1 : bits(25) = exception.syndrome;
        __tc1 = __SetSlice_bits(25, 16, __tc1, 0, imm);
        exception.syndrome = __tc1;
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CheckForERetTrap : forall ('eret_with_pac : Bool) ('pac_uses_key_a : Bool).
  (bool('eret_with_pac), bool('pac_uses_key_a)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckForERetTrap (eret_with_pac, pac_uses_key_a) = {
    let route_to_el2 = ((HaveNVExt() & EL2Enabled()) & PSTATE.EL == EL1) & [HCR_EL2[42]] == 0b1;
    vect_offset : int = undefined : int;
    if route_to_el2 then {
        exception : ExceptionRecord = undefined : ExceptionRecord;
        let preferred_exception_return : bits(64) = ThisInstrAddr();
        vect_offset = 0;
        exception = ExceptionSyndrome(Exception_ERetTrap);
        if ~(eret_with_pac) then {
            __tc1 : bits(25) = exception.syndrome;
            __tc1 = __SetSlice_bits(25, 1, __tc1, 1, 0b0);
            exception.syndrome = __tc1;
            __tc2 : bits(25) = exception.syndrome;
            __tc2 = __SetSlice_bits(25, 1, __tc2, 0, 0b0);
            exception.syndrome = __tc2
        } else {
            __tc3 : bits(25) = exception.syndrome;
            __tc3 = __SetSlice_bits(25, 1, __tc3, 1, 0b1);
            exception.syndrome = __tc3;
            if pac_uses_key_a then {
                __tc4 : bits(25) = exception.syndrome;
                __tc4 = __SetSlice_bits(25, 1, __tc4, 0, 0b0);
                exception.syndrome = __tc4
            } else {
                __tc5 : bits(25) = exception.syndrome;
                __tc5 = __SetSlice_bits(25, 1, __tc5, 0, 0b1);
                exception.syndrome = __tc5
            }
        };
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CallSupervisor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CallSupervisor immediate = {
    if UsingAArch32() then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    let route_to_el2 = (EL2Enabled() & PSTATE.EL == EL0) & [HCR_EL2[27]] == 0b1;
    let preferred_exception_return : bits(64) = NextInstrAddr();
    let vect_offset = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_SupervisorCall);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 16, __tc1, 0, immediate);
    exception.syndrome = __tc1;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val system_exceptions_runtime_svc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_svc imm = {
    AArch64_CallSupervisor(imm)
}

val AArch64_CallSecureMonitor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CallSecureMonitor immediate = {
    assert(HaveEL(EL3) & ~(ELUsingAArch32(EL3)));
    if UsingAArch32() then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    let preferred_exception_return : bits(64) = NextInstrAddr();
    let vect_offset = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_MonitorCall);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 16, __tc1, 0, immediate);
    exception.syndrome = __tc1;
    AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
}

val system_exceptions_runtime_smc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_smc imm = {
    AArch64_CheckForSMCUndefOrTrap(imm);
    if [SCR_EL3[7]] == 0b1 then {
        AArch64_UndefinedFault()
    } else {
        AArch64_CallSecureMonitor(imm)
    }
}

val AArch64_CallHypervisor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CallHypervisor immediate = {
    assert(HaveEL(EL2));
    if UsingAArch32() then {
        AArch32_ITAdvance()
    };
    SSAdvance();
    let preferred_exception_return : bits(64) = NextInstrAddr();
    let vect_offset = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_HypervisorCall);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 16, __tc1, 0, immediate);
    exception.syndrome = __tc1;
    if PSTATE.EL == EL3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    }
}

val system_exceptions_runtime_hvc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_hvc imm = {
    if (~(HaveEL(EL2)) | PSTATE.EL == EL0) | PSTATE.EL == EL1 & ~(IsSecureEL2Enabled()) & IsSecure() then {
        throw(Error_Undefined())
    };
    let hvc_enable = if HaveEL(EL3) then [SCR_EL3[8]] else ~([HCR_EL2[29]]);
    if hvc_enable == 0b0 then {
        AArch64_UndefinedFault()
    } else {
        AArch64_CallHypervisor(imm)
    }
}

val AArch64_CheckAlignment : forall ('alignment : Int) ('iswrite : Bool).
  (bits(64), int('alignment), AccType, bool('iswrite)) -> bool effect {escape, rreg, undef, wreg}

function AArch64_CheckAlignment (address, alignment, acctype, iswrite) = {
    let aligned = address == Align(address, alignment);
    let atomic = acctype == AccType_ATOMIC | acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDATOMIC | acctype == AccType_ORDEREDATOMICRW;
    let ordered = acctype == AccType_ORDERED | acctype == AccType_ORDEREDRW | acctype == AccType_LIMITEDORDERED | acctype == AccType_ORDEREDATOMIC | acctype == AccType_ORDEREDATOMICRW;
    let vector_name = acctype == AccType_VEC;
    check : bool = undefined : bool;
    if [SCTLR()[1]] == 0b1 then {
        check = true
    } else {
        if HaveUA16Ext() then {
            check = UInt(slice(address, 0, 4)) + alignment > 16 & (ordered & [SCTLR()[6]] == 0b0 | atomic)
        } else {
            check = atomic | ordered
        }
    };
    secondstage : bool = undefined : bool;
    if check & ~(aligned) then {
        secondstage = false;
        AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
    };
    aligned
}

val AArch64_BranchTargetException : bits(52) -> unit effect {escape, rreg, undef, wreg}

function AArch64_BranchTargetException vaddress = {
    let route_to_el2 = (EL2Enabled() & PSTATE.EL == EL0) & [HCR_EL2[27]] == 0b1;
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset = 0;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    exception = ExceptionSyndrome(Exception_BranchTarget);
    __tc1 : bits(25) = exception.syndrome;
    let __tc1 = __SetSlice_bits(25, 2, __tc1, 0, PSTATE.BTYPE);
    exception.syndrome = __tc1;
    __tc2 : bits(25) = exception.syndrome;
    let __tc2 = __SetSlice_bits(25, 23, __tc2, 2, Zeros());
    exception.syndrome = __tc2;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else {
        if route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    }
}

val BranchTargetCheck : unit -> unit effect {escape, rreg, undef, wreg}

function BranchTargetCheck () = {
    assert(HaveBTIExt() & ~(UsingAArch32()));
    if ((InGuardedPage & PSTATE.BTYPE != 0b00) & ~(BTypeCompatible)) & ~(Halted()) then {
        let pc : bits(64) = ThisInstrAddr();
        AArch64_BranchTargetException(slice(pc, 0, 52))
    };
    let branch_instr = AArch64_ExecutingBROrBLROrRetInstr();
    let bti_instr = AArch64_ExecutingBTIInstr();
    if ~(branch_instr | bti_instr) then {
        BTypeNext = 0b00
    }
}

val __PostDecode : unit -> unit effect {escape, rreg, undef, wreg}

function __PostDecode () = {
    if HaveBTIExt() & ~(UsingAArch32()) then {
        BranchTargetCheck()
    }
}

val system_monitors_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function system_monitors_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    __PostDecode();
    system_monitors()
}

val system_hints_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function system_hints_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    op : SystemHintOp = undefined : SystemHintOp;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      [bitzero] @ [bitzero] @ [bitzero] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          throw(Error_See("PACIA1716, PACIB1716, AUTIA1716, AUTIB1716"))
      },
      0b0010000 => {
          if ~(HaveRASExt()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if ~(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_PSB
      },
      0b0010010 => {
          if ~(HaveSelfHostedTrace()) then {
              EndOfInstruction()
          };
          op = SystemHintOp_TSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ _ : bits(1) @ _ : bits(1) @ _ : bits(1) => {
          throw(Error_See("PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP"))
      },
      [bitzero] @ [bitone] @ [bitzero] @ [bitzero] @ _ : bits(1) @ _ : bits(1) @ [bitzero] => {
          op = SystemHintOp_BTI;
          BTypeCompatible = BTypeCompatible_BTI(slice(op2, 1, 2))
      },
      _ => {
          EndOfInstruction()
      }
    };
    __PostDecode();
    system_hints(op)
}

val system_exceptions_runtime_svc_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_svc_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    let imm = imm16;
    __PostDecode();
    system_exceptions_runtime_svc(imm)
}

val system_exceptions_runtime_smc_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_smc_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    let imm = imm16;
    __PostDecode();
    system_exceptions_runtime_smc(imm)
}

val system_exceptions_runtime_hvc_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_runtime_hvc_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    let imm = imm16;
    __PostDecode();
    system_exceptions_runtime_hvc(imm)
}

val system_exceptions_debug_breakpoint_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_debug_breakpoint_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    let comment = imm16;
    if HaveBTIExt() then {
        BTypeCompatible = true
    };
    __PostDecode();
    system_exceptions_debug_breakpoint(comment)
}

val system_barriers_decode : (bits(5), bits(2), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function system_barriers_decode (Rt, opc, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    op : MemBarrierOp = undefined : MemBarrierOp;
    domain : MBReqDomain = undefined : MBReqDomain;
    types : MBReqTypes = undefined : MBReqTypes;
    match opc {
      0b00 => {
          op = MemBarrierOp_DSB
      },
      0b01 => {
          op = MemBarrierOp_DMB
      },
      0b10 => {
          op = MemBarrierOp_ISB
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    match slice(CRm, 2, 2) {
      0b00 => {
          domain = MBReqDomain_OuterShareable
      },
      0b01 => {
          domain = MBReqDomain_Nonshareable
      },
      0b10 => {
          domain = MBReqDomain_InnerShareable
      },
      0b11 => {
          domain = MBReqDomain_FullSystem
      }
    };
    match slice(CRm, 0, 2) {
      0b01 => {
          types = MBReqTypes_Reads
      },
      0b10 => {
          types = MBReqTypes_Writes
      },
      0b11 => {
          types = MBReqTypes_All
      },
      _ => {
          if slice(CRm, 2, 2) == 0b01 then {
              op = MemBarrierOp_PSSBB
          } else {
              if slice(CRm, 2, 2) == 0b00 & opc == 0b00 then {
                  op = MemBarrierOp_SSBB
              } else {
                  types = MBReqTypes_All;
                  domain = MBReqDomain_FullSystem
              }
          }
      }
    };
    __PostDecode();
    system_barriers(domain, op, types)
}

val integer_tags_mcsubtag_decode : (bits(5), bits(5), bits(4), bits(2), bits(6)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcsubtag_decode (Xd, Xn, uimm4, op3, uimm6) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let tag_offset : bits(4) = uimm4;
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(ZeroExtend(uimm6, 64), log2_tag_granule);
    let ADD : bool = false;
    __PostDecode();
    integer_tags_mcsubtag(ADD, d, n, offset, tag_offset)
}

val integer_tags_mcinserttagmask_decode : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcinserttagmask_decode (Xd, Xn, Xm) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    __PostDecode();
    integer_tags_mcinserttagmask(d, m, n)
}

val integer_tags_mcinsertrandomtag_decode : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcinsertrandomtag_decode (Xd, Xn, Xm) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    __PostDecode();
    integer_tags_mcinsertrandomtag(d, m, n)
}

val integer_tags_mcaddtag_decode : (bits(5), bits(5), bits(4), bits(2), bits(6)) -> unit effect {escape, rreg, undef, wreg}

function integer_tags_mcaddtag_decode (Xd, Xn, uimm4, op3, uimm6) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let tag_offset : bits(4) = uimm4;
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(ZeroExtend(uimm6, 64), log2_tag_granule);
    let ADD : bool = true;
    __PostDecode();
    integer_tags_mcaddtag(ADD, d, n, offset, tag_offset)
}

val integer_shift_variable_decode : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_shift_variable_decode (Rd, Rn, op2, opcode2_5_2_, Rm, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let shift_type = DecodeShift(op2);
    __PostDecode();
    integer_shift_variable(d, datasize, m, n, shift_type)
}

val integer_pac_strip_hint_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_strip_hint_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    let 'd = 30;
    let data = false;
    __PostDecode();
    integer_pac_strip_dp_1src(d, data)
}

val integer_pac_strip_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_strip_dp_1src_decode (Rd, Rn, D, opcode2, S, sf) = {
    __unconditional = true;
    let data = D == 0b1;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if n != 31 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    integer_pac_strip_dp_1src(d, data)
}

val integer_pac_pacib_hint_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacib_hint_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    d : int = undefined : int;
    n : int = undefined : int;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011010 => {
          d = 30;
          n = 31
      },
      0b0011011 => {
          d = 30;
          source_is_sp = true;
          if HaveBTIExt() then {
              BTypeCompatible = BTypeCompatible_PACIXSP()
          }
      },
      0b0001010 => {
          d = 17;
          n = 16
      },
      0b0001000 => {
          throw(Error_See("PACIA"))
      },
      0b0001100 => {
          throw(Error_See("AUTIA"))
      },
      0b0001110 => {
          throw(Error_See("AUTIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("PACIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("AUTIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("AUTIB"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      }
    };
    __PostDecode();
    let 'n = n;
    let 'd = d;
    assert(constraint((0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31)));
    integer_pac_pacib_dp_1src(d, n, source_is_sp)
}

val integer_pac_pacib_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacib_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_pacib_dp_1src(d, n, source_is_sp)
}

val integer_pac_pacia_hint_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacia_hint_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    d : int = undefined : int;
    n : int = undefined : int;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011000 => {
          d = 30;
          n = 31
      },
      0b0011001 => {
          d = 30;
          source_is_sp = true;
          if HaveBTIExt() then {
              BTypeCompatible = BTypeCompatible_PACIXSP()
          }
      },
      0b0001000 => {
          d = 17;
          n = 16
      },
      0b0001010 => {
          throw(Error_See("PACIB"))
      },
      0b0001100 => {
          throw(Error_See("AUTIA"))
      },
      0b0001110 => {
          throw(Error_See("AUTIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("PACIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("AUTIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("AUTIB"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      }
    };
    __PostDecode();
    let 'd = d;
    let 'n = n;
    assert(constraint((0 <= 'd & 'd <= 31 & 0 <= 'n & 'n <= 31)));
    integer_pac_pacia_dp_1src(d, n, source_is_sp)
}

val integer_pac_pacia_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacia_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_pacia_dp_1src(d, n, source_is_sp)
}

val integer_pac_pacga_dp_2src_decode : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacga_dp_2src_decode (Rd, Rn, opcode2, Rm, S, op, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if m == 31 then {
        source_is_sp = true
    };
    __PostDecode();
    integer_pac_pacga_dp_2src(d, m, n, source_is_sp)
}

val integer_pac_pacdb_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacdb_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_pacdb_dp_1src(d, n, source_is_sp)
}

val integer_pac_pacda_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_pacda_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_pacda_dp_1src(d, n, source_is_sp)
}

val integer_pac_autib_hint_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autib_hint_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    d : int = undefined : int;
    n : int = undefined : int;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011110 => {
          d = 30;
          n = 31
      },
      0b0011111 => {
          d = 30;
          source_is_sp = true
      },
      0b0001110 => {
          d = 17;
          n = 16
      },
      0b0001000 => {
          throw(Error_See("PACIA"))
      },
      0b0001010 => {
          throw(Error_See("PACIB"))
      },
      0b0001100 => {
          throw(Error_See("AUTIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("PACIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("PACIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("AUTIA"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      }
    };
    __PostDecode();
    let 'd = d;
    let 'n = n;
    assert(constraint((0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31)));
    integer_pac_autib_dp_1src(d, n, source_is_sp)
}

val integer_pac_autib_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autib_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_autib_dp_1src(d, n, source_is_sp)
}

val integer_pac_autia_hint_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autia_hint_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    d : int = undefined : int;
    n : int = undefined : int;
    source_is_sp : bool = false;
    match CRm @ op2 {
      0b0011100 => {
          d = 30;
          n = 31
      },
      0b0011101 => {
          d = 30;
          source_is_sp = true
      },
      0b0001100 => {
          d = 17;
          n = 16
      },
      0b0001000 => {
          throw(Error_See("PACIA"))
      },
      0b0001010 => {
          throw(Error_See("PACIB"))
      },
      0b0001110 => {
          throw(Error_See("AUTIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitzero] @ _ : bits(1) => {
          throw(Error_See("PACIA"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitzero] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("PACIB"))
      },
      [bitzero] @ [bitzero] @ [bitone] @ [bitone] @ [bitone] @ [bitone] @ _ : bits(1) => {
          throw(Error_See("AUTIB"))
      },
      0b0000111 => {
          throw(Error_See("XPACLRI"))
      },
      _ => {
          throw(Error_See("HINT"))
      }
    };
    __PostDecode();
    let 'd = d;
    let 'n = n;
    assert(constraint((0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31)));
    integer_pac_autia_dp_1src(d, n, source_is_sp)
}

val integer_pac_autia_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autia_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_autia_dp_1src(d, n, source_is_sp)
}

val integer_pac_autdb_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autdb_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_autdb_dp_1src(d, n, source_is_sp)
}

val integer_pac_autda_dp_1src_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_pac_autda_dp_1src_decode (Rd, Rn, Z, opcode2, S, sf) = {
    __unconditional = true;
    source_is_sp : bool = false;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if ~(HavePACExt()) then {
        throw(Error_Undefined())
    };
    if Z == 0b0 then {
        if n == 31 then {
            source_is_sp = true
        }
    } else {
        if n != 31 then {
            throw(Error_Undefined())
        }
    };
    __PostDecode();
    integer_pac_autda_dp_1src(d, n, source_is_sp)
}

val integer_logical_shiftedreg_decode : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_logical_shiftedreg_decode (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined : bool;
    op : LogicalOp = undefined : LogicalOp;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert = N == 0b1;
    __PostDecode();
    integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

val integer_logical_immediate_decode : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_logical_immediate_decode (Rd, Rn, imms, immr, N, opc, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined : bool;
    op : LogicalOp = undefined : LogicalOp;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    imm : bits('datasize) = undefined : bits('datasize);
    if sf == 0b0 & N != 0b0 then {
        throw(Error_Undefined())
    };
    __anon1 : bits('datasize) = undefined : bits('datasize);
    (imm, __anon1) = DecodeBitMasks(N, imms, immr, true);
    __PostDecode();
    integer_logical_immediate(d, datasize, imm, n, op, setflags)
}

val integer_insext_insert_movewide_decode : (bits(5), bits(16), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_insext_insert_movewide_decode (Rd, imm16, hw, opc, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let imm = imm16;
    pos : int = undefined : int;
    opcode : MoveWideOp = undefined : MoveWideOp;
    match opc {
      0b00 => {
          opcode = MoveWideOp_N
      },
      0b10 => {
          opcode = MoveWideOp_Z
      },
      0b11 => {
          opcode = MoveWideOp_K
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let opcode = opcode;
    if sf == 0b0 & [hw[1]] == 0b1 then {
        throw(Error_Undefined())
    };
    let pos = UInt(hw @ 0x0);
    __PostDecode();
    integer_insext_insert_movewide(d, datasize, imm, opcode, pos)
}

val integer_insext_extract_immediate_decode : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_insext_extract_immediate_decode (Rd, Rn, imms, Rm, o0, N, op21, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    lsb : int = undefined : int;
    if N != sf then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & [imms[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let lsb = UInt(imms);
    __PostDecode();
    integer_insext_extract_immediate(d, datasize, lsb, m, n)
}

val integer_flags_xaflag_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function integer_flags_xaflag_decode CRm = {
    __unconditional = true;
    if ~(HaveFlagFormatExt()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    integer_flags_xaflag()
}

val integer_flags_setf_decode : (bits(4), bits(5), bits(4), bits(1), bits(6), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_flags_setf_decode (mask, Rn, opcode2, sz, imm6, sf) = {
    __unconditional = true;
    if ~(HaveFlagManipulateExt()) | sf != 0b0 then {
        throw(Error_Undefined())
    };
    let 'msb = if sz == 0b1 then 15 else 7;
    let 'n = UInt(Rn);
    __PostDecode();
    integer_flags_setf(msb, n)
}

val integer_flags_rmif_decode : (bits(4), bits(5), bits(6), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_flags_rmif_decode (mask, Rn, imm6, sf) = {
    __unconditional = true;
    if ~(HaveFlagManipulateExt()) | sf != 0b1 then {
        throw(Error_Undefined())
    };
    let 'lsb = UInt(imm6);
    let 'n = UInt(Rn);
    __PostDecode();
    integer_flags_rmif(lsb, mask, n)
}

val integer_flags_cfinv_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function integer_flags_cfinv_decode CRm = {
    __unconditional = true;
    if ~(HaveFlagManipulateExt()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    integer_flags_cfinv()
}

val integer_flags_axflag_decode : bits(4) -> unit effect {escape, rreg, undef, wreg}

function integer_flags_axflag_decode CRm = {
    __unconditional = true;
    if ~(HaveFlagFormatExt()) then {
        throw(Error_Undefined())
    };
    __PostDecode();
    integer_flags_axflag()
}

val integer_crc_decode : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_crc_decode (Rd, Rn, sz, C, opcode2_5_3_, Rm, S, op, sf) = {
    __unconditional = true;
    if ~(HaveCRCExt()) then {
        throw(Error_Undefined())
    };
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sf == 0b1 & sz != 0b11 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & sz == 0b11 then {
        throw(Error_Undefined())
    };
    let 'size = shl_int(8, UInt(sz));
    assert(constraint('size in {8, 16, 32, 64}));
    let crc32c : bool = C == 0b1;
    __PostDecode();
    integer_crc(crc32c, d, m, n, size)
}

val integer_conditional_select_decode : (bits(5), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_conditional_select_decode (Rd, Rn, o2, cond, Rm, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let condition = cond;
    let else_inv = op == 0b1;
    let else_inc = o2 == 0b1;
    __PostDecode();
    integer_conditional_select(condition, d, datasize, else_inc, else_inv, m, n)
}

val integer_conditional_compare_register_decode : (bits(4), bits(1), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_conditional_compare_register_decode (nzcv, o3, Rn, o2, cond, Rm, S, op, sf) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op = op == 0b1;
    let condition = cond;
    let flags = nzcv;
    __PostDecode();
    integer_conditional_compare_register(condition, datasize, flags, m, n, sub_op)
}

val integer_conditional_compare_immediate_decode : (bits(4), bits(1), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_conditional_compare_immediate_decode (nzcv, o3, Rn, o2, cond, imm5, S, op, sf) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op = op == 0b1;
    let condition = cond;
    let flags = nzcv;
    let imm : bits('datasize) = ZeroExtend(imm5, datasize);
    __PostDecode();
    integer_conditional_compare_immediate(condition, datasize, flags, imm, n, sub_op)
}

val integer_bitfield_decode : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_bitfield_decode (Rd, Rn, imms, immr, N, opc, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    inzero : bool = undefined : bool;
    extend : bool = undefined : bool;
    R : int = undefined : int;
    S : int = undefined : int;
    wmask : bits('datasize) = undefined : bits('datasize);
    tmask : bits('datasize) = undefined : bits('datasize);
    match opc {
      0b00 => {
          inzero = true;
          extend = true
      },
      0b01 => {
          inzero = false;
          extend = false
      },
      0b10 => {
          inzero = true;
          extend = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let extend = extend;
    let inzero = inzero;
    if sf == 0b1 & N != 0b1 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & ((N != 0b0 | [immr[5]] != 0b0) | [imms[5]] != 0b0) then {
        throw(Error_Undefined())
    };
    let R = UInt(immr);
    let S = UInt(imms);
    (wmask, tmask) = DecodeBitMasks(N, imms, immr, false);
    __PostDecode();
    integer_bitfield(R, S, d, datasize, extend, inzero, n, tmask, wmask)
}

val integer_arithmetic_rev_decode : (bits(5), bits(5), bits(2), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_rev_decode (Rd, Rn, opc, opcode2, S, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    container_size : int = undefined : int;
    match opc {
      0b00 => {
          Unreachable()
      },
      0b01 => {
          container_size = 16
      },
      0b10 => {
          container_size = 32
      },
      0b11 => {
          if sf == 0b0 then {
              throw(Error_Undefined())
          };
          container_size = 64
      }
    };
    __PostDecode();
    integer_arithmetic_rev(container_size, d, datasize, n)
}

val integer_arithmetic_rbit_decode : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_rbit_decode (Rd, Rn, opcode2, S, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    __PostDecode();
    integer_arithmetic_rbit(d, datasize, n)
}

val integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags_decode : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags_decode (Xd, Xn, Xm) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    let setflags = true;
    __PostDecode();
    integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags(d, m, n, setflags)
}

val integer_arithmetic_pointer_mcsubtracttaggedaddress_decode : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_pointer_mcsubtracttaggedaddress_decode (Xd, Xn, Xm) = {
    __unconditional = true;
    let 'd = UInt(Xd);
    let 'n = UInt(Xn);
    let 'm = UInt(Xm);
    let setflags = false;
    __PostDecode();
    integer_arithmetic_pointer_mcsubtracttaggedaddress(d, m, n, setflags)
}

val integer_arithmetic_mul_widening_64128hi_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_mul_widening_64128hi_decode (Rd, Rn, Ra, o0, Rm, U, op54, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = destsize;
    let unsigned = U == 0b1;
    __PostDecode();
    integer_arithmetic_mul_widening_64128hi(d, datasize, m, n, unsigned)
}

val integer_arithmetic_mul_widening_3264_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_mul_widening_3264_decode (Rd, Rn, Ra, o0, Rm, U, op54, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = 32;
    let sub_op = o0 == 0b1;
    let unsigned = U == 0b1;
    __PostDecode();
    integer_arithmetic_mul_widening_3264(a, d, datasize, destsize, m, n, sub_op, unsigned)
}

val integer_arithmetic_mul_uniform_addsub_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_mul_uniform_addsub_decode (Rd, Rn, Ra, o0, Rm, op31, op54, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = if sf == 0b1 then 64 else 32;
    let 'datasize = destsize;
    let sub_op = o0 == 0b1;
    __PostDecode();
    integer_arithmetic_mul_uniform_addsub(a, d, datasize, destsize, m, n, sub_op)
}

val integer_arithmetic_div_decode : (bits(5), bits(5), bits(1), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_div_decode (Rd, Rn, o1, opcode2_5_1_, Rm, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let unsigned = o1 == 0b0;
    __PostDecode();
    integer_arithmetic_div(d, datasize, m, n, unsigned)
}

val integer_arithmetic_cnt_decode : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_cnt_decode (Rd, Rn, op, opcode2, S, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let opcode = if op == 0b0 then CountOp_CLZ else CountOp_CLS;
    __PostDecode();
    integer_arithmetic_cnt(d, datasize, n, opcode)
}

val integer_arithmetic_address_pcrel_decode : (bits(5), bits(19), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_address_pcrel_decode (Rd, immhi, immlo, op) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let page = op == 0b1;
    imm : bits(64) = undefined : bits(64);
    if page then {
        imm = SignExtend((immhi @ immlo) @ Zeros(12), 64)
    } else {
        imm = SignExtend(immhi @ immlo, 64)
    };
    __PostDecode();
    integer_arithmetic_address_pcrel(d, imm, page)
}

val integer_arithmetic_addsub_shiftedreg_decode : (bits(5), bits(5), bits(6), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_shiftedreg_decode (Rd, Rn, imm6, Rm, shift, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op = op == 0b1;
    let setflags = S == 0b1;
    if shift == 0b11 then {
        throw(Error_Undefined())
    };
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    };
    let shift_type = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    __PostDecode();
    integer_arithmetic_addsub_shiftedreg(d, datasize, m, n, setflags, shift_amount, shift_type, sub_op)
}

val integer_arithmetic_addsub_extendedreg_decode : (bits(5), bits(5), bits(3), bits(3), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_extendedreg_decode (Rd, Rn, imm3, option_name, Rm, opt, S, op, sf) = {
    __unconditional = true;
    let d = UInt(Rd);
    let n = UInt(Rn);
    let m = UInt(Rm);
    let datasize : {|64, 32|} = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    };
    assert(shift <= 4);
    __PostDecode();
    integer_arithmetic_addsub_extendedreg(d, datasize, extend_type, m, n, setflags, shift, sub_op)
}

val integer_arithmetic_addsub_carry_decode : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_carry_decode (Rd, Rn, opcode2, Rm, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op = op == 0b1;
    let setflags = S == 0b1;
    __PostDecode();
    integer_arithmetic_addsub_carry(d, datasize, m, n, setflags, sub_op)
}

val branch_unconditional_register_decode : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_register_decode (Rm, Rn, M, A, op2, op, Z) = {
    __unconditional = true;
    n : int = UInt(Rn);
    branch_type : BranchType = undefined : BranchType;
    let 'm = UInt(Rm);
    let pac : bool = A == 0b1;
    let use_key_a : bool = M == 0b0;
    source_is_sp : bool = Z == 0b1 & m == 31;
    if ~(pac) & m != 0 then {
        throw(Error_Undefined())
    } else {
        if pac & ~(HavePACExt()) then {
            throw(Error_Undefined())
        }
    };
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    if pac then {
        if Z == 0b0 & m != 31 then {
            throw(Error_Undefined())
        };
        if branch_type == BranchType_RET then {
            if n != 31 then {
                throw(Error_Undefined())
            };
            n = 30;
            source_is_sp = true
        }
    };
    __PostDecode();
    let 'n = n;
    assert(constraint((0 <= 'n & 'n <= 31)));
    branch_unconditional_register(branch_type, m, n, pac, source_is_sp, use_key_a)
}

val branch_unconditional_immediate_decode : (bits(26), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_immediate_decode (imm26, op) = {
    __unconditional = true;
    let branch_type = if op == 0b1 then BranchType_DIRCALL else BranchType_DIR;
    let offset = SignExtend(imm26 @ 0b00, 64);
    __PostDecode();
    branch_unconditional_immediate(branch_type, offset)
}

val branch_conditional_test_decode : (bits(5), bits(14), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_test_decode (Rt, imm14, b40, op, b5) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'datasize = if b5 == 0b1 then 64 else 32;
    let 'bit_pos = UInt(b5 @ b40);
    let bit_val = op;
    let offset = SignExtend(imm14 @ 0b00, 64);
    __PostDecode();
    branch_conditional_test(bit_pos, bit_val, datasize, offset, t)
}

val branch_conditional_cond_decode : (bits(4), bits(1), bits(19), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_cond_decode (cond, o0, imm19, o1) = {
    __unconditional = true;
    let offset = SignExtend(imm19 @ 0b00, 64);
    let condition = cond;
    __PostDecode();
    branch_conditional_cond(condition, offset)
}

val branch_conditional_compare_decode : (bits(5), bits(19), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function branch_conditional_compare_decode (Rt, imm19, op, sf) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let iszero = op == 0b0;
    let offset = SignExtend(imm19 @ 0b00, 64);
    __PostDecode();
    branch_conditional_compare(datasize, iszero, offset, t)
}

val AArch64_AdvSIMDFPAccessTrap : bits(2) -> unit effect {escape, rreg, undef, wreg}

function AArch64_AdvSIMDFPAccessTrap target_el = {
    let preferred_exception_return : bits(64) = ThisInstrAddr();
    let vect_offset = 0;
    let route_to_el2 : bool = (target_el == EL1 & EL2Enabled()) & [HCR_EL2[27]] == 0b1;
    exception : ExceptionRecord = undefined : ExceptionRecord;
    if route_to_el2 then {
        exception = ExceptionSyndrome(Exception_Uncategorized);
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        exception = ExceptionSyndrome(Exception_AdvSIMDFPAccessTrap);
        __tc1 : bits(25) = exception.syndrome;
        __tc1 = __SetSlice_bits(25, 5, __tc1, 20, ConditionSyndrome());
        exception.syndrome = __tc1;
        AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
    };
    return()
}

val AArch64_CheckFPAdvSIMDTrap : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckFPAdvSIMDTrap () = {
    disabled : bool = undefined : bool;
    if EL2Enabled() then {
        if HaveVirtHostExt() & [HCR_EL2[34]] == 0b1 then {
            match slice(CPTR_EL2, 20, 2) {
              _ : bits(1) @ [bitzero] => {
                  disabled = ~(PSTATE.EL == EL1 & [HCR_EL2[27]] == 0b1)
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0 & [HCR_EL2[27]] == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            }
        } else {
            if [CPTR_EL2[10]] == 0b1 then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            }
        }
    };
    if HaveEL(EL3) then {
        if [CPTR_EL3[10]] == 0b1 then {
            AArch64_AdvSIMDFPAccessTrap(EL3)
        }
    };
    return()
}

val AArch64_CheckFPAdvSIMDEnabled : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckFPAdvSIMDEnabled () = {
    disabled : bool = undefined : bool;
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & ~(IsInHost()) then {
        match slice(CPACR(), 20, 2) {
          _ : bits(1) @ [bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = PSTATE.EL == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if disabled then {
            AArch64_AdvSIMDFPAccessTrap(EL1)
        }
    };
    AArch64_CheckFPAdvSIMDTrap()
}

val CheckFPAdvSIMDEnabled64 : unit -> unit effect {escape, rreg, undef, wreg}

function CheckFPAdvSIMDEnabled64 () = {
    AArch64_CheckFPAdvSIMDEnabled()
}

val AArch32_TakeReset : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit effect {escape, rreg, undef, wreg}

function AArch32_TakeReset cold_reset = {
    assert(HighestELUsingAArch32());
    if HaveEL(EL3) then {
        AArch32_WriteMode(M32_Svc);
        __tc1 : bits(32) = get_SCR();
        __tc1 = __SetSlice_bits(32, 1, __tc1, 0, 0b0);
        set_SCR(__tc1)
    } else {
        if HaveEL(EL2) then {
            AArch32_WriteMode(M32_Hyp)
        } else {
            AArch32_WriteMode(M32_Svc)
        }
    };
    AArch32_ResetControlRegisters(cold_reset);
    __tc2 : bits(32) = get_FPEXC();
    let __tc2 = __SetSlice_bits(32, 1, __tc2, 30, 0b0);
    set_FPEXC(__tc2);
    (PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b111;
    PSTATE.IT = 0x00;
    PSTATE.T = [get_SCTLR()[30]];
    PSTATE.E = [get_SCTLR()[25]];
    PSTATE.IL = 0b0;
    //AArch32_ResetGeneralRegisters();
    AArch32_ResetSIMDFPRegisters();
    AArch32_ResetSpecialRegisters();
    ResetExternalDebugRegisters(cold_reset);
    rv : bits(32) = undefined : bits(32);
    if HaveEL(EL3) then {
        if [MVBAR[0]] == 0b1 then {
            rv = slice(MVBAR, 1, 31) @ 0b0
        } else {
            rv = undefined
        }
    } else {
        rv = slice(RVBAR, 1, 31) @ 0b0
    };
    assert([rv[0]] == 0b0 & (PSTATE.T == 0b1 | [rv[1]] == 0b0));
    BranchTo(rv, BranchType_RESET)
}

val TakeReset : forall ('cold : Bool).
  bool('cold) -> unit effect {escape, rreg, undef, wreg}

function TakeReset cold = {
    assert(HighestEL() == EL1 | HighestEL() == EL2 | HighestEL() == EL3);
    EDSCR = __SetSlice_bits(32, 6, EDSCR, 0, 0b000010);
    if cold then {
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 12, CFG_ID_AA64PFR0_EL1_EL3);
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 8, CFG_ID_AA64PFR0_EL1_EL2);
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 4, CFG_ID_AA64PFR0_EL1_EL1);
        ID_AA64PFR0_EL1 = __SetSlice_bits(64, 4, ID_AA64PFR0_EL1, 0, CFG_ID_AA64PFR0_EL1_EL0);
        RMR_EL3 = __SetSlice_bits(32, 1, RMR_EL3, 0, CFG_RMR_AA64)
    };
    if [RMR_EL3[0]] == 0b1 then {
        __highest_el_aarch32 = false;
        SetResetVector(CFG_RVBAR);
        AArch64_TakeReset(cold)
    } else {
        match HighestEL() {
          ? if ? == EL3 => {
              assert(slice(ID_AA64PFR0_EL1, 12, 4) == 0x2)
          },
          ? if ? == EL2 => {
              assert(slice(ID_AA64PFR0_EL1, 8, 4) == 0x2)
          },
          ? if ? == EL1 => {
              assert(slice(ID_AA64PFR0_EL1, 4, 4) == 0x2)
          }
        };
        __highest_el_aarch32 = true;
        SetResetVector(CFG_RVBAR);
        AArch32_TakeReset(cold)
    }
}

val AArch64_AutoGen_SysRegTrapFP : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1)) -> (bool, bits(2)) effect {escape, rreg, undef}

function AArch64_AutoGen_SysRegTrapFP (el, op0, op1, CRn, op2, CRm, read) = {
    let ___ELUsingAArch32_EL2_ : bool = ~(ELUsingAArch32(EL2));
    let __HCR_EL2_E2H : bits(1) = [HCR_EL2[34]];
    let ___ELUsingAArch32_EL3_ : bool = ~(ELUsingAArch32(EL3));
    let __HCR_EL2_TGE : bits(1) = [HCR_EL2[27]];
    let __CPTR_EL2_FPEN : bits(2) = slice(CPTR_EL2, 20, 2);
    let __CPTR_EL3_TFP : bits(1) = [CPTR_EL3[10]];
    let __SCR_EL3_EEL2 : bits(1) = [SCR_EL3[18]];
    let __SCR_EL3_NS : bits(1) = [SCR_EL3[0]];
    let __HCR_EL2_TID3 : bits(1) = [HCR_EL2[18]];
    let __CPTR_EL2_TFP : bits(1) = [CPTR_EL2[10]];
    let __CPACR_EL1_FPEN : bits(2) = slice(CPACR_EL1, 20, 2);
    let __HCR_EL2_NV : bits(1) = [HCR_EL2[42]];
    if op0 == 0b11 then {
        if CRm == 0x3 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b010 then {
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                            return((true, EL2))
                        }
                    } else {
                        if op2 == 0b000 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                return((true, EL2))
                            }
                        } else {
                            if op2 == 0b001 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if op1 == 0b100 then {
                        if CRn == 0x5 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TFP == 1) & el == EL2 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0) & el == EL2 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0b10) & el == EL2 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0) & el == EL2 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0b10) & el == EL2 then {
                                return((true, EL2))
                            };
                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TFP == 1) & (el == EL2 | el == EL3) then {
                                return((true, EL3))
                            }
                        }
                    }
                }
            }
        } else {
            if CRm == 0x4 then {
                if CRn == 0x4 then {
                    if op1 == 0b011 then {
                        if op2 == 0b000 then {
                            if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & (el == EL0 | el == EL1) then {
                                return((true, EL1))
                            };
                            if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & (el == EL0 | el == EL1) then {
                                return((true, EL2))
                            };
                            if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b01) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                return((true, EL1))
                            };
                            if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b01) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                return((true, EL2))
                            };
                            if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b10) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & (el == EL0 | el == EL1) then {
                                return((true, EL1))
                            };
                            if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b10) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & (el == EL0 | el == EL1) then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TFP == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0) & (el == EL0 | el == EL1) then {
                                return((true, EL1))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0b01) & el == EL0 then {
                                return((true, EL1))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0b10) & (el == EL0 | el == EL1) then {
                                return((true, EL1))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0) & ((el == EL0 | el == EL1) | el == EL2) then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0b10) & ((el == EL0 | el == EL1) | el == EL2) then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0) & (el == EL0 | el == EL2) then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0b01) & el == EL0 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0b10) & (el == EL0 | el == EL2) then {
                                return((true, EL2))
                            };
                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TFP == 1) & (((el == EL0 | el == EL1) | el == EL2) | el == EL3) then {
                                return((true, EL3))
                            }
                        } else {
                            if op2 == 0b001 then {
                                if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & (el == EL0 | el == EL1) then {
                                    return((true, EL1))
                                };
                                if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & (el == EL0 | el == EL1) then {
                                    return((true, EL2))
                                };
                                if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b01) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                    return((true, EL1))
                                };
                                if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b01) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                    return((true, EL2))
                                };
                                if ((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b10) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & (el == EL0 | el == EL1) then {
                                    return((true, EL1))
                                };
                                if (((__HCR_EL2_E2H == 0 & __CPACR_EL1_FPEN == 0b10) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & (el == EL0 | el == EL1) then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TFP == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0) & (el == EL0 | el == EL1) then {
                                    return((true, EL1))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0b01) & el == EL0 then {
                                    return((true, EL1))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPACR_EL1_FPEN == 0b10) & (el == EL0 | el == EL1) then {
                                    return((true, EL1))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0) & ((el == EL0 | el == EL1) | el == EL2) then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_FPEN == 0b10) & ((el == EL0 | el == EL1) | el == EL2) then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0) & (el == EL0 | el == EL2) then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0b01) & el == EL0 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CPTR_EL2_FPEN == 0b10) & (el == EL0 | el == EL2) then {
                                    return((true, EL2))
                                };
                                if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TFP == 1) & (((el == EL0 | el == EL1) | el == EL2) | el == EL3) then {
                                    return((true, EL3))
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    return((false, EL0))
}

val AArch64_CheckAdvSIMDFPSystemRegisterTraps : (bits(2), bits(3), bits(4), bits(4), bits(3), bits(1)) -> (bool, bits(2)) effect {escape, rreg, undef}

function AArch64_CheckAdvSIMDFPSystemRegisterTraps (op0, op1, crn, crm, op2, read) = {
    target_el : bits(2) = undefined : bits(2);
    trap : bool = undefined : bool;
    (trap, target_el) = AArch64_AutoGen_SysRegTrapFP(PSTATE.EL, op0, op1, crn, op2, crm, read);
    return((trap, target_el))
}

val AArch64_AutoGen_SysRegTrap : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1)) -> (bool, bits(2)) effect {escape, rreg, undef}

function AArch64_AutoGen_SysRegTrap (el, op0, op1, CRn, op2, CRm, read) = {
    let __CNTHCTL_EL2_EL0PCTEN = [CNTHCTL_EL2[0]];
    let __HaveEL_EL3_ = HaveEL(EL3);
    let __HCR_EL2_EnSCXT = [HCR_EL2[53]];
    let __SCTLR_EL1_EnRCTX = [SCTLR_EL1[10]];
    let __MDCR_EL2_TPMCR = [MDCR_EL2[5]];
    let __ICC_SRE_EL2_SRE = [ICC_SRE_EL2[0]];
    let __EDSCR_TDA = [EDSCR[21]];
    let __MDCR_EL2_TDOSA = [MDCR_EL2[10]];
    let __CNTKCTL_EL1_EL0VTEN = [CNTKCTL_EL1[8]];
    let __CNTHCTL_EL2_EL0VCTEN = [CNTHCTL_EL2[1]];
    let __HCR_EL2_TACR = [HCR_EL2[21]];
    let __SCR_EL3_EnSCXT = [SCR_EL3[25]];
    let __MDCR_EL2_TTRF = [MDCR_EL2[19]];
    let __CNTKCTL_EL1_EL0PCTEN = [CNTKCTL_EL1[0]];
    let __SCTLR_EL2_EnRCTX = [SCTLR_EL2[10]];
    let __MPAM2_EL2_TRAPMPAM0EL1 = [MPAM2_EL2[49]];
    let __MDCR_EL3_TDA = [MDCR_EL3[9]];
    let __HCR_EL2_TID1 = [HCR_EL2[16]];
    let __HCR_EL2_TID2 = [HCR_EL2[17]];
    let __HCR_EL2_TID3 = [HCR_EL2[18]];
    let __MDCR_EL2_TPM = [MDCR_EL2[6]];
    let __CNTHCTL_EL2_EL1PCTEN = [CNTHCTL_EL2[if [HCR_EL2[34]] == 0 then 0 else 10]];
    let __MPAM2_EL2_TRAPMPAM1EL1 = [MPAM2_EL2[48]];
    let __SCR_EL3_TLOR = [SCR_EL3[14]];
    let __SCTLR___UCT = [SCTLR()[15]];
    let __SCTLR___UCI = [SCTLR()[26]];
    let __HCR_EL2_AT = [HCR_EL2[44]];
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __MDCR_EL3_TDOSA = [MDCR_EL3[10]];
    let __HCR_EL2_IMO = [HCR_EL2[4]];
    let __HCR_EL2_TRVM = [HCR_EL2[30]];
    let __HCR_EL2_NV = [HCR_EL2[42]];
    let __MDCR_EL2_TDA = [MDCR_EL2[9]];
    let __CNTHCTL_EL2_EL0VTEN = [CNTHCTL_EL2[8]];
    let __HCR_EL2_NV1 = [HCR_EL2[43]];
    let __HCR_EL2_NV2 = [HCR_EL2[45]];
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    let __MDCR_EL3_TPM = [MDCR_EL3[6]];
    let __SCTLR_EL1_UCI = [SCTLR_EL1[26]];
    let __SCR_EL3_NS = [SCR_EL3[0]];
    let __MDCR_EL2_TDRA = [MDCR_EL2[11]];
    let __HCR_EL2_TDZ = [HCR_EL2[28]];
    let __ICH_HCR_EL2_TC = [ICH_HCR_EL2[10]];
    let __ICC_SRE_EL1_SRE = [get_ICC_SRE_EL1()[0]];
    let __HCR_EL2_FMO = [HCR_EL2[3]];
    let __CNTKCTL_EL1_EL0VCTEN = [CNTKCTL_EL1[1]];
    let __SCR_EL3_IRQ = [SCR_EL3[1]];
    let __SCTLR_EL2_UCI = [SCTLR_EL2[26]];
    let __MPAMIDR_EL1_HAS_HCR = [MPAMIDR_EL1[17]];
    let __CNTKCTL_EL1_EL0PTEN = [CNTKCTL_EL1[9]];
    let ___ELUsingAArch32_EL3_ = ~(ELUsingAArch32(EL3));
    let __PMUSERENR_EL0_ER = [PMUSERENR_EL0[3]];
    let __PMUSERENR_EL0_EN = [PMUSERENR_EL0[0]];
    let __SCR_EL3_ST = [SCR_EL3[11]];
    let __CPTR_EL2_TCPAC = [CPTR_EL2[31]];
    let __MPAM3_EL3_TRAPLOWER = [MPAM3_EL3[62]];
    let __ICC_SRE_EL3_Enable = [ICC_SRE_EL3[3]];
    let __CNTHCTL_EL2_EL1PCEN = [CNTHCTL_EL2[1]];
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let __HCR_EL2_TVM = [HCR_EL2[26]];
    let __ICC_SRE_EL2_Enable = [ICC_SRE_EL2[3]];
    let __MPAMHCR_EL2_TRAP_MPAMIDR_EL1 = [MPAMHCR_EL2[31]];
    let __CNTHCTL_EL2_EL0PTEN = [CNTHCTL_EL2[9]];
    let __SCR_EL3_FIQ = [SCR_EL3[2]];
    let ___ELUsingAArch32_EL2_ = ~(ELUsingAArch32(EL2));
    let __SCTLR___DZE = [SCTLR()[14]];
    let __ICH_HCR_EL2_TDIR = [ICH_HCR_EL2[14]];
    let __HSTR_EL2_T12 = [HSTR_EL2[12]];
    let __CNTHCTL_EL2_EL1PTEN = [CNTHCTL_EL2[11]];
    let __OSLSR_EL1_OSLK = [OSLSR_EL1[1]];
    let __PMUSERENR_EL0_SW = [PMUSERENR_EL0[1]];
    let __HCR_EL2_TLOR = [HCR_EL2[35]];
    let __HCR_EL2_TSW = [HCR_EL2[22]];
    let __HCR_EL2_TTLB = [HCR_EL2[25]];
    let __HCR_EL2_APK = [HCR_EL2[40]];
    let __SCR_EL3_APK = [SCR_EL3[16]];
    let __SCTLR_EL1_UMA = [SCTLR_EL1[9]];
    let __PMUSERENR_EL0_CR = [PMUSERENR_EL0[2]];
    let __HaveEL_EL2_ = HaveEL(EL2);
    let __HCR_EL2_TPC = [HCR_EL2[23]];
    let __CPTR_EL3_TCPAC = [CPTR_EL3[31]];
    let __HCR_EL2_TPU = [HCR_EL2[24]];
    let __SCTLR___TSCXT = [SCTLR()[20]];
    let __ICC_SRE_EL3_SRE = [ICC_SRE_EL3[0]];
    let __MDSCR_EL1_TDCC = [MDSCR_EL1[12]];
    let __ICH_HCR_EL2_TALL0 = [ICH_HCR_EL2[11]];
    let __ICH_HCR_EL2_TALL1 = [ICH_HCR_EL2[12]];
    if (CRm & 0x0) == 0x0 then {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b101 then {
                        if ((__EDSCR_TDA == 1 & true) & __OSLSR_EL1_OSLK == 0) & (el == EL1 | el == EL2) then {
                            return((true, EL3))
                        };
                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                            return((true, EL3))
                        }
                    } else {
                        if op2 == 0b111 then {
                            if ((__EDSCR_TDA == 1 & true) & __OSLSR_EL1_OSLK == 0) & (el == EL1 | el == EL2) then {
                                return((true, EL3))
                            };
                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                return((true, EL3))
                            }
                        } else {
                            if op2 == 0b100 then {
                                if ((__EDSCR_TDA == 1 & true) & __OSLSR_EL1_OSLK == 0) & (el == EL1 | el == EL2) then {
                                    return((true, EL3))
                                };
                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                    return((true, EL3))
                                }
                            } else {
                                if op2 == 0b110 then {
                                    if ((__EDSCR_TDA == 1 & true) & __OSLSR_EL1_OSLK == 0) & (el == EL1 | el == EL2) then {
                                        return((true, EL3))
                                    };
                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                        return((true, EL3))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                            return((true, EL1))
                        };
                        if ((((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                            return((true, EL2))
                        };
                        if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                            return((true, EL1))
                        };
                        if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                            return((true, EL2))
                        };
                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                            return((true, EL3))
                        }
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                            return((true, EL1))
                        };
                        if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                            return((true, EL2))
                        };
                        if ((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                            return((true, EL2))
                        };
                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                            return((true, EL3))
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if op1 == 0b000 then {
                    if op0 == 0b11 then {
                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                            return((true, EL1))
                        };
                        if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                            return((true, EL2))
                        };
                        if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                            return((true, EL3))
                        };
                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1 then {
                            return((true, EL3))
                        };
                        if (___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2 then {
                            return((true, EL3))
                        };
                        if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1 then {
                            return((true, EL3))
                        };
                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                            return((true, EL1))
                        };
                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                            return((true, EL2))
                        };
                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                            return((true, EL2))
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if op0 == 0b11 then {
                if op1 == 0b100 then {
                    if CRm == 0x8 then {
                        if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                            return((true, EL2))
                        };
                        if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                            return((true, EL3))
                        };
                        if (((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV == 1) & el == EL1 then {
                            return((true, EL2))
                        }
                    } else {
                        if CRm == 0x9 then {
                            if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                return((true, EL2))
                            };
                            if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                return((true, EL3))
                            };
                            if (((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x9 then {
                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                return((true, EL1))
                            };
                            if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                return((true, EL2))
                            };
                            if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                return((true, EL3))
                            };
                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                return((true, EL3))
                            };
                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                return((true, EL3))
                            };
                            if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1 then {
                                return((true, EL3))
                            };
                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                return((true, EL1))
                            };
                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                return((true, EL2))
                            }
                        }
                    }
                }
            }
        }
    };
    if op0 == 0b11 then {
        if op1 == 0b000 then {
            if CRn == 0x0 then {
                if CRm == 0x1 then {
                    if op2 == 0b010 then {
                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                            return((true, EL2))
                        }
                    } else {
                        if op2 == 0b011 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                return((true, EL2))
                            }
                        } else {
                            if op2 == 0b000 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b111 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b001 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b110 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x2 then {
                        if op2 == 0b010 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                return((true, EL2))
                            }
                        } else {
                            if op2 == 0b011 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b000 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b101 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b000 then {
                            if CRm == 0x5 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRm == 0x4 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x6 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x7 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b001 then {
                                if CRm == 0x5 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x4 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x7 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b100 then {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b010 then {
                                        if CRm == 0x7 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if op2 == 0b110 then {
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if op2 == 0b101 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_TID3 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRn == 0x1 then {
                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x6 then {
                                    if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0xA then {
                            if CRm == 0x2 then {
                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRm == 0x5 then {
                                    if __MPAM3_EL3_TRAPLOWER == 1 & (el == EL1 | el == EL2) then {
                                        return((true, EL3))
                                    };
                                    if __MPAM2_EL2_TRAPMPAM1EL1 == 1 & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x4 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_TLOR == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x1 then {
                                if CRn == 0xE then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xC then {
                                    if CRm == 0x8 then {
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0xC then {
                                            if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if ((___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1) & read == 1 then {
                                                return((true, EL3))
                                            };
                                            if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0x5 then {
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x6 then {
                                                if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                    return((true, EL1))
                                                };
                                                if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                    return((true, EL2))
                                                };
                                                if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                    return((true, EL3))
                                                };
                                                if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                                    return((true, EL3))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                    return((true, EL3))
                                                };
                                                if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                    return((true, EL1))
                                                };
                                                if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if CRn == 0x6 then {
                                                    if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if CRm == 0x3 then {
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                            return((true, EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRn == 0xC then {
                        if CRm == 0xC then {
                            if op2 == 0b010 then {
                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                    return((true, EL1))
                                };
                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                    return((true, EL3))
                                };
                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 1 then {
                                    return((true, EL3))
                                };
                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2) & read == 1 then {
                                    return((true, EL3))
                                };
                                if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1) & read == 1 then {
                                    return((true, EL3))
                                };
                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                    return((true, EL1))
                                };
                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 1 then {
                                    return((true, EL2))
                                };
                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b011 then {
                                    if __ICC_SRE_EL1_SRE == 0 & (el == EL1 | el == EL1) then {
                                        throw(Error_Undefined())
                                    };
                                    if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                        return((true, EL2))
                                    };
                                    if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                        return((true, EL3))
                                    };
                                    if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                        return((true, EL3))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                        return((true, EL3))
                                    };
                                    if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1 then {
                                        return((true, EL3))
                                    };
                                    if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                        return((true, EL1))
                                    };
                                    if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b101 then {
                                        if (__HaveEL_EL3_ & __ICC_SRE_EL3_Enable == 0) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __HaveEL_EL2_) & __ICC_SRE_EL2_Enable == 0) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                return((true, EL1))
                                            };
                                            if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                return((true, EL2))
                                            };
                                            if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                return((true, EL3))
                                            };
                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                return((true, EL1))
                                            };
                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL1 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL1 == 1) & true) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                        return((true, EL1))
                                                    };
                                                    if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                        return((true, EL2))
                                                    };
                                                    if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                        return((true, EL3))
                                                    };
                                                    if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                        return((true, EL3))
                                                    };
                                                    if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                        return((true, EL1))
                                                    };
                                                    if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                            return((true, EL1))
                                                        };
                                                        if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                            return((true, EL2))
                                                        };
                                                        if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                            return((true, EL3))
                                                        };
                                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1 then {
                                                            return((true, EL3))
                                                        };
                                                        if (___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2 then {
                                                            return((true, EL3))
                                                        };
                                                        if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                            return((true, EL3))
                                                        };
                                                        if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                            return((true, EL1))
                                                        };
                                                        if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0xB then {
                                if op2 == 0b101 then {
                                    if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                        return((true, EL1))
                                    };
                                    if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                        return((true, EL3))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_FMO == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_IMO == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                        return((true, EL3))
                                    };
                                    if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                        return((true, EL3))
                                    };
                                    if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TC == 1) & true) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                return((true, EL1))
                                            };
                                            if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                                return((true, EL3))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_FMO == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_IMO == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                                return((true, EL3))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                                return((true, EL3))
                                            };
                                            if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TDIR == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TDIR == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b110 then {
                                                    if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                        return((true, EL1))
                                                    };
                                                    if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_FMO == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_IMO == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __ICH_HCR_EL2_TC == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & el == EL2) & read == 0 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __SCR_EL3_IRQ == 1) & __HCR_EL2_IMO == 0) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x8 then {
                                    if op2 == 0b010 then {
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1) & read == 1 then {
                                            return((true, EL3))
                                        };
                                        if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                return((true, EL1))
                                            };
                                            if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                return((true, EL2))
                                            };
                                            if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                return((true, EL3))
                                            };
                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if __ICC_SRE_EL1_SRE == 0 & el == EL1 then {
                                                return((true, EL1))
                                            };
                                            if (__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0) & __SCR_EL3_FIQ == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_FIQ == 1) & el == EL2) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if ((((___ELUsingAArch32_EL3_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __SCR_EL3_FIQ == 1) & __HCR_EL2_FMO == 0) & el == EL1) & read == 0 then {
                                                    return((true, EL3))
                                                };
                                                if (__ICC_SRE_EL1_SRE == 0 & el == EL1) & read == 0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __ICH_HCR_EL2_TALL0 == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 1) & __ICH_HCR_EL2_TALL0 == 1) & true) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b001 then {
                            if CRm == 0x0 then {
                                if CRn == 0x2 then {
                                    if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TACR == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TACR == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x5 then {
                                            if __MPAM3_EL3_TRAPLOWER == 1 & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            };
                                            if __MPAM2_EL2_TRAPMPAM0EL1 == 1 & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_TLOR == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x5 then {
                                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x1 then {
                                                    if (((__HaveEL_EL2_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __MDCR_EL2_TTRF == 1) & true) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__HaveEL_EL2_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __MDCR_EL2_TTRF == 1) & true) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x9 then {
                                                    if CRm == 0xE then {
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & (el == EL1 | el == EL2) then {
                                                            return((true, EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b010 then {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0x1 then {
                                            if ((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TCPAC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_TCPAC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TCPAC == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if ((true & ___ELUsingAArch32_EL3_) & __CPTR_EL3_TCPAC == 1) & el == EL1 then {
                                                return((true, EL3))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TCPAC == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x9 then {
                                            if CRm == 0xE then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if CRn == 0xA then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_TLOR == 1) & (el == EL1 | el == EL2) then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b011 then {
                                    if CRn == 0x2 then {
                                        if CRm == 0x2 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_APK == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_APK == 0) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if CRn == 0xA then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 1) & __SCR_EL3_TLOR == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x4 then {
                                            if op2 == 0b111 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TLOR == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __SCR_EL3_TLOR == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if (__MPAM3_EL3_TRAPLOWER == 1 & (el == EL2 | el == EL1)) & read == 1 then {
                                                        return((true, EL3))
                                                    };
                                                    if ((__MPAMIDR_EL1_HAS_HCR == 1 & __MPAMHCR_EL2_TRAP_MPAMIDR_EL1 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if op2 == 0b111 then {
                                                if CRn == 0xD then {
                                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if __HCR_EL2_EnSCXT == 0 & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (__HCR_EL2_EnSCXT == 1 & __SCR_EL3_EnSCXT == 0) & (el == EL1 | el == EL2) then {
                                                        return((true, EL3))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if __SCR_EL3_EnSCXT == 0 & el == EL2 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x9 then {
                                                if CRm == 0xE then {
                                                    if op2 == 0b110 then {
                                                        if ((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __MDCR_EL2_TPM == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (__HaveEL_EL3_ & __MDCR_EL3_TPM == 1) & (el == EL1 | el == EL2) then {
                                                            return((true, EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op1 == 0b100 then {
                if op2 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRn == 0x4 then {
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x3 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x6 then {
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x0 then {
                                                if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xE then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xA then {
                                if CRm == 0x2 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                            return((true, EL3))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xE then {
                                    if CRm == 0x2 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0xB then {
                                            if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                return((true, EL2))
                                            };
                                            if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                return((true, EL3))
                                            };
                                            if (((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRn == 0x5 then {
                                                if CRm == 0x2 then {
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0x2 then {
                                                            if (((((__HCR_EL2_NV2 == 0 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__HCR_EL2_NV2 == 0 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            if CRn == 0x5 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0x1 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & el == EL2 then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x4 then {
                                            if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                                    return((true, EL3))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x1 then {
                                                    if (((__HaveEL_EL2_ & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __HCR_EL2_NV == 1) & true) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b010 then {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & true) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0xD then {
                                                if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TCPAC == 1) & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if CRn == 0xA then {
                                                if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if (((((__HCR_EL2_NV2 == 0 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__HCR_EL2_NV2 == 0 & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0xB then {
                                                    if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b011 then {
                                if CRn == 0xC then {
                                    if CRm == 0xB then {
                                        if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                            return((true, EL3))
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0xE then {
                                            if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if CRn == 0xA then {
                                                    if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x6 then {
                                        if op2 == 0b101 then {
                                            if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                return((true, EL3))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                    return((true, EL3))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if __MPAM3_EL3_TRAPLOWER == 1 & el == EL2 then {
                                                            return((true, EL3))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if op2 == 0b101 then {
                                            if CRm == 0xB then {
                                                if (__ICC_SRE_EL2_SRE == 0 & el == EL2) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (__ICC_SRE_EL3_SRE == 0 & el == EL3) & read == 1 then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if CRm == 0x9 then {
                                                    if __ICC_SRE_EL3_Enable == 0 & el == EL2 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0xB then {
                                                if op2 == 0b111 then {
                                                    if __ICC_SRE_EL2_SRE == 0 & el == EL2 then {
                                                        return((true, EL2))
                                                    };
                                                    if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                        return((true, EL3))
                                                    };
                                                    if (((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0xD then {
                                                if op2 == 0b111 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if __SCR_EL3_EnSCXT == 0 & el == EL2 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            } else {
                                                if op2 == 0b101 then {
                                                    if CRn == 0x0 then {
                                                        if ((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__HCR_EL2_NV2 == 0 & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                } else {
                                                    if CRn == 0x6 then {
                                                        if op2 == 0b100 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if op2 == 0b111 then {
                                                    if CRn == 0x1 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op1 == 0b101 then {
                    if op2 == 0b000 then {
                        if CRm == 0x0 then {
                            if CRn == 0xC then {
                                if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRn == 0x4 then {
                                    if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x6 then {
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0xE then {
                                    if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0xE then {
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if CRn == 0x6 then {
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRn == 0xA then {
                                                if __MPAM3_EL3_TRAPLOWER == 1 & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                };
                                                if __MPAM2_EL2_TRAPMPAM1EL1 == 1 & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if CRn == 0xE then {
                                                if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b001 then {
                            if CRm == 0x0 then {
                                if CRn == 0x2 then {
                                    if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((true & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_NV1 == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0xD then {
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & __HaveEL_EL2_) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & __HCR_EL2_NV == 1) & (__HCR_EL2_NV1 == 1 | __HCR_EL2_NV2 == 0)) & true) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x3 then {
                                            if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x5 then {
                                                if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b010 then {
                                if CRm == 0x0 then {
                                    if CRn == 0x1 then {
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CPTR_EL2_TCPAC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CPTR_EL2_TCPAC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __CPTR_EL3_TCPAC == 1) & el == EL2 then {
                                            return((true, EL3))
                                        };
                                        if (((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & ___ELUsingAArch32_EL3_) & __CPTR_EL3_TCPAC == 1) & el == EL1 then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TVM == 1) & el == EL1) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if op2 == 0b111 then {
                                        if CRn == 0xD then {
                                            if ((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TRVM == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & true) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if __HCR_EL2_EnSCXT == 0 & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (__HCR_EL2_EnSCXT == 1 & __SCR_EL3_EnSCXT == 0) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if CRn == 0x9 then {
                            if CRm == 0xC then {
                                if op2 == 0b010 then {
                                    if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                        return((true, EL2))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if op2 == 0b000 then {
                                            if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPMCR == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if op2 == 0b101 then {
                                                if ((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if op2 == 0b111 then {
                                                    if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                        return((true, EL1))
                                                    };
                                                    if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                                        return((true, EL3))
                                                    }
                                                } else {
                                                    if op2 == 0b100 then {
                                                        if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_SW == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_SW == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 0 then {
                                                            return((true, EL3))
                                                        }
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                                return((true, EL1))
                                                            };
                                                            if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                                return((true, EL2))
                                                            };
                                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                                return((true, EL3))
                                                            }
                                                        } else {
                                                            if op2 == 0b110 then {
                                                                if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                                    return((true, EL1))
                                                                };
                                                                if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                                                    return((true, EL3))
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xD then {
                                    if op2 == 0b010 then {
                                        if (((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if ((((__PMUSERENR_EL0_EN == 0 & __PMUSERENR_EL0_ER == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                            return((true, EL1))
                                        };
                                        if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                            return((true, EL2))
                                        };
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if op2 == 0b000 then {
                                            if (((__PMUSERENR_EL0_CR == 0 & __PMUSERENR_EL0_EN == 0) & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if ((((__PMUSERENR_EL0_CR == 0 & __PMUSERENR_EL0_EN == 0) & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                                return((true, EL1))
                                            };
                                            if (((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0xE then {
                                        if op2 == 0b000 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if op2 == 0b011 then {
                                                if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if op2 == 0b010 then {
                                    if CRm == 0x2 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if ((__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                return((true, EL1))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if CRm == 0x2 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if (((__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PCTEN == 0) & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                    return((true, EL1))
                                                };
                                                if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PCTEN == 0) & __CNTKCTL_EL1_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                    return((true, EL1))
                                                };
                                                if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PCTEN == 0) & __CNTHCTL_EL2_EL0VCTEN == 0) & el == EL0) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b001 then {
                                            if CRm == 0x2 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((((__HCR_EL2_NV2 == 0 | __HCR_EL2_NV1 == 0) | __HCR_EL2_NV == 0) & true) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PTEN == 0) & __CNTKCTL_EL1_EL0PTEN == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PTEN == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PTEN == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x0 then {
                                                    if ((__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                                        return((true, EL1))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & __CNTKCTL_EL1_EL0PCTEN == 1) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTHCTL_EL2_EL1PCTEN == 0) & __CNTKCTL_EL1_EL0PCTEN == 1) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0PCTEN == 0) & el == EL0) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if (__HCR_EL2_E2H == 0 & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __CNTKCTL_EL1_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __CNTHCTL_EL2_EL0VTEN == 0) & el == EL0 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if CRm == 0xF then {
                                                    if (__PMUSERENR_EL0_EN == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((__PMUSERENR_EL0_EN == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TPM == 1) & (el == EL0 | el == EL1) then {
                                                        return((true, EL2))
                                                    };
                                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TPM == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if op2 == 0b111 then {
                                        if CRn == 0xD then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if __SCTLR___TSCXT == 1 & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if (__SCTLR___TSCXT == 0 & __HCR_EL2_EnSCXT == 0) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if ((__SCTLR___TSCXT == 0 & __HCR_EL2_EnSCXT == 1) & __SCR_EL3_EnSCXT == 0) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    } else {
                                        if op2 == 0b001 then {
                                            if CRn == 0x0 then {
                                                if ((__SCTLR___UCT == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                                    return((true, EL1))
                                                };
                                                if (((__SCTLR___UCT == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0x4 then {
                                            if op2 == 0b001 then {
                                                if (__SCR_EL3_NS == 0 & __SCTLR_EL1_UMA == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __SCTLR_EL1_UMA == 0) & ~(__HCR_EL2_E2H == 1 & __HCR_EL2_TGE == 1)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__SCR_EL3_NS == 1 & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x0 then {
                            if CRn == 0x0 then {
                                if op1 == 0b001 then {
                                    if op2 == 0b010 then {
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b000 then {
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID1 == 1) & el == EL1) & read == 1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b001 then {
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1) & read == 1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b010 then {
                                        if op2 == 0b000 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TID2 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TID2 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if op1 == 0b110 then {
                                    if CRm == 0xC then {
                                        if op2 == 0b101 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HSTR_EL2_T12 == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if __ICC_SRE_EL3_SRE == 0 & el == EL3 then {
                                                        return((true, EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        if op1 == 0b111 then {
                                            if op2 == 0b010 then {
                                                if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_ST == 0) & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                                    return((true, EL3))
                                                }
                                            } else {
                                                if op2 == 0b000 then {
                                                    if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_ST == 0) & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                                        return((true, EL3))
                                                    }
                                                } else {
                                                    if op2 == 0b001 then {
                                                        if (((___ELUsingAArch32_EL3_ & __SCR_EL3_NS == 0) & __SCR_EL3_ST == 0) & __SCR_EL3_EEL2 == 0) & el == EL1 then {
                                                            return((true, EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if op0 == 0b01 then {
            if CRn == 0x8 then {
                if op1 == 0b100 then {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            };
                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                return((true, EL2))
                            }
                        } else {
                            if CRm == 0x1 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x7 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b101 then {
                            if CRm == 0x0 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x6 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x7 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if CRm == 0x3 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x4 then {
                                if op2 == 0b010 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b110 then {
                                    if CRm == 0x0 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x7 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if CRm == 0x1 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x7 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b100 then {
                                            if CRm == 0x1 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x7 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x3 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b010 then {
                                                if CRm == 0x0 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x1 then {
                            if op2 == 0b010 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b001 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x3 then {
                                if op2 == 0b010 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b000 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b101 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b011 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b111 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b001 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x7 then {
                                    if op2 == 0b010 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b101 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b000 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b011 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b111 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if op2 == 0b101 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b011 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b111 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b001 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if op2 == 0b101 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b011 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b111 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if op2 == 0b101 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b011 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if op2 == 0b111 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        } else {
                                                            if op2 == 0b001 then {
                                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                    return((true, EL2))
                                                                };
                                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TTLB == 1) & el == EL1 then {
                                                                    return((true, EL2))
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if CRn == 0x7 then {
                    if op1 == 0b000 then {
                        if CRm == 0x6 then {
                            if op2 == 0b010 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                    return((true, EL2))
                                };
                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b001 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b110 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b000 then {
                                if CRm == 0x8 then {
                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0x5 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x9 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b010 then {
                                    if CRm == 0x8 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0xA then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0xE then {
                                        if op2 == 0b100 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b110 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0xA then {
                                            if op2 == 0b100 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b110 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TSW == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x8 then {
                                                if op2 == 0b011 then {
                                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b001 then {
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            } else {
                                                if op2 == 0b001 then {
                                                    if CRm == 0x9 then {
                                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_AT == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b011 then {
                            if op2 == 0b001 then {
                                if CRm == 0xE then {
                                    if (__SCTLR___UCI == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((__SCTLR___UCI == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                        return((true, EL2))
                                    };
                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                } else {
                                    if CRm == 0xA then {
                                        if (__SCTLR___UCI == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if ((__SCTLR___UCI == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0xD then {
                                            if __SCTLR___UCI == 0 & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if (__SCTLR___UCI == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((__SCTLR___UCI == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0xB then {
                                                    if (__SCTLR___UCI == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((__SCTLR___UCI == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPU == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPU == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x4 then {
                                                        if (__SCTLR___DZE == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((__SCTLR___DZE == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if CRm == 0xC then {
                                                            if (__SCTLR___UCI == 0 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                                return((true, EL1))
                                                            };
                                                            if ((__SCTLR___UCI == 0 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b011 then {
                                    if CRm == 0xA then {
                                        if __SCTLR___UCI == 0 & el == EL0 then {
                                            return((true, EL1))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if __SCTLR___DZE == 0 & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if __SCTLR___UCI == 0 & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0xC then {
                                                    if __SCTLR___UCI == 0 & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b101 then {
                                        if CRm == 0xA then {
                                            if __SCTLR___UCI == 0 & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0 | __HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0) & __SCTLR_EL1_EnRCTX == 0) & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_EnRCTX == 0) & el == EL0 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0xE then {
                                                    if __SCTLR___UCI == 0 & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if CRm == 0xC then {
                                                        if __SCTLR___UCI == 0 & el == EL0 then {
                                                            return((true, EL1))
                                                        };
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if ((((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TPC == 1) & __SCTLR_EL1_UCI == 1) & el == EL0 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_UCI == 0) & el == EL0 then {
                                                            return((true, EL2))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b100 then {
                                            if CRm == 0x4 then {
                                                if __SCTLR___DZE == 0 & el == EL0 then {
                                                    return((true, EL1))
                                                };
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_TDZ == 1) & (el == EL0 | el == EL1) then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if ((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0 | __HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0) & __SCTLR_EL1_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if CRm == 0x3 then {
                                                    if ((__SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0 | __HCR_EL2_E2H == 0 | __HCR_EL2_TGE == 0) & __SCTLR_EL1_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL1))
                                                    };
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & __SCTLR_EL2_EnRCTX == 0) & el == EL0 then {
                                                        return((true, EL2))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b100 then {
                                if CRm == 0x8 then {
                                    if op2 == 0b000 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        }
                                    } else {
                                        if op2 == 0b101 then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                return((true, EL2))
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                }
                                            } else {
                                                if op2 == 0b001 then {
                                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    };
                                                    if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                        return((true, EL2))
                                                    }
                                                } else {
                                                    if op2 == 0b100 then {
                                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        };
                                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                            return((true, EL2))
                                                        }
                                                    } else {
                                                        if op2 == 0b110 then {
                                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            };
                                                            if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                                                return((true, EL2))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op0 == 0b10 then {
                if op1 == 0b000 then {
                    if CRn == 0x1 then {
                        if op2 == 0b100 then {
                            if CRm == 0x0 then {
                                if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDOSA == 1) & el == EL1) & read == 0 then {
                                    return((true, EL2))
                                };
                                if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2)) & read == 0 then {
                                    return((true, EL3))
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDOSA == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x4 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDOSA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x3 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDOSA == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDOSA == 1) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if op2 == 0b000 then {
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDRA == 1) & el == EL1) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                        return((true, EL3))
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0x0 then {
                            if op2 == 0b010 then {
                                if CRm == 0x2 then {
                                    if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                        return((true, EL2))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & el == EL2 then {
                                        return((true, EL3))
                                    };
                                    if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & el == EL1 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if op2 == 0b000 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x7 then {
                                if op2 == 0b110 then {
                                    if CRm == 0x8 then {
                                        if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0xE then {
                                            if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1) & read == 1 then {
                                                return((true, EL2))
                                            };
                                            if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2)) & read == 1 then {
                                                return((true, EL3))
                                            }
                                        } else {
                                            if CRm == 0x9 then {
                                                if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & el == EL1 then {
                                                    return((true, EL2))
                                                };
                                                if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & (el == EL1 | el == EL2) then {
                                                    return((true, EL3))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b000 then {
                        if CRn == 0x0 then {
                            if op1 == 0b011 then {
                                if CRm == 0x5 then {
                                    if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                        return((true, EL1))
                                    };
                                    if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                        return((true, EL3))
                                    };
                                    if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 0 then {
                                        return((true, EL1))
                                    };
                                    if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1)) & read == 0 then {
                                        return((true, EL2))
                                    };
                                    if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 0 then {
                                        return((true, EL3))
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if ((__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0) & read == 1 then {
                                            return((true, EL1))
                                        };
                                        if (((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1)) & read == 1 then {
                                            return((true, EL2))
                                        };
                                        if ((___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2)) & read == 1 then {
                                            return((true, EL3))
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if (__MDSCR_EL1_TDCC == 1 & (__HCR_EL2_TGE == 0 | __SCR_EL3_NS == 0 & __SCR_EL3_EEL2 == 0)) & el == EL0 then {
                                                return((true, EL1))
                                            };
                                            if ((__MDSCR_EL1_TDCC == 1 & __HCR_EL2_TGE == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) & el == EL0 then {
                                                return((true, EL2))
                                            };
                                            if (((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __MDCR_EL2_TDA == 1) & (el == EL0 | el == EL1) then {
                                                return((true, EL2))
                                            };
                                            if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & ((el == EL0 | el == EL1) | el == EL2) then {
                                                return((true, EL3))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b100 then {
                                    if CRm == 0x7 then {
                                        if ((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (((((__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) & ___ELUsingAArch32_EL2_) & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_NV == 1) & el == EL1 then {
                                            return((true, EL2))
                                        };
                                        if (___ELUsingAArch32_EL3_ & __MDCR_EL3_TDA == 1) & el == EL2 then {
                                            return((true, EL3))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op0 == 0b00 then {
                    if CRn == 0x4 then {
                        if op1 == 0b011 then {
                            if op2 == 0b111 then {
                                if (__SCR_EL3_NS == 0 & __SCTLR_EL1_UMA == 0) & el == EL0 then {
                                    return((true, EL1))
                                };
                                if ((__SCR_EL3_NS == 1 & __SCTLR_EL1_UMA == 0) & ~(__HCR_EL2_E2H == 1 & __HCR_EL2_TGE == 1)) & el == EL0 then {
                                    return((true, EL1))
                                };
                                if ((__SCR_EL3_NS == 1 & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & el == EL0 then {
                                    return((true, EL2))
                                }
                            } else {
                                if op2 == 0b110 then {
                                    if (__SCR_EL3_NS == 0 & __SCTLR_EL1_UMA == 0) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __SCTLR_EL1_UMA == 0) & ~(__HCR_EL2_E2H == 1 & __HCR_EL2_TGE == 1)) & el == EL0 then {
                                        return((true, EL1))
                                    };
                                    if ((__SCR_EL3_NS == 1 & __HCR_EL2_E2H == 1) & __HCR_EL2_TGE == 1) & el == EL0 then {
                                        return((true, EL2))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    return((false, EL0))
}

val AArch64_CheckSystemRegisterTraps : (bits(2), bits(3), bits(4), bits(4), bits(3), bits(1)) -> (bool, bits(2)) effect {escape, rreg, undef}

function AArch64_CheckSystemRegisterTraps (op0, op1, crn, crm, op2, read) = {
    target_el : bits(2) = undefined : bits(2);
    trap : bool = undefined : bool;
    (trap, target_el) = AArch64_AutoGen_SysRegTrap(PSTATE.EL, op0, op1, crn, op2, crm, read);
    return((trap, target_el))
}

val AArch64_CheckSystemAccess : (bits(2), bits(3), bits(4), bits(4), bits(3), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckSystemAccess (op0, op1, crn, crm, op2, rt, read) = {
    let unallocated = false;
    need_secure : bool = false;
    min_EL : bits(2) = undefined : bits(2);
    if HaveBTIExt() then {
        BranchTargetCheck()
    };
    rcs_el0_trap : bool = undefined : bool;
    if ((((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & [HCR_EL2[20]] == 1) & (op0 & 0b01) == 0b01) & (crn & 0xB) == 0xB then {
        rcs_el0_trap = __IMPDEF_boolean("Reserved Control Space EL0 Trapped");
        if PSTATE.EL == EL1 | rcs_el0_trap then {
            AArch64_SystemRegisterTrap(EL2, op0, op2, op1, crn, rt, crm, read)
        }
    };
    match op1 {
      [bitzero] @ [bitzero] @ _ : bits(1) => {
          min_EL = EL1
      },
      0b010 => {
          min_EL = EL1
      },
      0b011 => {
          min_EL = EL0
      },
      0b100 => {
          min_EL = EL2
      },
      0b101 => {
          if ~(HaveVirtHostExt()) then {
              throw(Error_Undefined())
          };
          min_EL = EL2
      },
      0b110 => {
          min_EL = EL3
      },
      0b111 => {
          min_EL = EL1;
          need_secure = true
      }
    };
    let min_EL = min_EL;
    nv_access : bool = undefined : bool;
    if UInt(PSTATE.EL) < UInt(min_EL) then {
        nv_access = (((HaveNVExt() & min_EL == EL2) & PSTATE.EL == EL1) & EL2Enabled()) & [HCR_EL2[42]] == 0b1;
        if ~(nv_access) then {
            throw(Error_Undefined())
        }
    } else {
        if need_secure & ~(IsSecure()) then {
            throw(Error_Undefined())
        } else {
            if AArch64_CheckUnallocatedSystemAccess(PSTATE.EL, op0, op1, crn, crm, op2, read) then {
                throw(Error_Undefined())
            }
        }
    };
    take_trap : bool = undefined : bool;
    target_el : bits(2) = undefined : bits(2);
    (take_trap, target_el) = AArch64_CheckAdvSIMDFPSystemRegisterTraps(op0, op1, crn, crm, op2, read);
    if take_trap then {
        AArch64_AdvSIMDFPAccessTrap(target_el)
    };
    (take_trap, target_el) = AArch64_CheckSystemRegisterTraps(op0, op1, crn, crm, op2, read);
    if take_trap then {
        AArch64_SystemRegisterTrap(target_el, op0, op2, op1, crn, rt, crm, read)
    }
}

val system_register_cpsr_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function system_register_cpsr_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    if op1 == 0b000 & op2 == 0b000 then {
        throw(Error_See("CFINV"))
    };
    if op1 == 0b000 & op2 == 0b001 then {
        throw(Error_See("XAFlag"))
    };
    if op1 == 0b000 & op2 == 0b010 then {
        throw(Error_See("AXFlag"))
    };
    AArch64_CheckSystemAccess(0b00, op1, 0x4, CRm, op2, 0b11111, 0b0);
    let operand = CRm;
    field : PSTATEField = undefined : PSTATEField;
    match op1 @ op2 {
      0b000011 => {
          if ~(HaveUAOExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_UAO
      },
      0b000100 => {
          if ~(HavePANExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_PAN
      },
      0b000101 => {
          field = PSTATEField_SP
      },
      0b011010 => {
          if ~(HaveDITExt()) then {
              throw(Error_Undefined())
          };
          field = PSTATEField_DIT
      },
      0b011110 => {
          field = PSTATEField_DAIFSet
      },
      0b011111 => {
          field = PSTATEField_DAIFClr
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let field = field;
    if (op1 == 0b011 & PSTATE.EL == EL0) & (IsInHost() | [SCTLR_EL1[9]] == 0b0) then {
        AArch64_SystemRegisterTrap(EL1, 0b00, op2, op1, 0x4, 0b11111, CRm, 0b0)
    };
    __PostDecode();
    system_register_cpsr(field, operand)
}

val check_access_z : forall ('iswrite : Bool).
  (bits(64), bool('iswrite)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function check_access_z (val_name, iswrite) = {
    let 'size = 4 * 2 ^ UInt(slice(DCZID_EL0, 0, 4));
    let vaddress : bits(64) = Align(val_name, size);
    let memaddrdesc : AddressDescriptor = AArch64_FullTranslate(vaddress, AccType_DCZVA, iswrite, true, 1);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(val_name, memaddrdesc.fault)
    }
}

val aset_MemTag : (bits(64), bits(4)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_MemTag (address, value_name) = {
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    let iswrite = true;
    if address != Align(address, TAG_GRANULE) then {
        let secondstage = false;
        AArch64_Abort(address, AArch64_AlignmentFault(AccType_NORMAL, iswrite, secondstage))
    };
    let wasaligned = true;
    let memaddrdesc = AArch64_TranslateAddress(address, AccType_NORMAL, iswrite, wasaligned, TAG_GRANULE);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if AllocationTagAccessIsEnabled() then {
        _MemTag(memaddrdesc) = value_name
    }
}

overload MemTag = {aset_MemTag}

val integer_tags_mcsettagarray : forall 'n 't,
  ('t >= 0 & 't <= 31) & ('n >= 0 & 'n <= 31 | not(not('n == 31))).
  (int('n), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagarray (n, t) = {
    let data : bits(64) = X(t);
    address : bits(64) = undefined : bits(64);
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    count : int = undefined : int;
    (address, count) = ImpDefTagArrayStartAndCount(address);
    foreach (i from 0 to (count - 1) by 1 in inc) {
        let 'index = UInt(slice(address, LOG2_TAG_GRANULE, 4));
        let tag : bits(4) = slice(data, index * 4, 4);
        MemTag(address) = tag;
        address = address + TAG_GRANULE
    };
    if n == 31 then {
        SP() = address
    } else {
        X(n) = address
    }
}

val integer_tags_mcsettagarray_decode : (bits(5), bits(5)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagarray_decode (Xt, Xn) = {
    __unconditional = true;
    let 't = UInt(Xt);
    let 'n = UInt(Xn);
    __PostDecode();
    integer_tags_mcsettagarray(n, t)
}

val integer_tags_mcgettag : forall 'n 't,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcgettag (n, offset, t) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    address = address + offset;
    address = Align(address, TAG_GRANULE);
    let tag = MemTag(address);
    let address = AddressWithAllocationTag(address, tag);
    X(t) = address
}

val integer_tags_mcgettag_decode : (bits(5), bits(5), bits(9)) -> unit effect {escape, rmem, rreg, undef, wreg, wmem}

function integer_tags_mcgettag_decode (Xt, Xn, imm9) = {
    __unconditional = true;
    let 't = UInt(Xt);
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    __PostDecode();
    integer_tags_mcgettag(n, offset, t)
}

val AArch64_SetExclusiveMonitors : forall ('size : Int).
  (bits(64), int('size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_SetExclusiveMonitors (address, size) = {
    let acctype = AccType_ATOMIC;
    let iswrite = false;
    let aligned = address == Align(address, size);
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, acctype, iswrite, aligned, size);
    if IsFault(memaddrdesc) then {
        return()
    };
    if memaddrdesc.memattrs.shareable then {
        MarkExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
    };
    MarkExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    AArch64_MarkExclusiveVA(address, ProcessorID(), size)
}

val AArch64_ExclusiveMonitorsPass : forall ('size : Int).
  (bits(64), int('size)) -> bool effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_ExclusiveMonitorsPass (address, size) = {
    let acctype = AccType_ATOMIC;
    let iswrite = true;
    let aligned = address == Align(address, size);
    secondstage : bool = undefined : bool;
    if ~(aligned) then {
        secondstage = false;
        AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
    };
    passed : bool = undefined : bool;
    passed = AArch64_IsExclusiveVA(address, ProcessorID(), size);
    if ~(passed) then {
        return(false)
    };
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, acctype, iswrite, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    passed = IsExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    if passed then {
        ClearExclusiveLocal(ProcessorID());
        if memaddrdesc.memattrs.shareable then {
            passed = IsExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
        }
    };
    passed
}

val DebugExceptionReturnSS : bits(32) -> bits(1) effect {escape, rreg, undef}

function DebugExceptionReturnSS spsr = {
    assert((Halted() | Restarting()) | PSTATE.EL != EL0);
    SS_bit : bits(1) = undefined : bits(1);
    SS_bit = 0b0;
    ELd : bits(2) = undefined : bits(2);
    dest : bits(2) = undefined : bits(2);
    enabled_at_dest : bool = undefined : bool;
    enabled_at_source : bool = undefined : bool;
    mask : bits(1) = undefined : bits(1);
    secure : bool = undefined : bool;
    valid_name : bool = undefined : bool;
    if [MDSCR_EL1[0]] == 0b1 then {
        if Restarting() then {
            enabled_at_source = false
        } else {
            if UsingAArch32() then {
                enabled_at_source = AArch32_GenerateDebugExceptions()
            } else {
                enabled_at_source = AArch64_GenerateDebugExceptions()
            }
        };
        if IllegalExceptionReturn(spsr) then {
            dest = PSTATE.EL
        } else {
            (valid_name, dest) = ELFromSPSR(spsr);
            assert(valid_name)
        };
        secure = IsSecureBelowEL3() | dest == EL3;
        if ELUsingAArch32(dest) then {
            enabled_at_dest = AArch32_GenerateDebugExceptionsFrom(dest, secure)
        } else {
            mask = [spsr[9]];
            enabled_at_dest = AArch64_GenerateDebugExceptionsFrom(dest, secure, mask)
        };
        ELd = DebugTargetFrom(secure);
        if (~(ELUsingAArch32(ELd)) & ~(enabled_at_source)) & enabled_at_dest then {
            SS_bit = [spsr[21]]
        }
    };
    SS_bit
}

val SetPSTATEFromPSR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function SetPSTATEFromPSR spsr__arg = {
    spsr = spsr__arg;
    PSTATE.SS = DebugExceptionReturnSS(spsr);
    if IllegalExceptionReturn(spsr) then {
        PSTATE.IL = 0b1
    } else {
        PSTATE.IL = [spsr[20]];
        if [spsr[4]] == 0b1 then {
            AArch32_WriteMode(slice(spsr, 0, 5))
        } else {
            PSTATE.nRW = 0b0;
            PSTATE.EL = slice(spsr, 2, 2);
            PSTATE.SP = [spsr[0]]
        }
    };
    if PSTATE.IL == 0b1 & PSTATE.nRW == 0b1 then {
        if ConstrainUnpredictableBool(Unpredictable_ILZEROT) then {
            spsr = __SetSlice_bits(32, 1, spsr, 5, 0b0)
        }
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = slice(spsr, 28, 4);
    if HaveDITExt() then {
        PSTATE.DIT = [spsr[24]]
    };
    if PSTATE.nRW == 0b1 then {
        PSTATE.Q = [spsr[27]];
        PSTATE.IT = RestoredITBits(spsr);
        ShouldAdvanceIT = false;
        PSTATE.GE = slice(spsr, 16, 4);
        PSTATE.E = [spsr[9]];
        (PSTATE.A @ PSTATE.I @ PSTATE.F) = slice(spsr, 6, 3);
        PSTATE.T = [spsr[5]]
    } else {
        if HaveUAOExt() then {
            PSTATE.UAO = [spsr[23]]
        };
        (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = slice(spsr, 6, 4);
        if HaveBTIExt() then {
            PSTATE.BTYPE = slice(spsr, 10, 2)
        }
    };
    if HavePANExt() then {
        PSTATE.PAN = [spsr[22]]
    };
    if HaveMTEExt() then {
        if PSTATE.nRW != 0b1 then {
            PSTATE.TCO = [spsr[25]]
        }
    };
    return()
}

val DRPSInstruction : unit -> unit effect {escape, rreg, undef, wreg}

function DRPSInstruction () = {
    SynchronizeContext();
    sync_errors : bool = undefined : bool;
    sync_errors = HaveIESB() & [SCTLR()[21]] == 0b1;
    if HaveDoubleFaultExt() & ~(UsingAArch32()) then {
        sync_errors = sync_errors | ([SCR_EL3[3]] == 0b1 & [SCR_EL3[20]] == 0b1) & PSTATE.EL == EL3
    };
    if ~(ConstrainUnpredictableBool(Unpredictable_IESBinDebug)) then {
        sync_errors = false
    };
    if sync_errors then {
        SynchronizeErrors()
    };
    SetPSTATEFromPSR(SPSR());
    if UsingAArch32() then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V @ PSTATE.Q @ PSTATE.GE @ PSTATE.SS @ PSTATE.A @ PSTATE.I @ PSTATE.F) = undefined : bits(13);
        PSTATE.IT = 0x00;
        PSTATE.T = 0b1;
        set_DLR(undefined : bits(32));
        set_DSPSR(undefined : bits(32))
    } else {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V @ PSTATE.SS @ PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = undefined : bits(9);
        DLR_EL0 = undefined : bits(64);
        DSPSR_EL0 = undefined : bits(32)
    };
    UpdateEDSCRFields();
    return()
}

val branch_unconditional_dret : unit -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_dret () = {
    DRPSInstruction()
}

val branch_unconditional_dret_decode : (bits(5), bits(5), bits(6), bits(5), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_dret_decode (op4, Rt, op3, op2, opc) = {
    __unconditional = true;
    if ~(Halted()) | PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    branch_unconditional_dret()
}

val AArch64_ExceptionReturn : (bits(64), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_ExceptionReturn (new_pc__arg, spsr) = {
    new_pc = new_pc__arg;
    SynchronizeContext();
    sync_errors : bool = undefined : bool;
    sync_errors = HaveIESB() & [SCTLR()[21]] == 0b1;
    if HaveDoubleFaultExt() then {
        sync_errors = sync_errors | ([SCR_EL3[3]] == 0b1 & [SCR_EL3[20]] == 0b1) & PSTATE.EL == EL3
    };
    iesb_req : bool = undefined : bool;
    if sync_errors then {
        SynchronizeErrors();
        iesb_req = true;
        TakeUnmaskedPhysicalSErrorInterrupts(iesb_req)
    };
    SetPSTATEFromPSR(spsr);
    ClearExclusiveLocal(ProcessorID());
    SendEventLocal();
    if (PSTATE.IL == 0b1 & [spsr[4]] == 0b1) & [spsr[20]] == 0b0 then {
        new_pc = __SetSlice_bits(64, 32, new_pc, 32, undefined : bits(32));
        new_pc = __SetSlice_bits(64, 2, new_pc, 0, undefined : bits(2))
    } else {
        if UsingAArch32() then {
            if PSTATE.T == 0b1 then {
                new_pc = __SetSlice_bits(64, 1, new_pc, 0, 0b0)
            } else {
                new_pc = __SetSlice_bits(64, 2, new_pc, 0, 0b00)
            }
        } else {
            new_pc = AArch64_BranchAddr(new_pc)
        }
    };
    if UsingAArch32() then {
        BranchTo(slice(new_pc, 0, 32), BranchType_ERET)
    } else {
        BranchToAddr(new_pc, BranchType_ERET)
    }
}

val branch_unconditional_eret : forall ('pac : Bool) ('use_key_a : Bool).
  (bool('pac), bool('use_key_a)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_eret (pac, use_key_a) = {
    AArch64_CheckForERetTrap(pac, use_key_a);
    target : bits(64) = ELR();
    if pac then {
        if use_key_a then {
            target = AuthIA(ELR(), SP())
        } else {
            target = AuthIB(ELR(), SP())
        }
    };
    AArch64_ExceptionReturn(target, SPSR())
}

val branch_unconditional_eret_decode : (bits(5), bits(5), bits(1), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function branch_unconditional_eret_decode (op4, Rn, M, A, op2) = {
    __unconditional = true;
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    };
    let pac = A == 0b1;
    let use_key_a = M == 0b0;
    if ~(pac) & op4 != 0b00000 then {
        throw(Error_Undefined())
    } else {
        if pac & (~(HavePACExt()) | op4 != 0b11111) then {
            throw(Error_Undefined())
        }
    };
    if Rn != 0b11111 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    branch_unconditional_eret(pac, use_key_a)
}

val UnallocatedEncoding : unit -> unit effect {escape, rreg, undef, wreg}

function UnallocatedEncoding () = {
    if UsingAArch32() & AArch32_ExecutingCP10or11Instr() then {
        __tc1 : bits(32) = get_FPEXC();
        __tc1 = __SetSlice_bits(32, 1, __tc1, 29, 0b0);
        set_FPEXC(__tc1)
    };
    if UsingAArch32() & ~(AArch32_GeneralExceptionsToAArch64()) then {
        AArch32_TakeUndefInstrException()
    } else {
        AArch64_UndefinedFault()
    }
}

val integer_tags_mcgettagarray : forall 'n 't ('wb_unknown : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (int('n), int('t), bool('wb_unknown), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcgettagarray (n, t, wb_unknown__arg, wback__arg) = {
    wb_unknown : bool = wb_unknown__arg;
    wback : bool = wback__arg;
    data : bits(64) = Zeros(64);
    address : bits(64) = undefined : bits(64);
    count : int = undefined : int;
    c : Constraint = undefined : Constraint;
    if n == t then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              UnallocatedEncoding()
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    (address, count) = ImpDefTagArrayStartAndCount(address);
    foreach (i from 0 to (count - 1) by 1 in inc) {
        let 'index = UInt(slice(address, LOG2_TAG_GRANULE, 4));
        let tag : bits(4) = aget_MemTag(address);
        data = __SetSlice_bits(64, 4, data, index * 4, tag);
        address = address + TAG_GRANULE
    };
    aset_X(t, data);
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcgettagarray_decode : (bits(5), bits(5)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcgettagarray_decode (Xt, Xn) = {
    __unconditional = true;
    let 't = UInt(Xt);
    let 'n = UInt(Xn);
    let wback = true;
    let wb_unknown = false;
    __PostDecode();
    integer_tags_mcgettagarray(n, t, wb_unknown, wback)
}

val ReservedValue : unit -> unit effect {escape, rreg, undef, wreg}

function ReservedValue () = {
    if UsingAArch32() & ~(AArch32_GeneralExceptionsToAArch64()) then {
        AArch32_TakeUndefInstrException()
    } else {
        AArch64_UndefinedFault()
    }
}

val integer_arithmetic_addsub_immediate_decode : (bits(5), bits(5), bits(12), bits(2), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function integer_arithmetic_addsub_immediate_decode (Rd, Rn, imm12, shift, S, op, sf) = {
    __unconditional = true;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op = op == 0b1;
    let setflags = S == 0b1;
    imm : bits('datasize) = undefined : bits('datasize);
    match shift {
      0b00 => {
          imm = ZeroExtend(imm12, datasize)
      },
      0b01 => {
          imm = ZeroExtend(imm12 @ Zeros(12), datasize)
      },
      0b10 => {
          throw(Error_See("ADDG, SUBG"))
      },
      0b11 => {
          ReservedValue()
      }
    };
    __PostDecode();
    integer_arithmetic_addsub_immediate(d, datasize, imm, n, setflags, sub_op)
}

val AArch32_UndefinedFault : unit -> unit effect {escape, rreg, undef, wreg}

function AArch32_UndefinedFault () = {
    if AArch32_GeneralExceptionsToAArch64() then {
        AArch64_UndefinedFault()
    };
    AArch32_TakeUndefInstrException()
}

val UndefinedFault : unit -> unit effect {escape, rreg, undef, wreg}

function UndefinedFault () = {
    if UsingAArch32() then {
        AArch32_UndefinedFault()
    } else {
        AArch64_UndefinedFault()
    }
}

val fault_at_EL0 : unit -> unit effect {escape, rreg, undef, wreg}

function fault_at_EL0 () = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    }
}

val DC_IGSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_IGSW val_name = {
    fault_at_EL0();
    return()
}

val DC_IGDSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_IGDSW val_name = {
    fault_at_EL0();
    return()
}

val DC_GVA : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_GVA val_name = {
    fault_at_EL0();
    check_access_z(val_name, false);
    let 'size = 4 * 2 ^ UInt(slice(DCZID_EL0, 0, 4));
    address : bits(64) = Align(val_name, size);
    let 'count = shr_int(size, LOG2_TAG_GRANULE);
    let tag : bits(4) = AllocationTagFromAddress(address);
    foreach (i from 0 to (count - 1) by 1 in inc) {
        MemTag(address) = tag;
        address = address + TAG_GRANULE
    };
    return()
}

val DC_CIGSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CIGSW val_name = {
    fault_at_EL0();
    return()
}

val DC_CGVADP : unit -> unit effect {escape, rreg, undef, wreg}

function DC_CGVADP () = {
    fault_at_EL0();
    return()
}

val DC_CGDVADP : unit -> unit effect {escape, rreg, undef, wreg}

function DC_CGDVADP () = {
    DC_CGVADP();
    return()
}

val DC_CGSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CGSW val_name = {
    fault_at_EL0();
    return()
}

val default_system_exceptions_debug_halt_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function default_system_exceptions_debug_halt_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    if [EDSCR[14]] == 0b0 | ~(HaltingAllowed()) then {
        UndefinedFault()
    };
    if HaveBTIExt() then {
        BTypeCompatible = true
    };
    __PostDecode();
    system_exceptions_debug_halt()
}

val TLBI_VALE2OS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VALE2OS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_VALE2IS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VALE2IS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_VALE2 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VALE2 val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_VAE2OS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VAE2OS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_VAE2IS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VAE2IS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_VAE2 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_VAE2 val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVALE2OS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVALE2OS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVALE2IS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVALE2IS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVALE2 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVALE2 val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVAE2OS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVAE2OS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVAE2IS : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVAE2IS val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_RVAE2 : bits(64) -> unit effect {escape, rreg, undef, wreg}

function TLBI_RVAE2 val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_ALLE2OS : unit -> unit effect {escape, rreg, undef, wreg}

function TLBI_ALLE2OS () = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_ALLE2IS : unit -> unit effect {escape, rreg, undef, wreg}

function TLBI_ALLE2IS () = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val TLBI_ALLE2 : unit -> unit effect {escape, rreg, undef, wreg}

function TLBI_ALLE2 () = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        _TLB_Invalidate()
    } else {
        UndefinedFault()
    }
}

val IC_IALLUIS : unit -> unit effect {escape, rreg, undef, wreg}

function IC_IALLUIS () = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    };
    return()
}

val IC_IALLU : unit -> unit effect {escape, rreg, undef, wreg}

function IC_IALLU () = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    };
    return()
}

val DC_ISW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_ISW val_name = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    };
    if HasS2Translation() & ([HCR_EL2[0]] == 0b1 | [HCR_EL2[1]] == 0b1) then ();
    return()
}

val DC_CSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CSW val_name = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    };
    return()
}

val DC_CGDSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CGDSW val_name = {
    DC_CSW(val_name);
    DC_CGSW(val_name);
    return()
}

val DC_CISW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CISW val_name = {
    if PSTATE.EL == EL0 then {
        UndefinedFault()
    };
    return()
}

val DC_CIGDSW : bits(64) -> unit effect {escape, rreg, undef, wreg}

function DC_CIGDSW val_name = {
    DC_CISW(val_name);
    DC_CIGSW(val_name);
    return()
}

val DCPSInstruction : bits(2) -> unit effect {escape, rreg, undef, wreg}

function DCPSInstruction target_el = {
    SynchronizeContext();
    handle_el : bits(2) = undefined : bits(2);
    match target_el {
      ? if ? == EL1 => {
          if PSTATE.EL == EL2 | PSTATE.EL == EL3 & ~(UsingAArch32()) then {
              handle_el = PSTATE.EL
          } else {
              if EL2Enabled() & [HCR_EL2[27]] == 0b1 then {
                  UndefinedFault()
              } else {
                  handle_el = EL1
              }
          }
      },
      ? if ? == EL2 => {
          if ~(HaveEL(EL2)) then {
              UndefinedFault()
          } else {
              if PSTATE.EL == EL3 & ~(UsingAArch32()) then {
                  handle_el = EL3
              } else {
                  if ~(IsSecureEL2Enabled()) & IsSecure() then {
                      UndefinedFault()
                  } else {
                      handle_el = EL2
                  }
              }
          }
      },
      ? if ? == EL3 => {
          if [EDSCR[16]] == 0b1 | ~(HaveEL(EL3)) then {
              UndefinedFault()
          };
          handle_el = EL3
      },
      _ => {
          Unreachable()
      }
    };
    let from_secure = IsSecure();
    if ELUsingAArch32(handle_el) then {
        if PSTATE.M == M32_Monitor then {
            __tc1 : bits(32) = get_SCR();
            __tc1 = __SetSlice_bits(32, 1, __tc1, 0, 0b0);
            set_SCR(__tc1)
        };
        assert(UsingAArch32());
        match handle_el {
          ? if ? == EL1 => {
              AArch32_WriteMode(M32_Svc);
              if HavePANExt() & [get_SCTLR()[23]] == 0b0 then {
                  PSTATE.PAN = 0b1
              }
          },
          ? if ? == EL2 => {
              AArch32_WriteMode(M32_Hyp)
          },
          ? if ? == EL3 => {
              AArch32_WriteMode(M32_Monitor);
              if HavePANExt() then {
                  if ~(from_secure) then {
                      PSTATE.PAN = 0b0
                  } else {
                      if [get_SCTLR()[23]] == 0b0 then {
                          PSTATE.PAN = 0b1
                      }
                  }
              }
          }
        };
        if handle_el == EL2 then {
            set_ELR_hyp(undefined : bits(32));
            set_HSR(undefined : bits(32))
        } else {
            set_LR(undefined : bits(32))
        };
        SPSR() = undefined : bits(32);
        PSTATE.E = [SCTLR()[25]];
        set_DLR(undefined : bits(32));
        set_DSPSR(undefined : bits(32))
    } else {
        if UsingAArch32() then {
            AArch64_MaybeZeroRegisterUppers()
        };
        PSTATE.nRW = 0b0;
        PSTATE.SP = 0b1;
        PSTATE.EL = handle_el;
        if HavePANExt() & (handle_el == EL1 & [SCTLR_EL1[23]] == 0b0 | ((handle_el == EL2 & [HCR_EL2[34]] == 0b1) & [HCR_EL2[27]] == 0b1) & [SCTLR_EL2[23]] == 0b0) then {
            PSTATE.PAN = 0b1
        };
        ELR() = undefined : bits(64);
        SPSR() = undefined : bits(32);
        ESR() = undefined : bits(32);
        DLR_EL0 = undefined : bits(64);
        DSPSR_EL0 = undefined : bits(32);
        if HaveUAOExt() then {
            PSTATE.UAO = 0b0
        }
    };
    UpdateEDSCRFields();
    sync_errors : bool = undefined : bool;
    sync_errors = HaveIESB() & [SCTLR()[21]] == 0b1;
    if HaveDoubleFaultExt() & ~(UsingAArch32()) then {
        sync_errors = sync_errors | ([SCR_EL3[3]] == 0b1 & [SCR_EL3[20]] == 0b1) & PSTATE.EL == EL3
    };
    if ~(ConstrainUnpredictableBool(Unpredictable_IESBinDebug)) then {
        sync_errors = false
    };
    if sync_errors then {
        SynchronizeErrors()
    };
    return()
}

val system_exceptions_debug_exception : bits(2) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_debug_exception target_level = {
    DCPSInstruction(target_level)
}

val system_exceptions_debug_exception_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function system_exceptions_debug_exception_decode (LL, op2, imm16, opc) = {
    __unconditional = true;
    let target_level = LL;
    if LL == 0b00 then {
        throw(Error_Undefined())
    };
    if ~(Halted()) then {
        AArch64_UndefinedFault()
    };
    __PostDecode();
    system_exceptions_debug_exception(target_level)
}

val AArch64_SysInstrWithResult : forall 'op0 'op1 'crn 'crm 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bits(64) effect {escape, rreg, undef, wreg}

function AArch64_SysInstrWithResult (op0, op1, crn, crm, op2) = {
    if (__GetSlice_int(2, op0, 0) == 0b01 | __GetSlice_int(2, op0, 0) == 0b11) & (__GetSlice_int(4, crn, 0) == 0xB | __GetSlice_int(4, crn, 0) == 0xF) then {
        throw(Error_Implementation_Defined(""))
    } else {
        UndefinedFault()
    };
    undefined : bits(64)
}

val DC_ZVA : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_ZVA val_name = {
    let iswrite = true;
    let 'size = 4 * 2 ^ UInt(slice(DCZID_EL0, 0, 4));
    let vaddress : bits(64) = Align(val_name, size);
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    memaddrdesc = AArch64_FullTranslate(vaddress, AccType_DCZVA, iswrite, true, 1);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(val_name, memaddrdesc.fault)
    };
    accdesc : AccessDescriptor = undefined : AccessDescriptor;
    foreach (i from 0 to (size - 1) by 1 in inc) {
        accdesc = CreateAccessDescriptor(AccType_DCZVA);
        if HaveMTEExt() then {
            if AccessIsTagChecked(vaddress, AccType_DCZVA) then {
                let ptag : bits(4) = TransformTag(vaddress);
                if ~(CheckTag(memaddrdesc, ptag, iswrite)) then {
                    TagCheckFail(vaddress, iswrite)
                }
            }
        };
        _Mem(memaddrdesc, 1, accdesc) = Zeros();
        __tc1 : FullAddress = memaddrdesc.paddress;
        __tc1.address = memaddrdesc.paddress.address + 1;
        memaddrdesc.paddress = __tc1
    };
    return()
}

val DC_GZVA : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_GZVA val_name = {
    DC_GVA(val_name);
    DC_ZVA(val_name);
    return()
}

val AArch64_aset_MemSingle : forall 'size ('wasaligned : Bool),
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccType, bool('wasaligned), bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_aset_MemSingle (address, size, acctype, wasaligned, value_name) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    assert(address == Align(address, size));
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    let iswrite = true;
    let memaddrdesc = AArch64_TranslateAddress(address, acctype, iswrite, wasaligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    };
    if memaddrdesc.memattrs.shareable then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), size)
    };
    let accdesc = CreateAccessDescriptor(acctype);
    if HaveMTEExt() then {
        if AccessIsTagChecked(ZeroExtend(address, 64), acctype) then {
            let ptag = TransformTag(ZeroExtend(address, 64));
            if ~(CheckTag(memaddrdesc, ptag, iswrite)) then {
                TagCheckFail(ZeroExtend(address, 64), iswrite)
            }
        }
    };
    _Mem(memaddrdesc, size, accdesc) = value_name;
    return()
}

overload MemSingle = {AArch64_aset_MemSingle}

val aset_Mem : forall 'size,
  8 * 'size >= 0 & 'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccType, bits(8 * 'size)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_Mem (address, size, acctype, value_name__arg) = {
    value_name = value_name__arg;
    let iswrite = true;
    if (HaveNV2Ext() & acctype == AccType_NV2REGISTER) & [SCTLR_EL2[25]] == 0b1 | BigEndian() then {
        value_name = BigEndianReverse(value_name)
    };
    aligned : bool = undefined : bool;
    aligned = AArch64_CheckAlignment(address, size, acctype, iswrite);
    atomic : bool = undefined : bool;
    if size != 16 | ~(acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
        atomic = aligned
    } else {
        atomic = address == Align(address, 8)
    };
    c : Constraint = undefined : Constraint;
    if ~(atomic) then {
        assert(size > 1);
        MemSingle(address, 1, acctype, aligned) = slice(value_name, 0, 8);
        if ~(aligned) then {
            c = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
            assert(c == Constraint_FAULT | c == Constraint_NONE);
            if c == Constraint_NONE then {
                aligned = true
            }
        };
        foreach (i from 1 to (size - 1) by 1 in inc) {
            MemSingle(address + i, 1, acctype, aligned) = slice(value_name, 8 * i, 8)
        }
    } else {
        if size == 16 & (acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
            MemSingle(address, 8, acctype, aligned) = slice(value_name, 0, 64);
            MemSingle(address + 8, 8, acctype, aligned) = slice(value_name, 64, 64)
        } else {
            MemSingle(address, size, acctype, aligned) = value_name
        }
    };
    return()
}

overload Mem = {aset_Mem}

val semihost_writeparam : forall ('index : Int).
  (int('index), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function semihost_writeparam (index, value_name) = {
    let base = semihost_arg(1);
    Mem(base + index * 8, 8, AccType_NORMAL) = value_name
}

val aset_NVMem : forall ('offset : Int).
  (int('offset), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function aset_NVMem (offset, val_name) = {
    base : bits(52) = undefined : bits(52);
    if [VNCR_EL2[52]] == 0b1 then {
        base = Ones(11) @ slice(VNCR_EL2, 12, 41)
    } else {
        base = Zeros(11) @ slice(VNCR_EL2, 12, 41)
    };
    let address : bits(64) = base @ __GetSlice_int(12, offset, 0);
    Mem(address, 8, AccType_NV2REGISTER) = val_name
}

overload NVMem = {aset_NVMem}

val AArch64_AutoGen_SysRegWrite : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_AutoGen_SysRegWrite (el, op0, op1, CRn, op2, CRm, read, val_name) = {
    let __HCR_EL2_NV1 = [HCR_EL2[43]];
    let __HCR_EL2_FMO = [HCR_EL2[3]];
    let __HCR_EL2_NV2 = [HCR_EL2[45]];
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __SCR_EL3_NS = [SCR_EL3[0]];
    let __HCR_EL2_IMO = [HCR_EL2[4]];
    let __HCR_EL2_NV = [HCR_EL2[42]];
    if (CRm & 0x0) == 0x0 then {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b101 then {
                        DBGBCR_EL1[UInt(slice(CRm, 0, 4))] = slice(val_name, 0, 32)
                    } else {
                        if op2 == 0b111 then {
                            DBGWCR_EL1[UInt(slice(CRm, 0, 4))] = slice(val_name, 0, 32)
                        } else {
                            if op2 == 0b100 then {
                                DBGBVR_EL1[UInt(slice(CRm, 0, 4))] = val_name
                            } else {
                                if op2 == 0b110 then {
                                    DBGWVR_EL1[UInt(slice(CRm, 0, 4))] = val_name
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        PMEVCNTR_EL0[UInt(slice(CRm, 0, 2) @ slice(op2, 0, 3))] = slice(val_name, 0, 32)
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        PMEVTYPER_EL0[UInt(slice(CRm, 0, 2) @ slice(op2, 0, 3))] = slice(val_name, 0, 32)
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if op1 == 0b000 then {
                    if op0 == 0b11 then {
                        if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            ICV_AP0R_EL1[UInt(slice(op2, 0, 2))] = slice(val_name, 0, 32)
                        } else {
                            ICC_AP0R_EL1[UInt(slice(op2, 0, 2))] = slice(val_name, 0, 32)
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if op0 == 0b11 then {
                if op1 == 0b100 then {
                    if CRm == 0x8 then {
                        if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            NVMem(1152 + 8 * UInt(slice(op2, 0, 2))) = ZeroExtend(slice(val_name, 0, 32))
                        } else {
                            ICH_AP0R_EL2[UInt(slice(op2, 0, 2))] = ZeroExtend(slice(val_name, 0, 32))
                        }
                    } else {
                        if CRm == 0x9 then {
                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                NVMem(1184 + 8 * UInt(slice(op2, 0, 2))) = ZeroExtend(slice(val_name, 0, 32))
                            } else {
                                ICH_AP1R_EL2[UInt(slice(op2, 0, 2))] = ZeroExtend(slice(val_name, 0, 32))
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x9 then {
                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                ICV_AP1R_EL1[UInt(slice(op2, 0, 2))] = slice(val_name, 0, 32)
                            } else {
                                if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                    ICC_AP1R_EL1[UInt(slice(op2, 0, 2))] = slice(val_name, 0, 32)
                                } else {
                                    ICC_AP1R_EL1[UInt(slice(op2, 0, 2))] = slice(val_name, 0, 32)
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if op0 == 0b11 then {
        if op2 == 0b000 then {
            if op1 == 0b100 then {
                if CRm == 0x0 then {
                    if CRn == 0xC then {
                        VBAR_EL2 = val_name
                    } else {
                        if CRn == 0x4 then {
                            SPSR_EL2 = slice(val_name, 0, 32)
                        } else {
                            if CRn == 0x3 then {
                                DACR32_EL2 = slice(val_name, 0, 32)
                            } else {
                                if CRn == 0x6 then {
                                    FAR_EL2 = val_name
                                } else {
                                    if CRn == 0x1 then {
                                        SCTLR_EL2 = val_name
                                    } else {
                                        if CRn == 0x0 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(136) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                VPIDR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                TTBR0_EL2 = val_name
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x1 then {
                        if CRn == 0xE then {
                            CNTHCTL_EL2 = slice(val_name, 0, 32)
                        } else {
                            if CRn == 0x1 then {
                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    NVMem(120) = val_name
                                } else {
                                    HCR_EL2 = val_name
                                }
                            } else {
                                if CRn == 0x4 then {
                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        NVMem(576) = val_name
                                    } else {
                                        SP_EL1 = val_name
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        AFSR0_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRn == 0x2 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(32) = val_name
                                            } else {
                                                VTTBR_EL2 = val_name
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0xA then {
                            if CRm == 0x2 then {
                                MAIR_EL2 = val_name
                            } else {
                                if CRm == 0x5 then {
                                    MPAM2_EL2 = val_name
                                } else {
                                    if CRm == 0x4 then {
                                        if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(2352) = ZeroExtend(slice(val_name, 0, 32))
                                        } else {
                                            MPAMHCR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2368) = val_name
                                            } else {
                                                MPAMVPM0_EL2 = val_name
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                AMAIR_EL2 = val_name
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    CNTHP_TVAL_EL2 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x5 then {
                                        CNTHPS_TVAL_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRm == 0x4 then {
                                            CNTHVS_TVAL_EL2 = slice(val_name, 0, 32)
                                        } else {
                                            if CRm == 0x3 then {
                                                CNTHV_TVAL_EL2 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x5 then {
                                    if CRm == 0x2 then {
                                        ESR_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRm == 0x3 then {
                                            FPEXC32_EL2 = slice(val_name, 0, 32)
                                        }
                                    }
                                } else {
                                    if CRn == 0x2 then {
                                        if CRm == 0x2 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(176) = val_name
                                            } else {
                                                VNCR_EL2 = val_name
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if ((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0 then {
                                                    NVMem(48) = val_name
                                                } else {
                                                    VSTTBR_EL2 = val_name
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(1216) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    ICH_HCR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if CRn == 0x6 then {
                                                    TFSR_EL2 = slice(val_name, 0, 32)
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        SPSR_irq = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op1 == 0b000 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                VBAR_EL2 = val_name
                            } else {
                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    NVMem(592) = val_name
                                } else {
                                    VBAR_EL1 = val_name
                                }
                            }
                        } else {
                            if CRn == 0x1 then {
                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    SCTLR_EL2 = val_name
                                } else {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        NVMem(272) = val_name
                                    } else {
                                        SCTLR_EL1 = val_name
                                    }
                                }
                            } else {
                                if CRn == 0x6 then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        FAR_EL2 = val_name
                                    } else {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(544) = val_name
                                        } else {
                                            FAR_EL1 = val_name
                                        }
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            SPSR_EL2 = slice(val_name, 0, 32)
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(352) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                SPSR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                TTBR0_EL2 = val_name
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(512) = val_name
                                                } else {
                                                    TTBR0_EL1 = val_name
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xE then {
                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    CNTHCTL_EL2 = slice(val_name, 0, 32)
                                } else {
                                    CNTKCTL_EL1 = slice(val_name, 0, 32)
                                }
                            } else {
                                if CRn == 0x4 then {
                                    SP_EL0 = val_name
                                } else {
                                    if CRn == 0x5 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            AFSR0_EL2 = slice(val_name, 0, 32)
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(296) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                AFSR0_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            APIAKeyLo_EL1 = val_name
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0x4 then {
                                    set_SPSel(slice(val_name, 0, 32))
                                } else {
                                    if CRn == 0xA then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            MAIR_EL2 = val_name
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(320) = val_name
                                            } else {
                                                MAIR_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                ESR_EL2 = slice(val_name, 0, 32)
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(312) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    ESR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                APDAKeyLo_EL1 = val_name
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x5 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            MPAM2_EL2 = val_name
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2304) = val_name
                                            } else {
                                                MPAM1_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            LORSA_EL1 = val_name
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    AMAIR_EL2 = val_name
                                                } else {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(328) = val_name
                                                    } else {
                                                        AMAIR_EL1 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x7 then {
                                        if CRm == 0x4 then {
                                            PAR_EL1 = val_name
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x6 then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    ICV_PMR_EL1 = slice(val_name, 0, 32)
                                                } else {
                                                    ICC_PMR_EL1 = slice(val_name, 0, 32)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x5 then {
                                                if CRn == 0x6 then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(400) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        TFSR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if CRm == 0x3 then {
                                                        APGAKeyLo_EL1 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if CRn == 0xF then {
                            if CRm == 0x0 then {
                                ESP_EL0 = val_name
                            } else {
                                if CRm == 0x2 then {
                                    SPSR_EL0 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x5 then {
                                        VBAR_EL0 = val_name
                                    } else {
                                        if CRm == 0x1 then {
                                            ELR_EL0 = val_name
                                        } else {
                                            if CRm == 0x4 then {
                                                FAR_EL0 = val_name
                                            } else {
                                                if CRm == 0x3 then {
                                                    ESR_EL0 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x4 then {
                                if CRm == 0x2 then {
                                    set_NZCV(slice(val_name, 0, 32))
                                } else {
                                    if CRm == 0x5 then {
                                        DSPSR_EL0 = slice(val_name, 0, 32)
                                    } else {
                                        if CRm == 0x4 then {
                                            FPCR = slice(val_name, 0, 32)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x9 then {
                                    if CRm == 0xD then {
                                        PMCCNTR_EL0 = val_name
                                    } else {
                                        if CRm == 0xE then {
                                            PMUSERENR_EL0 = slice(val_name, 0, 32)
                                        } else {
                                            if CRm == 0xC then {
                                                PMCR_EL0 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                CNTHP_TVAL_EL2 = slice(val_name, 0, 32)
                                            } else {
                                                CNTP_TVAL_EL0 = slice(val_name, 0, 32)
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                CNTFRQ_EL0 = slice(val_name, 0, 32)
                                            } else {
                                                if CRm == 0x3 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        CNTHV_TVAL_EL2 = slice(val_name, 0, 32)
                                                    } else {
                                                        CNTV_TVAL_EL0 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b101 then {
                            if CRm == 0x0 then {
                                if CRn == 0xC then {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        NVMem(592) = val_name
                                    } else {
                                        VBAR_EL1 = val_name
                                    }
                                } else {
                                    if CRn == 0x2 then {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(512) = val_name
                                        } else {
                                            TTBR0_EL1 = val_name
                                        }
                                    } else {
                                        if CRn == 0x6 then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(544) = val_name
                                            } else {
                                                FAR_EL1 = val_name
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(272) = val_name
                                                } else {
                                                    SCTLR_EL1 = val_name
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(352) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        SPSR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        CNTP_TVAL_EL0 = slice(val_name, 0, 32)
                                    } else {
                                        if CRn == 0xA then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(320) = val_name
                                            } else {
                                                MAIR_EL1 = val_name
                                            }
                                        } else {
                                            if CRn == 0x5 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(312) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    ESR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0xE then {
                                            CNTKCTL_EL1 = slice(val_name, 0, 32)
                                        } else {
                                            if CRn == 0x5 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(296) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    AFSR0_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if CRn == 0x6 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(400) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    TFSR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(2304) = val_name
                                                    } else {
                                                        MPAM1_EL1 = val_name
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if CRn == 0xE then {
                                                    CNTV_TVAL_EL0 = slice(val_name, 0, 32)
                                                } else {
                                                    if CRn == 0xA then {
                                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            NVMem(328) = val_name
                                                        } else {
                                                            AMAIR_EL1 = val_name
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b110 then {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        VBAR_EL3 = val_name
                                    } else {
                                        if CRn == 0x2 then {
                                            TTBR0_EL3 = val_name
                                        } else {
                                            if CRn == 0x6 then {
                                                FAR_EL3 = val_name
                                            } else {
                                                if CRn == 0x1 then {
                                                    SCTLR_EL3 = val_name
                                                } else {
                                                    if CRn == 0x4 then {
                                                        SPSR_EL3 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            SCR_EL3 = slice(val_name, 0, 32)
                                        } else {
                                            if CRn == 0x4 then {
                                                SP_EL2 = val_name
                                            } else {
                                                if CRn == 0x5 then {
                                                    AFSR0_EL3 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x2 then {
                                                MAIR_EL3 = val_name
                                            } else {
                                                if CRm == 0x5 then {
                                                    MPAM3_EL3 = val_name
                                                } else {
                                                    if CRm == 0x3 then {
                                                        AMAIR_EL3 = val_name
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x5 then {
                                                    ESR_EL3 = slice(val_name, 0, 32)
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        TFSR_EL3 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if op1 == 0b010 then {
                                        if CRn == 0x0 then {
                                            CSSELR_EL1 = slice(val_name, 0, 32)
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if op1 == 0b111 then {
                                                CNTPS_TVAL_EL1 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op2 == 0b001 then {
                if op1 == 0b100 then {
                    if CRm == 0x0 then {
                        if CRn == 0x4 then {
                            ELR_EL2 = val_name
                        } else {
                            if CRn == 0xD then {
                                CONTEXTIDR_EL2 = slice(val_name, 0, 32)
                            } else {
                                if CRn == 0x1 then {
                                    ACTLR_EL2 = val_name
                                } else {
                                    if CRn == 0x5 then {
                                        IFSR32_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRn == 0x2 then {
                                            TTBR1_EL2 = val_name
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0xE then {
                            if CRm == 0x2 then {
                                CNTHP_CTL_EL2 = slice(val_name, 0, 32)
                            } else {
                                if CRm == 0x5 then {
                                    CNTHPS_CTL_EL2 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x4 then {
                                        CNTHVS_CTL_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRm == 0x3 then {
                                            CNTHV_CTL_EL2 = slice(val_name, 0, 32)
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x1 then {
                                if CRm == 0x2 then {
                                    TRFCR_EL2 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x1 then {
                                        MDCR_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRm == 0x3 then {
                                            SDER32_EL2 = slice(val_name, 0, 32)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x4 then {
                                        if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(2360) = ZeroExtend(slice(val_name, 0, 32))
                                        } else {
                                            MPAMVPMV_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2376) = val_name
                                            } else {
                                                MPAMVPM1_EL2 = val_name
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x5 then {
                                            AFSR1_EL2 = slice(val_name, 0, 32)
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x3 then {
                                                SPSR_abt = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x0 then {
                            if CRn == 0x4 then {
                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    ELR_EL2 = val_name
                                } else {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        NVMem(560) = val_name
                                    } else {
                                        ELR_EL1 = val_name
                                    }
                                }
                            } else {
                                if CRn == 0xD then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        CONTEXTIDR_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(264) = ZeroExtend(slice(val_name, 0, 32))
                                        } else {
                                            CONTEXTIDR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                        }
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(280) = val_name
                                        } else {
                                            ACTLR_EL1 = val_name
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                TTBR1_EL2 = val_name
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(528) = val_name
                                                } else {
                                                    TTBR1_EL1 = val_name
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if CRm == 0x8 then {
                                    if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        ICV_EOIR0_EL1 = slice(val_name, 0, 32)
                                    } else {
                                        ICC_EOIR0_EL1 = slice(val_name, 0, 32)
                                    }
                                } else {
                                    if CRm == 0xB then {
                                        if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            ICV_DIR_EL1 = slice(val_name, 0, 32)
                                        } else {
                                            ICC_DIR_EL1 = slice(val_name, 0, 32)
                                        }
                                    } else {
                                        if CRm == 0xC then {
                                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                ICV_EOIR1_EL1 = slice(val_name, 0, 32)
                                            } else {
                                                ICC_EOIR1_EL1 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        APDAKeyHi_EL1 = val_name
                                    } else {
                                        if CRm == 0x1 then {
                                            APIAKeyHi_EL1 = val_name
                                        } else {
                                            if CRm == 0x3 then {
                                                APGAKeyHi_EL1 = val_name
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x5 then {
                                            MPAM0_EL1 = val_name
                                        } else {
                                            if CRm == 0x4 then {
                                                LOREA_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x5 then {
                                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    AFSR1_EL2 = slice(val_name, 0, 32)
                                                } else {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(304) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        AFSR1_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0xE then {
                                                if CRn == 0x9 then {
                                                    PMINTENSET_EL1 = slice(val_name, 0, 32)
                                                }
                                            } else {
                                                if CRm == 0x2 then {
                                                    if CRn == 0x1 then {
                                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            TRFCR_EL2 = slice(val_name, 0, 32)
                                                        } else {
                                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                                NVMem(2176) = ZeroExtend(slice(val_name, 0, 32))
                                                            } else {
                                                                TRFCR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0x6 then {
                                                            TFSRE0_EL1 = slice(val_name, 0, 32)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b101 then {
                            if CRm == 0x0 then {
                                if CRn == 0x2 then {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        NVMem(528) = val_name
                                    } else {
                                        TTBR1_EL1 = val_name
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(560) = val_name
                                        } else {
                                            ELR_EL1 = val_name
                                        }
                                    } else {
                                        if CRn == 0xD then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(264) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                CONTEXTIDR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(384) = ZeroExtend(slice(val_name, 0, 32))
                                        } else {
                                            CNTP_CTL_EL0 = ZeroExtend(slice(val_name, 0, 32))
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2176) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                TRFCR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x3 then {
                                            if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(368) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                CNTV_CTL_EL0 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x5 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(304) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    AFSR1_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b011 then {
                                if CRn == 0x4 then {
                                    if CRm == 0x2 then {
                                        set_DAIF(slice(val_name, 0, 32))
                                    } else {
                                        if CRm == 0x5 then {
                                            DLR_EL0 = val_name
                                        } else {
                                            if CRm == 0x4 then {
                                                FPSR = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x9 then {
                                        if CRm == 0xD then {
                                            PMXEVTYPER_EL0 = slice(val_name, 0, 32)
                                        } else {
                                            if CRm == 0xC then {
                                                PMCNTENSET_EL0 = slice(val_name, 0, 32)
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if CRm == 0x2 then {
                                                if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    CNTHP_CTL_EL2 = slice(val_name, 0, 32)
                                                } else {
                                                    if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                        NVMem(384) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        CNTP_CTL_EL0 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        CNTHV_CTL_EL2 = slice(val_name, 0, 32)
                                                    } else {
                                                        if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                            NVMem(368) = ZeroExtend(slice(val_name, 0, 32))
                                                        } else {
                                                            CNTV_CTL_EL0 = ZeroExtend(slice(val_name, 0, 32))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b110 then {
                                    if CRn == 0x1 then {
                                        if CRm == 0x0 then {
                                            ACTLR_EL3 = val_name
                                        } else {
                                            if CRm == 0x1 then {
                                                SDER32_EL3 = slice(val_name, 0, 32)
                                            } else {
                                                if CRm == 0x3 then {
                                                    MDCR_EL3 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0x4 then {
                                                ELR_EL3 = val_name
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x5 then {
                                                    AFSR1_EL3 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if op1 == 0b111 then {
                                                CNTPS_CTL_EL1 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b010 then {
                    if CRm == 0x0 then {
                        if CRn == 0x2 then {
                            if op1 == 0b101 then {
                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    NVMem(288) = val_name
                                } else {
                                    TCR_EL1 = val_name
                                }
                            } else {
                                if op1 == 0b000 then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        TCR_EL2 = val_name
                                    } else {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(288) = val_name
                                        } else {
                                            TCR_EL1 = val_name
                                        }
                                    }
                                } else {
                                    if op1 == 0b110 then {
                                        TCR_EL3 = slice(val_name, 0, 32)
                                    } else {
                                        if op1 == 0b100 then {
                                            TCR_EL2 = val_name
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if op1 == 0b000 then {
                                    RMR_EL1 = slice(val_name, 0, 32)
                                } else {
                                    if op1 == 0b110 then {
                                        RMR_EL3 = slice(val_name, 0, 32)
                                    } else {
                                        if op1 == 0b100 then {
                                            RMR_EL2 = slice(val_name, 0, 32)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xD then {
                                    if op1 == 0b110 then {
                                        TPIDR_EL3 = val_name
                                    } else {
                                        if op1 == 0b100 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(144) = val_name
                                            } else {
                                                TPIDR_EL2 = val_name
                                            }
                                        } else {
                                            if op1 == 0b011 then {
                                                TPIDR_EL0 = val_name
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if op1 == 0b000 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                CPTR_EL2 = slice(val_name, 0, 32)
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(256) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    CPACR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        } else {
                                            if op1 == 0b101 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(256) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    CPACR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xF then {
                                            if op1 == 0b011 then {
                                                RD_EL0 = val_name
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b100 then {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    CNTHP_CVAL_EL2 = val_name
                                } else {
                                    if CRm == 0x5 then {
                                        CNTHPS_CVAL_EL2 = val_name
                                    } else {
                                        if CRm == 0x4 then {
                                            CNTHVS_CVAL_EL2 = val_name
                                        } else {
                                            if CRm == 0x3 then {
                                                CNTHV_CVAL_EL2 = val_name
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x1 then {
                                    if CRn == 0x1 then {
                                        CPTR_EL2 = slice(val_name, 0, 32)
                                    } else {
                                        if CRn == 0x2 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(64) = ZeroExtend(slice(val_name, 0, 32))
                                            } else {
                                                VTCR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x6 then {
                                        if CRn == 0xA then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2384) = val_name
                                            } else {
                                                MPAMVPM2_EL2 = val_name
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0 then {
                                                    NVMem(72) = ZeroExtend(slice(val_name, 0, 32))
                                                } else {
                                                    VSTCR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x3 then {
                                                SPSR_und = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    if op1 == 0b101 then {
                                        if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(376) = val_name
                                        } else {
                                            CNTP_CVAL_EL0 = val_name
                                        }
                                    } else {
                                        if op1 == 0b111 then {
                                            CNTPS_CVAL_EL1 = val_name
                                        } else {
                                            if op1 == 0b011 then {
                                                if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    CNTHP_CVAL_EL2 = val_name
                                                } else {
                                                    if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                        NVMem(376) = val_name
                                                    } else {
                                                        CNTP_CVAL_EL0 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x3 then {
                                        if op1 == 0b101 then {
                                            if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(360) = val_name
                                            } else {
                                                CNTV_CVAL_EL0 = val_name
                                            }
                                        } else {
                                            if op1 == 0b011 then {
                                                if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    CNTHV_CVAL_EL2 = val_name
                                                } else {
                                                    if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                        NVMem(360) = val_name
                                                    } else {
                                                        CNTV_CVAL_EL0 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b000 then {
                                    if CRn == 0x2 then {
                                        if CRm == 0x2 then {
                                            APDBKeyLo_EL1 = val_name
                                        } else {
                                            if CRm == 0x1 then {
                                                APIBKeyLo_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if CRn == 0x9 then {
                                            if CRm == 0xE then {
                                                PMINTENCLR_EL1 = slice(val_name, 0, 32)
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if CRn == 0xA then {
                                                    LORN_EL1 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x9 then {
                                        if op1 == 0b011 then {
                                            if CRm == 0xD then {
                                                PMXEVCNTR_EL0 = slice(val_name, 0, 32)
                                            } else {
                                                if CRm == 0xC then {
                                                    PMCNTENCLR_EL0 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if op1 == 0b110 then {
                                                if CRn == 0x1 then {
                                                    CPTR_EL3 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRn == 0xC then {
                            if CRm == 0xC then {
                                if op2 == 0b101 then {
                                    if (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1 then {
                                        ICC_SRE_EL1_NS = slice(val_name, 0, 32)
                                    } else {
                                        ICC_SRE_EL1_S = slice(val_name, 0, 32)
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            ICV_BPR1_EL1 = slice(val_name, 0, 32)
                                        } else {
                                            if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                ICC_BPR1_EL1_NS = slice(val_name, 0, 32)
                                            } else {
                                                ICC_BPR1_EL1_S = slice(val_name, 0, 32)
                                            }
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                ICV_IGRPEN1_EL1 = slice(val_name, 0, 32)
                                            } else {
                                                if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                    ICC_IGRPEN1_EL1_NS = slice(val_name, 0, 32)
                                                } else {
                                                    ICC_IGRPEN1_EL1_S = slice(val_name, 0, 32)
                                                }
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    ICV_CTLR_EL1 = slice(val_name, 0, 32)
                                                } else {
                                                    if ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & (__HCR_EL2_FMO == 1 | __HCR_EL2_IMO == 1)) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                        ICC_CTLR_EL1_NS = slice(val_name, 0, 32)
                                                    } else {
                                                        ICC_CTLR_EL1_S = slice(val_name, 0, 32)
                                                    }
                                                }
                                            } else {
                                                if op2 == 0b110 then {
                                                    if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        ICV_IGRPEN0_EL1 = slice(val_name, 0, 32)
                                                    } else {
                                                        ICC_IGRPEN0_EL1 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xB then {
                                    if op2 == 0b101 then {
                                        ICC_SGI1R_EL1 = val_name
                                    } else {
                                        if op2 == 0b111 then {
                                            ICC_SGI0R_EL1 = val_name
                                        } else {
                                            if op2 == 0b110 then {
                                                ICC_ASGI1R_EL1 = val_name
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x8 then {
                                        if op2 == 0b011 then {
                                            if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                ICV_BPR0_EL1 = slice(val_name, 0, 32)
                                            } else {
                                                ICC_BPR0_EL1 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if CRn == 0xD then {
                                    if op2 == 0b111 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            SCXTNUM_EL2 = val_name
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(392) = val_name
                                            } else {
                                                SCXTNUM_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if op2 == 0b100 then {
                                            TPIDR_EL1 = val_name
                                        }
                                    }
                                } else {
                                    if CRn == 0x1 then {
                                        if op2 == 0b101 then {
                                            RGSR_EL1 = slice(val_name, 0, 32)
                                        } else {
                                            if op2 == 0b110 then {
                                                GCR_EL1 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b011 then {
                                    if CRm == 0x2 then {
                                        if CRn == 0x4 then {
                                            set_PAN(slice(val_name, 0, 32))
                                        } else {
                                            if CRn == 0x2 then {
                                                APDBKeyHi_EL1 = val_name
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if CRn == 0xA then {
                                                LORC_EL1 = slice(val_name, 0, 32)
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x2 then {
                                                    APIBKeyHi_EL1 = val_name
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0x4 then {
                                            if op2 == 0b100 then {
                                                set_UAO(slice(val_name, 0, 32))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b100 then {
                            if CRm == 0x6 then {
                                if CRn == 0xA then {
                                    if op2 == 0b101 then {
                                        if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            NVMem(2408) = val_name
                                        } else {
                                            MPAMVPM5_EL2 = val_name
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(2392) = val_name
                                            } else {
                                                MPAMVPM3_EL2 = val_name
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    NVMem(2424) = val_name
                                                } else {
                                                    MPAMVPM7_EL2 = val_name
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(2400) = val_name
                                                    } else {
                                                        MPAMVPM4_EL2 = val_name
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            NVMem(2416) = val_name
                                                        } else {
                                                            MPAMVPM6_EL2 = val_name
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if op2 == 0b011 then {
                                        if CRn == 0xE then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                NVMem(96) = val_name
                                            } else {
                                                CNTVOFF_EL2 = val_name
                                            }
                                        }
                                    } else {
                                        if CRn == 0xD then {
                                            if op2 == 0b111 then {
                                                SCXTNUM_EL2 = val_name
                                            }
                                        } else {
                                            if op2 == 0b101 then {
                                                if CRn == 0x0 then {
                                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(80) = val_name
                                                    } else {
                                                        VMPIDR_EL2 = val_name
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x6 then {
                                                    if op2 == 0b100 then {
                                                        HPFAR_EL2 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if op2 == 0b101 then {
                                            if CRm == 0x9 then {
                                                ICC_SRE_EL2 = slice(val_name, 0, 32)
                                            }
                                        } else {
                                            if CRm == 0xB then {
                                                if op2 == 0b111 then {
                                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(1224) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        ICH_VMCR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                if op2 == 0b011 then {
                                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(128) = ZeroExtend(slice(val_name, 0, 32))
                                                    } else {
                                                        HSTR_EL2 = ZeroExtend(slice(val_name, 0, 32))
                                                    }
                                                } else {
                                                    if op2 == 0b111 then {
                                                        HACR_EL2 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b011 then {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        SPSR_fiq = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b011 then {
                                if CRn == 0x9 then {
                                    if CRm == 0xC then {
                                        if op2 == 0b101 then {
                                            PMSELR_EL0 = slice(val_name, 0, 32)
                                        } else {
                                            if op2 == 0b011 then {
                                                PMOVSCLR_EL0 = slice(val_name, 0, 32)
                                            } else {
                                                if op2 == 0b100 then {
                                                    PMSWINC_EL0 = slice(val_name, 0, 32)
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if CRm == 0xE then {
                                                PMOVSSET_EL0 = slice(val_name, 0, 32)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if CRm == 0x2 then {
                                            if op2 == 0b101 then {
                                                set_DIT(slice(val_name, 0, 32))
                                            } else {
                                                if op2 == 0b111 then {
                                                    set_TCO(slice(val_name, 0, 32))
                                                } else {
                                                    if op2 == 0b110 then {
                                                        set_SSBS(slice(val_name, 0, 32))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0xD then {
                                                if op2 == 0b011 then {
                                                    TPIDRRO_EL0 = val_name
                                                } else {
                                                    if op2 == 0b111 then {
                                                        SCXTNUM_EL0 = val_name
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if op2 == 0b111 then {
                                                    if CRm == 0xF then {
                                                        PMCCFILTR_EL0 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b110 then {
                                    if CRn == 0xC then {
                                        if CRm == 0xC then {
                                            if op2 == 0b101 then {
                                                ICC_SRE_EL3 = slice(val_name, 0, 32)
                                            } else {
                                                if op2 == 0b111 then {
                                                    ICC_IGRPEN1_EL3 = slice(val_name, 0, 32)
                                                } else {
                                                    if op2 == 0b100 then {
                                                        ICC_CTLR_EL3 = slice(val_name, 0, 32)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if op2 == 0b111 then {
                                                if CRn == 0xD then {
                                                    SCXTNUM_EL3 = val_name
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b101 then {
                                        if CRm == 0x0 then {
                                            if op2 == 0b111 then {
                                                if CRn == 0xD then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        NVMem(392) = val_name
                                                    } else {
                                                        SCXTNUM_EL1 = val_name
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b010 then {
                        if CRm == 0x2 then {
                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                NVMem(344) = ZeroExtend(slice(val_name, 0, 32))
                            } else {
                                MDSCR_EL1 = ZeroExtend(slice(val_name, 0, 32))
                            }
                        } else {
                            if CRm == 0x0 then {
                                OSDTRRX_EL1 = slice(val_name, 0, 32)
                            } else {
                                if CRm == 0x6 then {
                                    OSECCR_EL1 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x3 then {
                                        OSDTRTX_EL1 = slice(val_name, 0, 32)
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x2 then {
                            if op2 == 0b000 then {
                                MDCCINT_EL1 = slice(val_name, 0, 32)
                            }
                        }
                    }
                } else {
                    if op2 == 0b100 then {
                        if CRn == 0x1 then {
                            if CRm == 0x0 then {
                                OSLAR_EL1 = slice(val_name, 0, 32)
                            } else {
                                if CRm == 0x4 then {
                                    DBGPRCR_EL1 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x3 then {
                                        OSDLR_EL1 = slice(val_name, 0, 32)
                                    }
                                }
                            }
                        }
                    } else {
                        if CRn == 0x7 then {
                            if op2 == 0b110 then {
                                if CRm == 0x8 then {
                                    DBGCLAIMSET_EL1 = slice(val_name, 0, 32)
                                } else {
                                    if CRm == 0x9 then {
                                        DBGCLAIMCLR_EL1 = slice(val_name, 0, 32)
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if CRn == 0x0 then {
                        if op1 == 0b011 then {
                            if CRm == 0x5 then {
                                DBGDTRTX_EL0 = slice(val_name, 0, 32)
                            } else {
                                if CRm == 0x4 then {
                                    DBGDTR_EL0 = val_name
                                }
                            }
                        } else {
                            if op1 == 0b100 then {
                                if CRm == 0x7 then {
                                    DBGVCR32_EL2 = slice(val_name, 0, 32)
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if CRn == 0x4 then {
                if op0 == 0b00 then {
                    if op1 == 0b011 then {
                        if op2 == 0b010 then {
                            set_DIT(slice(val_name, 0, 32))
                        } else {
                            if op2 == 0b111 then {
                                set_DAIF(slice(val_name, 0, 32))
                            } else {
                                if op2 == 0b001 then {
                                    set_SSBS(slice(val_name, 0, 32))
                                } else {
                                    if op2 == 0b100 then {
                                        set_TCO(slice(val_name, 0, 32))
                                    } else {
                                        if op2 == 0b110 then {
                                            set_DAIF(slice(val_name, 0, 32))
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b000 then {
                            if op2 == 0b101 then {
                                set_SPSel(slice(val_name, 0, 32))
                            } else {
                                if op2 == 0b011 then {
                                    set_UAO(slice(val_name, 0, 32))
                                } else {
                                    if op2 == 0b100 then {
                                        set_PAN(slice(val_name, 0, 32))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

val AArch64_SysRegWrite : forall 'op0 'op1 'crn 'crm 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_SysRegWrite (op0, op1, crn, crm, op2, val_name) = {
    AArch64_AutoGen_SysRegWrite(PSTATE.EL, __GetSlice_int(2, op0, 0), __GetSlice_int(3, op1, 0), __GetSlice_int(4, crn, 0), __GetSlice_int(3, op2, 0), __GetSlice_int(4, crm, 0), 0b0, val_name);
    if ((((op0 == 3 & crn == 12) & ((op1 == 6 | op1 == 4) | op1 == 0)) & op2 == 2) & crm == 0) & [val_name[1]] == 0b1 then {
        TakeReset(false)
    };
    return()
}

val integer_tags_mcsettagpre : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpre (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        let 'tag_granule = TAG_GRANULE;
        assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpre_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpre_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettagpre(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpost : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpost (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        let 'tag_granule = TAG_GRANULE;
        assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpost_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpost_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettagpost(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpairpre : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairpre (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpairpre_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairpre_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettagpairpre(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpairpost : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairpost (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpairpost_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairpost_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettagpairpost(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpairandzerodatapre : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodatapre (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpairandzerodatapre_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodatapre_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagpairandzerodatapre(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpairandzerodatapost : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodatapost (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpairandzerodatapost_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodatapost_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagpairandzerodatapost(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpairandzerodata : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodata (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpairandzerodata_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpairandzerodata_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagpairandzerodata(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagpair : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpair (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    tag : bits(4) = undefined : bits(4);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule));
        aset_Mem(address + tag_granule, tag_granule, AccType_NORMAL, Zeros(8 * tag_granule))
    };
    let tag = AllocationTagFromAddress(address);
    aset_MemTag(address, tag);
    aset_MemTag(address + tag_granule, tag);
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagpair_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagpair_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettagpair(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagandzerodatapre : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodatapre (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    let 'tag_granule = TAG_GRANULE;
    assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagandzerodatapre_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodatapre_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = false;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagandzerodatapre(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagandzerodatapost : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodatapost (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        let 'tag_granule = TAG_GRANULE;
        assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagandzerodatapost_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodatapost_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = true;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagandzerodatapost(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettagandzerodata : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodata (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        let 'tag_granule = TAG_GRANULE;
        assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettagandzerodata_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettagandzerodata_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = true;
    __PostDecode();
    integer_tags_mcsettagandzerodata(n, offset, postindex, writeback, zero_data)
}

val integer_tags_mcsettaganddatapairpre : forall 'n 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31).
  (int('n), bits(64), bool, int('t), int('t2), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapairpre (n, offset, postindex, t, t2, writeback) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data1 : bits(64) = aget_X(t);
    let data2 : bits(64) = aget_X(t2);
    if ~(postindex) then {
        address = address + offset
    };
    aset_Mem(address, 8, AccType_NORMAL, data1);
    aset_Mem(address + 8, 8, AccType_NORMAL, data2);
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettaganddatapairpre_decode : (bits(5), bits(5), bits(5), bits(7)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapairpre_decode (Xt, Xn, Xt2, simm7) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let 't2 = UInt(Xt2);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(simm7, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = false;
    __PostDecode();
    integer_tags_mcsettaganddatapairpre(n, offset, postindex, t, t2, writeback)
}

val integer_tags_mcsettaganddatapairpost : forall 'n 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31).
  (int('n), bits(64), bool, int('t), int('t2), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapairpost (n, offset, postindex, t, t2, writeback) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data1 : bits(64) = aget_X(t);
    let data2 : bits(64) = aget_X(t2);
    if ~(postindex) then {
        address = address + offset
    };
    aset_Mem(address, 8, AccType_NORMAL, data1);
    aset_Mem(address + 8, 8, AccType_NORMAL, data2);
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettaganddatapairpost_decode : (bits(5), bits(5), bits(5), bits(7)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapairpost_decode (Xt, Xn, Xt2, simm7) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let 't2 = UInt(Xt2);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(simm7, 64), log2_tag_granule);
    let writeback : bool = true;
    let postindex : bool = true;
    __PostDecode();
    integer_tags_mcsettaganddatapairpost(n, offset, postindex, t, t2, writeback)
}

val integer_tags_mcsettaganddatapair : forall 'n 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31).
  (int('n), bits(64), bool, int('t), int('t2), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapair (n, offset, postindex, t, t2, writeback) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data1 : bits(64) = aget_X(t);
    let data2 : bits(64) = aget_X(t2);
    if ~(postindex) then {
        address = address + offset
    };
    aset_Mem(address, 8, AccType_NORMAL, data1);
    aset_Mem(address + 8, 8, AccType_NORMAL, data2);
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettaganddatapair_decode : (bits(5), bits(5), bits(5), bits(7)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettaganddatapair_decode (Xt, Xn, Xt2, simm7) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let 't = UInt(Xt);
    let 't2 = UInt(Xt2);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(simm7, 64), log2_tag_granule);
    let writeback : bool = false;
    let postindex : bool = false;
    __PostDecode();
    integer_tags_mcsettaganddatapair(n, offset, postindex, t, t2, writeback)
}

val integer_tags_mcsettag : forall ('n : Int), ('n >= 0 & 'n <= 31).
  (int('n), bits(64), bool, bool, bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettag (n, offset, postindex, writeback, zero_data) = {
    address : bits(64) = undefined : bits(64);
    SetNotTagCheckedInstruction(true);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    if zero_data then {
        let 'tag_granule = TAG_GRANULE;
        assert(constraint('tag_granule in {1, 2, 4, 8, 16}));
        aset_Mem(address, tag_granule, AccType_NORMAL, Zeros(tag_granule * 8))
    };
    aset_MemTag(address, AllocationTagFromAddress(address));
    if writeback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val integer_tags_mcsettag_decode : (bits(5), bits(5), bits(9)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function integer_tags_mcsettag_decode (Rt, Xn, imm9) = {
    __unconditional = true;
    let 'n = UInt(Xn);
    let log2_tag_granule = LOG2_TAG_GRANULE;
    assert(log2_tag_granule >= 0);
    let offset : bits(64) = LSL(SignExtend(imm9, 64), log2_tag_granule);
    let writeback : bool = false;
    let postindex : bool = false;
    let zero_data : bool = false;
    __PostDecode();
    integer_tags_mcsettag(n, offset, postindex, writeback, zero_data)
}

val aget_Mem : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccType) -> bits(8 * 'size) effect {escape, rmem, rreg, undef, wmem, wreg}

function aget_Mem (address, size, acctype) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    value_name : bits(8 * 'size) = undefined : bits('size * 8);
    let iswrite = false;
    aligned : bool = undefined : bool;
    aligned = AArch64_CheckAlignment(address, size, acctype, iswrite);
    atomic : bool = undefined : bool;
    if size != 16 | ~(acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
        atomic = aligned
    } else {
        atomic = address == Align(address, 8)
    };
    c : Constraint = undefined : Constraint;
    if ~(atomic) then {
        assert(size > 1);
        value_name = __SetSlice_bits(8 * size, 8, value_name, 0, MemSingle(address, 1, acctype, aligned));
        if ~(aligned) then {
            c = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
            assert(c == Constraint_FAULT | c == Constraint_NONE);
            if c == Constraint_NONE then {
                aligned = true
            }
        };
        foreach (i from 1 to (size - 1) by 1 in inc) {
            value_name = __SetSlice_bits(8 * size, 8, value_name, 8 * i, MemSingle(address + i, 1, acctype, aligned))
        }
    } else {
        if size == 16 & (acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
            value_name = __SetSlice_bits(8 * size, 64, value_name, 0, MemSingle(address, 8, acctype, aligned));
            value_name = __SetSlice_bits(8 * size, 64, value_name, 64, MemSingle(address + 8, 8, acctype, aligned))
        } else {
            value_name = MemSingle(address, size, acctype, aligned)
        }
    };
    if (HaveNV2Ext() & acctype == AccType_NV2REGISTER) & [SCTLR_EL2[25]] == 0b1 | BigEndian() then {
        value_name = BigEndianReverse(value_name)
    };
    value_name
}

overload Mem = {aget_Mem}

val semihost_readparam : forall ('index : Int).
  int('index) -> bits(64) effect {escape, rmem, rreg, undef, wmem, wreg}

function semihost_readparam index = {
    let base = semihost_arg(1);
    let data : bits(64) = Mem(base + index * 8, 8, AccType_NORMAL);
    data
}

val semihost : unit -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function semihost () = {
    let 'op = UInt(semihost_arg(0));
    ret : int = undefined : int;
    match op {
      1 => {
          let namep = semihost_readparam(0);
          let mode = semihost_readparam(1);
          let 'len = UInt(semihost_readparam(2));
          handle : int = undefined : int;
          let acc : bits(2) = slice(mode, 2, 2);
          if acc == MODE_R then {
              handle = STDIN_HANDLE
          } else {
              if acc == MODE_A then {
                  handle = STDERR_HANDLE
              } else {
                  if acc == MODE_W then {
                      handle = STDOUT_HANDLE
                  } else {
                      handle = 0
                  }
              }
          };
          semihost_ret(__GetSlice_int(64, handle, 0))
      },
      2 => {
          let 'handle = UInt(semihost_readparam(0));
          let 'ret = 0;
          semihost_ret(__GetSlice_int(64, ret, 0))
      },
      3 => {
          let buffer = semihost_arg(1);
          let data : bits(8) = Mem(buffer, 1, AccType_NORMAL);
          putchar(UInt(data))
      },
      4 => {
          buffer : bits(64) = semihost_arg(1);
          data : bits(8) = Mem(buffer, 1, AccType_NORMAL);
          while UInt(data) != 0 do {
              buffer = buffer + 1;
              putchar(UInt(data));
              data = Mem(buffer, 1, AccType_NORMAL)
          }
      },
      5 => {
          let 'handle = UInt(semihost_readparam(0));
          let buffer = semihost_readparam(1);
          let 'len = UInt(semihost_readparam(2));
          ret : int = 0;
          if handle == STDOUT_HANDLE | handle == STDERR_HANDLE then {
              foreach (i from 0 to (len - 1) by 1 in inc) {
                  let data : bits(8) = Mem(buffer + i, 1, AccType_NORMAL);
                  putchar(UInt(data))
              };
              ret = 0
          } else {
              ret = negate(1)
          };
          semihost_ret(__GetSlice_int(64, ret, 0))
      },
      9 => {
          let 'handle = UInt(semihost_readparam(0));
          let 'istty = 1;
          semihost_ret(__GetSlice_int(64, istty, 0))
      },
      16 => {
          semihost_ret(__GetSlice_int(64, RoundTowardsZero(Real(UInt(semihost_clock)) / 10.0), 0))
      },
      19 => {
          let 'errnum = 0;
          semihost_ret(__GetSlice_int(64, errnum, 0))
      },
      21 => {
          let buffer = semihost_readparam(0);
          let 'length = UInt(semihost_readparam(1));
          if length >= 7 then {
              Mem(buffer + 0, 1, AccType_NORMAL) = __GetSlice_int(8, 97, 0);
              Mem(buffer + 1, 1, AccType_NORMAL) = __GetSlice_int(8, 114, 0);
              Mem(buffer + 2, 1, AccType_NORMAL) = __GetSlice_int(8, 99, 0);
              Mem(buffer + 3, 1, AccType_NORMAL) = __GetSlice_int(8, 104, 0);
              Mem(buffer + 4, 1, AccType_NORMAL) = __GetSlice_int(8, 101, 0);
              Mem(buffer + 5, 1, AccType_NORMAL) = __GetSlice_int(8, 120, 0);
              Mem(buffer + 6, 1, AccType_NORMAL) = __GetSlice_int(8, 32, 0);
              Mem(buffer + 7, 1, AccType_NORMAL) = __GetSlice_int(8, 0, 0);
              semihost_writeparam(1, __GetSlice_int(64, 7, 0));
              ret = 0
          } else {
              ret = negate(1)
          };
          semihost_ret(__GetSlice_int(64, ret, 0))
      },
      22 => {
          let buffer = semihost_readparam(0);
          Mem(buffer + 0, 8, AccType_NORMAL) = HEAP_BASE;
          Mem(buffer + 8, 8, AccType_NORMAL) = HEAP_LIMIT;
          Mem(buffer + 16, 8, AccType_NORMAL) = STACK_BASE;
          Mem(buffer + 24, 8, AccType_NORMAL) = STACK_LIMIT;
          semihost_ret(__GetSlice_int(64, 0, 0))
      },
      24 => {
          let 'excep = UInt(semihost_readparam(0));
          let 'ecode = UInt(semihost_readparam(1));
          match excep {
            131110 => {
                exit(())
            },
            _ => {
                prerr("unhandled semihost exception " ++ HexStr(op) ++ "\n")
            }
          }
      },
      48 => {
          semihost_ret(slice(semihost_clock, 0, 64))
      },
      49 => {
          semihost_ret(__GetSlice_int(64, 1000, 0))
      },
      _ => {
          prerr("semihosting: unknown opcode " ++ DecStr(op) ++ "\n");
          assert(false)
      }
    }
}

val system_exceptions_debug_halt_decode : (bits(2), bits(3), bits(16), bits(3)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function system_exceptions_debug_halt_decode (LL, op2, imm16, opc) = {
    if imm16 == 0xF000 then {
        semihost()
    } else {
        default_system_exceptions_debug_halt_decode(LL, op2, imm16, opc)
    };
    return()
}

val aget_NVMem : forall ('offset : Int).
  int('offset) -> bits(64) effect {escape, rmem, rreg, undef, wmem, wreg}

function aget_NVMem offset = {
    base : bits(52) = undefined : bits(52);
    if [VNCR_EL2[52]] == 0b1 then {
        base = Ones(11) @ slice(VNCR_EL2, 12, 41)
    } else {
        base = Zeros(11) @ slice(VNCR_EL2, 12, 41)
    };
    let address : bits(64) = base @ __GetSlice_int(12, offset, 0);
    Mem(address, 8, AccType_NV2REGISTER)
}

overload NVMem = {aget_NVMem}

val AArch64_AutoGen_SysRegRead : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1)) -> bits(64) effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_AutoGen_SysRegRead (el, op0, op1, CRn, op2, CRm, read) = {
    let __HCR_EL2_NV1 = [HCR_EL2[43]];
    let __HCR_EL2_FMO = [HCR_EL2[3]];
    let __HCR_EL2_NV2 = [HCR_EL2[45]];
    let __HCR_EL2_E2H = [HCR_EL2[34]];
    let __HCR_EL2_TGE = [HCR_EL2[27]];
    let __SCR_EL3_EEL2 = [SCR_EL3[18]];
    let __SCR_EL3_NS = [SCR_EL3[0]];
    let __HCR_EL2_IMO = [HCR_EL2[4]];
    let __HCR_EL2_NV = [HCR_EL2[42]];
    if (CRm & 0x0) == 0x0 then {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b101 then {
                        return(ZeroExtend(DBGBCR_EL1[UInt(slice(CRm, 0, 4))]))
                    } else {
                        if op2 == 0b111 then {
                            return(ZeroExtend(DBGWCR_EL1[UInt(slice(CRm, 0, 4))]))
                        } else {
                            if op2 == 0b100 then {
                                return(DBGBVR_EL1[UInt(slice(CRm, 0, 4))])
                            } else {
                                if op2 == 0b110 then {
                                    return(DBGWVR_EL1[UInt(slice(CRm, 0, 4))])
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b000) == 0b000 then {
        if (CRm & 0xC) == 0x8 then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        return(ZeroExtend(PMEVCNTR_EL0[UInt(slice(CRm, 0, 2) @ slice(op2, 0, 3))]))
                    }
                }
            }
        };
        if (CRm & 0xC) == 0xC then {
            if CRn == 0xE then {
                if op1 == 0b011 then {
                    if op0 == 0b11 then {
                        return(ZeroExtend(PMEVTYPER_EL0[UInt(slice(CRm, 0, 2) @ slice(op2, 0, 3))]))
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b100 then {
        if CRm == 0x8 then {
            if CRn == 0xC then {
                if op1 == 0b000 then {
                    if op0 == 0b11 then {
                        if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            return(ZeroExtend(ICV_AP0R_EL1[UInt(slice(op2, 0, 2))]))
                        } else {
                            return(ZeroExtend(ICC_AP0R_EL1[UInt(slice(op2, 0, 2))]))
                        }
                    }
                }
            }
        }
    };
    if (op2 & 0b100) == 0b000 then {
        if CRn == 0xC then {
            if op0 == 0b11 then {
                if op1 == 0b100 then {
                    if CRm == 0x8 then {
                        if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                            return(ZeroExtend(NVMem(1152 + 8 * UInt(slice(op2, 0, 2)))))
                        } else {
                            return(ZeroExtend(ICH_AP0R_EL2[UInt(slice(op2, 0, 2))]))
                        }
                    } else {
                        if CRm == 0x9 then {
                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                return(ZeroExtend(NVMem(1184 + 8 * UInt(slice(op2, 0, 2)))))
                            } else {
                                return(ZeroExtend(ICH_AP1R_EL2[UInt(slice(op2, 0, 2))]))
                            }
                        }
                    }
                } else {
                    if op1 == 0b000 then {
                        if CRm == 0x9 then {
                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                return(ZeroExtend(ICV_AP1R_EL1[UInt(slice(op2, 0, 2))]))
                            } else {
                                if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                    return(ZeroExtend(ICC_AP1R_EL1[UInt(slice(op2, 0, 2))]))
                                } else {
                                    return(ZeroExtend(ICC_AP1R_EL1[UInt(slice(op2, 0, 2))]))
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    if op0 == 0b11 then {
        if op2 == 0b000 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if CRm == 0x0 then {
                        return(ZeroExtend(MIDR_EL1))
                    } else {
                        if CRm == 0x1 then {
                            return(ZeroExtend(ID_PFR0_EL1))
                        } else {
                            if CRm == 0x2 then {
                                return(ZeroExtend(ID_ISAR0_EL1))
                            } else {
                                if CRm == 0x5 then {
                                    return(ID_AA64DFR0_EL1)
                                } else {
                                    if CRm == 0x4 then {
                                        return(ID_AA64PFR0_EL1)
                                    } else {
                                        if CRm == 0x6 then {
                                            return(ID_AA64ISAR0_EL1)
                                        } else {
                                            if CRm == 0x7 then {
                                                return(ID_AA64MMFR0_EL1)
                                            } else {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(MVFR0_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                return(VBAR_EL2)
                            } else {
                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    return(NVMem(592))
                                } else {
                                    return(VBAR_EL1)
                                }
                            }
                        } else {
                            if CRn == 0x1 then {
                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                    return(SCTLR_EL2)
                                } else {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(NVMem(272))
                                    } else {
                                        return(SCTLR_EL1)
                                    }
                                }
                            } else {
                                if CRn == 0x6 then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(FAR_EL2)
                                    } else {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(NVMem(544))
                                        } else {
                                            return(FAR_EL1)
                                        }
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(ZeroExtend(SPSR_EL2))
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(NVMem(352)))
                                            } else {
                                                return(ZeroExtend(SPSR_EL1))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(TTBR0_EL2)
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(512))
                                                } else {
                                                    return(TTBR0_EL1)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xC then {
                                return(ZeroExtend(ISR_EL1))
                            } else {
                                if CRn == 0xE then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(ZeroExtend(CNTHCTL_EL2))
                                    } else {
                                        return(ZeroExtend(CNTKCTL_EL1))
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        return(SP_EL0)
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(AFSR0_EL2))
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(296)))
                                                } else {
                                                    return(ZeroExtend(AFSR0_EL1))
                                                }
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                return(APIAKeyLo_EL1)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x2 then {
                                if CRn == 0x4 then {
                                    return(ZeroExtend(get_SPSel()))
                                } else {
                                    if CRn == 0xA then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(MAIR_EL2)
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(320))
                                            } else {
                                                return(MAIR_EL1)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(ESR_EL2))
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(312)))
                                                } else {
                                                    return(ZeroExtend(ESR_EL1))
                                                }
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                return(APDAKeyLo_EL1)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x5 then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(MPAM2_EL2)
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(2304))
                                            } else {
                                                return(MPAM1_EL1)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            return(LORSA_EL1)
                                        } else {
                                            if CRm == 0x3 then {
                                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(AMAIR_EL2)
                                                } else {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(328))
                                                    } else {
                                                        return(AMAIR_EL1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if CRm == 0x8 then {
                                            if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(ICV_IAR0_EL1))
                                            } else {
                                                return(ZeroExtend(ICC_IAR0_EL1))
                                            }
                                        } else {
                                            if CRm == 0xC then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(ICV_IAR1_EL1))
                                                } else {
                                                    return(ZeroExtend(ICC_IAR1_EL1))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x7 then {
                                            if CRm == 0x4 then {
                                                return(PAR_EL1)
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if CRm == 0x6 then {
                                                    if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(ICV_PMR_EL1))
                                                    } else {
                                                        return(ZeroExtend(ICC_PMR_EL1))
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(ZeroExtend(NVMem(400)))
                                                        } else {
                                                            return(ZeroExtend(TFSR_EL1))
                                                        }
                                                    }
                                                } else {
                                                    if CRn == 0x2 then {
                                                        if CRm == 0x3 then {
                                                            return(APGAKeyLo_EL1)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op1 == 0b100 then {
                    if CRm == 0x0 then {
                        if CRn == 0xC then {
                            return(VBAR_EL2)
                        } else {
                            if CRn == 0x4 then {
                                return(ZeroExtend(SPSR_EL2))
                            } else {
                                if CRn == 0x3 then {
                                    return(ZeroExtend(DACR32_EL2))
                                } else {
                                    if CRn == 0x6 then {
                                        return(FAR_EL2)
                                    } else {
                                        if CRn == 0x1 then {
                                            return(SCTLR_EL2)
                                        } else {
                                            if CRn == 0x0 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(136)))
                                                } else {
                                                    return(ZeroExtend(VPIDR_EL2))
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    return(TTBR0_EL2)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x1 then {
                            if CRn == 0xE then {
                                return(ZeroExtend(CNTHCTL_EL2))
                            } else {
                                if CRn == 0x1 then {
                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(NVMem(120))
                                    } else {
                                        return(HCR_EL2)
                                    }
                                } else {
                                    if CRn == 0x4 then {
                                        if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(NVMem(576))
                                        } else {
                                            return(SP_EL1)
                                        }
                                    } else {
                                        if CRn == 0x5 then {
                                            return(ZeroExtend(AFSR0_EL2))
                                        } else {
                                            if CRn == 0x2 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(32))
                                                } else {
                                                    return(VTTBR_EL2)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xA then {
                                if CRm == 0x2 then {
                                    return(MAIR_EL2)
                                } else {
                                    if CRm == 0x5 then {
                                        return(MPAM2_EL2)
                                    } else {
                                        if CRm == 0x4 then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(NVMem(2352)))
                                            } else {
                                                return(ZeroExtend(MPAMHCR_EL2))
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(2368))
                                                } else {
                                                    return(MPAMVPM0_EL2)
                                                }
                                            } else {
                                                if CRm == 0x3 then {
                                                    return(AMAIR_EL2)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xE then {
                                    if CRm == 0x2 then {
                                        return(ZeroExtend(CNTHP_TVAL_EL2))
                                    } else {
                                        if CRm == 0x5 then {
                                            return(ZeroExtend(CNTHPS_TVAL_EL2))
                                        } else {
                                            if CRm == 0x4 then {
                                                return(ZeroExtend(CNTHVS_TVAL_EL2))
                                            } else {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(CNTHV_TVAL_EL2))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0x5 then {
                                        if CRm == 0x2 then {
                                            return(ZeroExtend(ESR_EL2))
                                        } else {
                                            if CRm == 0x3 then {
                                                return(ZeroExtend(FPEXC32_EL2))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x2 then {
                                            if CRm == 0x2 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(176))
                                                } else {
                                                    return(VNCR_EL2)
                                                }
                                            } else {
                                                if CRm == 0x6 then {
                                                    if ((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0 then {
                                                        return(NVMem(48))
                                                    } else {
                                                        return(VSTTBR_EL2)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0xB then {
                                                    if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(NVMem(1216)))
                                                    } else {
                                                        return(ZeroExtend(ICH_HCR_EL2))
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        return(ZeroExtend(TFSR_EL2))
                                                    }
                                                } else {
                                                    if CRn == 0x4 then {
                                                        if CRm == 0x3 then {
                                                            return(ZeroExtend(SPSR_irq))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if CRn == 0xF then {
                            if CRm == 0x0 then {
                                return(ESP_EL0)
                            } else {
                                if CRm == 0x2 then {
                                    return(ZeroExtend(SPSR_EL0))
                                } else {
                                    if CRm == 0x5 then {
                                        return(VBAR_EL0)
                                    } else {
                                        if CRm == 0x1 then {
                                            return(ELR_EL0)
                                        } else {
                                            if CRm == 0x4 then {
                                                return(FAR_EL0)
                                            } else {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(ESR_EL0))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x4 then {
                                if CRm == 0x2 then {
                                    return(ZeroExtend(get_NZCV()))
                                } else {
                                    if CRm == 0x5 then {
                                        return(ZeroExtend(DSPSR_EL0))
                                    } else {
                                        if CRm == 0x4 then {
                                            return(ZeroExtend(FPCR))
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x9 then {
                                    if CRm == 0xD then {
                                        return(PMCCNTR_EL0)
                                    } else {
                                        if CRm == 0xE then {
                                            return(ZeroExtend(PMUSERENR_EL0))
                                        } else {
                                            if CRm == 0xC then {
                                                return(ZeroExtend(PMCR_EL0))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(CNTHP_TVAL_EL2))
                                            } else {
                                                return(ZeroExtend(CNTP_TVAL_EL0))
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                return(ZeroExtend(CNTFRQ_EL0))
                                            } else {
                                                if CRm == 0x3 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(CNTHV_TVAL_EL2))
                                                    } else {
                                                        return(ZeroExtend(CNTV_TVAL_EL0))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x4 then {
                                            if CRn == 0x2 then {
                                                return(RNDR);
                                                return(RNDRRS)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op1 == 0b101 then {
                            if CRm == 0x0 then {
                                if CRn == 0xC then {
                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(NVMem(592))
                                    } else {
                                        return(VBAR_EL1)
                                    }
                                } else {
                                    if CRn == 0x2 then {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(NVMem(512))
                                        } else {
                                            return(TTBR0_EL1)
                                        }
                                    } else {
                                        if CRn == 0x6 then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(544))
                                            } else {
                                                return(FAR_EL1)
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(272))
                                                } else {
                                                    return(SCTLR_EL1)
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(NVMem(352)))
                                                    } else {
                                                        return(ZeroExtend(SPSR_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0xE then {
                                        return(ZeroExtend(CNTP_TVAL_EL0))
                                    } else {
                                        if CRn == 0xA then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(320))
                                            } else {
                                                return(MAIR_EL1)
                                            }
                                        } else {
                                            if CRn == 0x5 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(312)))
                                                } else {
                                                    return(ZeroExtend(ESR_EL1))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0xE then {
                                            return(ZeroExtend(CNTKCTL_EL1))
                                        } else {
                                            if CRn == 0x5 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(296)))
                                                } else {
                                                    return(ZeroExtend(AFSR0_EL1))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if CRn == 0x6 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(400)))
                                                } else {
                                                    return(ZeroExtend(TFSR_EL1))
                                                }
                                            } else {
                                                if CRn == 0xA then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(2304))
                                                    } else {
                                                        return(MPAM1_EL1)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x3 then {
                                                if CRn == 0xE then {
                                                    return(ZeroExtend(CNTV_TVAL_EL0))
                                                } else {
                                                    if CRn == 0xA then {
                                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(NVMem(328))
                                                        } else {
                                                            return(AMAIR_EL1)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b110 then {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        return(VBAR_EL3)
                                    } else {
                                        if CRn == 0x4 then {
                                            return(ZeroExtend(SPSR_EL3))
                                        } else {
                                            if CRn == 0x6 then {
                                                return(FAR_EL3)
                                            } else {
                                                if CRn == 0x1 then {
                                                    return(SCTLR_EL3)
                                                } else {
                                                    if CRn == 0x2 then {
                                                        return(TTBR0_EL3)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            return(ZeroExtend(SCR_EL3))
                                        } else {
                                            if CRn == 0x4 then {
                                                return(SP_EL2)
                                            } else {
                                                if CRn == 0x5 then {
                                                    return(ZeroExtend(AFSR0_EL3))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x2 then {
                                                return(MAIR_EL3)
                                            } else {
                                                if CRm == 0x5 then {
                                                    return(MPAM3_EL3)
                                                } else {
                                                    if CRm == 0x3 then {
                                                        return(AMAIR_EL3)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x5 then {
                                                    return(ZeroExtend(ESR_EL3))
                                                }
                                            } else {
                                                if CRm == 0x5 then {
                                                    if CRn == 0x6 then {
                                                        return(ZeroExtend(TFSR_EL3))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0x0 then {
                                        if op1 == 0b010 then {
                                            return(ZeroExtend(CSSELR_EL1))
                                        } else {
                                            if op1 == 0b001 then {
                                                return(CCSIDR_EL1)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if op1 == 0b111 then {
                                                return(ZeroExtend(CNTPS_TVAL_EL1))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if CRm == 0x1 then {
                        if op2 == 0b010 then {
                            return(ZeroExtend(ID_DFR0_EL1))
                        } else {
                            if op2 == 0b011 then {
                                return(ZeroExtend(ID_AFR0_EL1))
                            } else {
                                if op2 == 0b101 then {
                                    return(ZeroExtend(ID_MMFR1_EL1))
                                } else {
                                    if op2 == 0b111 then {
                                        return(ZeroExtend(ID_MMFR3_EL1))
                                    } else {
                                        if op2 == 0b001 then {
                                            return(ZeroExtend(ID_PFR1_EL1))
                                        } else {
                                            if op2 == 0b100 then {
                                                return(ZeroExtend(ID_MMFR0_EL1))
                                            } else {
                                                if op2 == 0b110 then {
                                                    return(ZeroExtend(ID_MMFR2_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x2 then {
                            if op2 == 0b010 then {
                                return(ZeroExtend(ID_ISAR2_EL1))
                            } else {
                                if op2 == 0b011 then {
                                    return(ZeroExtend(ID_ISAR3_EL1))
                                } else {
                                    if op2 == 0b101 then {
                                        return(ZeroExtend(ID_ISAR5_EL1))
                                    } else {
                                        if op2 == 0b111 then {
                                            return(ZeroExtend(ID_ISAR6_EL1))
                                        } else {
                                            if op2 == 0b001 then {
                                                return(ZeroExtend(ID_ISAR1_EL1))
                                            } else {
                                                if op2 == 0b100 then {
                                                    return(ZeroExtend(ID_ISAR4_EL1))
                                                } else {
                                                    if op2 == 0b110 then {
                                                        return(ZeroExtend(ID_MMFR4_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b001 then {
                                if CRm == 0x5 then {
                                    return(ZeroExtend(ID_AA64DFR1_EL1))
                                } else {
                                    if CRm == 0x4 then {
                                        return(ZeroExtend(ID_AA64PFR1_EL1))
                                    } else {
                                        if CRm == 0x6 then {
                                            return(ID_AA64ISAR1_EL1)
                                        } else {
                                            if CRm == 0x7 then {
                                                return(ZeroExtend(ID_AA64MMFR1_EL1))
                                            } else {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(MVFR1_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b010 then {
                                    if CRm == 0x7 then {
                                        return(ID_AA64MMFR2_EL1)
                                    } else {
                                        if CRm == 0x3 then {
                                            return(ZeroExtend(MVFR2_EL1))
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if op2 == 0b101 then {
                                            return(MPIDR_EL1)
                                        } else {
                                            if op2 == 0b110 then {
                                                return(ZeroExtend(REVIDR_EL1))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if op2 == 0b101 then {
                                                return(ZeroExtend(ID_AA64AFR1_EL1))
                                            } else {
                                                if op2 == 0b100 then {
                                                    return(ZeroExtend(ID_AA64AFR0_EL1))
                                                }
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(ID_PFR2_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            if CRn == 0xC then {
                                return(RVBAR_EL1)
                            } else {
                                if CRn == 0x4 then {
                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(ELR_EL2)
                                    } else {
                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(NVMem(560))
                                        } else {
                                            return(ELR_EL1)
                                        }
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                            return(ZeroExtend(CONTEXTIDR_EL2))
                                        } else {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(NVMem(264)))
                                            } else {
                                                return(ZeroExtend(CONTEXTIDR_EL1))
                                            }
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(280))
                                            } else {
                                                return(ACTLR_EL1)
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(TTBR1_EL2)
                                                } else {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(528))
                                                    } else {
                                                        return(TTBR1_EL1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0x2 then {
                                if CRm == 0x2 then {
                                    return(APDAKeyHi_EL1)
                                } else {
                                    if CRm == 0x1 then {
                                        return(APIAKeyHi_EL1)
                                    } else {
                                        if CRm == 0x3 then {
                                            return(APGAKeyHi_EL1)
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0xA then {
                                    if CRm == 0x5 then {
                                        return(MPAM0_EL1)
                                    } else {
                                        if CRm == 0x4 then {
                                            return(LOREA_EL1)
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x5 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(AFSR1_EL2))
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(304)))
                                                } else {
                                                    return(ZeroExtend(AFSR1_EL1))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0xE then {
                                            if CRn == 0x9 then {
                                                return(ZeroExtend(PMINTENSET_EL1))
                                            }
                                        } else {
                                            if CRm == 0x2 then {
                                                if CRn == 0x1 then {
                                                    if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(TRFCR_EL2))
                                                    } else {
                                                        if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(ZeroExtend(NVMem(2176)))
                                                        } else {
                                                            return(ZeroExtend(TRFCR_EL1))
                                                        }
                                                    }
                                                }
                                            } else {
                                                if CRm == 0x6 then {
                                                    if CRn == 0x6 then {
                                                        return(ZeroExtend(TFSRE0_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b010 then {
                            if CRn == 0xC then {
                                if CRm == 0x8 then {
                                    if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                        return(ZeroExtend(ICV_HPPIR0_EL1))
                                    } else {
                                        return(ZeroExtend(ICC_HPPIR0_EL1))
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        return(ZeroExtend(RMR_EL1))
                                    } else {
                                        if CRm == 0xC then {
                                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(ICV_HPPIR1_EL1))
                                            } else {
                                                return(ZeroExtend(ICC_HPPIR1_EL1))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x2 then {
                                    if CRm == 0x2 then {
                                        return(APDBKeyLo_EL1)
                                    } else {
                                        if CRm == 0x0 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(TCR_EL2)
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(288))
                                                } else {
                                                    return(TCR_EL1)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                return(APIBKeyLo_EL1)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0x1 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(CPTR_EL2))
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(256)))
                                                } else {
                                                    return(ZeroExtend(CPACR_EL1))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0x4 then {
                                            if CRm == 0x2 then {
                                                return(ZeroExtend(get_CurrentEL()))
                                            }
                                        } else {
                                            if CRn == 0x9 then {
                                                if CRm == 0xE then {
                                                    return(ZeroExtend(PMINTENCLR_EL1))
                                                }
                                            } else {
                                                if CRm == 0x4 then {
                                                    if CRn == 0xA then {
                                                        return(ZeroExtend(LORN_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xC then {
                                if CRm == 0xC then {
                                    if op2 == 0b101 then {
                                        if (((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1 then {
                                            return(ZeroExtend(ICC_SRE_EL1_NS))
                                        } else {
                                            return(ZeroExtend(ICC_SRE_EL1_S))
                                        }
                                    } else {
                                        if op2 == 0b011 then {
                                            if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(ICV_BPR1_EL1))
                                            } else {
                                                if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                    return(ZeroExtend(ICC_BPR1_EL1_NS))
                                                } else {
                                                    return(ZeroExtend(ICC_BPR1_EL1_S))
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(ICV_IGRPEN1_EL1))
                                                } else {
                                                    if (((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                        return(ZeroExtend(ICC_IGRPEN1_EL1_NS))
                                                    } else {
                                                        return(ZeroExtend(ICC_IGRPEN1_EL1_S))
                                                    }
                                                }
                                            } else {
                                                if op2 == 0b100 then {
                                                    if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(ICV_CTLR_EL1))
                                                    } else {
                                                        if ((((((el == EL2 | el == EL3) | el == EL1) & __HCR_EL2_FMO == 0) & __HCR_EL2_IMO == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 | ((el == EL2 | el == EL3) & __HCR_EL2_TGE == 1) & __SCR_EL3_NS == 1) | (((el == EL2 | el == EL3) & (__HCR_EL2_FMO == 1 | __HCR_EL2_IMO == 1)) & __HCR_EL2_TGE == 0) & __SCR_EL3_NS == 1 then {
                                                            return(ZeroExtend(ICC_CTLR_EL1_NS))
                                                        } else {
                                                            return(ZeroExtend(ICC_CTLR_EL1_S))
                                                        }
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(ZeroExtend(ICV_IGRPEN0_EL1))
                                                        } else {
                                                            return(ZeroExtend(ICC_IGRPEN0_EL1))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if CRm == 0x8 then {
                                            if ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(ICV_BPR0_EL1))
                                            } else {
                                                return(ZeroExtend(ICC_BPR0_EL1))
                                            }
                                        } else {
                                            if CRm == 0xB then {
                                                if ((el == EL1 & __HCR_EL2_IMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL1 & __HCR_EL2_FMO == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(ICV_RPR_EL1))
                                                } else {
                                                    return(ZeroExtend(ICC_RPR_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0xD then {
                                        if op2 == 0b111 then {
                                            if ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(SCXTNUM_EL2)
                                            } else {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(392))
                                                } else {
                                                    return(SCXTNUM_EL1)
                                                }
                                            }
                                        } else {
                                            if op2 == 0b100 then {
                                                return(TPIDR_EL1)
                                            }
                                        }
                                    } else {
                                        if CRn == 0x1 then {
                                            if op2 == 0b101 then {
                                                return(ZeroExtend(RGSR_EL1))
                                            } else {
                                                if op2 == 0b110 then {
                                                    return(ZeroExtend(GCR_EL1))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if CRm == 0x2 then {
                                            if CRn == 0x4 then {
                                                return(ZeroExtend(get_PAN()))
                                            } else {
                                                if CRn == 0x2 then {
                                                    return(APDBKeyHi_EL1)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x4 then {
                                                if CRn == 0xA then {
                                                    return(ZeroExtend(LORC_EL1))
                                                }
                                            } else {
                                                if CRm == 0x1 then {
                                                    if CRn == 0x2 then {
                                                        return(APIBKeyHi_EL1)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x4 then {
                                                if op2 == 0b111 then {
                                                    return(ZeroExtend(LORID_EL1))
                                                } else {
                                                    if op2 == 0b100 then {
                                                        return(MPAMIDR_EL1)
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if CRm == 0x2 then {
                                                    if op2 == 0b100 then {
                                                        return(ZeroExtend(get_UAO()))
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x9 then {
                                                    if CRm == 0xE then {
                                                        if op2 == 0b110 then {
                                                            return(ZeroExtend(PMMIR_EL1))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op1 == 0b100 then {
                    if op2 == 0b001 then {
                        if CRm == 0x0 then {
                            if CRn == 0xC then {
                                return(RVBAR_EL2)
                            } else {
                                if CRn == 0x4 then {
                                    return(ELR_EL2)
                                } else {
                                    if CRn == 0x2 then {
                                        return(TTBR1_EL2)
                                    } else {
                                        if CRn == 0x1 then {
                                            return(ACTLR_EL2)
                                        } else {
                                            if CRn == 0x5 then {
                                                return(ZeroExtend(IFSR32_EL2))
                                            } else {
                                                if CRn == 0xD then {
                                                    return(ZeroExtend(CONTEXTIDR_EL2))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    return(ZeroExtend(CNTHP_CTL_EL2))
                                } else {
                                    if CRm == 0x5 then {
                                        return(ZeroExtend(CNTHPS_CTL_EL2))
                                    } else {
                                        if CRm == 0x4 then {
                                            return(ZeroExtend(CNTHVS_CTL_EL2))
                                        } else {
                                            if CRm == 0x3 then {
                                                return(ZeroExtend(CNTHV_CTL_EL2))
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRn == 0x1 then {
                                    if CRm == 0x2 then {
                                        return(ZeroExtend(TRFCR_EL2))
                                    } else {
                                        if CRm == 0x1 then {
                                            return(ZeroExtend(MDCR_EL2))
                                        } else {
                                            if CRm == 0x3 then {
                                                return(ZeroExtend(SDER32_EL2))
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xA then {
                                        if CRm == 0x4 then {
                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(NVMem(2360)))
                                            } else {
                                                return(ZeroExtend(MPAMVPMV_EL2))
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(2376))
                                                } else {
                                                    return(MPAMVPM1_EL2)
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                return(ZeroExtend(ICH_VTR_EL2))
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x5 then {
                                                    return(ZeroExtend(AFSR1_EL2))
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        return(ZeroExtend(SPSR_abt))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b010 then {
                            if CRn == 0xE then {
                                if CRm == 0x2 then {
                                    return(CNTHP_CVAL_EL2)
                                } else {
                                    if CRm == 0x5 then {
                                        return(CNTHPS_CVAL_EL2)
                                    } else {
                                        if CRm == 0x4 then {
                                            return(CNTHVS_CVAL_EL2)
                                        } else {
                                            if CRm == 0x3 then {
                                                return(CNTHV_CVAL_EL2)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x0 then {
                                    if CRn == 0xC then {
                                        return(ZeroExtend(RMR_EL2))
                                    } else {
                                        if CRn == 0xD then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(144))
                                            } else {
                                                return(TPIDR_EL2)
                                            }
                                        } else {
                                            if CRn == 0x2 then {
                                                return(TCR_EL2)
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x1 then {
                                        if CRn == 0x1 then {
                                            return(ZeroExtend(CPTR_EL2))
                                        } else {
                                            if CRn == 0x2 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(64)))
                                                } else {
                                                    return(ZeroExtend(VTCR_EL2))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x6 then {
                                            if CRn == 0xA then {
                                                if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(2384))
                                                } else {
                                                    return(MPAMVPM2_EL2)
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if ((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0 | (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 1) & __HCR_EL2_TGE == 0 then {
                                                        return(ZeroExtend(NVMem(72)))
                                                    } else {
                                                        return(ZeroExtend(VSTCR_EL2))
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRn == 0xC then {
                                                if CRm == 0xB then {
                                                    return(ZeroExtend(ICH_MISR_EL2))
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        return(ZeroExtend(SPSR_und))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b011 then {
                                if CRn == 0xC then {
                                    if CRm == 0xB then {
                                        return(ZeroExtend(ICH_EISR_EL2))
                                    }
                                } else {
                                    if CRm == 0x0 then {
                                        if CRn == 0xE then {
                                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(96))
                                            } else {
                                                return(CNTVOFF_EL2)
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(128)))
                                                } else {
                                                    return(ZeroExtend(HSTR_EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if CRn == 0xA then {
                                                    if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(2392))
                                                    } else {
                                                        return(MPAMVPM3_EL2)
                                                    }
                                                }
                                            } else {
                                                if CRn == 0x4 then {
                                                    if CRm == 0x3 then {
                                                        return(ZeroExtend(SPSR_fiq))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if CRn == 0xC then {
                                        if CRm == 0xB then {
                                            return(ZeroExtend(ICH_ELRSR_EL2))
                                        } else {
                                            if CRm == 0x9 then {
                                                return(ZeroExtend(ICC_SRE_EL2))
                                            }
                                        }
                                    } else {
                                        if CRm == 0x0 then {
                                            if CRn == 0x0 then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(80))
                                                } else {
                                                    return(VMPIDR_EL2)
                                                }
                                            }
                                        } else {
                                            if CRm == 0x6 then {
                                                if CRn == 0xA then {
                                                    if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(2408))
                                                    } else {
                                                        return(MPAMVPM5_EL2)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b111 then {
                                        if CRn == 0xC then {
                                            if CRm == 0xB then {
                                                if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(1224)))
                                                } else {
                                                    return(ZeroExtend(ICH_VMCR_EL2))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if CRn == 0xD then {
                                                    return(SCXTNUM_EL2)
                                                }
                                            } else {
                                                if CRm == 0x1 then {
                                                    if CRn == 0x1 then {
                                                        return(ZeroExtend(HACR_EL2))
                                                    }
                                                } else {
                                                    if CRm == 0x6 then {
                                                        if CRn == 0xA then {
                                                            if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                                return(NVMem(2424))
                                                            } else {
                                                                return(MPAMVPM7_EL2)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xA then {
                                            if CRm == 0x6 then {
                                                if op2 == 0b100 then {
                                                    if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(2400))
                                                    } else {
                                                        return(MPAMVPM4_EL2)
                                                    }
                                                } else {
                                                    if op2 == 0b110 then {
                                                        if ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | ((((el == EL1 & __HCR_EL2_NV2 == 1) & __HCR_EL2_NV == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                            return(NVMem(2416))
                                                        } else {
                                                            return(MPAMVPM6_EL2)
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            if CRm == 0x0 then {
                                                if CRn == 0x6 then {
                                                    if op2 == 0b100 then {
                                                        return(HPFAR_EL2)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if CRn == 0x9 then {
                            if CRm == 0xC then {
                                if op2 == 0b010 then {
                                    return(ZeroExtend(PMCNTENCLR_EL0))
                                } else {
                                    if op2 == 0b101 then {
                                        return(ZeroExtend(PMSELR_EL0))
                                    } else {
                                        if op2 == 0b011 then {
                                            return(ZeroExtend(PMOVSCLR_EL0))
                                        } else {
                                            if op2 == 0b111 then {
                                                return(PMCEID1_EL0)
                                            } else {
                                                if op2 == 0b001 then {
                                                    return(ZeroExtend(PMCNTENSET_EL0))
                                                } else {
                                                    if op2 == 0b110 then {
                                                        return(PMCEID0_EL0)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xD then {
                                    if op2 == 0b010 then {
                                        return(ZeroExtend(PMXEVCNTR_EL0))
                                    } else {
                                        if op2 == 0b001 then {
                                            return(ZeroExtend(PMXEVTYPER_EL0))
                                        }
                                    }
                                } else {
                                    if op2 == 0b011 then {
                                        if CRm == 0xE then {
                                            return(ZeroExtend(PMOVSSET_EL0))
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if op2 == 0b010 then {
                                    if CRn == 0xE then {
                                        return(CNTVCT_EL0)
                                    } else {
                                        if CRn == 0xF then {
                                            return(RD_EL0)
                                        } else {
                                            if CRn == 0xD then {
                                                return(TPIDR_EL0)
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xD then {
                                        if op2 == 0b011 then {
                                            return(TPIDRRO_EL0)
                                        } else {
                                            if op2 == 0b111 then {
                                                return(SCXTNUM_EL0)
                                            }
                                        }
                                    } else {
                                        if op2 == 0b001 then {
                                            if CRn == 0xE then {
                                                return(CNTPCT_EL0)
                                            } else {
                                                if CRn == 0x0 then {
                                                    return(CTR_EL0)
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if CRn == 0x0 then {
                                                    return(ZeroExtend(DCZID_EL0))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if CRn == 0x4 then {
                                        if op2 == 0b101 then {
                                            return(ZeroExtend(get_DIT()))
                                        } else {
                                            if op2 == 0b111 then {
                                                return(ZeroExtend(get_TCO()))
                                            } else {
                                                if op2 == 0b001 then {
                                                    return(ZeroExtend(get_DAIF()))
                                                } else {
                                                    if op2 == 0b110 then {
                                                        return(ZeroExtend(get_SSBS()))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b010 then {
                                            if CRn == 0xE then {
                                                if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(CNTHP_CVAL_EL2)
                                                } else {
                                                    if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                        return(NVMem(376))
                                                    } else {
                                                        return(CNTP_CVAL_EL0)
                                                    }
                                                }
                                            } else {
                                                if CRn == 0xF then {
                                                    return(ZeroExtend(RMUID_EL0))
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if op2 == 0b001 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(CNTHP_CTL_EL2))
                                                    } else {
                                                        if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                            return(ZeroExtend(NVMem(384)))
                                                        } else {
                                                            return(ZeroExtend(CNTP_CTL_EL0))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b001 then {
                                        if CRn == 0x4 then {
                                            if CRm == 0x5 then {
                                                return(DLR_EL0)
                                            } else {
                                                if CRm == 0x4 then {
                                                    return(ZeroExtend(FPSR))
                                                }
                                            }
                                        } else {
                                            if CRn == 0xE then {
                                                if CRm == 0x3 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(CNTHV_CTL_EL2))
                                                    } else {
                                                        if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                            return(ZeroExtend(NVMem(368)))
                                                        } else {
                                                            return(ZeroExtend(CNTV_CTL_EL0))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if op2 == 0b010 then {
                                                if CRm == 0x3 then {
                                                    if (((el == EL2 | el == EL0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | ((el == EL2 & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(CNTHV_CVAL_EL2)
                                                    } else {
                                                        if (((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 0) & __SCR_EL3_EEL2 == 1 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __HCR_EL2_TGE == 1) & __HCR_EL2_E2H == 1) & __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & __SCR_EL3_NS == 1 then {
                                                            return(NVMem(360))
                                                        } else {
                                                            return(CNTV_CVAL_EL0)
                                                        }
                                                    }
                                                }
                                            } else {
                                                if op2 == 0b111 then {
                                                    if CRm == 0xF then {
                                                        return(ZeroExtend(PMCCFILTR_EL0))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x0 then {
                            if op1 == 0b110 then {
                                if op2 == 0b010 then {
                                    if CRn == 0xC then {
                                        return(ZeroExtend(RMR_EL3))
                                    } else {
                                        if CRn == 0x2 then {
                                            return(ZeroExtend(TCR_EL3))
                                        } else {
                                            if CRn == 0xD then {
                                                return(TPIDR_EL3)
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b001 then {
                                        if CRn == 0xC then {
                                            return(RVBAR_EL3)
                                        } else {
                                            if CRn == 0x4 then {
                                                return(ELR_EL3)
                                            } else {
                                                if CRn == 0x1 then {
                                                    return(ACTLR_EL3)
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if CRn == 0xD then {
                                                return(SCXTNUM_EL3)
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b101 then {
                                    if op2 == 0b001 then {
                                        if CRn == 0x2 then {
                                            if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(NVMem(528))
                                            } else {
                                                return(TTBR1_EL1)
                                            }
                                        } else {
                                            if CRn == 0x4 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(560))
                                                } else {
                                                    return(ELR_EL1)
                                                }
                                            } else {
                                                if CRn == 0xD then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(NVMem(264)))
                                                    } else {
                                                        return(ZeroExtend(CONTEXTIDR_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b010 then {
                                            if CRn == 0x1 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(256)))
                                                } else {
                                                    return(ZeroExtend(CPACR_EL1))
                                                }
                                            } else {
                                                if CRn == 0x2 then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(288))
                                                    } else {
                                                        return(TCR_EL1)
                                                    }
                                                }
                                            }
                                        } else {
                                            if op2 == 0b111 then {
                                                if CRn == 0xD then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 0 | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(392))
                                                    } else {
                                                        return(SCXTNUM_EL1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b001 then {
                                        if CRn == 0x0 then {
                                            if op2 == 0b010 then {
                                                return(ZeroExtend(CCSIDR2_EL1))
                                            } else {
                                                if op2 == 0b111 then {
                                                    return(ZeroExtend(AIDR_EL1))
                                                } else {
                                                    if op2 == 0b001 then {
                                                        return(CLIDR_EL1)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b001 then {
                                if op1 == 0b101 then {
                                    if CRm == 0x2 then {
                                        if CRn == 0xE then {
                                            if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                return(ZeroExtend(NVMem(384)))
                                            } else {
                                                return(ZeroExtend(CNTP_CTL_EL0))
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(2176)))
                                                } else {
                                                    return(ZeroExtend(TRFCR_EL1))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRn == 0xE then {
                                            if CRm == 0x3 then {
                                                if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(ZeroExtend(NVMem(368)))
                                                } else {
                                                    return(ZeroExtend(CNTV_CTL_EL0))
                                                }
                                            }
                                        } else {
                                            if CRm == 0x1 then {
                                                if CRn == 0x5 then {
                                                    if (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(ZeroExtend(NVMem(304)))
                                                    } else {
                                                        return(ZeroExtend(AFSR1_EL1))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op1 == 0b110 then {
                                        if CRm == 0x1 then {
                                            if CRn == 0x1 then {
                                                return(ZeroExtend(SDER32_EL3))
                                            } else {
                                                if CRn == 0x5 then {
                                                    return(ZeroExtend(AFSR1_EL3))
                                                }
                                            }
                                        } else {
                                            if CRn == 0x1 then {
                                                if CRm == 0x3 then {
                                                    return(ZeroExtend(MDCR_EL3))
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x2 then {
                                            if CRn == 0xE then {
                                                if op1 == 0b111 then {
                                                    return(ZeroExtend(CNTPS_CTL_EL1))
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b010 then {
                                    if CRn == 0xE then {
                                        if CRm == 0x2 then {
                                            if op1 == 0b101 then {
                                                if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                    return(NVMem(376))
                                                } else {
                                                    return(CNTP_CVAL_EL0)
                                                }
                                            } else {
                                                if op1 == 0b111 then {
                                                    return(CNTPS_CVAL_EL1)
                                                }
                                            }
                                        } else {
                                            if op1 == 0b101 then {
                                                if CRm == 0x3 then {
                                                    if ((((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0 | ((((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __SCR_EL3_NS == 0) & __SCR_EL3_EEL2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1)) | (((((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV1 == 0) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & __HCR_EL2_E2H == 1) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                                        return(NVMem(360))
                                                    } else {
                                                        return(CNTV_CVAL_EL0)
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x1 then {
                                            if op1 == 0b110 then {
                                                if CRn == 0x1 then {
                                                    return(ZeroExtend(CPTR_EL3))
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRn == 0xC then {
                                        if op1 == 0b110 then {
                                            if CRm == 0xC then {
                                                if op2 == 0b101 then {
                                                    return(ZeroExtend(ICC_SRE_EL3))
                                                } else {
                                                    if op2 == 0b111 then {
                                                        return(ZeroExtend(ICC_IGRPEN1_EL3))
                                                    } else {
                                                        if op2 == 0b100 then {
                                                            return(ZeroExtend(ICC_CTLR_EL3))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if op0 == 0b10 then {
            if op1 == 0b000 then {
                if CRn == 0x0 then {
                    if op2 == 0b010 then {
                        if CRm == 0x2 then {
                            if (((el == EL1 & __HCR_EL2_NV == 1) & __HCR_EL2_NV2 == 1) & __HCR_EL2_TGE == 0) & (__SCR_EL3_NS == 1 | __SCR_EL3_EEL2 == 1) then {
                                return(ZeroExtend(NVMem(344)))
                            } else {
                                return(ZeroExtend(MDSCR_EL1))
                            }
                        } else {
                            if CRm == 0x0 then {
                                return(ZeroExtend(OSDTRRX_EL1))
                            } else {
                                if CRm == 0x6 then {
                                    return(ZeroExtend(OSECCR_EL1))
                                } else {
                                    if CRm == 0x3 then {
                                        return(ZeroExtend(OSDTRTX_EL1))
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x2 then {
                            if op2 == 0b000 then {
                                return(ZeroExtend(MDCCINT_EL1))
                            }
                        }
                    }
                } else {
                    if CRn == 0x1 then {
                        if op2 == 0b100 then {
                            if CRm == 0x1 then {
                                return(ZeroExtend(OSLSR_EL1))
                            } else {
                                if CRm == 0x4 then {
                                    return(ZeroExtend(DBGPRCR_EL1))
                                } else {
                                    if CRm == 0x3 then {
                                        return(ZeroExtend(OSDLR_EL1))
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x0 then {
                                if op2 == 0b000 then {
                                    return(MDRAR_EL1)
                                }
                            }
                        }
                    } else {
                        if CRn == 0x7 then {
                            if op2 == 0b110 then {
                                if CRm == 0x8 then {
                                    return(ZeroExtend(DBGCLAIMSET_EL1))
                                } else {
                                    if CRm == 0xE then {
                                        return(ZeroExtend(DBGAUTHSTATUS_EL1))
                                    } else {
                                        if CRm == 0x9 then {
                                            return(ZeroExtend(DBGCLAIMCLR_EL1))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op2 == 0b000 then {
                    if CRn == 0x0 then {
                        if op1 == 0b011 then {
                            if CRm == 0x5 then {
                                return(ZeroExtend(DBGDTRRX_EL0))
                            } else {
                                if CRm == 0x4 then {
                                    return(DBGDTR_EL0)
                                } else {
                                    if CRm == 0x1 then {
                                        return(ZeroExtend(MDCCSR_EL0))
                                    }
                                }
                            }
                        } else {
                            if op1 == 0b100 then {
                                if CRm == 0x7 then {
                                    return(ZeroExtend(DBGVCR32_EL2))
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    undefined : bits(64)
}

val AArch64_SysRegRead : forall 'op0 'op1 'crn 'crm 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bits(64) effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_SysRegRead (op0, op1, crn, crm, op2) = {
    if (((op0 == 3 & crn == 12) & op1 == 0) & op2 == 0) & crm == 1 then {
        return(ZeroExtend(getISR()))
    };
    if (((op0 == 3 & crn == 0) & op1 == 0) & op2 == 5) & crm == 0 then {
        if PSTATE.EL == EL1 & EL2Enabled() then {
            return(VMPIDR_EL2)
        }
    };
    if (((op0 == 3 & crn == 0) & op1 == 0) & op2 == 0) & crm == 0 then {
        if PSTATE.EL == EL1 & EL2Enabled() then {
            return(ZeroExtend(VPIDR_EL2))
        }
    };
    if (((op0 == 3 & crn == 5) & op1 == 4) & op2 == 0) & crm == 2 then {
        if PSTATE.EL == EL1 then {
            return(ZeroExtend(ESR_EL1))
        }
    };
    if (((op0 == 3 & crn == 6) & op1 == 4) & op2 == 0) & crm == 0 then {
        if PSTATE.EL == EL1 then {
            return(FAR_EL1)
        }
    };
    if (((op0 == 3 & crn == 0) & op1 == 3) & op2 == 7) & crm == 0 then {
        if PSTATE.EL == EL0 & ([SCTLR_EL1[14]] == 0b0 | [HCR_EL2[28]] == 0b1) | PSTATE.EL == EL1 & [HCR_EL2[28]] == 0b1 then {
            value_name : bits(64) = ZeroExtend(slice(DCZID_EL0, 0, 32));
            value_name = __SetSlice_bits(64, 1, value_name, 4, 0b1);
            return(value_name)
        }
    };
    value_name : bits(64) = AArch64_AutoGen_SysRegRead(PSTATE.EL, __GetSlice_int(2, op0, 0), __GetSlice_int(3, op1, 0), __GetSlice_int(4, crn, 0), __GetSlice_int(3, op2, 0), __GetSlice_int(4, crm, 0), 0b1);
    if AArch64_CheckNVCondsIfCurrentEL(op0, op1, crn, crm, op2) then {
        value_name = __SetSlice_bits(64, 2, value_name, 2, 0b10)
    };
    value_name
}

val system_register_system : forall ('read : Bool) 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't,
  ('t >= 0 & 't <= 31 | not('read)) & ('t >= 0 & 't <= 31 | not(not('read))).
  (bool('read), int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function system_register_system (read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t) = {
    if read then {
        X(t) = AArch64_SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2)
    } else {
        AArch64_SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X(t))
    }
}

val system_register_system_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1), bits(1)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function system_register_system_decode (Rt, op2, CRm, CRn, op1, o0, L) = {
    __unconditional = true;
    AArch64_CheckSystemAccess(0b1 @ o0, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 2 + UInt(o0);
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let read = L == 0b1;
    __PostDecode();
    system_register_system(read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

val memory_vector_single_nowb : forall 'datasize 'esize 'index 'm 'n 'selem 't,
  ('n >= 0 & 'n <= 31).
  (int('datasize), int('esize), int('index), int('m), MemOp, int('n), bool, int('selem), int('t), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_single_nowb (datasize, esize, index, m, memop, n, replicate, selem, t__arg, wback) = {
    t : int = t__arg;
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(~(wback) & n == 31)
    };
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    offs : bits(64) = undefined : bits(64);
    rval : bits(128) = undefined : bits(128);
    element : bits('esize) = undefined : bits('esize);
    let 'ebytes : {'n, 'n == div('esize, 8). int('n)} = esize / 8;
    assert(constraint(('ebytes in {1, 2, 4, 8, 16} & 'ebytes == 8 * 'esize)));
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    offs = Zeros();
    if replicate then {
        foreach (s from 0 to (selem - 1) by 1 in inc) {
            element = aget_Mem(address + offs, ebytes, AccType_VEC);
            aset_V(t, replicate_bits(element, datasize / esize));
            offs = offs + ebytes;
            t = (t + 1) % 32
        }
    } else {
        foreach (s from 0 to (selem - 1) by 1 in inc) {
            rval = aget_V(t);
            if memop == MemOp_LOAD then {
                rval = aset_Elem(rval, index, esize, aget_Mem(address + offs, ebytes, AccType_VEC));
                aset_V(t, rval)
            } else {
                aset_Mem(address + offs, ebytes, AccType_VEC, aget_Elem(rval, index, esize))
            };
            offs = offs + ebytes;
            t = (t + 1) % 32
        }
    };
    if wback then {
        if m != 31 then {
            offs = aget_X(m)
        };
        if n == 31 then {
            aset_SP(address + offs)
        } else {
            aset_X(n, address + offs)
        }
    }
}

val memory_vector_single_postinc_memory_vector_single_nowb__decode : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_single_postinc_memory_vector_single_nowb__decode (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback = true;
    scale : int = UInt(slice(opcode, 1, 2));
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined : int;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      }
    };
    let memop = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = shl_int(8, scale);
    __PostDecode();
    memory_vector_single_nowb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

val memory_vector_single_nowb_memory_vector_single_nowb__decode : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_single_nowb_memory_vector_single_nowb__decode (Rt, Rn, size, S, opcode, R, L, Q) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = undefined : int;
    let wback = false;
    scale : int = UInt(slice(opcode, 1, 2));
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined : int;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          };
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          };
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          };
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              };
              index = UInt(Q);
              scale = 3
          }
      }
    };
    let memop = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = shl_int(8, scale);
    __PostDecode();
    memory_vector_single_nowb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

val memory_vector_multiple_nowb : forall 'datasize 'elements 'esize 'm 'n 'rpt 'selem 't,
  ('n >= 0 & 'n <= 31).
  (int('datasize), int('elements), int('esize), int('m), MemOp, int('n), int('rpt), int('selem), int('t), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_multiple_nowb (datasize, elements, esize, m, memop, n, rpt, selem, t, wback) = {
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    offs : bits(64) = undefined : bits(64);
    rval : bits('datasize) = undefined : bits('datasize);
    tt : int = undefined : int;
    let 'ebytes : {'n, 'n == div('esize, 8). int('n)} = esize / 8;
    assert(constraint(('ebytes in {1, 2, 4, 8, 16} & 'ebytes == 'esize * 8)));
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(~(wback) & n == 31)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    offs = Zeros();
    foreach (r from 0 to (rpt - 1) by 1 in inc) {
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            tt = (t + r) % 32;
            foreach (s from 0 to (selem - 1) by 1 in inc) {
                let tt_fixed = tt;
                assert(0 <= tt_fixed & tt_fixed <= 31);
                rval = aget_V(tt_fixed);
                if memop == MemOp_LOAD then {
                    rval = aset_Elem(rval, e, esize, aget_Mem(address + offs, ebytes, AccType_VEC));
                    aset_V(tt_fixed, rval)
                } else {
                    aset_Mem(address + offs, ebytes, AccType_VEC, aget_Elem(rval, e, esize))
                };
                offs = offs + ebytes;
                tt = (tt + 1) % 32
            }
        }
    };
    if wback then {
        if m != 31 then {
            offs = aget_X(m)
        };
        if n == 31 then {
            aset_SP(address + offs)
        } else {
            aset_X(n, address + offs)
        }
    }
}

val memory_vector_multiple_postinc_memory_vector_multiple_nowb__decode : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_multiple_postinc_memory_vector_multiple_nowb__decode (Rt, Rn, size, opcode, Rm, L, Q) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback = true;
    let memop = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = shl_int(8, UInt(size));
    let 'elements = datasize / esize;
    rpt : int = undefined : int;
    selem : int = undefined : int;
    match opcode {
      0x0 => {
          rpt = 1;
          selem = 4
      },
      0x2 => {
          rpt = 4;
          selem = 1
      },
      0x4 => {
          rpt = 1;
          selem = 3
      },
      0x6 => {
          rpt = 3;
          selem = 1
      },
      0x7 => {
          rpt = 1;
          selem = 1
      },
      0x8 => {
          rpt = 1;
          selem = 2
      },
      0xA => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let selem = selem;
    let rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    memory_vector_multiple_nowb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

val memory_vector_multiple_nowb_memory_vector_multiple_nowb__decode : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_vector_multiple_nowb_memory_vector_multiple_nowb__decode (Rt, Rn, size, opcode, L, Q) = {
    __unconditional = true;
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = undefined : int;
    let wback = false;
    let memop = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = shl_int(8, UInt(size));
    let 'elements = datasize / esize;
    rpt : int = undefined : int;
    selem : int = undefined : int;
    match opcode {
      0x0 => {
          rpt = 1;
          selem = 4
      },
      0x2 => {
          rpt = 4;
          selem = 1
      },
      0x4 => {
          rpt = 1;
          selem = 3
      },
      0x6 => {
          rpt = 3;
          selem = 1
      },
      0x7 => {
          rpt = 1;
          selem = 1
      },
      0x8 => {
          rpt = 1;
          selem = 2
      },
      0xA => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let selem = selem;
    let rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    };
    __PostDecode();
    memory_vector_multiple_nowb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

val memory_single_simdfp_register : forall 'datasize 'm 'n 'shift 't,
  ('shift >= 0 & 'shift <= 4 & 'm >= 0 & 'm <= 31 & 'n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (AccType, int('datasize), ExtendType, int('m), MemOp, int('n), bool, int('shift), int('t), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_register (acctype, datasize, extend_type, m, memop, n, postindex, shift, t, wback) = {
    let offset : bits(64) = ExtendReg(m, extend_type, shift);
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    let 'd = datasize / 8;
    assert(constraint(('d * 8 == 'datasize & 'd in {1, 2, 4, 8, 16})));
    match memop {
      MemOp_STORE => {
          data = aget_V(t);
          aset_Mem(address, d, acctype, data)
      },
      MemOp_LOAD => {
          data = aget_Mem(address, d, acctype);
          aset_V(t, data)
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_single_simdfp_register_memory_single_simdfp_register__decode : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_register_memory_single_simdfp_register__decode (Rt, Rn, S, option_name, Rm, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift : {'n, ('n == 'scale | 'n == 0). int('n)} = if S == 0b1 then scale else 0;
    assert(constraint('shift <= 4));
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = shl_int(8, scale);
    __PostDecode();
    memory_single_simdfp_register(acctype, datasize, extend_type, m, memop, n, postindex, shift, t, wback)
}

val memory_single_simdfp_immediate_signed_postidx : forall 'datasize 'n 't,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool, int('t), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_signed_postidx (acctype, datasize, memop, n, offset, postindex, t, wback) = {
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    let 'd = datasize / 8;
    assert(constraint(('d * 8 == 'datasize & 'd in {1, 2, 4, 8, 16})));
    match memop {
      MemOp_STORE => {
          data = aget_V(t);
          aset_Mem(address, d, acctype, data)
      },
      MemOp_LOAD => {
          data = aget_Mem(address, d, acctype);
          aset_V(t, data)
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_single_simdfp_immediate_unsigned_memory_single_simdfp_immediate_signed_postidx__decode : (bits(5), bits(5), bits(12), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_unsigned_memory_single_simdfp_immediate_signed_postidx__decode (Rt, Rn, imm12, opc, V, size) = {
    __unconditional = true;
    let wback = false;
    let postindex = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype = AccType_VEC;
    let memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = shl_int(8, scale);
    __PostDecode();
    memory_single_simdfp_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

val memory_single_simdfp_immediate_signed_preidx_memory_single_simdfp_immediate_signed_postidx__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_signed_preidx_memory_single_simdfp_immediate_signed_postidx__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback = true;
    let postindex = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype = AccType_VEC;
    let memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = shl_int(8, scale);
    __PostDecode();
    memory_single_simdfp_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

val memory_single_simdfp_immediate_signed_postidx_memory_single_simdfp_immediate_signed_postidx__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_signed_postidx_memory_single_simdfp_immediate_signed_postidx__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback = true;
    let postindex = true;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype = AccType_VEC;
    let memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = shl_int(8, scale);
    __PostDecode();
    memory_single_simdfp_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

val memory_single_simdfp_immediate_signed_offset_normal : forall 'datasize 'n 't,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool, int('t), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_signed_offset_normal (acctype, datasize, memop, n, offset, postindex, t, wback) = {
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    let 'd = datasize / 8;
    assert(constraint(('d * 8 == 'datasize & 'd in {1, 2, 4, 8, 16})));
    match memop {
      MemOp_STORE => {
          data = aget_V(t);
          aset_Mem(address, datasize / 8, acctype, data)
      },
      MemOp_LOAD => {
          data = aget_Mem(address, datasize / 8, acctype);
          aset_V(t, data)
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_single_simdfp_immediate_signed_offset_normal_memory_single_simdfp_immediate_signed_offset_normal__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_simdfp_immediate_signed_offset_normal_memory_single_simdfp_immediate_signed_offset_normal__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback = false;
    let postindex = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    };
    let offset = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype = AccType_VEC;
    let memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = shl_int(8, scale);
    __PostDecode();
    memory_single_simdfp_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, t, wback)
}

val memory_single_general_register : forall 'datasize 'm 'n ('postindex : Bool) 'regsize 'shift ('signed : Bool) 't ('wback : Bool),
  ('shift >= 0 & 'shift <= 4 & 'm >= 0 & 'm <= 31 & 'n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 'shift >= 0 & 'shift <= 4 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), ExtendType, int('m), MemOp, int('n), bool('postindex), int('regsize), int('shift), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_register (acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    let offset : bits(64) = ExtendReg(m, extend_type, shift);
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = aget_X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          aset_Mem(address, datasize / 8, acctype, data)
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = aget_Mem(address, datasize / 8, acctype);
          if signed then {
              aset_X(t, SignExtend(data, regsize))
          } else {
              aset_X(t, ZeroExtend(data, regsize))
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_single_general_register_memory_single_general_register__decode : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_register_memory_single_general_register__decode (Rt, Rn, S, option_name, Rm, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    };
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift : {'n, ('n == 'scale | 'n == 0). int('n)} = if S == 0b1 then scale else 0;
    assert(shift <= 4);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = 64;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            }
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    let 'regsize = regsize;
    let signed = signed;
    assert(regsize >= datasize);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, signed, t, wback)
}

val memory_single_general_immediate_unsigned : forall 'datasize 'n ('postindex : Bool) 'regsize ('signed : Bool) 't ('wback : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 't & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_unsigned (acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = aget_X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          aset_Mem(address, datasize / 8, acctype, data)
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = aget_Mem(address, datasize / 8, acctype);
          if signed then {
              aset_X(t, SignExtend(data, regsize))
          } else {
              aset_X(t, ZeroExtend(data, regsize))
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_single_general_immediate_unsigned_memory_single_general_immediate_unsigned__decode : (bits(5), bits(5), bits(12), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_unsigned_memory_single_general_immediate_unsigned__decode (Rt, Rn, imm12, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = 64;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            }
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    let regsize = regsize;
    let signed = signed;
    assert(regsize >= datasize);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_unsigned(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_postidx : forall 'datasize 'n ('postindex : Bool) 'regsize ('signed : Bool) 't ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_postidx (acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    if HaveMTEExt() then {
        let is_load_store = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          Mem(address, datasize / 8, acctype) = data
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = Mem(address, datasize / 8, acctype);
          if signed then {
              X(t) = SignExtend(data, regsize)
          } else {
              X(t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_single_general_immediate_unsigned_memory_single_general_immediate_signed_postidx__decode : (bits(5), bits(5), bits(12), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_unsigned_memory_single_general_immediate_signed_postidx__decode (Rt, Rn, imm12, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = 64;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    let regsize = regsize;
    let signed = signed;
    assert(regsize >= datasize);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_preidx_memory_single_general_immediate_signed_postidx__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_preidx_memory_single_general_immediate_signed_postidx__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = 64;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    let regsize = regsize;
    let signed = signed;
    assert(regsize >= datasize);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_postidx_memory_single_general_immediate_signed_postidx__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_postidx_memory_single_general_immediate_signed_postidx__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = 64;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    let regsize = regsize;
    let signed = signed;
    assert(regsize >= datasize);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_postidx(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_pac : forall 'n 't ('use_key_a : Bool) ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31).
  (int('n), bits(64), int('t), bool('use_key_a), bool('wback)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_pac (n, offset, t, use_key_a, wback__arg) = {
    wback : bool = wback__arg;
    address : bits(64) = undefined : bits(64);
    data : bits(64) = undefined : bits(64);
    wb_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if (wback & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    if use_key_a then {
        address = AuthDA(address, X(31))
    } else {
        address = AuthDB(address, X(31))
    };
    address = address + offset;
    let data = Mem(address, 8, AccType_NORMAL);
    X(t) = data;
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_single_general_immediate_signed_pac_decode : (bits(5), bits(5), bits(1), bits(9), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_pac_decode (Rt, Rn, W, imm9, S, M, V, size) = {
    __unconditional = true;
    if ~(HavePACExt()) | size != 0b11 then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let wback = W == 0b1;
    let use_key_a = M == 0b0;
    let S10 = S @ imm9;
    let 'scale = 3;
    let offset : bits(64) = LSL(SignExtend(S10, 64), scale);
    __PostDecode();
    memory_single_general_immediate_signed_pac(n, offset, t, use_key_a, wback)
}

val memory_single_general_immediate_signed_offset_unpriv : forall 'datasize 'n ('postindex : Bool) 'regsize ('signed : Bool) 't ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_unpriv (acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    if HaveMTEExt() then {
        let is_load_store = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          Mem(address, datasize / 8, acctype) = data
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = Mem(address, datasize / 8, acctype);
          if signed then {
              X(t) = SignExtend(data, regsize)
          } else {
              X(t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_single_general_immediate_signed_offset_unpriv_memory_single_general_immediate_signed_offset_unpriv__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_unpriv_memory_single_general_immediate_signed_offset_unpriv__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1 & ~((EL2Enabled() & HaveNVExt()) & (HCR_EL2[42 .. 42] @ HCR_EL2[43 .. 43]) == 0b11);
    let unpriv_at_el2 : bool = ((HaveEL(EL2) & HaveVirtHostExt()) & PSTATE.EL == EL2) & (HCR_EL2[34 .. 34] @ HCR_EL2[27 .. 27]) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    acctype : AccType = undefined : AccType;
    if ~(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = 64;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    let regsize = regsize;
    let signed = signed;
    assert(regsize >= datasize);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_offset_normal : forall 'datasize 'n ('postindex : Bool) 'regsize ('signed : Bool) 't ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_normal (acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    if HaveMTEExt() then {
        let is_load_store = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          Mem(address, datasize / 8, acctype) = data
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = Mem(address, datasize / 8, acctype);
          if signed then {
              X(t) = SignExtend(data, regsize)
          } else {
              X(t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_single_general_immediate_signed_offset_normal_memory_single_general_immediate_signed_offset_normal__decode : (bits(5), bits(5), bits(9), bits(2), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_normal_memory_single_general_immediate_signed_offset_normal__decode (Rt, Rn, imm9, opc, V, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = 64;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            }
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    let regsize = regsize;
    let signed = signed;
    assert(regsize >= datasize);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_single_general_immediate_signed_offset_lda_stl : forall 'datasize 'n ('postindex : Bool) 'regsize ('signed : Bool) 't ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('signed), int('t), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_lda_stl (acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback__arg) = {
    wback : bool = wback__arg;
    if HaveMTEExt() then {
        let is_load_store = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    c : Constraint = undefined : Constraint;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        if memop != MemOp_PREFETCH then {
            CheckSPAlignment()
        };
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              data = X(t)
          };
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, false, t, regsize == 64, false)
          };
          Mem(address, datasize / 8, acctype) = data
      },
      MemOp_LOAD => {
          if ~(wback) then {
              AArch64_SetLSInstructionSyndrome(datasize / 8, signed, t, regsize == 64, false)
          };
          data = Mem(address, datasize / 8, acctype);
          if signed then {
              X(t) = SignExtend(data, regsize)
          } else {
              X(t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_single_general_immediate_signed_offset_lda_stl_memory_single_general_immediate_signed_offset_lda_stl__decode : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_single_general_immediate_signed_offset_lda_stl_memory_single_general_immediate_signed_offset_lda_stl__decode (Rt, Rn, imm9, opc, size) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_ORDERED;
    memop : MemOp = undefined : MemOp;
    signed : bool = undefined : bool;
    regsize : int = 64;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            }
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            };
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            signed = true
        }
    };
    let 'datasize = shl_int(8, scale);
    let regsize = regsize;
    let signed = signed;
    assert(regsize >= datasize);
    assert(constraint('datasize in {8, 16, 32, 64}));
    __PostDecode();
    memory_single_general_immediate_signed_offset_lda_stl(acctype, datasize, memop, n, offset, postindex, regsize, signed, t, wback)
}

val memory_pair_simdfp_postidx : forall 'datasize 'n 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool, int('t), int('t2), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_postidx (acctype, datasize, memop, n, offset, postindex, t, t2, wback) = {
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    data1 : bits('datasize) = undefined : bits('datasize);
    data2 : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    rt_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          data1 = aget_V(t);
          data2 = aget_V(t2);
          aset_Mem(address + 0, dbytes, acctype, data1);
          aset_Mem(address + dbytes, dbytes, acctype, data2)
      },
      MemOp_LOAD => {
          data1 = aget_Mem(address + 0, dbytes, acctype);
          data2 = aget_Mem(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = undefined : bits('datasize);
              data2 = undefined : bits('datasize)
          };
          aset_V(t, data1);
          aset_V(t2, data2)
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_pair_simdfp_preidx_memory_pair_simdfp_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_preidx_memory_pair_simdfp_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_simdfp_postidx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

val memory_pair_simdfp_postidx_memory_pair_simdfp_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_postidx_memory_pair_simdfp_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_simdfp_postidx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

val memory_pair_simdfp_offset_memory_pair_simdfp_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_offset_memory_pair_simdfp_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_simdfp_postidx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

val memory_pair_simdfp_noalloc : forall 'datasize 'n 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool, int('t), int('t2), bool) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_noalloc (acctype, datasize, memop, n, offset, postindex, t, t2, wback) = {
    CheckFPAdvSIMDEnabled64();
    address : bits(64) = undefined : bits(64);
    data1 : bits('datasize) = undefined : bits('datasize);
    data2 : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    rt_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          data1 = aget_V(t);
          data2 = aget_V(t2);
          aset_Mem(address + 0, dbytes, acctype, data1);
          aset_Mem(address + dbytes, dbytes, acctype, data2)
      },
      MemOp_LOAD => {
          data1 = aget_Mem(address + 0, dbytes, acctype);
          data2 = aget_Mem(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = undefined : bits('datasize);
              data2 = undefined : bits('datasize)
          };
          aset_V(t, data1);
          aset_V(t2, data2)
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            aset_SP(address)
        } else {
            aset_X(n, address)
        }
    }
}

val memory_pair_simdfp_noalloc_memory_pair_simdfp_noalloc__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_simdfp_noalloc_memory_pair_simdfp_noalloc__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VECSTREAM;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt(opc);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_simdfp_noalloc(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

val memory_pair_general_postidx : forall 'datasize 'n ('postindex : Bool) ('signed : Bool) 't 't2 ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}) & ('t2 >= 0 & 't2 <= 31).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), bool('signed), int('t), int('t2), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_postidx (acctype, datasize, memop, n, offset, postindex, signed, t, t2, wback__arg) = {
    wback : bool = wback__arg;
    address : bits(64) = undefined : bits(64);
    data1 : bits('datasize) = undefined : bits('datasize);
    data2 : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    rt_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown & t == n then {
              data1 = undefined : bits('datasize)
          } else {
              data1 = X(t)
          };
          if rt_unknown & t2 == n then {
              data2 = undefined : bits('datasize)
          } else {
              data2 = X(t2)
          };
          Mem(address + 0, dbytes, acctype) = data1;
          Mem(address + dbytes, dbytes, acctype) = data2
      },
      MemOp_LOAD => {
          data1 = Mem(address + 0, dbytes, acctype);
          data2 = Mem(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = undefined : bits('datasize);
              data2 = undefined : bits('datasize)
          };
          if signed then {
              X(t) = SignExtend(data1, 64);
              X(t2) = SignExtend(data2, 64)
          } else {
              X(t) = data1;
              X(t2) = data2
          }
      }
    };
    if wback then {
        if wb_unknown then {
            address = undefined : bits(64)
        } else {
            if postindex then {
                address = address + offset
            }
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_pair_general_preidx_memory_pair_general_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_preidx_memory_pair_general_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_general_postidx(acctype, datasize, memop, n, offset, postindex, signed, t, t2, wback)
}

val memory_pair_general_postidx_memory_pair_general_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_postidx_memory_pair_general_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_general_postidx(acctype, datasize, memop, n, offset, postindex, signed, t, t2, wback)
}

val memory_pair_general_offset_memory_pair_general_postidx__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_offset_memory_pair_general_postidx__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    };
    let signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_general_postidx(acctype, datasize, memop, n, offset, postindex, signed, t, t2, wback)
}

val memory_pair_general_noalloc : forall 'datasize 'n ('postindex : Bool) 't 't2 ('wback : Bool),
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}) & ('t2 >= 0 & 't2 <= 31).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('t), int('t2), bool('wback)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_noalloc (acctype, datasize, memop, n, offset, postindex, t, t2, wback) = {
    address : bits(64) = undefined : bits(64);
    data1 : bits('datasize) = undefined : bits('datasize);
    data2 : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    rt_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction((is_load_store & n == 31) & ~(wback))
    };
    if memop == MemOp_LOAD & t == t2 then {
        let c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    if ~(postindex) then {
        address = address + offset
    };
    match memop {
      MemOp_STORE => {
          if rt_unknown & t == n then {
              data1 = undefined : bits('datasize)
          } else {
              data1 = X(t)
          };
          if rt_unknown & t2 == n then {
              data2 = undefined : bits('datasize)
          } else {
              data2 = X(t2)
          };
          Mem(address + 0, dbytes, acctype) = data1;
          Mem(address + dbytes, dbytes, acctype) = data2
      },
      MemOp_LOAD => {
          data1 = Mem(address + 0, dbytes, acctype);
          data2 = Mem(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = undefined : bits('datasize);
              data2 = undefined : bits('datasize)
          };
          X(t) = data1;
          X(t2) = data2
      }
    };
    if wback then {
        if postindex then {
            address = address + offset
        };
        if n == 31 then {
            SP() = address
        } else {
            X(n) = address
        }
    }
}

val memory_pair_general_noalloc_memory_pair_general_noalloc__decode : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_pair_general_noalloc_memory_pair_general_noalloc__decode (Rt, Rn, Rt2, imm7, L, V, opc) = {
    __unconditional = true;
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_STREAM;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if [opc[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = shl_int(8, scale);
    assert(constraint('datasize in {8, 16, 32, 64}));
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    __PostDecode();
    memory_pair_general_noalloc(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

val memory_ordered : forall 'datasize 'n 'regsize 't,
  ('n >= 0 & 'n <= 31 | not(not('n == 31))) & ('t >= 0 & 't <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), int('regsize), int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_ordered (acctype, datasize, memop, n, regsize, t) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    match memop {
      MemOp_STORE => {
          data = X(t);
          AArch64_SetLSInstructionSyndrome(dbytes, false, t, regsize == 64, true);
          Mem(address, dbytes, acctype) = data
      },
      MemOp_LOAD => {
          AArch64_SetLSInstructionSyndrome(dbytes, false, t, regsize == 64, true);
          data = Mem(address, dbytes, acctype);
          X(t) = ZeroExtend(data, regsize)
      }
    };
    let data = data;
    ()
}

val memory_ordered_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_ordered_decode (Rt, Rn, Rt2, o0, Rs, o1, L, o2, size) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = shl_int(8, UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    __PostDecode();
    memory_ordered(acctype, datasize, memop, n, regsize, t)
}

val memory_orderedrcpc : forall 'datasize 'n 'regsize 't,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64, 128} & 't >= 0 & 't <= 31).
  (AccType, int('datasize), int('n), int('regsize), int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wreg, wmem}

function memory_orderedrcpc (acctype, datasize, n, regsize, t) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data = aget_Mem(address, dbytes, acctype);
    aset_X(t, ZeroExtend(data, regsize))
}

val memory_orderedrcpc_decode : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_orderedrcpc_decode (Rt, Rn, opc, o3, Rs, R, A, V, size) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let acctype = AccType_ORDERED;
    let 'elsize = shl_int(8, UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    __PostDecode();
    memory_orderedrcpc(acctype, datasize, n, regsize, t)
}

val memory_literal_simdfp : forall 'size 't,
  'size in {1, 2, 4, 8, 16} & ('t >= 0 & 't <= 31).
  (bits(64), int('size), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function memory_literal_simdfp (offset, size, t) = {
    let address = PC() + offset;
    data : bits(8 * 'size) = undefined : bits('size * 8);
    CheckFPAdvSIMDEnabled64();
    let data = Mem(address, size, AccType_VEC);
    V(t) = data
}

val memory_literal_simdfp_decode : (bits(5), bits(19), bits(1), bits(2)) -> unit effect {escape, rmem, rreg, undef, wreg, wmem}

function memory_literal_simdfp_decode (Rt, imm19, V, opc) = {
    __unconditional = true;
    let 't = UInt(Rt);
    size : int = undefined : int;
    offset : bits(64) = undefined : bits(64);
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 16
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let offset = SignExtend(imm19 @ 0b00, 64);
    __PostDecode();
    let size_fixed = size;
    assert(size_fixed == 4 | size_fixed == 8 | size_fixed == 16);
    memory_literal_simdfp(offset, size_fixed, t)
}

val memory_literal_general : forall ('size : Int) ('t : Int), (0 <= 't & 't <= 31).
  (MemOp, bits(64), bool, int('size), int('t)) -> unit effect {escape, rmem, rreg, undef, wreg, wmem}

function memory_literal_general (memop, offset, signed, size, t) = {
    let address : bits(64) = aget_PC() + offset;
    data : bits(8 * 'size) = undefined : bits('size * 8);
    match memop {
      MemOp_LOAD => {
          assert(constraint('size in {1, 2, 4, 8, 16}));
          data = aget_Mem(address, size, AccType_NORMAL);
          if signed then {
              aset_X(t, SignExtend(data, 64))
          } else {
              aset_X(t, data)
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, __GetSlice_int(5, t, 0))
      }
    }
}

val memory_literal_general_decode : (bits(5), bits(19), bits(1), bits(2)) -> unit effect {escape, rmem, rreg, undef, wreg, wmem}

function memory_literal_general_decode (Rt, imm19, V, opc) = {
    __unconditional = true;
    let 't = UInt(Rt);
    memop : MemOp = MemOp_LOAD;
    signed : bool = false;
    size : int = undefined : int;
    offset : bits(64) = undefined : bits(64);
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 4;
          signed = true
      },
      0b11 => {
          memop = MemOp_PREFETCH
      }
    };
    let offset = SignExtend(imm19 @ 0b00, 64);
    let size = size;
    __PostDecode();
    memory_literal_general(memop, offset, signed, size, t)
}

val memory_exclusive_single : forall 'datasize 'elsize 'n 'regsize 's 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31 & 's >= 0 & 's <= 31).
  (AccType, int('datasize), int('elsize), MemOp, int('n), bool, int('regsize), int('s), int('t), int('t2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_exclusive_single (acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction(is_load_store & n == 31)
    };
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_NONE => {
                  rt_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              }
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_NONE => {
                  rn_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              }
            }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        if rn_unknown then {
            address = undefined : bits(64)
        } else {
            address = aget_X(n)
        }
    };
    iswrite : bool = undefined : bool;
    secondstage : bool = undefined : bool;
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              if pair then {
                  let 'd2 = 'datasize / 2;
                  assert(constraint('datasize in {16, 32, 64, 128}));
                  assert(constraint('d2 * 2 == 'datasize));
                  let el1 : bits('d2) = aget_X(t);
                  let el2 : bits('d2) = aget_X(t2);
                  data = if BigEndian() then el1 @ el2 else el2 @ el1
              } else {
                  assert(constraint('datasize in {8, 16, 32, 64}));
                  data = aget_X(t)
              }
          };
          status : bits(1) = 0b1;
          if AArch64_ExclusiveMonitorsPass(address, dbytes) then {
              assert(constraint('dbytes in {1, 2, 4, 8, 16}));
              aset_Mem(address, dbytes, acctype, data);
              status = ExclusiveMonitorsStatus()
          };
          aset_X(s, ZeroExtend(status, 32))
      },
      MemOp_LOAD => {
          AArch64_SetExclusiveMonitors(address, dbytes);
          if pair then {
              if rt_unknown then {
                  aset_X(t, undefined : bits('datasize))
              } else {
                  if elsize == 32 then {
                      assert(constraint('dbytes in {1, 2, 4, 8, 16}));
                      assert(constraint(- 'elsize + 'datasize >= 0));
                      data = aget_Mem(address, dbytes, acctype);
                      if BigEndian() then {
                          aset_X(t, slice(data, elsize, negate(elsize) + datasize));
                          aset_X(t2, slice(data, 0, elsize))
                      } else {
                          aset_X(t, slice(data, 0, elsize));
                          aset_X(t2, slice(data, elsize, negate(elsize) + datasize))
                      }
                  } else {
                      if address != Align(address, dbytes) then {
                          iswrite = false;
                          secondstage = false;
                          AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
                      };
                      aset_X(t, aget_Mem(address + 0, 8, acctype));
                      aset_X(t2, aget_Mem(address + 8, 8, acctype))
                  }
              }
          } else {
              assert(constraint('dbytes in {1, 2, 4, 8, 16}));
              data = aget_Mem(address, dbytes, acctype);
              assert(regsize >= 'datasize);
              aset_X(t, ZeroExtend(data, regsize))
          }
      }
    }
}

val memory_exclusive_single_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_exclusive_single_decode (Rt, Rn, Rt2, o0, Rs, o1, L, o2, size) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair = false;
    let memop = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = shl_int(8, UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    __PostDecode();
    memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

val memory_exclusive_pair : forall 'datasize 'elsize 'n 'regsize 's 't 't2,
  ('n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31 & 't2 >= 0 & 't2 <= 31 & 's >= 0 & 's <= 31).
  (AccType, int('datasize), int('elsize), MemOp, int('n), bool, int('regsize), int('s), int('t), int('t2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_exclusive_pair (acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    let 'dbytes : {'n, 'n == div('datasize, 8). int('n)} = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if HaveMTEExt() then {
        let is_load_store : bool = memop == MemOp_STORE | memop == MemOp_LOAD;
        SetNotTagCheckedInstruction(is_load_store & n == 31)
    };
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          }
        }
    };
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_NONE => {
                  rt_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              }
            }
        };
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_NONE => {
                  rn_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              }
            }
        }
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        if rn_unknown then {
            address = undefined : bits(64)
        } else {
            address = aget_X(n)
        }
    };
    iswrite : bool = undefined : bool;
    secondstage : bool = undefined : bool;
    match memop {
      MemOp_STORE => {
          if rt_unknown then {
              data = undefined : bits('datasize)
          } else {
              if pair then {
                  let 'd2 = 'datasize / 2;
                  assert(constraint('datasize in {16, 32, 64, 128}));
                  assert(constraint('d2 * 2 == 'datasize));
                  let el1 : bits('d2) = aget_X(t);
                  let el2 : bits('d2) = aget_X(t2);
                  data = if BigEndian() then el1 @ el2 else el2 @ el1
              } else {
                  assert(constraint('datasize in {8, 16, 32, 64}));
                  data = aget_X(t)
              }
          };
          status : bits(1) = 0b1;
          if AArch64_ExclusiveMonitorsPass(address, dbytes) then {
              assert(constraint('dbytes in {1, 2, 4, 8, 16}));
              aset_Mem(address, dbytes, acctype, data);
              status = ExclusiveMonitorsStatus()
          };
          aset_X(s, ZeroExtend(status, 32))
      },
      MemOp_LOAD => {
          AArch64_SetExclusiveMonitors(address, dbytes);
          if pair then {
              if rt_unknown then {
                  aset_X(t, undefined : bits('datasize))
              } else {
                  if elsize == 32 then {
                      assert(constraint('dbytes in {1, 2, 4, 8, 16}));
                      assert(constraint(- 'elsize + 'datasize >= 0));
                      data = aget_Mem(address, dbytes, acctype);
                      if BigEndian() then {
                          aset_X(t, slice(data, elsize, negate(elsize) + datasize));
                          aset_X(t2, slice(data, 0, elsize))
                      } else {
                          aset_X(t, slice(data, 0, elsize));
                          aset_X(t2, slice(data, elsize, negate(elsize) + datasize))
                      }
                  } else {
                      if address != Align(address, dbytes) then {
                          iswrite = false;
                          secondstage = false;
                          AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
                      };
                      aset_X(t, aget_Mem(address + 0, 8, acctype));
                      aset_X(t2, aget_Mem(address + 8, 8, acctype))
                  }
              }
          } else {
              assert(constraint('dbytes in {1, 2, 4, 8, 16}));
              data = aget_Mem(address, dbytes, acctype);
              assert(regsize >= 'datasize);
              aset_X(t, ZeroExtend(data, regsize))
          }
      }
    }
}

val memory_exclusive_pair_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_exclusive_pair_decode (Rt, Rn, Rt2, o0, Rs, o1, L, o2, sz) = {
    __unconditional = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair = true;
    let memop = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = shl_int(32, UInt(sz));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    __PostDecode();
    memory_exclusive_pair(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

val memory_atomicops_swp : forall 'datasize 'n 'regsize 's 't,
  ('n >= 0 & 'n <= 31 & 'datasize in {8, 16, 32, 64} & 's >= 0 & 's <= 31 & 't >= 0 & 't <= 31).
  (int('datasize), AccType, int('n), int('regsize), int('s), AccType, int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_swp (datasize, ldacctype, n, regsize, s, stacctype, t) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let 'dbytes = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    let data = aget_Mem(address, dbytes, ldacctype);
    aset_Mem(address, dbytes, stacctype, aget_X(s));
    aset_X(t, ZeroExtend(data, regsize))
}

val memory_atomicops_swp_decode : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_swp_decode (Rt, Rn, opc, o3, Rs, R, A, V, size) = {
    __unconditional = true;
    if ~(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = shl_int(8, UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    __PostDecode();
    memory_atomicops_swp(datasize, ldacctype, n, regsize, s, stacctype, t)
}

val memory_atomicops_st : forall 'datasize 'n 's,
  ('s >= 0 & 's <= 31 & 'datasize in {8, 16, 32, 64} & 'n >= 0 & 'n <= 31).
  (int('datasize), AccType, int('n), MemAtomicOp, int('s), AccType) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_st (datasize, ldacctype, n, op, s, stacctype) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    result : bits('datasize) = undefined : bits('datasize);
    let 'dbytes = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    let value_name : bits('datasize) = aget_X(s);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data = aget_Mem(address, dbytes, ldacctype);
    match op {
      MemAtomicOp_ADD => {
          result = data + value_name
      },
      MemAtomicOp_BIC => {
          result = data & ~(value_name)
      },
      MemAtomicOp_EOR => {
          result = data ^ value_name
      },
      MemAtomicOp_ORR => {
          result = data | value_name
      },
      MemAtomicOp_SMAX => {
          result = if SInt(data) > SInt(value_name) then data else value_name
      },
      MemAtomicOp_SMIN => {
          result = if SInt(data) > SInt(value_name) then value_name else data
      },
      MemAtomicOp_UMAX => {
          result = if UInt(data) > UInt(value_name) then data else value_name
      },
      MemAtomicOp_UMIN => {
          result = if UInt(data) > UInt(value_name) then value_name else data
      }
    };
    aset_Mem(address, dbytes, stacctype, result)
}

val memory_atomicops_st_decode : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_st_decode (Rt, Rn, opc, o3, Rs, R, A, V, size) = {
    __unconditional = true;
    if ~(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = shl_int(8, UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype = AccType_ATOMICRW;
    let stacctype = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined : MemAtomicOp;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    __PostDecode();
    memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

val memory_atomicops_ld : forall 'datasize 'n 'regsize 's 't,
  ('s >= 0 & 's <= 31 & 'datasize in {8, 16, 32, 64} & 'n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (int('datasize), AccType, int('n), MemAtomicOp, int('regsize), int('s), AccType, int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_ld (datasize, ldacctype, n, op, regsize, s, stacctype, t) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    result : bits('datasize) = undefined : bits('datasize);
    let 'dbytes = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    let value_name : bits('datasize) = aget_X(s);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data = aget_Mem(address, dbytes, ldacctype);
    match op {
      MemAtomicOp_ADD => {
          result = data + value_name
      },
      MemAtomicOp_BIC => {
          result = data & ~(value_name)
      },
      MemAtomicOp_EOR => {
          result = data ^ value_name
      },
      MemAtomicOp_ORR => {
          result = data | value_name
      },
      MemAtomicOp_SMAX => {
          result = if SInt(data) > SInt(value_name) then data else value_name
      },
      MemAtomicOp_SMIN => {
          result = if SInt(data) > SInt(value_name) then value_name else data
      },
      MemAtomicOp_UMAX => {
          result = if UInt(data) > UInt(value_name) then data else value_name
      },
      MemAtomicOp_UMIN => {
          result = if UInt(data) > UInt(value_name) then value_name else data
      }
    };
    aset_Mem(address, dbytes, stacctype, result);
    if t != 31 then {
        aset_X(t, ZeroExtend(data, regsize))
    }
}

val memory_atomicops_ld_decode : (bits(5), bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_ld_decode (Rt, Rn, opc, o3, Rs, R, A, V, size) = {
    __unconditional = true;
    if ~(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = shl_int(8, UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined : MemAtomicOp;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    __PostDecode();
    memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

val memory_atomicops_cas_single : forall 'datasize 'n 'regsize 's 't,
  ('s >= 0 & 's <= 31 & 'datasize in {8, 16, 32, 64} & 'n >= 0 & 'n <= 31 & 't >= 0 & 't <= 31).
  (int('datasize), AccType, int('n), int('regsize), int('s), AccType, int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_cas_single (datasize, ldacctype, n, regsize, s, stacctype, t) = {
    address : bits(64) = undefined : bits(64);
    data : bits('datasize) = undefined : bits('datasize);
    let 'dbytes = datasize / 8;
    assert(constraint('dbytes * 8 == 'datasize));
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    let comparevalue : bits('datasize) = aget_X(s);
    let newvalue : bits('datasize) = aget_X(t);
    if n == 31 then {
        CheckSPAlignment();
        address = aget_SP()
    } else {
        address = aget_X(n)
    };
    let data = aget_Mem(address, dbytes, ldacctype);
    if data == comparevalue then {
        aset_Mem(address, dbytes, stacctype, newvalue)
    };
    aset_X(s, ZeroExtend(data, regsize))
}

val memory_atomicops_cas_single_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_cas_single_decode (Rt, Rn, Rt2, o0, Rs, o1, L, o2, size) = {
    __unconditional = true;
    if ~(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'datasize = shl_int(8, UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype = if L == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype = if o0 == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    __PostDecode();
    memory_atomicops_cas_single(datasize, ldacctype, n, regsize, s, stacctype, t)
}

val memory_atomicops_cas_pair : forall 'datasize 'n 'regsize 's 't,
  ('s >= 0 & 's <= 31 & 'datasize in {8, 16, 32, 64}) & 's + 1 <= 31 & ('t >= 0 & 't <= 31) & 't + 1 <= 31 & ('n >= 0 & 'n <= 31 | not(not('n == 31))).
  (int('datasize), AccType, int('n), int('regsize), int('s), AccType, int('t)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_cas_pair (datasize, ldacctype, n, regsize, s, stacctype, t) = {
    address : bits(64) = undefined : bits(64);
    comparevalue : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    newvalue : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    data : bits(2 * 'datasize) = undefined : bits(2 * 'datasize);
    let s1 : bits('datasize) = X(s);
    let s2 : bits('datasize) = X(s + 1);
    let t1 : bits('datasize) = X(t);
    let t2 : bits('datasize) = X(t + 1);
    let comparevalue = if BigEndian() then s1 @ s2 else s2 @ s1;
    let newvalue = if BigEndian() then t1 @ t2 else t2 @ t1;
    if HaveMTEExt() then {
        SetNotTagCheckedInstruction(n == 31)
    };
    if n == 31 then {
        CheckSPAlignment();
        address = SP()
    } else {
        address = X(n)
    };
    let data = Mem(address, 2 * datasize / 8, ldacctype);
    if data == comparevalue then {
        Mem(address, 2 * datasize / 8, stacctype) = newvalue
    };
    if BigEndian() then {
        X(s) = ZeroExtend(slice(data, datasize, datasize), regsize);
        X(s + 1) = ZeroExtend(slice(data, 0, datasize), regsize)
    } else {
        X(s) = ZeroExtend(slice(data, 0, datasize), regsize);
        X(s + 1) = ZeroExtend(slice(data, datasize, datasize), regsize)
    }
}

val memory_atomicops_cas_pair_decode : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {configuration, escape, rmem, rreg, undef, wmem, wreg}

function memory_atomicops_cas_pair_decode (Rt, Rn, Rt2, o0, Rs, o1, L, o2, sz) = {
    __unconditional = true;
    if ~(HaveAtomicExt()) then {
        throw(Error_Undefined())
    };
    if [Rs[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    if [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    };
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    assert(t <= 30);
    let 's = UInt(Rs);
    assert(s <= 30);
    let 'datasize = shl_int(32, UInt(sz));
    let 'regsize : {'n, 'n == 'datasize. int('n)} = datasize;
    let ldacctype : AccType = if L == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    __PostDecode();
    memory_atomicops_cas_pair(datasize, ldacctype, n, regsize, s, stacctype, t)
}

val AArch64_AT_S1Ex : forall ('iswrite : Bool).
  (bits(64), bits(2), bool('iswrite)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_AT_S1Ex (val_name, el, iswrite) = {
    __SAVE_EL(el);
    addrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if el == EL0 & ELUsingAArch32(EL1) | el != EL0 & ELUsingAArch32(el) then {
        addrdesc = AArch32_FirstStageTranslate(slice(val_name, 0, 32), AccType_AT, iswrite, true, 1)
    } else {
        addrdesc = AArch64_FirstStageTranslate(val_name, AccType_AT, iswrite, true, 1)
    };
    __RESTORE_EL();
    if IsFault(addrdesc) then {
        if IsExternalAbort(addrdesc.fault) | (PSTATE.EL == EL1 & EL2Enabled()) & addrdesc.fault.s2fs1walk then {
            PAR_EL1 = undefined : bits(64);
            AArch64_Abort(val_name, addrdesc.fault)
        }
    };
    AArch64_EncodePAR(addrdesc)
}

val AT_S1E3W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E3W val_name = {
    AArch64_AT_S1Ex(val_name, EL3, true)
}

val AT_S1E3R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E3R val_name = {
    AArch64_AT_S1Ex(val_name, EL3, false)
}

val AT_S1E2W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E2W val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        AArch64_AT_S1Ex(val_name, EL2, true)
    } else {
        UndefinedFault()
    }
}

val AT_S1E2R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E2R val_name = {
    if HaveEL(EL2) | PSTATE.EL != EL3 then {
        AArch64_AT_S1Ex(val_name, EL2, false)
    } else {
        UndefinedFault()
    }
}

val AT_S1E1WP : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E1WP val_name = {
    AArch64_AT_S1Ex(val_name, EL1, true)
}

val AT_S1E1W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E1W val_name = {
    AArch64_AT_S1Ex(val_name, EL1, true)
}

val AT_S1E1RP : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E1RP val_name = {
    AArch64_AT_S1Ex(val_name, EL1, false)
}

val AT_S1E1R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E1R val_name = {
    AArch64_AT_S1Ex(val_name, EL1, false)
}

val AT_S1E0W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E0W val_name = {
    AArch64_AT_S1Ex(val_name, EL0, true)
}

val AT_S1E0R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S1E0R val_name = {
    AArch64_AT_S1Ex(val_name, EL0, false)
}

val AArch64_AT_S12Ex : forall ('iswrite : Bool).
  (bits(64), bits(2), bool('iswrite)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_AT_S12Ex (val_name, el, iswrite) = {
    has_s2_translation : bool = undefined : bool;
    if HaveEL(EL3) then {
        has_s2_translation = HaveEL(EL2) & ([SCR_EL3[0]] == 0b1 | [SCR_EL3[18]] == 0b1)
    } else {
        has_s2_translation = HaveEL(EL2)
    };
    let has_s2_enabled : bool = has_s2_translation & ([HCR_EL2[0]] == 0b1 | [HCR_EL2[12]] == 0b1);
    if ~(has_s2_enabled) then {
        AArch64_AT_S1Ex(val_name, el, iswrite);
        return()
    };
    __SAVE_EL(el);
    addrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ELUsingAArch32(EL1) then {
        addrdesc = AArch32_FullTranslate(slice(val_name, 0, 32), AccType_AT, iswrite, true, 1)
    } else {
        addrdesc = AArch64_FullTranslate(val_name, AccType_AT, iswrite, true, 1)
    };
    __RESTORE_EL();
    if IsFault(addrdesc) then {
        if IsExternalAbort(addrdesc.fault) | (PSTATE.EL == EL1 & EL2Enabled()) & addrdesc.fault.s2fs1walk then {
            PAR_EL1 = undefined : bits(64);
            AArch64_Abort(val_name, addrdesc.fault)
        }
    };
    AArch64_EncodePAR(addrdesc)
}

val AT_S12E1W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S12E1W val_name = {
    AArch64_AT_S12Ex(val_name, EL1, true)
}

val AT_S12E1R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S12E1R val_name = {
    AArch64_AT_S12Ex(val_name, EL1, false)
}

val AT_S12E0W : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S12E0W val_name = {
    AArch64_AT_S12Ex(val_name, EL0, true)
}

val AT_S12E0R : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AT_S12E0R val_name = {
    AArch64_AT_S12Ex(val_name, EL0, false)
}

val check_access : forall ('iswrite : Bool) ('a64nb : Int).
  (bits(64), bool('iswrite), int('a64nb)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function check_access (val_name, iswrite, a64nb) = {
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        memaddrdesc = AArch64_TranslateAddress(val_name, AccType_DC, iswrite, true, a64nb);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), AccType_DC, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    }
}

val DC_IGVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_IGVAC val_name = {
    fault_at_EL0();
    check_access(val_name, true, 4);
    return()
}

val DC_CIGVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CIGVAC val_name = {
    fault_at_EL0();
    check_access(val_name, false, 8);
    return()
}

val DC_CGVAP : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CGVAP val_name = {
    fault_at_EL0();
    check_access(val_name, false, 4);
    return()
}

val DC_CGVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CGVAC val_name = {
    fault_at_EL0();
    check_access(val_name, false, 4);
    return()
}

val IC_IVAU : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function IC_IVAU val_name = {
    if PSTATE.EL == EL0 & ELUsingAArch32(PSTATE.EL) then {
        UndefinedFault()
    };
    let iswrite = false;
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        memaddrdesc = AArch64_TranslateAddress(val_name, AccType_DC, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), AccType_DC, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    };
    return()
}

val DC_IVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_IVAC val_name = {
    acctype : AccType = undefined : AccType;
    if PSTATE.EL == EL0 then {
        if ELUsingAArch32(PSTATE.EL) then {
            UndefinedFault()
        } else {
            acctype = AccType_DC_UNPRIV
        }
    } else {
        acctype = AccType_DC
    };
    iswrite : bool = undefined : bool;
    iswrite = true;
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        iswrite = true;
        memaddrdesc = AArch64_TranslateAddress(val_name, acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        iswrite = true;
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    };
    if HasS2Translation() & [HCR_EL2[0]] == 0b1 then ();
    return()
}

val DC_IGDVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_IGDVAC val_name = {
    DC_IVAC(val_name);
    DC_IGVAC(val_name);
    return()
}

val DC_CVAU : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CVAU val_name = {
    acctype : AccType = undefined : AccType;
    if PSTATE.EL == EL0 then {
        if ELUsingAArch32(PSTATE.EL) then {
            UndefinedFault()
        } else {
            acctype = AccType_DC_UNPRIV
        }
    } else {
        acctype = AccType_DC
    };
    let iswrite = false;
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        memaddrdesc = AArch64_TranslateAddress(val_name, acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    };
    return()
}

val DC_CVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CVAC val_name = {
    acctype : AccType = undefined : AccType;
    if PSTATE.EL == EL0 then {
        if ELUsingAArch32(PSTATE.EL) then {
            UndefinedFault()
        } else {
            acctype = AccType_DC_UNPRIV
        }
    } else {
        acctype = AccType_DC
    };
    let iswrite = false;
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        memaddrdesc = AArch64_TranslateAddress(val_name, acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    };
    return()
}

val DC_CVAP : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CVAP val_name = {
    DC_CVAC(val_name)
}

val DC_CGDVAP : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CGDVAP val_name = {
    DC_CVAP(val_name);
    DC_CGVAP(val_name);
    return()
}

val DC_CGDVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CGDVAC val_name = {
    DC_CVAC(val_name);
    DC_CGVAC(val_name);
    return()
}

val DC_CIVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CIVAC val_name = {
    acctype : AccType = undefined : AccType;
    if PSTATE.EL == EL0 then {
        if ELUsingAArch32(PSTATE.EL) then {
            UndefinedFault()
        } else {
            acctype = AccType_DC_UNPRIV
        }
    } else {
        acctype = AccType_DC
    };
    let iswrite = false;
    memaddrdesc : AddressDescriptor = undefined : AddressDescriptor;
    if ~(ELUsingAArch32(PSTATE.EL)) then {
        memaddrdesc = AArch64_TranslateAddress(val_name, acctype, iswrite, true, 8);
        if IsFault(memaddrdesc) then {
            AArch64_Abort(val_name, memaddrdesc.fault)
        }
    } else {
        memaddrdesc = AArch32_TranslateAddress(slice(val_name, 0, 32), acctype, iswrite, true, 4);
        if IsFault(memaddrdesc) then {
            AArch32_Abort(slice(val_name, 0, 32), memaddrdesc.fault)
        }
    };
    return()
}

val DC_CIGDVAC : bits(64) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function DC_CIGDVAC val_name = {
    DC_CIVAC(val_name);
    DC_CIGVAC(val_name);
    return()
}

val AArch64_AutoGen_SysOpsWrite : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(1), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_AutoGen_SysOpsWrite (el, op0, op1, CRn, op2, CRm, read, val_name) = {
    if op0 == 0b01 then {
        if CRn == 0x8 then {
            if op1 == 0b100 then {
                if op2 == 0b001 then {
                    if CRm == 0x0 then {
                        TLBI_IPAS2E1IS(ZeroExtend(val_name));
                        return()
                    } else {
                        if CRm == 0x1 then {
                            TLBI_VAE2OS(ZeroExtend(val_name));
                            return()
                        } else {
                            if CRm == 0x2 then {
                                TLBI_RVAE2IS(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x5 then {
                                    TLBI_RVAE2OS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x4 then {
                                        TLBI_IPAS2E1(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x6 then {
                                            TLBI_RVAE2(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x7 then {
                                                TLBI_VAE2(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x3 then {
                                                    TLBI_VAE2IS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op2 == 0b101 then {
                        if CRm == 0x0 then {
                            TLBI_IPAS2LE1IS(ZeroExtend(val_name));
                            return()
                        } else {
                            if CRm == 0x1 then {
                                TLBI_VALE2OS(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x2 then {
                                    TLBI_RVALE2IS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x5 then {
                                        TLBI_RVALE2OS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x4 then {
                                            TLBI_IPAS2LE1(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x6 then {
                                                TLBI_RVALE2(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x7 then {
                                                    TLBI_VALE2(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0x3 then {
                                                        TLBI_VALE2IS(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x4 then {
                            if op2 == 0b010 then {
                                TLBI_RIPAS2E1(ZeroExtend(val_name));
                                return()
                            } else {
                                if op2 == 0b000 then {
                                    TLBI_IPAS2E1OS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if op2 == 0b011 then {
                                        TLBI_RIPAS2E1OS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b111 then {
                                            TLBI_RIPAS2LE1OS(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b100 then {
                                                TLBI_IPAS2LE1OS(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b110 then {
                                                    TLBI_RIPAS2LE1(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b110 then {
                                if CRm == 0x0 then {
                                    TLBI_RIPAS2LE1IS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x1 then {
                                        TLBI_VMALLS12E1OS();
                                        return()
                                    } else {
                                        if CRm == 0x7 then {
                                            TLBI_VMALLS12E1();
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                TLBI_VMALLS12E1IS();
                                                return()
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b000 then {
                                    if CRm == 0x1 then {
                                        TLBI_ALLE2OS();
                                        return()
                                    } else {
                                        if CRm == 0x7 then {
                                            TLBI_ALLE2();
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                TLBI_ALLE2IS();
                                                return()
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b100 then {
                                        if CRm == 0x1 then {
                                            TLBI_ALLE1OS();
                                            return()
                                        } else {
                                            if CRm == 0x7 then {
                                                TLBI_ALLE1();
                                                return()
                                            } else {
                                                if CRm == 0x3 then {
                                                    TLBI_ALLE1IS();
                                                    return()
                                                }
                                            }
                                        }
                                    } else {
                                        if op2 == 0b010 then {
                                            if CRm == 0x0 then {
                                                TLBI_RIPAS2E1IS(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if op1 == 0b000 then {
                    if CRm == 0x1 then {
                        if op2 == 0b010 then {
                            TLBI_ASIDE1OS(ZeroExtend(val_name));
                            return()
                        } else {
                            if op2 == 0b101 then {
                                TLBI_VALE1OS(ZeroExtend(val_name));
                                return()
                            } else {
                                if op2 == 0b000 then {
                                    TLBI_VMALLE1OS();
                                    return()
                                } else {
                                    if op2 == 0b011 then {
                                        TLBI_VAAE1OS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b111 then {
                                            TLBI_VAALE1OS(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b001 then {
                                                TLBI_VAE1OS(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x3 then {
                            if op2 == 0b010 then {
                                TLBI_ASIDE1IS(ZeroExtend(val_name));
                                return()
                            } else {
                                if op2 == 0b000 then {
                                    TLBI_VMALLE1IS();
                                    return()
                                } else {
                                    if op2 == 0b101 then {
                                        TLBI_VALE1IS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b011 then {
                                            TLBI_VAAE1IS(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b111 then {
                                                TLBI_VAALE1IS(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b001 then {
                                                    TLBI_VAE1IS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if CRm == 0x7 then {
                                if op2 == 0b010 then {
                                    TLBI_ASIDE1(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if op2 == 0b000 then {
                                        TLBI_VMALLE1();
                                        return()
                                    } else {
                                        if op2 == 0b101 then {
                                            TLBI_VALE1(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b011 then {
                                                TLBI_VAAE1(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b111 then {
                                                    TLBI_VAALE1(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if op2 == 0b001 then {
                                                        TLBI_VAE1(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0x2 then {
                                    if op2 == 0b101 then {
                                        TLBI_RVALE1IS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b011 then {
                                            TLBI_RVAAE1IS(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b111 then {
                                                TLBI_RVAALE1IS(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b001 then {
                                                    TLBI_RVAE1IS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if CRm == 0x6 then {
                                        if op2 == 0b101 then {
                                            TLBI_RVALE1(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b011 then {
                                                TLBI_RVAAE1(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b111 then {
                                                    TLBI_RVAALE1(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if op2 == 0b001 then {
                                                        TLBI_RVAE1(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if CRm == 0x5 then {
                                            if op2 == 0b101 then {
                                                TLBI_RVALE1OS(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b011 then {
                                                    TLBI_RVAAE1OS(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if op2 == 0b111 then {
                                                        TLBI_RVAALE1OS(ZeroExtend(val_name));
                                                        return()
                                                    } else {
                                                        if op2 == 0b001 then {
                                                            TLBI_RVAE1OS(ZeroExtend(val_name));
                                                            return()
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b110 then {
                        if op2 == 0b001 then {
                            if CRm == 0x1 then {
                                TLBI_VAE3OS(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x2 then {
                                    TLBI_RVAE3IS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x5 then {
                                        TLBI_RVAE3OS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x6 then {
                                            TLBI_RVAE3(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x7 then {
                                                TLBI_VAE3(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x3 then {
                                                    TLBI_VAE3IS(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b101 then {
                                if CRm == 0x1 then {
                                    TLBI_VALE3OS(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0x2 then {
                                        TLBI_RVALE3IS(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x5 then {
                                            TLBI_RVALE3OS(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x6 then {
                                                TLBI_RVALE3(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0x7 then {
                                                    TLBI_VALE3(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0x3 then {
                                                        TLBI_VALE3IS(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b000 then {
                                    if CRm == 0x1 then {
                                        TLBI_ALLE3OS();
                                        return()
                                    } else {
                                        if CRm == 0x7 then {
                                            TLBI_ALLE3();
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                TLBI_ALLE3IS();
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if CRn == 0x7 then {
                if op1 == 0b000 then {
                    if CRm == 0x6 then {
                        if op2 == 0b010 then {
                            DC_ISW(ZeroExtend(val_name));
                            return()
                        } else {
                            if op2 == 0b101 then {
                                DC_IGDVAC(ZeroExtend(val_name));
                                return()
                            } else {
                                if op2 == 0b011 then {
                                    DC_IGVAC(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if op2 == 0b100 then {
                                        DC_IGSW(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b001 then {
                                            DC_IVAC(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b110 then {
                                                DC_IGDSW(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if op2 == 0b000 then {
                            if CRm == 0x8 then {
                                AT_S1E1R(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0x5 then {
                                    IC_IALLU();
                                    return()
                                } else {
                                    if CRm == 0x1 then {
                                        IC_IALLUIS();
                                        return()
                                    } else {
                                        if CRm == 0x9 then {
                                            AT_S1E1RP(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b010 then {
                                if CRm == 0x8 then {
                                    AT_S1E0R(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0xA then {
                                        DC_CSW(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0xE then {
                                            DC_CISW(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                }
                            } else {
                                if CRm == 0xE then {
                                    if op2 == 0b100 then {
                                        DC_CIGSW(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b110 then {
                                            DC_CIGDSW(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                } else {
                                    if CRm == 0xA then {
                                        if op2 == 0b100 then {
                                            DC_CGSW(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b110 then {
                                                DC_CGDSW(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    } else {
                                        if CRm == 0x8 then {
                                            if op2 == 0b011 then {
                                                AT_S1E0W(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b001 then {
                                                    AT_S1E1W(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        } else {
                                            if op2 == 0b001 then {
                                                if CRm == 0x9 then {
                                                    AT_S1E1WP(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if op1 == 0b011 then {
                        if op2 == 0b001 then {
                            if CRm == 0xE then {
                                DC_CIVAC(ZeroExtend(val_name));
                                return()
                            } else {
                                if CRm == 0xA then {
                                    DC_CVAC(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if CRm == 0xD then {
                                        DC_CVADP(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x5 then {
                                            IC_IVAU(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x4 then {
                                                DC_ZVA(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0xB then {
                                                    DC_CVAU(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0xC then {
                                                        DC_CVAP(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if op2 == 0b011 then {
                                if CRm == 0xD then {
                                    DC_CGVADP();
                                    return()
                                } else {
                                    if CRm == 0xA then {
                                        DC_CGVAC(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if CRm == 0x4 then {
                                            DC_GVA(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0xE then {
                                                DC_CIGVAC(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0xC then {
                                                    DC_CGVAP(ZeroExtend(val_name));
                                                    return()
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op2 == 0b101 then {
                                    if CRm == 0xD then {
                                        DC_CGDVADP();
                                        return()
                                    } else {
                                        if CRm == 0xA then {
                                            DC_CGDVAC(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                DVP_RCTX(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if CRm == 0xE then {
                                                    DC_CIGDVAC(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if CRm == 0xC then {
                                                        DC_CGDVAP(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if op2 == 0b100 then {
                                        if CRm == 0x4 then {
                                            DC_GZVA(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if CRm == 0x3 then {
                                                CFP_RCTX(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    } else {
                                        if op2 == 0b111 then {
                                            if CRm == 0x3 then {
                                                CPP_RCTX(ZeroExtend(val_name));
                                                return()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if CRm == 0x8 then {
                            if op1 == 0b100 then {
                                if op2 == 0b000 then {
                                    AT_S1E2R(ZeroExtend(val_name));
                                    return()
                                } else {
                                    if op2 == 0b101 then {
                                        AT_S12E1W(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b111 then {
                                            AT_S12E0W(ZeroExtend(val_name));
                                            return()
                                        } else {
                                            if op2 == 0b100 then {
                                                AT_S12E1R(ZeroExtend(val_name));
                                                return()
                                            } else {
                                                if op2 == 0b001 then {
                                                    AT_S1E2W(ZeroExtend(val_name));
                                                    return()
                                                } else {
                                                    if op2 == 0b110 then {
                                                        AT_S12E0R(ZeroExtend(val_name));
                                                        return()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if op1 == 0b110 then {
                                    if op2 == 0b000 then {
                                        AT_S1E3R(ZeroExtend(val_name));
                                        return()
                                    } else {
                                        if op2 == 0b001 then {
                                            AT_S1E3W(ZeroExtend(val_name));
                                            return()
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

val AArch64_SysInstr : forall 'op0 'op1 'crn 'crm 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), bits(64)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function AArch64_SysInstr (op0, op1, crn, crm, op2, val_name) = {
    AArch64_AutoGen_SysOpsWrite(PSTATE.EL, __GetSlice_int(2, op0, 0), __GetSlice_int(3, op1, 0), __GetSlice_int(4, crn, 0), __GetSlice_int(3, op2, 0), __GetSlice_int(4, crm, 0), 0b0, val_name)
}

val system_sysops : forall ('has_result : Bool) 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't,
  ('t >= 0 & 't <= 31 | not('has_result)) & ('t >= 0 & 't <= 31 | not(not('has_result))).
  (bool('has_result), int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function system_sysops (has_result, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t) = {
    if has_result then {
        X(t) = AArch64_SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2)
    } else {
        AArch64_SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X(t))
    }
}

val system_sysops_decode : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape, rmem, rreg, undef, wmem, wreg}

function system_sysops_decode (Rt, op2, CRm, CRn, op1, op0, L) = {
    __unconditional = true;
    AArch64_CheckSystemAccess(0b01, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 1;
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let has_result = L == 0b1;
    __PostDecode();
    system_sysops(has_result, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

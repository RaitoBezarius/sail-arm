chapter \<open>Generated by Lem from \<open>aarch64_extras.lem\<close>.\<close>

theory "Aarch64_extras" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_prompt"

begin 

\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_instr_kinds\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators_mwords\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt\<close>\<close>

\<comment> \<open>\<open>type ty512\<close>\<close>
\<comment> \<open>\<open>type ty1024\<close>\<close>
\<comment> \<open>\<open>type ty2048\<close>\<close>

\<comment> \<open>\<open>let hexchar_to_bool_list c =
  if c = #'0' then      Just ([false;false;false;false])
  else if c = #'1' then Just ([false;false;false;true ])
  else if c = #'2' then Just ([false;false;true; false])
  else if c = #'3' then Just ([false;false;true; true ])
  else if c = #'4' then Just ([false;true; false;false])
  else if c = #'5' then Just ([false;true; false;true ])
  else if c = #'6' then Just ([false;true; true; false])
  else if c = #'7' then Just ([false;true; true; true ])
  else if c = #'8' then Just ([true; false;false;false])
  else if c = #'9' then Just ([true; false;false;true ])
  else if c = #'A' then Just ([true; false;true; false])
  else if c = #'a' then Just ([true; false;true; false])
  else if c = #'B' then Just ([true; false;true; true ])
  else if c = #'b' then Just ([true; false;true; true ])
  else if c = #'C' then Just ([true; true; false;false])
  else if c = #'c' then Just ([true; true; false;false])
  else if c = #'D' then Just ([true; true; false;true ])
  else if c = #'d' then Just ([true; true; false;true ])
  else if c = #'E' then Just ([true; true; true; false])
  else if c = #'e' then Just ([true; true; true; false])
  else if c = #'F' then Just ([true; true; true; true ])
  else if c = #'f' then Just ([true; true; true; true ])
  else Nothing

let hexstring_to_bools s =
  match (toCharList s) with
    | z :: x :: hs ->
       let str = if (z = #'0' && x = #'x') then hs else z :: x :: hs in
       Maybe.map List.concat (just_list (List.map hexchar_to_bool_list str))
    | _ -> Nothing
  end\<close>\<close>

\<comment> \<open>\<open>val hex_slice : forall 'rv 'e. string -> integer -> integer -> monad 'rv (list bitU) 'e
let hex_slice v len lo =
  match hexstring_to_bools v with
    | Just bs ->
       let hi = len + lo - 1 in
       let bs = ext_list false (len + lo) bs in
       return (of_bools (subrange_list false bs hi lo))
    | Nothing -> Fail "hex_slice"
  end\<close>\<close>

definition undefined_string  :: " unit \<Rightarrow>('b,(string),'a)monad "  where 
     " undefined_string _ = ( return (''''))"

definition undefined_unit  :: " unit \<Rightarrow>('b,(unit),'a)monad "  where 
     " undefined_unit _ = ( return ()  )"

definition undefined_int  :: " unit \<Rightarrow>('c,'a,'b)monad "  where 
     " undefined_int _ = ( return (failwith (''undefined_int'')))"

\<comment> \<open>\<open>val undefined_vector : forall 'rv 'a 'e. integer -> 'a -> monad 'rv (list 'a) 'e\<close>\<close>
definition undefined_vector  :: " int \<Rightarrow> 'a \<Rightarrow>('rv,('a list),'e)monad "  where 
     " undefined_vector len u = ( return (repeat [u] len))"

\<comment> \<open>\<open>val undefined_bitvector : forall 'rv 'e 'a. Size 'a => integer -> monad 'rv (mword 'a) 'e\<close>\<close>
definition undefined_bitvector  :: " int \<Rightarrow>('rv,(('a::len)Word.word),'e)monad "  where 
     " undefined_bitvector len = ( of_bits_nondet 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (repeat [BU] len))"

\<comment> \<open>\<open>val undefined_bits : forall 'rv 'e 'a. Size 'a => integer -> monad 'rv (mword 'a) 'e\<close>\<close>
definition undefined_bits  :: " int \<Rightarrow>('rv,(('a::len)Word.word),'e)monad "  where 
     " undefined_bits = ( undefined_bitvector )"

definition undefined_bit  :: " unit \<Rightarrow>('b,(bitU),'a)monad "  where 
     " undefined_bit _ = ( choose_bool (''undefined_bit'') \<bind> (\<lambda> b .  return (bitU_of_bool b)))"

definition undefined_real  :: " unit \<Rightarrow> 'a "  where 
     " undefined_real _ = ( failwith (''undefined_real''))"

definition undefined_range  :: " int \<Rightarrow> int \<Rightarrow>('b,(int),'a)monad "  where 
     " undefined_range i j = ( chooseM (''undefined_range'') (index_list i j(( 1 :: int))))"

definition undefined_atom  :: " 'a \<Rightarrow>('c,'a,'b)monad "  where 
     " undefined_atom i = ( return i )"

definition undefined_nat  :: " unit \<Rightarrow> 'a "  where 
     " undefined_nat _ = ( failwith (''undefined_nat''))"


\<comment> \<open>\<open>val write_ram : forall 'rv 'e 'a 'b 'c. Size 'a, Size 'b, Size 'c =>
  integer -> integer -> mword 'a -> mword 'b -> mword 'c -> monad 'rv unit 'e\<close>\<close>
definition write_ram  :: " int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('c::len)Word.word \<Rightarrow>('rv,(unit),'e)monad "  where 
     " write_ram addrsize size1 hexRAM address value1 = (
  (write_mem_ea instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_plain ()  address size1 \<then>
  write_mem instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_plain ()  address size1 value1) \<bind>  
  (\<lambda>x .  (case  x of _ => return ()  )) )"


\<comment> \<open>\<open>val read_ram : forall 'rv 'e 'a 'b 'c. Size 'a, Size 'b, Size 'c =>
  integer -> integer -> mword 'a -> mword 'b -> monad 'rv (mword 'c) 'e\<close>\<close>
definition read_ram  :: " int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('rv,(('c::len)Word.word),'e)monad "  where 
     " read_ram addrsize size1 hexRAM address = (
  read_mem instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain ()  address size1 )"


\<comment> \<open>\<open>val elf_entry : unit -> integer\<close>\<close>
definition elf_entry  :: " unit \<Rightarrow> int "  where 
     " elf_entry _ = (( 0 :: int))"


definition hex_str  :: " int \<Rightarrow> string "  where 
     " hex_str = ( dec_str )"
 \<comment> \<open>\<open> TODO \<close>\<close>

\<comment> \<open>\<open>let prerr_bits _ _ = ()
let print_bits _ _ = ()
let print _ = ()\<close>\<close>

definition wakeup_request  :: " 'c \<Rightarrow>('b,(unit),'a)monad "  where 
     " wakeup_request _ = ( return ()  )"

definition sleep_request  :: " 'c \<Rightarrow>('b,(unit),'a)monad "  where 
     " sleep_request _ = ( return ()  )"


definition integerOfString0  :: " 'b \<Rightarrow> 'a "  where 
     " integerOfString0 _ = ( failwith (''integerOfString''))"
 \<comment> \<open>\<open> TODO \<close>\<close>
definition abs_real  :: " real \<Rightarrow> real "  where 
     " abs_real = ( abs )"

end

(*Generated by Lem from aarch64_extras.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory sail2_valuesTheory sail2_prompt_monadTheory sail2_promptTheory sail2_instr_kindsTheory sail2_operators_mwordsTheory;

val _ = numLib.prefer_num();



val _ = new_theory "aarch64_extras"

(*open import Pervasives_extra*)
(*open import Sail2_instr_kinds*)
(*open import Sail2_values*)
(*open import Sail2_operators_mwords*)
(*open import Sail2_prompt_monad*)
(*open import Sail2_prompt*)

(*type ty512*)
(*type ty1024*)
(*type ty2048*)

(*let hexchar_to_bool_list c =
  if c = #'0' then      Just ([false;false;false;false])
  else if c = #'1' then Just ([false;false;false;true ])
  else if c = #'2' then Just ([false;false;true; false])
  else if c = #'3' then Just ([false;false;true; true ])
  else if c = #'4' then Just ([false;true; false;false])
  else if c = #'5' then Just ([false;true; false;true ])
  else if c = #'6' then Just ([false;true; true; false])
  else if c = #'7' then Just ([false;true; true; true ])
  else if c = #'8' then Just ([true; false;false;false])
  else if c = #'9' then Just ([true; false;false;true ])
  else if c = #'A' then Just ([true; false;true; false])
  else if c = #'a' then Just ([true; false;true; false])
  else if c = #'B' then Just ([true; false;true; true ])
  else if c = #'b' then Just ([true; false;true; true ])
  else if c = #'C' then Just ([true; true; false;false])
  else if c = #'c' then Just ([true; true; false;false])
  else if c = #'D' then Just ([true; true; false;true ])
  else if c = #'d' then Just ([true; true; false;true ])
  else if c = #'E' then Just ([true; true; true; false])
  else if c = #'e' then Just ([true; true; true; false])
  else if c = #'F' then Just ([true; true; true; true ])
  else if c = #'f' then Just ([true; true; true; true ])
  else Nothing

let hexstring_to_bools s =
  match (toCharList s) with
    | z :: x :: hs ->
       let str = if (z = #'0' && x = #'x') then hs else z :: x :: hs in
       Maybe.map List.concat (just_list (List.map hexchar_to_bool_list str))
    | _ -> Nothing
  end*)

(*val hex_slice : forall 'rv 'e. string -> integer -> integer -> monad 'rv (list bitU) 'e
let hex_slice v len lo =
  match hexstring_to_bools v with
    | Just bs ->
       let hi = len + lo - 1 in
       let bs = ext_list false (len + lo) bs in
       return (of_bools (subrange_list false bs hi lo))
    | Nothing -> Fail "hex_slice"
  end*)

val _ = Define `
 ((undefined_string:unit -> 'a sail2_state_monad$sequential_state ->(((string),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$returnS ""))`;

val _ = Define `
 ((undefined_unit:unit -> 'a sail2_state_monad$sequential_state ->(((unit),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$returnS () ))`;

val _ = Define `
 ((undefined_int:unit -> 'b sail2_state_monad$sequential_state ->(('a,'c)sail2_state_monad$result#'b sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$returnS (failwith "undefined_int")))`;

(*val undefined_vector : forall 'rv 'a 'e. integer -> 'a -> monad 'rv (list 'a) 'e*)
val _ = Define `
 ((undefined_vector:int -> 'a -> 'rv sail2_state_monad$sequential_state ->((('a list),'e)sail2_state_monad$result#'rv sail2_state_monad$sequential_state)set) len u=  (sail2_state_monad$returnS (repeat [u] len)))`;

(*val undefined_bitvector : forall 'rv 'e 'a. Size 'a => integer -> monad 'rv (mword 'a) 'e*)
val _ = Define `
 ((undefined_bitvector:int -> 'rv sail2_state_monad$sequential_state ->((('a words$word),'e)sail2_state_monad$result#'rv sail2_state_monad$sequential_state)set) len=  (sail2_state$of_bits_nondetS 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (repeat [BU] len)))`;

(*val undefined_bits : forall 'rv 'e 'a. Size 'a => integer -> monad 'rv (mword 'a) 'e*)
val _ = Define `
 ((undefined_bits:int ->('rv,('a words$word),'e)monad)=  undefined_bitvector)`;

val _ = Define `
 ((undefined_bit:unit -> 'a sail2_state_monad$sequential_state ->(((bitU),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS (sail2_state_monad$choose_boolS () ) (\ b .  sail2_state_monad$returnS (bitU_of_bool b))))`;

val _ = Define `
 ((undefined_real:unit -> 'a) () =  (failwith "undefined_real"))`;

val _ = Define `
 ((undefined_range:int -> int -> 'a sail2_state_monad$sequential_state ->(((int),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) i j=  (sail2_state_monad$chooseS (index_list i j(( 1 : int)))))`;

val _ = Define `
 ((undefined_atom:'a -> 'b sail2_state_monad$sequential_state ->(('a,'c)sail2_state_monad$result#'b sail2_state_monad$sequential_state)set) i=  (sail2_state_monad$returnS i))`;

val _ = Define `
 ((undefined_nat:unit -> 'a) () =  (failwith "undefined_nat"))`;


(*val write_ram : forall 'rv 'e 'a 'b 'c. Size 'a, Size 'b, Size 'c =>
  integer -> integer -> mword 'a -> mword 'b -> mword 'c -> monad 'rv unit 'e*)
val _ = Define `
 ((write_ram:int -> int -> 'a words$word -> 'b words$word -> 'c words$word -> 'rv sail2_state_monad$sequential_state ->(((unit),'e)sail2_state_monad$result#'rv sail2_state_monad$sequential_state)set) addrsize size1 hexRAM address value=  (sail2_state_monad$bindS (sail2_state_monad$seqS
  (sail2_state_monad$returnS () )
  (sail2_state_monad$write_memS 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_plain ()  address size1 value)) 
  (\b .  (case (b ) of ( _ ) => sail2_state_monad$returnS ()  ))))`;


(*val read_ram : forall 'rv 'e 'a 'b 'c. Size 'a, Size 'b, Size 'c =>
  integer -> integer -> mword 'a -> mword 'b -> monad 'rv (mword 'c) 'e*)
val _ = Define `
 ((read_ram:int -> int -> 'a words$word -> 'b words$word -> 'rv sail2_state_monad$sequential_state ->((('c words$word),'e)sail2_state_monad$result#'rv sail2_state_monad$sequential_state)set) addrsize size1 hexRAM address=
   (sail2_state_monad$read_memS 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain ()  address size1))`;


(*val elf_entry : unit -> integer*)
val _ = Define `
 ((elf_entry:unit -> int) () = (( 0 : int)))`;


val _ = Define `
 ((hex_str:int -> string)=  dec_str)`;
 (* TODO *)

(*let prerr_bits _ _ = ()
let print_bits _ _ = ()
let print _ = ()*)

val _ = Define `
 ((wakeup_request:'c -> 'a sail2_state_monad$sequential_state ->(((unit),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) _=  (sail2_state_monad$returnS () ))`;

val _ = Define `
 ((sleep_request:'c -> 'a sail2_state_monad$sequential_state ->(((unit),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) _=  (sail2_state_monad$returnS () ))`;


val _ = Define `
 ((integerOfString0:'b -> 'a) _=  (failwith "integerOfString"))`;
 (* TODO *)
val _ = Define `
 ((abs_real:real -> real)=  (\ n. (if n >(real_of_num 0) then n else(real_of_num 0) - n)))`;

val _ = export_theory()


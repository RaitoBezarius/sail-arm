chapter \<open>Generated by Lem from \<open>lem/armv9_types.lem\<close>.\<close>

theory "Armv9_types" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_concurrency_interface"
  "Sail.Sail2_monadic_combinators"
  "Sail.Sail2_string"
  "Prelude"
  "Sail.Sail2_undefined_concurrency_interface"

begin 

\<comment> \<open>\<open>Generated by Sail from armv9.\<close>\<close>
\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_instr_kinds\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_string\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators_mwords\<close>\<close>
\<comment> \<open>\<open>open import Sail2_concurrency_interface\<close>\<close>
\<comment> \<open>\<open>open import Sail2_monadic_combinators\<close>\<close>
\<comment> \<open>\<open>open import Prelude\<close>\<close>
\<comment> \<open>\<open>open import Sail2_undefined_concurrency_interface\<close>\<close>
type_synonym 'n bits =" ( 'n::len)Word.word "




datatype signal =   LOW | HIGH



datatype exception  =
    Error_Undefined " (unit)"
  | Error_See " (string)"
  | Error_ImplementationDefined " (string)"
  | Error_ReservedEncoding " (unit)"
  | Error_ExceptionTaken " (unit)"
  | Error_Unpredictable " (unit)"
  | Error_ConstrainedUnpredictable " (unit)"
  | Error_SError " (bool)"







type_synonym vector_length  =" int "


type_synonym predicate_length  =" int "


record (overloaded) Configuration_Type  = 
 Configuration_Type_bits ::"  32 Word.word "  



record (overloaded) ACCDATA_EL1_Type  = 
 ACCDATA_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) AMCFGR_EL0_Type  = 
 AMCFGR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMCFGR_Type  = 
 AMCFGR_Type_bits ::"  32 Word.word "  



record (overloaded) AMCG1IDR_EL0_Type  = 
 AMCG1IDR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMCGCR_EL0_Type  = 
 AMCGCR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMCGCR_Type  = 
 AMCGCR_Type_bits ::"  32 Word.word "  



record (overloaded) AMCIDR0_Type  = 
 AMCIDR0_Type_bits ::"  32 Word.word "  



record (overloaded) AMCIDR1_Type  = 
 AMCIDR1_Type_bits ::"  32 Word.word "  



record (overloaded) AMCIDR2_Type  = 
 AMCIDR2_Type_bits ::"  32 Word.word "  



record (overloaded) AMCIDR3_Type  = 
 AMCIDR3_Type_bits ::"  32 Word.word "  



record (overloaded) AMCNTENCLR0_EL0_Type  = 
 AMCNTENCLR0_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMCNTENCLR0_Type  = 
 AMCNTENCLR0_Type_bits ::"  32 Word.word "  



record (overloaded) AMCNTENCLR1_EL0_Type  = 
 AMCNTENCLR1_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMCNTENCLR1_Type  = 
 AMCNTENCLR1_Type_bits ::"  32 Word.word "  



record (overloaded) AMCNTENSET0_EL0_Type  = 
 AMCNTENSET0_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMCNTENSET0_Type  = 
 AMCNTENSET0_Type_bits ::"  32 Word.word "  



record (overloaded) AMCNTENSET1_EL0_Type  = 
 AMCNTENSET1_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMCNTENSET1_Type  = 
 AMCNTENSET1_Type_bits ::"  32 Word.word "  



record (overloaded) AMCR_EL0_Type  = 
 AMCR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMCR_Type  = 
 AMCR_Type_bits ::"  32 Word.word "  



record (overloaded) AMDEVARCH_Type  = 
 AMDEVARCH_Type_bits ::"  32 Word.word "  



record (overloaded) AMDEVTYPE_Type  = 
 AMDEVTYPE_Type_bits ::"  32 Word.word "  



record (overloaded) AMEVCNTR0_EL0_Type  = 
 AMEVCNTR0_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMEVCNTR0_Type  = 
 AMEVCNTR0_Type_bits ::"  64 Word.word "  



record (overloaded) AMEVCNTR1_EL0_Type  = 
 AMEVCNTR1_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMEVCNTR1_Type  = 
 AMEVCNTR1_Type_bits ::"  64 Word.word "  



record (overloaded) AMEVTYPER0_EL0_Type  = 
 AMEVTYPER0_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMEVTYPER0_Type  = 
 AMEVTYPER0_Type_bits ::"  32 Word.word "  



record (overloaded) AMEVTYPER1_EL0_Type  = 
 AMEVTYPER1_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMEVTYPER1_Type  = 
 AMEVTYPER1_Type_bits ::"  32 Word.word "  



record (overloaded) AMIIDR_Type  = 
 AMIIDR_Type_bits ::"  32 Word.word "  



record (overloaded) AMPIDR0_Type  = 
 AMPIDR0_Type_bits ::"  32 Word.word "  



record (overloaded) AMPIDR1_Type  = 
 AMPIDR1_Type_bits ::"  32 Word.word "  



record (overloaded) AMPIDR2_Type  = 
 AMPIDR2_Type_bits ::"  32 Word.word "  



record (overloaded) AMPIDR3_Type  = 
 AMPIDR3_Type_bits ::"  32 Word.word "  



record (overloaded) AMPIDR4_Type  = 
 AMPIDR4_Type_bits ::"  32 Word.word "  



record (overloaded) AMUSERENR_EL0_Type  = 
 AMUSERENR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) AMUSERENR_Type  = 
 AMUSERENR_Type_bits ::"  32 Word.word "  



record (overloaded) BRBCR_EL1_Type  = 
 BRBCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) BRBCR_EL2_Type  = 
 BRBCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) BRBFCR_EL1_Type  = 
 BRBFCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) BRBIDR0_EL1_Type  = 
 BRBIDR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) BRBINFINJ_EL1_Type  = 
 BRBINFINJ_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) BRBINFType  = 
 BRBINFType_bits ::"  64 Word.word "  



record (overloaded) BRBINF_EL1_Type  = 
 BRBINF_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) BRBSRCINJ_EL1_Type  = 
 BRBSRCINJ_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) BRBSRCType  = 
 BRBSRCType_bits ::"  64 Word.word "  



record (overloaded) BRBSRC_EL1_Type  = 
 BRBSRC_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) BRBTGTINJ_EL1_Type  = 
 BRBTGTINJ_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) BRBTGTType  = 
 BRBTGTType_bits ::"  64 Word.word "  



record (overloaded) BRBTGT_EL1_Type  = 
 BRBTGT_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) BRBTS_EL1_Type  = 
 BRBTS_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CCSIDR2_EL1_Type  = 
 CCSIDR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CCSIDR2_Type  = 
 CCSIDR2_Type_bits ::"  32 Word.word "  



record (overloaded) CCSIDR_EL1_Type  = 
 CCSIDR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CCSIDR_Type  = 
 CCSIDR_Type_bits ::"  32 Word.word "  



record (overloaded) CLIDR_EL1_Type  = 
 CLIDR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CLIDR_Type  = 
 CLIDR_Type_bits ::"  32 Word.word "  



record (overloaded) CNTCR_Type  = 
 CNTCR_Type_bits ::"  32 Word.word "  



record (overloaded) CNTEL0ACR_Type  = 
 CNTEL0ACR_Type_bits ::"  32 Word.word "  



record (overloaded) CNTFID0_Type  = 
 CNTFID0_Type_bits ::"  32 Word.word "  



record (overloaded) CNTHCTL_EL2_Type  = 
 CNTHCTL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHCTL_Type  = 
 CNTHCTL_Type_bits ::"  32 Word.word "  



record (overloaded) CNTHPS_CTL_EL2_Type  = 
 CNTHPS_CTL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHPS_CTL_Type  = 
 CNTHPS_CTL_Type_bits ::"  32 Word.word "  



record (overloaded) CNTHPS_CVAL_EL2_Type  = 
 CNTHPS_CVAL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHPS_TVAL_EL2_Type  = 
 CNTHPS_TVAL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHP_CTL_EL2_Type  = 
 CNTHP_CTL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHP_CTL_Type  = 
 CNTHP_CTL_Type_bits ::"  32 Word.word "  



record (overloaded) CNTHP_CVAL_EL2_Type  = 
 CNTHP_CVAL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHP_CVAL_Type  = 
 CNTHP_CVAL_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHP_TVAL_EL2_Type  = 
 CNTHP_TVAL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHVS_CTL_EL2_Type  = 
 CNTHVS_CTL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHVS_CTL_Type  = 
 CNTHVS_CTL_Type_bits ::"  32 Word.word "  



record (overloaded) CNTHVS_CVAL_EL2_Type  = 
 CNTHVS_CVAL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHVS_TVAL_EL2_Type  = 
 CNTHVS_TVAL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHV_CTL_EL2_Type  = 
 CNTHV_CTL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHV_CTL_Type  = 
 CNTHV_CTL_Type_bits ::"  32 Word.word "  



record (overloaded) CNTHV_CVAL_EL2_Type  = 
 CNTHV_CVAL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTHV_TVAL_EL2_Type  = 
 CNTHV_TVAL_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CNTID_Type  = 
 CNTID_Type_bits ::"  32 Word.word "  



record (overloaded) CNTKCTL_EL1_Type  = 
 CNTKCTL_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CNTKCTL_Type  = 
 CNTKCTL_Type_bits ::"  32 Word.word "  



record (overloaded) CNTNSAR_Type  = 
 CNTNSAR_Type_bits ::"  32 Word.word "  



record (overloaded) CNTPS_CTL_EL1_Type  = 
 CNTPS_CTL_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CNTPS_CVAL_EL1_Type  = 
 CNTPS_CVAL_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CNTPS_TVAL_EL1_Type  = 
 CNTPS_TVAL_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CNTP_CTL_EL0_Type  = 
 CNTP_CTL_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) CNTP_CTL_Type  = 
 CNTP_CTL_Type_bits ::"  32 Word.word "  



record (overloaded) CNTP_CVAL_EL0_Type  = 
 CNTP_CVAL_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) CNTP_CVAL_Type  = 
 CNTP_CVAL_Type_bits ::"  64 Word.word "  



record (overloaded) CNTP_TVAL_EL0_Type  = 
 CNTP_TVAL_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) CNTSCR_Type  = 
 CNTSCR_Type_bits ::"  32 Word.word "  



record (overloaded) CNTSR_Type  = 
 CNTSR_Type_bits ::"  32 Word.word "  



record (overloaded) CNTV_CTL_EL0_Type  = 
 CNTV_CTL_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) CNTV_CTL_Type  = 
 CNTV_CTL_Type_bits ::"  32 Word.word "  



record (overloaded) CNTV_CVAL_EL0_Type  = 
 CNTV_CVAL_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) CNTV_CVAL_Type  = 
 CNTV_CVAL_Type_bits ::"  64 Word.word "  



record (overloaded) CNTV_TVAL_EL0_Type  = 
 CNTV_TVAL_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) CONTEXTIDR_EL1_Type  = 
 CONTEXTIDR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CONTEXTIDR_EL2_Type  = 
 CONTEXTIDR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CONTEXTIDR_Type  = 
 CONTEXTIDR_Type_bits ::"  32 Word.word "  



record (overloaded) CPACR_EL1_Type  = 
 CPACR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CPACR_Type  = 
 CPACR_Type_bits ::"  32 Word.word "  



record (overloaded) CPTR_EL2_Type  = 
 CPTR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) CPTR_EL3_Type  = 
 CPTR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) CSSELR_EL1_Type  = 
 CSSELR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) CSSELR_Type  = 
 CSSELR_Type_bits ::"  32 Word.word "  



record (overloaded) CTIAUTHSTATUS_Type  = 
 CTIAUTHSTATUS_Type_bits ::"  32 Word.word "  



record (overloaded) CTICIDR0_Type  = 
 CTICIDR0_Type_bits ::"  32 Word.word "  



record (overloaded) CTICIDR1_Type  = 
 CTICIDR1_Type_bits ::"  32 Word.word "  



record (overloaded) CTICIDR2_Type  = 
 CTICIDR2_Type_bits ::"  32 Word.word "  



record (overloaded) CTICIDR3_Type  = 
 CTICIDR3_Type_bits ::"  32 Word.word "  



record (overloaded) CTICONTROL_Type  = 
 CTICONTROL_Type_bits ::"  32 Word.word "  



record (overloaded) CTIDEVARCH_Type  = 
 CTIDEVARCH_Type_bits ::"  32 Word.word "  



record (overloaded) CTIDEVCTL_Type  = 
 CTIDEVCTL_Type_bits ::"  32 Word.word "  



record (overloaded) CTIDEVID_Type  = 
 CTIDEVID_Type_bits ::"  32 Word.word "  



record (overloaded) CTIDEVTYPE_Type  = 
 CTIDEVTYPE_Type_bits ::"  32 Word.word "  



record (overloaded) CTIITCTRL_Type  = 
 CTIITCTRL_Type_bits ::"  32 Word.word "  



record (overloaded) CTILAR_Type  = 
 CTILAR_Type_bits ::"  32 Word.word "  



record (overloaded) CTILSR_Type  = 
 CTILSR_Type_bits ::"  32 Word.word "  



record (overloaded) CTIPIDR0_Type  = 
 CTIPIDR0_Type_bits ::"  32 Word.word "  



record (overloaded) CTIPIDR1_Type  = 
 CTIPIDR1_Type_bits ::"  32 Word.word "  



record (overloaded) CTIPIDR2_Type  = 
 CTIPIDR2_Type_bits ::"  32 Word.word "  



record (overloaded) CTIPIDR3_Type  = 
 CTIPIDR3_Type_bits ::"  32 Word.word "  



record (overloaded) CTIPIDR4_Type  = 
 CTIPIDR4_Type_bits ::"  32 Word.word "  



record (overloaded) CTR_EL0_Type  = 
 CTR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) CTR_Type  = 
 CTR_Type_bits ::"  32 Word.word "  



record (overloaded) DACR32_EL2_Type  = 
 DACR32_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) DACR_Type  = 
 DACR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGAUTHSTATUS_EL1_Type  = 
 DBGAUTHSTATUS_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) DBGAUTHSTATUS_Type  = 
 DBGAUTHSTATUS_Type_bits ::"  32 Word.word "  



record (overloaded) DBGBCR_EL1_Type  = 
 DBGBCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) DBGBCR_Type  = 
 DBGBCR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGBVR_EL1_Type  = 
 DBGBVR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) DBGBVR_Type  = 
 DBGBVR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGBXVR_Type  = 
 DBGBXVR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGCLAIMCLR_EL1_Type  = 
 DBGCLAIMCLR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) DBGCLAIMCLR_Type  = 
 DBGCLAIMCLR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGCLAIMSET_EL1_Type  = 
 DBGCLAIMSET_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) DBGCLAIMSET_Type  = 
 DBGCLAIMSET_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDCCINT_Type  = 
 DBGDCCINT_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDEVID1_Type  = 
 DBGDEVID1_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDEVID_Type  = 
 DBGDEVID_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDIDR_Type  = 
 DBGDIDR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDRAR_Type  = 
 DBGDRAR_Type_bits ::"  64 Word.word "  



record (overloaded) DBGDSCRext_Type  = 
 DBGDSCRext_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDSCRint_Type  = 
 DBGDSCRint_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDTRRXext_Type  = 
 DBGDTRRXext_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDTRRXint_Type  = 
 DBGDTRRXint_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDTRTXext_Type  = 
 DBGDTRTXext_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDTRTXint_Type  = 
 DBGDTRTXint_Type_bits ::"  32 Word.word "  



record (overloaded) DBGDTR_EL0_Type  = 
 DBGDTR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) DBGOSDLR_Type  = 
 DBGOSDLR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGOSECCR_Type  = 
 DBGOSECCR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGOSLAR_Type  = 
 DBGOSLAR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGOSLSR_Type  = 
 DBGOSLSR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGPRCR_EL1_Type  = 
 DBGPRCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) DBGPRCR_Type  = 
 DBGPRCR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGVCR32_EL2_Type  = 
 DBGVCR32_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) DBGVCR_Type  = 
 DBGVCR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGWCR_EL1_Type  = 
 DBGWCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) DBGWCR_Type  = 
 DBGWCR_Type_bits ::"  32 Word.word "  



record (overloaded) DBGWVR_EL1_Type  = 
 DBGWVR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) DBGWVR_Type  = 
 DBGWVR_Type_bits ::"  32 Word.word "  



record (overloaded) DCZID_EL0_Type  = 
 DCZID_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) DFSR_Type  = 
 DFSR_Type_bits ::"  32 Word.word "  



record (overloaded) DISR_EL1_Type  = 
 DISR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) DISR_Type  = 
 DISR_Type_bits ::"  32 Word.word "  



record (overloaded) DSPSR2_Type  = 
 DSPSR2_Type_bits ::"  32 Word.word "  



record (overloaded) DSPSR_EL0_Type  = 
 DSPSR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) DSPSR_Type  = 
 DSPSR_Type_bits ::"  32 Word.word "  



record (overloaded) DormantCtl_Type  = 
 DormantCtl_Type_bits ::"  32 Word.word "  



record (overloaded) EDAA32PFR_Type  = 
 EDAA32PFR_Type_bits ::"  64 Word.word "  



record (overloaded) EDCIDR0_Type  = 
 EDCIDR0_Type_bits ::"  32 Word.word "  



record (overloaded) EDCIDR1_Type  = 
 EDCIDR1_Type_bits ::"  32 Word.word "  



record (overloaded) EDCIDR2_Type  = 
 EDCIDR2_Type_bits ::"  32 Word.word "  



record (overloaded) EDCIDR3_Type  = 
 EDCIDR3_Type_bits ::"  32 Word.word "  



record (overloaded) EDDEVARCH_Type  = 
 EDDEVARCH_Type_bits ::"  32 Word.word "  



record (overloaded) EDDEVID1_Type  = 
 EDDEVID1_Type_bits ::"  32 Word.word "  



record (overloaded) EDDEVID_Type  = 
 EDDEVID_Type_bits ::"  32 Word.word "  



record (overloaded) EDDEVTYPE_Type  = 
 EDDEVTYPE_Type_bits ::"  32 Word.word "  



record (overloaded) EDDFR1_Type  = 
 EDDFR1_Type_bits ::"  64 Word.word "  



record (overloaded) EDDFR_Type  = 
 EDDFR_Type_bits ::"  64 Word.word "  



record (overloaded) EDECCR_Type  = 
 EDECCR_Type_bits ::"  32 Word.word "  



record (overloaded) EDECR_Type  = 
 EDECR_Type_bits ::"  32 Word.word "  



record (overloaded) EDESR_Type  = 
 EDESR_Type_bits ::"  32 Word.word "  



record (overloaded) EDHSR_Type  = 
 EDHSR_Type_bits ::"  64 Word.word "  



record (overloaded) EDITCTRL_Type  = 
 EDITCTRL_Type_bits ::"  32 Word.word "  



record (overloaded) EDLAR_Type  = 
 EDLAR_Type_bits ::"  32 Word.word "  



record (overloaded) EDLSR_Type  = 
 EDLSR_Type_bits ::"  32 Word.word "  



record (overloaded) EDPCSR_Type  = 
 EDPCSR_Type_bits ::"  64 Word.word "  



record (overloaded) EDPFR_Type  = 
 EDPFR_Type_bits ::"  64 Word.word "  



record (overloaded) EDPIDR0_Type  = 
 EDPIDR0_Type_bits ::"  32 Word.word "  



record (overloaded) EDPIDR1_Type  = 
 EDPIDR1_Type_bits ::"  32 Word.word "  



record (overloaded) EDPIDR2_Type  = 
 EDPIDR2_Type_bits ::"  32 Word.word "  



record (overloaded) EDPIDR3_Type  = 
 EDPIDR3_Type_bits ::"  32 Word.word "  



record (overloaded) EDPIDR4_Type  = 
 EDPIDR4_Type_bits ::"  32 Word.word "  



record (overloaded) EDPRCR_Type  = 
 EDPRCR_Type_bits ::"  32 Word.word "  



record (overloaded) EDPRSR_Type  = 
 EDPRSR_Type_bits ::"  32 Word.word "  



record (overloaded) EDRCR_Type  = 
 EDRCR_Type_bits ::"  32 Word.word "  



record (overloaded) EDSCR2_Type  = 
 EDSCR2_Type_bits ::"  32 Word.word "  



record (overloaded) EDSCR_Type  = 
 EDSCR_Type_bits ::"  32 Word.word "  



record (overloaded) EDVIDSR_Type  = 
 EDVIDSR_Type_bits ::"  32 Word.word "  



record (overloaded) ERRIDR_EL1_Type  = 
 ERRIDR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ERRIDR_Type  = 
 ERRIDR_Type_bits ::"  32 Word.word "  



record (overloaded) ERRSELR_EL1_Type  = 
 ERRSELR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ERRSELR_Type  = 
 ERRSELR_Type_bits ::"  32 Word.word "  



record (overloaded) ERRnFR_ElemType  = 
 ERRnFR_ElemType_bits ::"  64 Word.word "  



record (overloaded) ERXGSR_EL1_Type  = 
 ERXGSR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ESRType  = 
 ESRType_bits ::"  64 Word.word "  



record (overloaded) ESR_EL1_Type  = 
 ESR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ESR_EL2_Type  = 
 ESR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ESR_EL3_Type  = 
 ESR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) FPCRType  = 
 FPCRType_bits ::"  64 Word.word "  



record (overloaded) FPCR_Type  = 
 FPCR_Type_bits ::"  64 Word.word "  



record (overloaded) FPEXC32_EL2_Type  = 
 FPEXC32_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) FPEXC_Type  = 
 FPEXC_Type_bits ::"  32 Word.word "  



record (overloaded) FPSCR_Type  = 
 FPSCR_Type_bits ::"  32 Word.word "  



record (overloaded) FPSID_Type  = 
 FPSID_Type_bits ::"  32 Word.word "  



record (overloaded) FPSR_Type  = 
 FPSR_Type_bits ::"  64 Word.word "  



record (overloaded) GCR_EL1_Type  = 
 GCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) GCSCRE0_EL1_Type  = 
 GCSCRE0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) GCSCR_EL1_Type  = 
 GCSCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) GCSCR_EL2_Type  = 
 GCSCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) GCSCR_EL3_Type  = 
 GCSCR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) GCSPR_EL0_Type  = 
 GCSPR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) GCSPR_EL1_Type  = 
 GCSPR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) GCSPR_EL2_Type  = 
 GCSPR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) GCSPR_EL3_Type  = 
 GCSPR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) GICC_ABPR_Type  = 
 GICC_ABPR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_AEOIR_Type  = 
 GICC_AEOIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_AHPPIR_Type  = 
 GICC_AHPPIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_AIAR_Type  = 
 GICC_AIAR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_BPR_Type  = 
 GICC_BPR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_CTLR_Type  = 
 GICC_CTLR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_DIR_Type  = 
 GICC_DIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_EOIR_Type  = 
 GICC_EOIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_HPPIR_Type  = 
 GICC_HPPIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_IAR_Type  = 
 GICC_IAR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_PMR_Type  = 
 GICC_PMR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_RPR_Type  = 
 GICC_RPR_Type_bits ::"  32 Word.word "  



record (overloaded) GICC_STATUSR_Type  = 
 GICC_STATUSR_Type_bits ::"  32 Word.word "  



record (overloaded) GICD_CLRSPI_NSR_Type  = 
 GICD_CLRSPI_NSR_Type_bits ::"  32 Word.word "  



record (overloaded) GICD_CLRSPI_SR_Type  = 
 GICD_CLRSPI_SR_Type_bits ::"  32 Word.word "  



record (overloaded) GICD_CTLR_Type  = 
 GICD_CTLR_Type_bits ::"  32 Word.word "  



record (overloaded) GICD_IIDR_Type  = 
 GICD_IIDR_Type_bits ::"  32 Word.word "  



record (overloaded) GICD_SETSPI_NSR_Type  = 
 GICD_SETSPI_NSR_Type_bits ::"  32 Word.word "  



record (overloaded) GICD_SETSPI_SR_Type  = 
 GICD_SETSPI_SR_Type_bits ::"  32 Word.word "  



record (overloaded) GICD_SGIR_Type  = 
 GICD_SGIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICD_STATUSR_Type  = 
 GICD_STATUSR_Type_bits ::"  32 Word.word "  



record (overloaded) GICD_TYPER2_Type  = 
 GICD_TYPER2_Type_bits ::"  32 Word.word "  



record (overloaded) GICD_TYPER_Type  = 
 GICD_TYPER_Type_bits ::"  32 Word.word "  



record (overloaded) GICH_EISR_Type  = 
 GICH_EISR_Type_bits ::"  32 Word.word "  



record (overloaded) GICH_ELRSR_Type  = 
 GICH_ELRSR_Type_bits ::"  32 Word.word "  



record (overloaded) GICH_HCR_Type  = 
 GICH_HCR_Type_bits ::"  32 Word.word "  



record (overloaded) GICH_MISR_Type  = 
 GICH_MISR_Type_bits ::"  32 Word.word "  



record (overloaded) GICH_VMCR_Type  = 
 GICH_VMCR_Type_bits ::"  32 Word.word "  



record (overloaded) GICH_VTR_Type  = 
 GICH_VTR_Type_bits ::"  32 Word.word "  



record (overloaded) GICM_CLRSPI_NSR_Type  = 
 GICM_CLRSPI_NSR_Type_bits ::"  32 Word.word "  



record (overloaded) GICM_CLRSPI_SR_Type  = 
 GICM_CLRSPI_SR_Type_bits ::"  32 Word.word "  



record (overloaded) GICM_IIDR_Type  = 
 GICM_IIDR_Type_bits ::"  32 Word.word "  



record (overloaded) GICM_SETSPI_NSR_Type  = 
 GICM_SETSPI_NSR_Type_bits ::"  32 Word.word "  



record (overloaded) GICM_SETSPI_SR_Type  = 
 GICM_SETSPI_SR_Type_bits ::"  32 Word.word "  



record (overloaded) GICM_TYPER_Type  = 
 GICM_TYPER_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_CLRLPIR_Type  = 
 GICR_CLRLPIR_Type_bits ::"  64 Word.word "  



record (overloaded) GICR_CTLR_Type  = 
 GICR_CTLR_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_IIDR_Type  = 
 GICR_IIDR_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_INMIR0_Type  = 
 GICR_INMIR0_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_INVALLR_Type  = 
 GICR_INVALLR_Type_bits ::"  64 Word.word "  



record (overloaded) GICR_INVLPIR_Type  = 
 GICR_INVLPIR_Type_bits ::"  64 Word.word "  



record (overloaded) GICR_ISENABLER0_Type  = 
 GICR_ISENABLER0_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_MPAMIDR_Type  = 
 GICR_MPAMIDR_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_PARTIDR_Type  = 
 GICR_PARTIDR_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_PENDBASER_Type  = 
 GICR_PENDBASER_Type_bits ::"  64 Word.word "  



record (overloaded) GICR_PROPBASER_Type  = 
 GICR_PROPBASER_Type_bits ::"  64 Word.word "  



record (overloaded) GICR_SETLPIR_Type  = 
 GICR_SETLPIR_Type_bits ::"  64 Word.word "  



record (overloaded) GICR_STATUSR_Type  = 
 GICR_STATUSR_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_SYNCR_Type  = 
 GICR_SYNCR_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_VPENDBASER_Type  = 
 GICR_VPENDBASER_Type_bits ::"  64 Word.word "  



record (overloaded) GICR_VPROPBASER_Type  = 
 GICR_VPROPBASER_Type_bits ::"  64 Word.word "  



record (overloaded) GICR_VSGIPENDR_Type  = 
 GICR_VSGIPENDR_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_VSGIR_Type  = 
 GICR_VSGIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICR_WAKER_Type  = 
 GICR_WAKER_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_ABPR_Type  = 
 GICV_ABPR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_AEOIR_Type  = 
 GICV_AEOIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_AHPPIR_Type  = 
 GICV_AHPPIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_AIAR_Type  = 
 GICV_AIAR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_BPR_Type  = 
 GICV_BPR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_CTLR_Type  = 
 GICV_CTLR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_DIR_Type  = 
 GICV_DIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_EOIR_Type  = 
 GICV_EOIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_HPPIR_Type  = 
 GICV_HPPIR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_IAR_Type  = 
 GICV_IAR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_PMR_Type  = 
 GICV_PMR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_RPR_Type  = 
 GICV_RPR_Type_bits ::"  32 Word.word "  



record (overloaded) GICV_STATUSR_Type  = 
 GICV_STATUSR_Type_bits ::"  32 Word.word "  



record (overloaded) GITS_CBASER_Type  = 
 GITS_CBASER_Type_bits ::"  64 Word.word "  



record (overloaded) GITS_CREADR_Type  = 
 GITS_CREADR_Type_bits ::"  64 Word.word "  



record (overloaded) GITS_CTLR_Type  = 
 GITS_CTLR_Type_bits ::"  32 Word.word "  



record (overloaded) GITS_CWRITER_Type  = 
 GITS_CWRITER_Type_bits ::"  64 Word.word "  



record (overloaded) GITS_IIDR_Type  = 
 GITS_IIDR_Type_bits ::"  32 Word.word "  



record (overloaded) GITS_MPAMIDR_Type  = 
 GITS_MPAMIDR_Type_bits ::"  32 Word.word "  



record (overloaded) GITS_MPIDR_Type  = 
 GITS_MPIDR_Type_bits ::"  32 Word.word "  



record (overloaded) GITS_PARTIDR_Type  = 
 GITS_PARTIDR_Type_bits ::"  32 Word.word "  



record (overloaded) GITS_SGIR_Type  = 
 GITS_SGIR_Type_bits ::"  64 Word.word "  



record (overloaded) GITS_STATUSR_Type  = 
 GITS_STATUSR_Type_bits ::"  32 Word.word "  



record (overloaded) GITS_TYPER_Type  = 
 GITS_TYPER_Type_bits ::"  64 Word.word "  



record (overloaded) GMID_EL1_Type  = 
 GMID_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) GPCCR_EL3_Type  = 
 GPCCR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) GPTBR_EL3_Type  = 
 GPTBR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) HAFGRTR_EL2_Type  = 
 HAFGRTR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HCPTR_Type  = 
 HCPTR_Type_bits ::"  32 Word.word "  



record (overloaded) HCR2_Type  = 
 HCR2_Type_bits ::"  32 Word.word "  



record (overloaded) HCRX_EL2_Type  = 
 HCRX_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HCR_EL2_Type  = 
 HCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HCR_Type  = 
 HCR_Type_bits ::"  32 Word.word "  



record (overloaded) HDCR_Type  = 
 HDCR_Type_bits ::"  32 Word.word "  



record (overloaded) HDFGRTR2_EL2_Type  = 
 HDFGRTR2_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HDFGRTR_EL2_Type  = 
 HDFGRTR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HDFGWTR2_EL2_Type  = 
 HDFGWTR2_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HDFGWTR_EL2_Type  = 
 HDFGWTR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HFGITR_EL2_Type  = 
 HFGITR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HFGRTR2_EL2_Type  = 
 HFGRTR2_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HFGRTR_EL2_Type  = 
 HFGRTR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HFGWTR2_EL2_Type  = 
 HFGWTR2_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HFGWTR_EL2_Type  = 
 HFGWTR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HMAIR0_Type  = 
 HMAIR0_Type_bits ::"  32 Word.word "  



record (overloaded) HMAIR1_Type  = 
 HMAIR1_Type_bits ::"  32 Word.word "  



record (overloaded) HPFAR_EL2_Type  = 
 HPFAR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HPFAR_Type  = 
 HPFAR_Type_bits ::"  32 Word.word "  



record (overloaded) HRMR_Type  = 
 HRMR_Type_bits ::"  32 Word.word "  



record (overloaded) HSCTLR_Type  = 
 HSCTLR_Type_bits ::"  32 Word.word "  



record (overloaded) HSR_Type  = 
 HSR_Type_bits ::"  32 Word.word "  



record (overloaded) HSTR_EL2_Type  = 
 HSTR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) HSTR_Type  = 
 HSTR_Type_bits ::"  32 Word.word "  



record (overloaded) HTCR_Type  = 
 HTCR_Type_bits ::"  32 Word.word "  



record (overloaded) HTRFCR_Type  = 
 HTRFCR_Type_bits ::"  32 Word.word "  



record (overloaded) HTTBR_Type  = 
 HTTBR_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_AP1R_EL1_Type  = 
 ICC_AP1R_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_ASGI1R_EL1_Type  = 
 ICC_ASGI1R_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_ASGI1R_Type  = 
 ICC_ASGI1R_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_BPR0_EL1_Type  = 
 ICC_BPR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_BPR0_Type  = 
 ICC_BPR0_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_BPR1_EL1_Type  = 
 ICC_BPR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_BPR1_Type  = 
 ICC_BPR1_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_CTLR_EL1_Type  = 
 ICC_CTLR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_CTLR_EL3_Type  = 
 ICC_CTLR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_CTLR_Type  = 
 ICC_CTLR_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_DIR_EL1_Type  = 
 ICC_DIR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_DIR_Type  = 
 ICC_DIR_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_EOIR0_EL1_Type  = 
 ICC_EOIR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_EOIR0_Type  = 
 ICC_EOIR0_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_EOIR1_EL1_Type  = 
 ICC_EOIR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_EOIR1_Type  = 
 ICC_EOIR1_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_HPPIR0_EL1_Type  = 
 ICC_HPPIR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_HPPIR0_Type  = 
 ICC_HPPIR0_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_HPPIR1_EL1_Type  = 
 ICC_HPPIR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_HPPIR1_Type  = 
 ICC_HPPIR1_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_HSRE_Type  = 
 ICC_HSRE_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_IAR0_EL1_Type  = 
 ICC_IAR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_IAR0_Type  = 
 ICC_IAR0_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_IAR1_EL1_Type  = 
 ICC_IAR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_IAR1_Type  = 
 ICC_IAR1_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_IGRPEN0_EL1_Type  = 
 ICC_IGRPEN0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_IGRPEN0_Type  = 
 ICC_IGRPEN0_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_IGRPEN1_EL1_Type  = 
 ICC_IGRPEN1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_IGRPEN1_EL3_Type  = 
 ICC_IGRPEN1_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_IGRPEN1_Type  = 
 ICC_IGRPEN1_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_MCTLR_Type  = 
 ICC_MCTLR_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_MGRPEN1_Type  = 
 ICC_MGRPEN1_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_MSRE_Type  = 
 ICC_MSRE_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_NMIAR1_EL1_Type  = 
 ICC_NMIAR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_PMR_EL1_Type  = 
 ICC_PMR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_PMR_Type  = 
 ICC_PMR_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_RPR_EL1_Type  = 
 ICC_RPR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_RPR_Type  = 
 ICC_RPR_Type_bits ::"  32 Word.word "  



record (overloaded) ICC_SGI0R_EL1_Type  = 
 ICC_SGI0R_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_SGI0R_Type  = 
 ICC_SGI0R_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_SGI1R_EL1_Type  = 
 ICC_SGI1R_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_SGI1R_Type  = 
 ICC_SGI1R_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_SRE_EL1_Type  = 
 ICC_SRE_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_SRE_EL2_Type  = 
 ICC_SRE_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_SRE_EL3_Type  = 
 ICC_SRE_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) ICC_SRE_Type  = 
 ICC_SRE_Type_bits ::"  32 Word.word "  



record (overloaded) ICH_AP0R_EL2_Type  = 
 ICH_AP0R_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ICH_AP0R_Type  = 
 ICH_AP0R_Type_bits ::"  32 Word.word "  



record (overloaded) ICH_AP1R_EL2_Type  = 
 ICH_AP1R_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ICH_AP1R_Type  = 
 ICH_AP1R_Type_bits ::"  32 Word.word "  



record (overloaded) ICH_EISR_EL2_Type  = 
 ICH_EISR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ICH_EISR_Type  = 
 ICH_EISR_Type_bits ::"  32 Word.word "  



record (overloaded) ICH_ELRSR_EL2_Type  = 
 ICH_ELRSR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ICH_ELRSR_Type  = 
 ICH_ELRSR_Type_bits ::"  32 Word.word "  



record (overloaded) ICH_HCR_EL2_Type  = 
 ICH_HCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ICH_HCR_Type  = 
 ICH_HCR_Type_bits ::"  32 Word.word "  



record (overloaded) ICH_LRC_Type  = 
 ICH_LRC_Type_bits ::"  32 Word.word "  



record (overloaded) ICH_LR_EL2_Type  = 
 ICH_LR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ICH_LR_Type  = 
 ICH_LR_Type_bits ::"  32 Word.word "  



record (overloaded) ICH_MISR_EL2_Type  = 
 ICH_MISR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ICH_MISR_Type  = 
 ICH_MISR_Type_bits ::"  32 Word.word "  



record (overloaded) ICH_VMCR_EL2_Type  = 
 ICH_VMCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ICH_VMCR_Type  = 
 ICH_VMCR_Type_bits ::"  32 Word.word "  



record (overloaded) ICH_VTR_EL2_Type  = 
 ICH_VTR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ICH_VTR_Type  = 
 ICH_VTR_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_AP1R_EL1_Type  = 
 ICV_AP1R_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_BPR0_EL1_Type  = 
 ICV_BPR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_BPR0_Type  = 
 ICV_BPR0_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_BPR1_EL1_Type  = 
 ICV_BPR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_BPR1_Type  = 
 ICV_BPR1_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_CTLR_EL1_Type  = 
 ICV_CTLR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_CTLR_Type  = 
 ICV_CTLR_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_DIR_EL1_Type  = 
 ICV_DIR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_DIR_Type  = 
 ICV_DIR_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_EOIR0_EL1_Type  = 
 ICV_EOIR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_EOIR0_Type  = 
 ICV_EOIR0_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_EOIR1_EL1_Type  = 
 ICV_EOIR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_EOIR1_Type  = 
 ICV_EOIR1_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_HPPIR0_EL1_Type  = 
 ICV_HPPIR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_HPPIR0_Type  = 
 ICV_HPPIR0_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_HPPIR1_EL1_Type  = 
 ICV_HPPIR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_HPPIR1_Type  = 
 ICV_HPPIR1_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_IAR0_EL1_Type  = 
 ICV_IAR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_IAR0_Type  = 
 ICV_IAR0_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_IAR1_EL1_Type  = 
 ICV_IAR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_IAR1_Type  = 
 ICV_IAR1_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_IGRPEN0_EL1_Type  = 
 ICV_IGRPEN0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_IGRPEN0_Type  = 
 ICV_IGRPEN0_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_IGRPEN1_EL1_Type  = 
 ICV_IGRPEN1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_IGRPEN1_Type  = 
 ICV_IGRPEN1_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_NMIAR1_EL1_Type  = 
 ICV_NMIAR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_PMR_EL1_Type  = 
 ICV_PMR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_PMR_Type  = 
 ICV_PMR_Type_bits ::"  32 Word.word "  



record (overloaded) ICV_RPR_EL1_Type  = 
 ICV_RPR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ICV_RPR_Type  = 
 ICV_RPR_Type_bits ::"  32 Word.word "  



record (overloaded) ID_AA64DFR0_EL1_Type  = 
 ID_AA64DFR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64DFR1_EL1_Type  = 
 ID_AA64DFR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64ISAR0_EL1_Type  = 
 ID_AA64ISAR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64ISAR1_EL1_Type  = 
 ID_AA64ISAR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64ISAR2_EL1_Type  = 
 ID_AA64ISAR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64MMFR0_EL1_Type  = 
 ID_AA64MMFR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64MMFR1_EL1_Type  = 
 ID_AA64MMFR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64MMFR2_EL1_Type  = 
 ID_AA64MMFR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64MMFR3_EL1_Type  = 
 ID_AA64MMFR3_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64MMFR4_EL1_Type  = 
 ID_AA64MMFR4_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64PFR0_EL1_Type  = 
 ID_AA64PFR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64PFR1_EL1_Type  = 
 ID_AA64PFR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64PFR2_EL1_Type  = 
 ID_AA64PFR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64SMFR0_EL1_Type  = 
 ID_AA64SMFR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_AA64ZFR0_EL1_Type  = 
 ID_AA64ZFR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_DFR0_EL1_Type  = 
 ID_DFR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_DFR0_Type  = 
 ID_DFR0_Type_bits ::"  32 Word.word "  



record (overloaded) ID_DFR1_EL1_Type  = 
 ID_DFR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_DFR1_Type  = 
 ID_DFR1_Type_bits ::"  32 Word.word "  



record (overloaded) ID_ISAR0_EL1_Type  = 
 ID_ISAR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_ISAR0_Type  = 
 ID_ISAR0_Type_bits ::"  32 Word.word "  



record (overloaded) ID_ISAR1_EL1_Type  = 
 ID_ISAR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_ISAR1_Type  = 
 ID_ISAR1_Type_bits ::"  32 Word.word "  



record (overloaded) ID_ISAR2_EL1_Type  = 
 ID_ISAR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_ISAR2_Type  = 
 ID_ISAR2_Type_bits ::"  32 Word.word "  



record (overloaded) ID_ISAR3_EL1_Type  = 
 ID_ISAR3_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_ISAR3_Type  = 
 ID_ISAR3_Type_bits ::"  32 Word.word "  



record (overloaded) ID_ISAR4_EL1_Type  = 
 ID_ISAR4_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_ISAR4_Type  = 
 ID_ISAR4_Type_bits ::"  32 Word.word "  



record (overloaded) ID_ISAR5_EL1_Type  = 
 ID_ISAR5_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_ISAR5_Type  = 
 ID_ISAR5_Type_bits ::"  32 Word.word "  



record (overloaded) ID_ISAR6_EL1_Type  = 
 ID_ISAR6_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_ISAR6_Type  = 
 ID_ISAR6_Type_bits ::"  32 Word.word "  



record (overloaded) ID_MMFR0_EL1_Type  = 
 ID_MMFR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_MMFR0_Type  = 
 ID_MMFR0_Type_bits ::"  32 Word.word "  



record (overloaded) ID_MMFR1_EL1_Type  = 
 ID_MMFR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_MMFR1_Type  = 
 ID_MMFR1_Type_bits ::"  32 Word.word "  



record (overloaded) ID_MMFR2_EL1_Type  = 
 ID_MMFR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_MMFR2_Type  = 
 ID_MMFR2_Type_bits ::"  32 Word.word "  



record (overloaded) ID_MMFR3_EL1_Type  = 
 ID_MMFR3_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_MMFR3_Type  = 
 ID_MMFR3_Type_bits ::"  32 Word.word "  



record (overloaded) ID_MMFR4_EL1_Type  = 
 ID_MMFR4_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_MMFR4_Type  = 
 ID_MMFR4_Type_bits ::"  32 Word.word "  



record (overloaded) ID_MMFR5_EL1_Type  = 
 ID_MMFR5_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_MMFR5_Type  = 
 ID_MMFR5_Type_bits ::"  32 Word.word "  



record (overloaded) ID_PFR0_EL1_Type  = 
 ID_PFR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_PFR0_Type  = 
 ID_PFR0_Type_bits ::"  32 Word.word "  



record (overloaded) ID_PFR1_EL1_Type  = 
 ID_PFR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_PFR1_Type  = 
 ID_PFR1_Type_bits ::"  32 Word.word "  



record (overloaded) ID_PFR2_EL1_Type  = 
 ID_PFR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ID_PFR2_Type  = 
 ID_PFR2_Type_bits ::"  32 Word.word "  



record (overloaded) IFSR32_EL2_Type  = 
 IFSR32_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) IFSR_Type  = 
 IFSR_Type_bits ::"  32 Word.word "  



record (overloaded) ISR_EL1_Type  = 
 ISR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ISR_Type  = 
 ISR_Type_bits ::"  32 Word.word "  



record (overloaded) LORC_EL1_Type  = 
 LORC_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) LOREA_EL1_Type  = 
 LOREA_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) LORID_EL1_Type  = 
 LORID_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) LORN_EL1_Type  = 
 LORN_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) LORSA_EL1_Type  = 
 LORSA_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MAIR0_Type  = 
 MAIR0_Type_bits ::"  32 Word.word "  



record (overloaded) MAIR1_Type  = 
 MAIR1_Type_bits ::"  32 Word.word "  



record (overloaded) MAIR2_EL1_Type  = 
 MAIR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MAIR2_EL2_Type  = 
 MAIR2_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MAIR2_EL3_Type  = 
 MAIR2_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) MAIRType  = 
 MAIRType_bits ::"  64 Word.word "  



record (overloaded) MAIR_EL1_Type  = 
 MAIR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MAIR_EL2_Type  = 
 MAIR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MAIR_EL3_Type  = 
 MAIR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) MDCCINT_EL1_Type  = 
 MDCCINT_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MDCCSR_EL0_Type  = 
 MDCCSR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) MDCR_EL2_Type  = 
 MDCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MDCR_EL3_Type  = 
 MDCR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) MDRAR_EL1_Type  = 
 MDRAR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MDSCR_EL1_Type  = 
 MDSCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MDSELR_EL1_Type  = 
 MDSELR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MECIDR_EL2_Type  = 
 MECIDR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MECID_A0_EL2_Type  = 
 MECID_A0_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MECID_A1_EL2_Type  = 
 MECID_A1_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MECID_P0_EL2_Type  = 
 MECID_P0_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MECID_P1_EL2_Type  = 
 MECID_P1_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MECID_RL_A_EL3_Type  = 
 MECID_RL_A_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) MFAR_EL3_Type  = 
 MFAR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) MIDR_EL1_Type  = 
 MIDR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MIDR_Type  = 
 MIDR_Type_bits ::"  32 Word.word "  



record (overloaded) MPAM0_EL1_Type  = 
 MPAM0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MPAM1_EL1_Type  = 
 MPAM1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MPAM2_EL2_Type  = 
 MPAM2_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPAM3_EL3_Type  = 
 MPAM3_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMHCR_EL2_Type  = 
 MPAMHCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMIDR_EL1_Type  = 
 MPAMIDR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMSM_EL1_Type  = 
 MPAMSM_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMVPM0_EL2_Type  = 
 MPAMVPM0_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMVPM1_EL2_Type  = 
 MPAMVPM1_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMVPM2_EL2_Type  = 
 MPAMVPM2_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMVPM3_EL2_Type  = 
 MPAMVPM3_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMVPM4_EL2_Type  = 
 MPAMVPM4_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMVPM5_EL2_Type  = 
 MPAMVPM5_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMVPM6_EL2_Type  = 
 MPAMVPM6_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMVPM7_EL2_Type  = 
 MPAMVPM7_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPAMVPMV_EL2_Type  = 
 MPAMVPMV_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) MPIDR_EL1_Type  = 
 MPIDR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MPIDR_Type  = 
 MPIDR_Type_bits ::"  32 Word.word "  



record (overloaded) MVBAR_Type  = 
 MVBAR_Type_bits ::"  32 Word.word "  



record (overloaded) MVFR0_EL1_Type  = 
 MVFR0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MVFR0_Type  = 
 MVFR0_Type_bits ::"  32 Word.word "  



record (overloaded) MVFR1_EL1_Type  = 
 MVFR1_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MVFR1_Type  = 
 MVFR1_Type_bits ::"  32 Word.word "  



record (overloaded) MVFR2_EL1_Type  = 
 MVFR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) MVFR2_Type  = 
 MVFR2_Type_bits ::"  32 Word.word "  



record (overloaded) NMRR_Type  = 
 NMRR_Type_bits ::"  32 Word.word "  



record (overloaded) NSACR_Type  = 
 NSACR_Type_bits ::"  32 Word.word "  



record (overloaded) OSDLR_EL1_Type  = 
 OSDLR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) OSECCR_EL1_Type  = 
 OSECCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) OSLAR_EL1_Type  = 
 OSLAR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) OSLSR_EL1_Type  = 
 OSLSR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PAR_EL1_Type  = 
 PAR_EL1_Type_bits ::"  128 Word.word "  



record (overloaded) PAR_Type  = 
 PAR_Type_bits ::"  64 Word.word "  



record (overloaded) PFAR_EL1_Type  = 
 PFAR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PFAR_EL2_Type  = 
 PFAR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) PIRE0_EL1_Type  = 
 PIRE0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PIRE0_EL2_Type  = 
 PIRE0_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) PIR_EL1_Type  = 
 PIR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PIR_EL2_Type  = 
 PIR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) PIR_EL3_Type  = 
 PIR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) PMAUTHSTATUS_Type  = 
 PMAUTHSTATUS_Type_bits ::"  32 Word.word "  



record (overloaded) PMBIDR_EL1_Type  = 
 PMBIDR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMBLIMITR_EL1_Type  = 
 PMBLIMITR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMBPTR_EL1_Type  = 
 PMBPTR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMBSR_EL1_Type  = 
 PMBSR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMCCFILTR_EL0_Type  = 
 PMCCFILTR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMCCFILTR_Type  = 
 PMCCFILTR_Type_bits ::"  32 Word.word "  



record (overloaded) PMCCNTR_EL0_Type  = 
 PMCCNTR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMCCNTR_Type  = 
 PMCCNTR_Type_bits ::"  64 Word.word "  



record (overloaded) PMCCNTSVR_EL1_Type  = 
 PMCCNTSVR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMCEID0_EL0_Type  = 
 PMCEID0_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMCEID0_Type  = 
 PMCEID0_Type_bits ::"  32 Word.word "  



record (overloaded) PMCEID1_EL0_Type  = 
 PMCEID1_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMCEID1_Type  = 
 PMCEID1_Type_bits ::"  32 Word.word "  



record (overloaded) PMCEID2_Type  = 
 PMCEID2_Type_bits ::"  32 Word.word "  



record (overloaded) PMCEID3_Type  = 
 PMCEID3_Type_bits ::"  32 Word.word "  



record (overloaded) PMCFGR_Type  = 
 PMCFGR_Type_bits ::"  64 Word.word "  



record (overloaded) PMCGCR0_Type  = 
 PMCGCR0_Type_bits ::"  32 Word.word "  



record (overloaded) PMCIDR0_Type  = 
 PMCIDR0_Type_bits ::"  32 Word.word "  



record (overloaded) PMCIDR1_Type  = 
 PMCIDR1_Type_bits ::"  32 Word.word "  



record (overloaded) PMCIDR2_Type  = 
 PMCIDR2_Type_bits ::"  32 Word.word "  



record (overloaded) PMCIDR3_Type  = 
 PMCIDR3_Type_bits ::"  32 Word.word "  



record (overloaded) PMCNTENCLR_EL0_Type  = 
 PMCNTENCLR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMCNTENCLR_Type  = 
 PMCNTENCLR_Type_bits ::"  32 Word.word "  



record (overloaded) PMCNTENSET_EL0_Type  = 
 PMCNTENSET_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMCNTENSET_Type  = 
 PMCNTENSET_Type_bits ::"  32 Word.word "  



record (overloaded) PMCNTEN_Type  = 
 PMCNTEN_Type_bits ::"  64 Word.word "  



record (overloaded) PMCR_EL0_Type  = 
 PMCR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMCR_Type  = 
 PMCR_Type_bits ::"  32 Word.word "  



record (overloaded) PMDEVID_Type  = 
 PMDEVID_Type_bits ::"  32 Word.word "  



record (overloaded) PMDEVTYPE_Type  = 
 PMDEVTYPE_Type_bits ::"  32 Word.word "  



record (overloaded) PMECR_EL1_Type  = 
 PMECR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMEVCNTSVR_EL1_Type  = 
 PMEVCNTSVR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMEVTYPER_EL0_Type  = 
 PMEVTYPER_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMEVTYPER_Type  = 
 PMEVTYPER_Type_bits ::"  32 Word.word "  



record (overloaded) PMIAR_EL1_Type  = 
 PMIAR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMICFILTR_EL0_Type  = 
 PMICFILTR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMICNTR_EL0_Type  = 
 PMICNTR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMICNTSVR_EL1_Type  = 
 PMICNTSVR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMIIDR_Type  = 
 PMIIDR_Type_bits ::"  64 Word.word "  



record (overloaded) PMINTENCLR_EL1_Type  = 
 PMINTENCLR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMINTENCLR_Type  = 
 PMINTENCLR_Type_bits ::"  32 Word.word "  



record (overloaded) PMINTENSET_EL1_Type  = 
 PMINTENSET_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMINTENSET_Type  = 
 PMINTENSET_Type_bits ::"  32 Word.word "  



record (overloaded) PMINTEN_Type  = 
 PMINTEN_Type_bits ::"  64 Word.word "  



record (overloaded) PMITCTRL_Type  = 
 PMITCTRL_Type_bits ::"  32 Word.word "  



record (overloaded) PMLAR_Type  = 
 PMLAR_Type_bits ::"  32 Word.word "  



record (overloaded) PMLSR_Type  = 
 PMLSR_Type_bits ::"  32 Word.word "  



record (overloaded) PMMIR_EL1_Type  = 
 PMMIR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMMIR_Type  = 
 PMMIR_Type_bits ::"  32 Word.word "  



record (overloaded) PMOVSCLR_EL0_Type  = 
 PMOVSCLR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMOVSR_Type  = 
 PMOVSR_Type_bits ::"  32 Word.word "  



record (overloaded) PMOVSSET_EL0_Type  = 
 PMOVSSET_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMOVSSET_Type  = 
 PMOVSSET_Type_bits ::"  32 Word.word "  



record (overloaded) PMOVS_Type  = 
 PMOVS_Type_bits ::"  64 Word.word "  



record (overloaded) PMPCSCTL_Type  = 
 PMPCSCTL_Type_bits ::"  64 Word.word "  



record (overloaded) PMPCSR_Type  = 
 PMPCSR_Type_bits ::"  64 Word.word "  



record (overloaded) PMPIDR0_Type  = 
 PMPIDR0_Type_bits ::"  32 Word.word "  



record (overloaded) PMPIDR1_Type  = 
 PMPIDR1_Type_bits ::"  32 Word.word "  



record (overloaded) PMPIDR2_Type  = 
 PMPIDR2_Type_bits ::"  32 Word.word "  



record (overloaded) PMPIDR3_Type  = 
 PMPIDR3_Type_bits ::"  32 Word.word "  



record (overloaded) PMPIDR4_Type  = 
 PMPIDR4_Type_bits ::"  32 Word.word "  



record (overloaded) PMSCR_EL1_Type  = 
 PMSCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMSCR_EL2_Type  = 
 PMSCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) PMSDSFR_EL1_Type  = 
 PMSDSFR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMSELR_EL0_Type  = 
 PMSELR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMSELR_Type  = 
 PMSELR_Type_bits ::"  32 Word.word "  



record (overloaded) PMSEVFR_EL1_Type  = 
 PMSEVFR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMSFCR_EL1_Type  = 
 PMSFCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMSICR_EL1_Type  = 
 PMSICR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMSIDR_EL1_Type  = 
 PMSIDR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMSIRR_EL1_Type  = 
 PMSIRR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMSLATFR_EL1_Type  = 
 PMSLATFR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMSNEVFR_EL1_Type  = 
 PMSNEVFR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMSSCR_EL1_Type  = 
 PMSSCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMSWINC_EL0_Type  = 
 PMSWINC_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMSWINC_Type  = 
 PMSWINC_Type_bits ::"  32 Word.word "  



record (overloaded) PMUACR_EL1_Type  = 
 PMUACR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) PMUSERENR_EL0_Type  = 
 PMUSERENR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMUSERENR_Type  = 
 PMUSERENR_Type_bits ::"  32 Word.word "  



record (overloaded) PMVCIDSR_Type  = 
 PMVCIDSR_Type_bits ::"  64 Word.word "  



record (overloaded) PMVIDSR_Type  = 
 PMVIDSR_Type_bits ::"  32 Word.word "  



record (overloaded) PMXEVCNTR_EL0_Type  = 
 PMXEVCNTR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) PMZR_EL0_Type  = 
 PMZR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) POR_EL0_Type  = 
 POR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) POR_EL1_Type  = 
 POR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) POR_EL2_Type  = 
 POR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) POR_EL3_Type  = 
 POR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) PRRR_Type  = 
 PRRR_Type_bits ::"  32 Word.word "  



record (overloaded) RCWMASK_EL1_Type  = 
 RCWMASK_EL1_Type_bits ::"  128 Word.word "  



record (overloaded) RCWSMASK_EL1_Type  = 
 RCWSMASK_EL1_Type_bits ::"  128 Word.word "  



record (overloaded) RGSR_EL1_Type  = 
 RGSR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) RMR_EL1_Type  = 
 RMR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) RMR_EL2_Type  = 
 RMR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) RMR_EL3_Type  = 
 RMR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) RMR_Type  = 
 RMR_Type_bits ::"  32 Word.word "  



record (overloaded) RNDRRS_Type  = 
 RNDRRS_Type_bits ::"  64 Word.word "  



record (overloaded) RNDR_Type  = 
 RNDR_Type_bits ::"  64 Word.word "  



record (overloaded) RVBAR_EL1_Type  = 
 RVBAR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) RVBAR_EL2_Type  = 
 RVBAR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) RVBAR_EL3_Type  = 
 RVBAR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) S1PIRType  = 
 S1PIRType_bits ::"  64 Word.word "  



record (overloaded) S1PORType  = 
 S1PORType_bits ::"  64 Word.word "  



record (overloaded) S2PIRType  = 
 S2PIRType_bits ::"  64 Word.word "  



record (overloaded) S2PIR_EL2_Type  = 
 S2PIR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) S2POR_EL1_Type  = 
 S2POR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) SCRType  = 
 SCRType_bits ::"  64 Word.word "  



record (overloaded) SCR_EL3_Type  = 
 SCR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) SCR_Type  = 
 SCR_Type_bits ::"  32 Word.word "  



record (overloaded) SCTLR2_EL1_Type  = 
 SCTLR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) SCTLR2_EL2_Type  = 
 SCTLR2_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) SCTLR2_EL3_Type  = 
 SCTLR2_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) SCTLRType  = 
 SCTLRType_bits ::"  64 Word.word "  



record (overloaded) SCTLR_EL1_Type  = 
 SCTLR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) SCTLR_EL2_Type  = 
 SCTLR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) SCTLR_EL3_Type  = 
 SCTLR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) SCTLR_Type  = 
 SCTLR_Type_bits ::"  32 Word.word "  



record (overloaded) SDCR_Type  = 
 SDCR_Type_bits ::"  32 Word.word "  



record (overloaded) SDER32_EL2_Type  = 
 SDER32_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) SDER32_EL3_Type  = 
 SDER32_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) SDER_Type  = 
 SDER_Type_bits ::"  32 Word.word "  



record (overloaded) SMCR_EL1_Type  = 
 SMCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) SMCR_EL2_Type  = 
 SMCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) SMCR_EL3_Type  = 
 SMCR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) SMIDR_EL1_Type  = 
 SMIDR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) SMPRIMAP_EL2_Type  = 
 SMPRIMAP_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) SMPRI_EL1_Type  = 
 SMPRI_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) SPMACCESSR_EL1_Type  = 
 SPMACCESSR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) SPMACCESSR_EL2_Type  = 
 SPMACCESSR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) SPMACCESSR_EL3_Type  = 
 SPMACCESSR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) SPMSELR_EL0_Type  = 
 SPMSELR_EL0_Type_bits ::"  64 Word.word "  



record (overloaded) SPSR_EL1_Type  = 
 SPSR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) SPSR_EL2_Type  = 
 SPSR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) SPSR_EL3_Type  = 
 SPSR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) SPSR_abt_Type  = 
 SPSR_abt_Type_bits ::"  64 Word.word "  



record (overloaded) SPSR_fiq_Type  = 
 SPSR_fiq_Type_bits ::"  64 Word.word "  



record (overloaded) SPSR_hyp_Type  = 
 SPSR_hyp_Type_bits ::"  32 Word.word "  



record (overloaded) SPSR_irq_Type  = 
 SPSR_irq_Type_bits ::"  64 Word.word "  



record (overloaded) SPSR_mon_Type  = 
 SPSR_mon_Type_bits ::"  32 Word.word "  



record (overloaded) SPSR_svc_Type  = 
 SPSR_svc_Type_bits ::"  32 Word.word "  



record (overloaded) SPSR_und_Type  = 
 SPSR_und_Type_bits ::"  64 Word.word "  



record (overloaded) TCR2_EL1_Type  = 
 TCR2_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) TCR2_EL2_Type  = 
 TCR2_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) TCR_EL1_Type  = 
 TCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) TCR_EL2_Type  = 
 TCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) TCR_EL3_Type  = 
 TCR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) TFSRE0_EL1_Type  = 
 TFSRE0_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) TFSR_EL1_Type  = 
 TFSR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) TFSR_EL2_Type  = 
 TFSR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) TFSR_EL3_Type  = 
 TFSR_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) TLBTR_Type  = 
 TLBTR_Type_bits ::"  32 Word.word "  



record (overloaded) TRFCR_EL1_Type  = 
 TRFCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) TRFCR_EL2_Type  = 
 TRFCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) TRFCR_Type  = 
 TRFCR_Type_bits ::"  32 Word.word "  



record (overloaded) TTBCR2_Type  = 
 TTBCR2_Type_bits ::"  32 Word.word "  



record (overloaded) TTBCR_Type  = 
 TTBCR_Type_bits ::"  32 Word.word "  



record (overloaded) TTBR0_EL1_Type  = 
 TTBR0_EL1_Type_bits ::"  128 Word.word "  



record (overloaded) TTBR0_EL2_Type  = 
 TTBR0_EL2_Type_bits ::"  128 Word.word "  



record (overloaded) TTBR0_EL3_Type  = 
 TTBR0_EL3_Type_bits ::"  64 Word.word "  



record (overloaded) TTBR0_Type  = 
 TTBR0_Type_bits ::"  64 Word.word "  



record (overloaded) TTBR1_EL1_Type  = 
 TTBR1_EL1_Type_bits ::"  128 Word.word "  



record (overloaded) TTBR1_EL2_Type  = 
 TTBR1_EL2_Type_bits ::"  128 Word.word "  



record (overloaded) TTBR1_Type  = 
 TTBR1_Type_bits ::"  64 Word.word "  



record (overloaded) VDFSR_Type  = 
 VDFSR_Type_bits ::"  32 Word.word "  



record (overloaded) VDISR_EL2_Type  = 
 VDISR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) VDISR_Type  = 
 VDISR_Type_bits ::"  32 Word.word "  



record (overloaded) VMECID_A_EL2_Type  = 
 VMECID_A_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) VMECID_P_EL2_Type  = 
 VMECID_P_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) VMPIDR_EL2_Type  = 
 VMPIDR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) VMPIDR_Type  = 
 VMPIDR_Type_bits ::"  32 Word.word "  



record (overloaded) VNCR_EL2_Type  = 
 VNCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) VPIDR_EL2_Type  = 
 VPIDR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) VPIDR_Type  = 
 VPIDR_Type_bits ::"  32 Word.word "  



record (overloaded) VSESR_EL2_Type  = 
 VSESR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) VSTCR_EL2_Type  = 
 VSTCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) VSTTBR_EL2_Type  = 
 VSTTBR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) VTCR_EL2_Type  = 
 VTCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) VTCR_Type  = 
 VTCR_Type_bits ::"  32 Word.word "  



record (overloaded) VTTBR_EL2_Type  = 
 VTTBR_EL2_Type_bits ::"  128 Word.word "  



record (overloaded) VTTBR_Type  = 
 VTTBR_Type_bits ::"  64 Word.word "  



record (overloaded) ZCR_EL1_Type  = 
 ZCR_EL1_Type_bits ::"  64 Word.word "  



record (overloaded) ZCR_EL2_Type  = 
 ZCR_EL2_Type_bits ::"  64 Word.word "  



record (overloaded) ZCR_EL3_Type  = 
 ZCR_EL3_Type_bits ::"  64 Word.word "  




type_synonym Feature =" int "
  \<comment> \<open>\<open>| FEAT_AA32EL0
  | FEAT_AA32EL1
  | FEAT_AA32EL2
  | FEAT_AA32EL3
  | FEAT_AA64EL0
  | FEAT_AA64EL1
  | FEAT_AA64EL2
  | FEAT_AA64EL3
  | FEAT_EL0
  | FEAT_EL1
  | FEAT_EL2
  | FEAT_EL3
  | FEAT_AES
  | FEAT_AdvSIMD
  | FEAT_CSV2_1p1
  | FEAT_CSV2_1p2
  | FEAT_CSV2_2
  | FEAT_CSV2_3
  | FEAT_DoubleLock
  | FEAT_ETMv4
  | FEAT_ETMv4p1
  | FEAT_ETMv4p2
  | FEAT_ETMv4p3
  | FEAT_ETMv4p4
  | FEAT_ETMv4p5
  | FEAT_ETMv4p6
  | FEAT_ETS2
  | FEAT_FP
  | FEAT_GICv3
  | FEAT_GICv3_LEGACY
  | FEAT_GICv3_TDIR
  | FEAT_GICv3p1
  | FEAT_GICv4
  | FEAT_GICv4p1
  | FEAT_IVIPT
  | FEAT_PCSRv8
  | FEAT_PMULL
  | FEAT_PMUv3
  | FEAT_PMUv3_EXT
  | FEAT_PMUv3_EXT32
  | FEAT_SHA1
  | FEAT_SHA256
  | FEAT_TRC_EXT
  | FEAT_TRC_SR
  | FEAT_nTLBPA
  | FEAT_CRC32
  | FEAT_Debugv8p1
  | FEAT_HAFDBS
  | FEAT_HPDS
  | FEAT_LOR
  | FEAT_LSE
  | FEAT_PAN
  | FEAT_PMUv3p1
  | FEAT_RDM
  | FEAT_VHE
  | FEAT_VMID16
  | FEAT_AA32BF16
  | FEAT_AA32HPD
  | FEAT_AA32I8MM
  | FEAT_ASMv8p2
  | FEAT_DPB
  | FEAT_Debugv8p2
  | FEAT_EDHSR
  | FEAT_F32MM
  | FEAT_F64MM
  | FEAT_FP16
  | FEAT_HPDS2
  | FEAT_I8MM
  | FEAT_IESB
  | FEAT_LPA
  | FEAT_LSMAOC
  | FEAT_LVA
  | FEAT_MPAM
  | FEAT_PAN2
  | FEAT_PCSRv8p2
  | FEAT_RAS
  | FEAT_SHA3
  | FEAT_SHA512
  | FEAT_SM3
  | FEAT_SM4
  | FEAT_SPE
  | FEAT_SVE
  | FEAT_TTCNP
  | FEAT_UAO
  | FEAT_VPIPT
  | FEAT_XNX
  | FEAT_CCIDX
  | FEAT_CONSTPACFIELD
  | FEAT_EPAC
  | FEAT_FCMA
  | FEAT_FPAC
  | FEAT_FPACCOMBINE
  | FEAT_JSCVT
  | FEAT_LRCPC
  | FEAT_NV
  | FEAT_PACIMP
  | FEAT_PACQARMA3
  | FEAT_PACQARMA5
  | FEAT_PAuth
  | FEAT_SPEv1p1
  | FEAT_AMUv1
  | FEAT_BBM
  | FEAT_CNTSC
  | FEAT_DIT
  | FEAT_Debugv8p4
  | FEAT_DotProd
  | FEAT_DoubleFault
  | FEAT_FHM
  | FEAT_FlagM
  | FEAT_IDST
  | FEAT_LRCPC2
  | FEAT_LSE2
  | FEAT_NV2
  | FEAT_PMUv3p4
  | FEAT_RASSAv1p1
  | FEAT_RASv1p1
  | FEAT_S2FWB
  | FEAT_SEL2
  | FEAT_TLBIOS
  | FEAT_TLBIRANGE
  | FEAT_TRF
  | FEAT_TTL
  | FEAT_TTST
  | FEAT_BTI
  | FEAT_CSV2
  | FEAT_CSV3
  | FEAT_DPB2
  | FEAT_E0PD
  | FEAT_EVT
  | FEAT_ExS
  | FEAT_FRINTTS
  | FEAT_FlagM2
  | FEAT_GTG
  | FEAT_MTE
  | FEAT_MTE2
  | FEAT_PMUv3p5
  | FEAT_RNG
  | FEAT_RNG_TRAP
  | FEAT_SB
  | FEAT_SPECRES
  | FEAT_SSBS
  | FEAT_SSBS2
  | FEAT_AMUv1p1
  | FEAT_BF16
  | FEAT_DGH
  | FEAT_ECV
  | FEAT_FGT
  | FEAT_HPMN0
  | FEAT_MPAMv0p1
  | FEAT_MPAMv1p1
  | FEAT_MTPMU
  | FEAT_PAuth2
  | FEAT_TWED
  | FEAT_AFP
  | FEAT_EBF16
  | FEAT_HCX
  | FEAT_LPA2
  | FEAT_LS64
  | FEAT_LS64_ACCDATA
  | FEAT_LS64_V
  | FEAT_MTE3
  | FEAT_PAN3
  | FEAT_PMUv3p7
  | FEAT_RPRES
  | FEAT_SPEv1p2
  | FEAT_WFxT
  | FEAT_XS
  | FEAT_CMOW
  | FEAT_Debugv8p8
  | FEAT_GICv3_NMI
  | FEAT_HBC
  | FEAT_MOPS
  | FEAT_NMI
  | FEAT_PMUv3_EXT64
  | FEAT_PMUv3_TH
  | FEAT_PMUv3p8
  | FEAT_SCTLR2
  | FEAT_SPEv1p3
  | FEAT_TCR2
  | FEAT_TIDCP1
  | FEAT_ADERR
  | FEAT_AIE
  | FEAT_ANERR
  | FEAT_CLRBHB
  | FEAT_CSSC
  | FEAT_Debugv8p9
  | FEAT_DoubleFault2
  | FEAT_ECBHB
  | FEAT_FGT2
  | FEAT_HAFT
  | FEAT_LRCPC3
  | FEAT_MTE4
  | FEAT_MTE_ASYM_FAULT
  | FEAT_MTE_ASYNC
  | FEAT_MTE_CANONICAL_TAGS
  | FEAT_MTE_NO_ADDRESS_TAGS
  | FEAT_MTE_PERM
  | FEAT_MTE_STORE_ONLY
  | FEAT_MTE_TAGGED_FAR
  | FEAT_PCSRv8p9
  | FEAT_PFAR
  | FEAT_PMUv3_EDGE
  | FEAT_PMUv3_ICNTR
  | FEAT_PMUv3_SS
  | FEAT_PMUv3p9
  | FEAT_PRFMSLC
  | FEAT_RASSAv2
  | FEAT_RASv2
  | FEAT_RPRFM
  | FEAT_S1PIE
  | FEAT_S1POE
  | FEAT_S2PIE
  | FEAT_S2POE
  | FEAT_SPECRES2
  | FEAT_SPE_CRR
  | FEAT_SPE_FDS
  | FEAT_SPEv1p4
  | FEAT_SPMU
  | FEAT_THE
  | FEAT_DoPD
  | FEAT_ETE
  | FEAT_SVE2
  | FEAT_SVE_AES
  | FEAT_SVE_BitPerm
  | FEAT_SVE_PMULL128
  | FEAT_SVE_SHA3
  | FEAT_SVE_SM4
  | FEAT_TME
  | FEAT_TRBE
  | FEAT_ETEv1p1
  | FEAT_BRBE
  | FEAT_ETEv1p2
  | FEAT_RME
  | FEAT_SME
  | FEAT_SME_F64F64
  | FEAT_SME_FA64
  | FEAT_SME_I16I64
  | FEAT_BRBEv1p1
  | FEAT_MEC
  | FEAT_SME2
  | FEAT_ABLE
  | FEAT_CHK
  | FEAT_D128
  | FEAT_EBEP
  | FEAT_ETEv1p3
  | FEAT_GCS
  | FEAT_ITE
  | FEAT_LSE128
  | FEAT_LVA3
  | FEAT_SEBEP
  | FEAT_SME2p1
  | FEAT_SME_F16F16
  | FEAT_SVE2p1
  | FEAT_SVE_B16B16
  | FEAT_SYSINSTR128
  | FEAT_SYSREG128
  | FEAT_TRBE_EXT
  | FEAT_TRBE_MPAM\<close>\<close>
definition FEAT_AA32EL0  :: \<open> int \<close>  where 
     \<open> FEAT_AA32EL0 = ( (( 0 :: int)::ii))\<close>

definition FEAT_AA32EL1  :: \<open> int \<close>  where 
     \<open> FEAT_AA32EL1 = ( (( 1 :: int)::ii))\<close>

definition FEAT_AA32EL2  :: \<open> int \<close>  where 
     \<open> FEAT_AA32EL2 = ( (( 2 :: int)::ii))\<close>

definition FEAT_AA32EL3  :: \<open> int \<close>  where 
     \<open> FEAT_AA32EL3 = ( (( 3 :: int)::ii))\<close>

definition FEAT_AA64EL0  :: \<open> int \<close>  where 
     \<open> FEAT_AA64EL0 = ( (( 4 :: int)::ii))\<close>

definition FEAT_AA64EL1  :: \<open> int \<close>  where 
     \<open> FEAT_AA64EL1 = ( (( 5 :: int)::ii))\<close>

definition FEAT_AA64EL2  :: \<open> int \<close>  where 
     \<open> FEAT_AA64EL2 = ( (( 6 :: int)::ii))\<close>

definition FEAT_AA64EL3  :: \<open> int \<close>  where 
     \<open> FEAT_AA64EL3 = ( (( 7 :: int)::ii))\<close>

definition FEAT_EL0  :: \<open> int \<close>  where 
     \<open> FEAT_EL0 = ( (( 8 :: int)::ii))\<close>

definition FEAT_EL1  :: \<open> int \<close>  where 
     \<open> FEAT_EL1 = ( (( 9 :: int)::ii))\<close>

definition FEAT_EL2  :: \<open> int \<close>  where 
     \<open> FEAT_EL2 = ( (( 10 :: int)::ii))\<close>

definition FEAT_EL3  :: \<open> int \<close>  where 
     \<open> FEAT_EL3 = ( (( 11 :: int)::ii))\<close>

definition FEAT_AES  :: \<open> int \<close>  where 
     \<open> FEAT_AES = ( (( 12 :: int)::ii))\<close>

definition FEAT_AdvSIMD  :: \<open> int \<close>  where 
     \<open> FEAT_AdvSIMD = ( (( 13 :: int)::ii))\<close>

definition FEAT_CSV2_1p1  :: \<open> int \<close>  where 
     \<open> FEAT_CSV2_1p1 = ( (( 14 :: int)::ii))\<close>

definition FEAT_CSV2_1p2  :: \<open> int \<close>  where 
     \<open> FEAT_CSV2_1p2 = ( (( 15 :: int)::ii))\<close>

definition FEAT_CSV2_2  :: \<open> int \<close>  where 
     \<open> FEAT_CSV2_2 = ( (( 16 :: int)::ii))\<close>

definition FEAT_CSV2_3  :: \<open> int \<close>  where 
     \<open> FEAT_CSV2_3 = ( (( 17 :: int)::ii))\<close>

definition FEAT_DoubleLock  :: \<open> int \<close>  where 
     \<open> FEAT_DoubleLock = ( (( 18 :: int)::ii))\<close>

definition FEAT_ETMv4  :: \<open> int \<close>  where 
     \<open> FEAT_ETMv4 = ( (( 19 :: int)::ii))\<close>

definition FEAT_ETMv4p1  :: \<open> int \<close>  where 
     \<open> FEAT_ETMv4p1 = ( (( 20 :: int)::ii))\<close>

definition FEAT_ETMv4p2  :: \<open> int \<close>  where 
     \<open> FEAT_ETMv4p2 = ( (( 21 :: int)::ii))\<close>

definition FEAT_ETMv4p3  :: \<open> int \<close>  where 
     \<open> FEAT_ETMv4p3 = ( (( 22 :: int)::ii))\<close>

definition FEAT_ETMv4p4  :: \<open> int \<close>  where 
     \<open> FEAT_ETMv4p4 = ( (( 23 :: int)::ii))\<close>

definition FEAT_ETMv4p5  :: \<open> int \<close>  where 
     \<open> FEAT_ETMv4p5 = ( (( 24 :: int)::ii))\<close>

definition FEAT_ETMv4p6  :: \<open> int \<close>  where 
     \<open> FEAT_ETMv4p6 = ( (( 25 :: int)::ii))\<close>

definition FEAT_ETS2  :: \<open> int \<close>  where 
     \<open> FEAT_ETS2 = ( (( 26 :: int)::ii))\<close>

definition FEAT_FP  :: \<open> int \<close>  where 
     \<open> FEAT_FP = ( (( 27 :: int)::ii))\<close>

definition FEAT_GICv3  :: \<open> int \<close>  where 
     \<open> FEAT_GICv3 = ( (( 28 :: int)::ii))\<close>

definition FEAT_GICv3_LEGACY  :: \<open> int \<close>  where 
     \<open> FEAT_GICv3_LEGACY = ( (( 29 :: int)::ii))\<close>

definition FEAT_GICv3_TDIR  :: \<open> int \<close>  where 
     \<open> FEAT_GICv3_TDIR = ( (( 30 :: int)::ii))\<close>

definition FEAT_GICv3p1  :: \<open> int \<close>  where 
     \<open> FEAT_GICv3p1 = ( (( 31 :: int)::ii))\<close>

definition FEAT_GICv4  :: \<open> int \<close>  where 
     \<open> FEAT_GICv4 = ( (( 32 :: int)::ii))\<close>

definition FEAT_GICv4p1  :: \<open> int \<close>  where 
     \<open> FEAT_GICv4p1 = ( (( 33 :: int)::ii))\<close>

definition FEAT_IVIPT  :: \<open> int \<close>  where 
     \<open> FEAT_IVIPT = ( (( 34 :: int)::ii))\<close>

definition FEAT_PCSRv8  :: \<open> int \<close>  where 
     \<open> FEAT_PCSRv8 = ( (( 35 :: int)::ii))\<close>

definition FEAT_PMULL  :: \<open> int \<close>  where 
     \<open> FEAT_PMULL = ( (( 36 :: int)::ii))\<close>

definition FEAT_PMUv3  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3 = ( (( 37 :: int)::ii))\<close>

definition FEAT_PMUv3_EXT  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3_EXT = ( (( 38 :: int)::ii))\<close>

definition FEAT_PMUv3_EXT32  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3_EXT32 = ( (( 39 :: int)::ii))\<close>

definition FEAT_SHA1  :: \<open> int \<close>  where 
     \<open> FEAT_SHA1 = ( (( 40 :: int)::ii))\<close>

definition FEAT_SHA256  :: \<open> int \<close>  where 
     \<open> FEAT_SHA256 = ( (( 41 :: int)::ii))\<close>

definition FEAT_TRC_EXT  :: \<open> int \<close>  where 
     \<open> FEAT_TRC_EXT = ( (( 42 :: int)::ii))\<close>

definition FEAT_TRC_SR  :: \<open> int \<close>  where 
     \<open> FEAT_TRC_SR = ( (( 43 :: int)::ii))\<close>

definition FEAT_nTLBPA  :: \<open> int \<close>  where 
     \<open> FEAT_nTLBPA = ( (( 44 :: int)::ii))\<close>

definition FEAT_CRC32  :: \<open> int \<close>  where 
     \<open> FEAT_CRC32 = ( (( 45 :: int)::ii))\<close>

definition FEAT_Debugv8p1  :: \<open> int \<close>  where 
     \<open> FEAT_Debugv8p1 = ( (( 46 :: int)::ii))\<close>

definition FEAT_HAFDBS  :: \<open> int \<close>  where 
     \<open> FEAT_HAFDBS = ( (( 47 :: int)::ii))\<close>

definition FEAT_HPDS  :: \<open> int \<close>  where 
     \<open> FEAT_HPDS = ( (( 48 :: int)::ii))\<close>

definition FEAT_LOR  :: \<open> int \<close>  where 
     \<open> FEAT_LOR = ( (( 49 :: int)::ii))\<close>

definition FEAT_LSE  :: \<open> int \<close>  where 
     \<open> FEAT_LSE = ( (( 50 :: int)::ii))\<close>

definition FEAT_PAN  :: \<open> int \<close>  where 
     \<open> FEAT_PAN = ( (( 51 :: int)::ii))\<close>

definition FEAT_PMUv3p1  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3p1 = ( (( 52 :: int)::ii))\<close>

definition FEAT_RDM  :: \<open> int \<close>  where 
     \<open> FEAT_RDM = ( (( 53 :: int)::ii))\<close>

definition FEAT_VHE  :: \<open> int \<close>  where 
     \<open> FEAT_VHE = ( (( 54 :: int)::ii))\<close>

definition FEAT_VMID16  :: \<open> int \<close>  where 
     \<open> FEAT_VMID16 = ( (( 55 :: int)::ii))\<close>

definition FEAT_AA32BF16  :: \<open> int \<close>  where 
     \<open> FEAT_AA32BF16 = ( (( 56 :: int)::ii))\<close>

definition FEAT_AA32HPD  :: \<open> int \<close>  where 
     \<open> FEAT_AA32HPD = ( (( 57 :: int)::ii))\<close>

definition FEAT_AA32I8MM  :: \<open> int \<close>  where 
     \<open> FEAT_AA32I8MM = ( (( 58 :: int)::ii))\<close>

definition FEAT_ASMv8p2  :: \<open> int \<close>  where 
     \<open> FEAT_ASMv8p2 = ( (( 59 :: int)::ii))\<close>

definition FEAT_DPB  :: \<open> int \<close>  where 
     \<open> FEAT_DPB = ( (( 60 :: int)::ii))\<close>

definition FEAT_Debugv8p2  :: \<open> int \<close>  where 
     \<open> FEAT_Debugv8p2 = ( (( 61 :: int)::ii))\<close>

definition FEAT_EDHSR  :: \<open> int \<close>  where 
     \<open> FEAT_EDHSR = ( (( 62 :: int)::ii))\<close>

definition FEAT_F32MM  :: \<open> int \<close>  where 
     \<open> FEAT_F32MM = ( (( 63 :: int)::ii))\<close>

definition FEAT_F64MM  :: \<open> int \<close>  where 
     \<open> FEAT_F64MM = ( (( 64 :: int)::ii))\<close>

definition FEAT_FP16  :: \<open> int \<close>  where 
     \<open> FEAT_FP16 = ( (( 65 :: int)::ii))\<close>

definition FEAT_HPDS2  :: \<open> int \<close>  where 
     \<open> FEAT_HPDS2 = ( (( 66 :: int)::ii))\<close>

definition FEAT_I8MM  :: \<open> int \<close>  where 
     \<open> FEAT_I8MM = ( (( 67 :: int)::ii))\<close>

definition FEAT_IESB  :: \<open> int \<close>  where 
     \<open> FEAT_IESB = ( (( 68 :: int)::ii))\<close>

definition FEAT_LPA  :: \<open> int \<close>  where 
     \<open> FEAT_LPA = ( (( 69 :: int)::ii))\<close>

definition FEAT_LSMAOC  :: \<open> int \<close>  where 
     \<open> FEAT_LSMAOC = ( (( 70 :: int)::ii))\<close>

definition FEAT_LVA  :: \<open> int \<close>  where 
     \<open> FEAT_LVA = ( (( 71 :: int)::ii))\<close>

definition FEAT_MPAM  :: \<open> int \<close>  where 
     \<open> FEAT_MPAM = ( (( 72 :: int)::ii))\<close>

definition FEAT_PAN2  :: \<open> int \<close>  where 
     \<open> FEAT_PAN2 = ( (( 73 :: int)::ii))\<close>

definition FEAT_PCSRv8p2  :: \<open> int \<close>  where 
     \<open> FEAT_PCSRv8p2 = ( (( 74 :: int)::ii))\<close>

definition FEAT_RAS  :: \<open> int \<close>  where 
     \<open> FEAT_RAS = ( (( 75 :: int)::ii))\<close>

definition FEAT_SHA3  :: \<open> int \<close>  where 
     \<open> FEAT_SHA3 = ( (( 76 :: int)::ii))\<close>

definition FEAT_SHA512  :: \<open> int \<close>  where 
     \<open> FEAT_SHA512 = ( (( 77 :: int)::ii))\<close>

definition FEAT_SM3  :: \<open> int \<close>  where 
     \<open> FEAT_SM3 = ( (( 78 :: int)::ii))\<close>

definition FEAT_SM4  :: \<open> int \<close>  where 
     \<open> FEAT_SM4 = ( (( 79 :: int)::ii))\<close>

definition FEAT_SPE  :: \<open> int \<close>  where 
     \<open> FEAT_SPE = ( (( 80 :: int)::ii))\<close>

definition FEAT_SVE  :: \<open> int \<close>  where 
     \<open> FEAT_SVE = ( (( 81 :: int)::ii))\<close>

definition FEAT_TTCNP  :: \<open> int \<close>  where 
     \<open> FEAT_TTCNP = ( (( 82 :: int)::ii))\<close>

definition FEAT_UAO  :: \<open> int \<close>  where 
     \<open> FEAT_UAO = ( (( 83 :: int)::ii))\<close>

definition FEAT_VPIPT  :: \<open> int \<close>  where 
     \<open> FEAT_VPIPT = ( (( 84 :: int)::ii))\<close>

definition FEAT_XNX  :: \<open> int \<close>  where 
     \<open> FEAT_XNX = ( (( 85 :: int)::ii))\<close>

definition FEAT_CCIDX  :: \<open> int \<close>  where 
     \<open> FEAT_CCIDX = ( (( 86 :: int)::ii))\<close>

definition FEAT_CONSTPACFIELD  :: \<open> int \<close>  where 
     \<open> FEAT_CONSTPACFIELD = ( (( 87 :: int)::ii))\<close>

definition FEAT_EPAC  :: \<open> int \<close>  where 
     \<open> FEAT_EPAC = ( (( 88 :: int)::ii))\<close>

definition FEAT_FCMA  :: \<open> int \<close>  where 
     \<open> FEAT_FCMA = ( (( 89 :: int)::ii))\<close>

definition FEAT_FPAC  :: \<open> int \<close>  where 
     \<open> FEAT_FPAC = ( (( 90 :: int)::ii))\<close>

definition FEAT_FPACCOMBINE  :: \<open> int \<close>  where 
     \<open> FEAT_FPACCOMBINE = ( (( 91 :: int)::ii))\<close>

definition FEAT_JSCVT  :: \<open> int \<close>  where 
     \<open> FEAT_JSCVT = ( (( 92 :: int)::ii))\<close>

definition FEAT_LRCPC  :: \<open> int \<close>  where 
     \<open> FEAT_LRCPC = ( (( 93 :: int)::ii))\<close>

definition FEAT_NV  :: \<open> int \<close>  where 
     \<open> FEAT_NV = ( (( 94 :: int)::ii))\<close>

definition FEAT_PACIMP  :: \<open> int \<close>  where 
     \<open> FEAT_PACIMP = ( (( 95 :: int)::ii))\<close>

definition FEAT_PACQARMA3  :: \<open> int \<close>  where 
     \<open> FEAT_PACQARMA3 = ( (( 96 :: int)::ii))\<close>

definition FEAT_PACQARMA5  :: \<open> int \<close>  where 
     \<open> FEAT_PACQARMA5 = ( (( 97 :: int)::ii))\<close>

definition FEAT_PAuth  :: \<open> int \<close>  where 
     \<open> FEAT_PAuth = ( (( 98 :: int)::ii))\<close>

definition FEAT_SPEv1p1  :: \<open> int \<close>  where 
     \<open> FEAT_SPEv1p1 = ( (( 99 :: int)::ii))\<close>

definition FEAT_AMUv1  :: \<open> int \<close>  where 
     \<open> FEAT_AMUv1 = ( (( 100 :: int)::ii))\<close>

definition FEAT_BBM  :: \<open> int \<close>  where 
     \<open> FEAT_BBM = ( (( 101 :: int)::ii))\<close>

definition FEAT_CNTSC  :: \<open> int \<close>  where 
     \<open> FEAT_CNTSC = ( (( 102 :: int)::ii))\<close>

definition FEAT_DIT  :: \<open> int \<close>  where 
     \<open> FEAT_DIT = ( (( 103 :: int)::ii))\<close>

definition FEAT_Debugv8p4  :: \<open> int \<close>  where 
     \<open> FEAT_Debugv8p4 = ( (( 104 :: int)::ii))\<close>

definition FEAT_DotProd  :: \<open> int \<close>  where 
     \<open> FEAT_DotProd = ( (( 105 :: int)::ii))\<close>

definition FEAT_DoubleFault  :: \<open> int \<close>  where 
     \<open> FEAT_DoubleFault = ( (( 106 :: int)::ii))\<close>

definition FEAT_FHM  :: \<open> int \<close>  where 
     \<open> FEAT_FHM = ( (( 107 :: int)::ii))\<close>

definition FEAT_FlagM  :: \<open> int \<close>  where 
     \<open> FEAT_FlagM = ( (( 108 :: int)::ii))\<close>

definition FEAT_IDST  :: \<open> int \<close>  where 
     \<open> FEAT_IDST = ( (( 109 :: int)::ii))\<close>

definition FEAT_LRCPC2  :: \<open> int \<close>  where 
     \<open> FEAT_LRCPC2 = ( (( 110 :: int)::ii))\<close>

definition FEAT_LSE2  :: \<open> int \<close>  where 
     \<open> FEAT_LSE2 = ( (( 111 :: int)::ii))\<close>

definition FEAT_NV2  :: \<open> int \<close>  where 
     \<open> FEAT_NV2 = ( (( 112 :: int)::ii))\<close>

definition FEAT_PMUv3p4  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3p4 = ( (( 113 :: int)::ii))\<close>

definition FEAT_RASSAv1p1  :: \<open> int \<close>  where 
     \<open> FEAT_RASSAv1p1 = ( (( 114 :: int)::ii))\<close>

definition FEAT_RASv1p1  :: \<open> int \<close>  where 
     \<open> FEAT_RASv1p1 = ( (( 115 :: int)::ii))\<close>

definition FEAT_S2FWB  :: \<open> int \<close>  where 
     \<open> FEAT_S2FWB = ( (( 116 :: int)::ii))\<close>

definition FEAT_SEL2  :: \<open> int \<close>  where 
     \<open> FEAT_SEL2 = ( (( 117 :: int)::ii))\<close>

definition FEAT_TLBIOS  :: \<open> int \<close>  where 
     \<open> FEAT_TLBIOS = ( (( 118 :: int)::ii))\<close>

definition FEAT_TLBIRANGE  :: \<open> int \<close>  where 
     \<open> FEAT_TLBIRANGE = ( (( 119 :: int)::ii))\<close>

definition FEAT_TRF  :: \<open> int \<close>  where 
     \<open> FEAT_TRF = ( (( 120 :: int)::ii))\<close>

definition FEAT_TTL  :: \<open> int \<close>  where 
     \<open> FEAT_TTL = ( (( 121 :: int)::ii))\<close>

definition FEAT_TTST  :: \<open> int \<close>  where 
     \<open> FEAT_TTST = ( (( 122 :: int)::ii))\<close>

definition FEAT_BTI  :: \<open> int \<close>  where 
     \<open> FEAT_BTI = ( (( 123 :: int)::ii))\<close>

definition FEAT_CSV2  :: \<open> int \<close>  where 
     \<open> FEAT_CSV2 = ( (( 124 :: int)::ii))\<close>

definition FEAT_CSV3  :: \<open> int \<close>  where 
     \<open> FEAT_CSV3 = ( (( 125 :: int)::ii))\<close>

definition FEAT_DPB2  :: \<open> int \<close>  where 
     \<open> FEAT_DPB2 = ( (( 126 :: int)::ii))\<close>

definition FEAT_E0PD  :: \<open> int \<close>  where 
     \<open> FEAT_E0PD = ( (( 127 :: int)::ii))\<close>

definition FEAT_EVT  :: \<open> int \<close>  where 
     \<open> FEAT_EVT = ( (( 128 :: int)::ii))\<close>

definition FEAT_ExS  :: \<open> int \<close>  where 
     \<open> FEAT_ExS = ( (( 129 :: int)::ii))\<close>

definition FEAT_FRINTTS  :: \<open> int \<close>  where 
     \<open> FEAT_FRINTTS = ( (( 130 :: int)::ii))\<close>

definition FEAT_FlagM2  :: \<open> int \<close>  where 
     \<open> FEAT_FlagM2 = ( (( 131 :: int)::ii))\<close>

definition FEAT_GTG  :: \<open> int \<close>  where 
     \<open> FEAT_GTG = ( (( 132 :: int)::ii))\<close>

definition FEAT_MTE  :: \<open> int \<close>  where 
     \<open> FEAT_MTE = ( (( 133 :: int)::ii))\<close>

definition FEAT_MTE2  :: \<open> int \<close>  where 
     \<open> FEAT_MTE2 = ( (( 134 :: int)::ii))\<close>

definition FEAT_PMUv3p5  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3p5 = ( (( 135 :: int)::ii))\<close>

definition FEAT_RNG  :: \<open> int \<close>  where 
     \<open> FEAT_RNG = ( (( 136 :: int)::ii))\<close>

definition FEAT_RNG_TRAP  :: \<open> int \<close>  where 
     \<open> FEAT_RNG_TRAP = ( (( 137 :: int)::ii))\<close>

definition FEAT_SB  :: \<open> int \<close>  where 
     \<open> FEAT_SB = ( (( 138 :: int)::ii))\<close>

definition FEAT_SPECRES  :: \<open> int \<close>  where 
     \<open> FEAT_SPECRES = ( (( 139 :: int)::ii))\<close>

definition FEAT_SSBS  :: \<open> int \<close>  where 
     \<open> FEAT_SSBS = ( (( 140 :: int)::ii))\<close>

definition FEAT_SSBS2  :: \<open> int \<close>  where 
     \<open> FEAT_SSBS2 = ( (( 141 :: int)::ii))\<close>

definition FEAT_AMUv1p1  :: \<open> int \<close>  where 
     \<open> FEAT_AMUv1p1 = ( (( 142 :: int)::ii))\<close>

definition FEAT_BF16  :: \<open> int \<close>  where 
     \<open> FEAT_BF16 = ( (( 143 :: int)::ii))\<close>

definition FEAT_DGH  :: \<open> int \<close>  where 
     \<open> FEAT_DGH = ( (( 144 :: int)::ii))\<close>

definition FEAT_ECV  :: \<open> int \<close>  where 
     \<open> FEAT_ECV = ( (( 145 :: int)::ii))\<close>

definition FEAT_FGT  :: \<open> int \<close>  where 
     \<open> FEAT_FGT = ( (( 146 :: int)::ii))\<close>

definition FEAT_HPMN0  :: \<open> int \<close>  where 
     \<open> FEAT_HPMN0 = ( (( 147 :: int)::ii))\<close>

definition FEAT_MPAMv0p1  :: \<open> int \<close>  where 
     \<open> FEAT_MPAMv0p1 = ( (( 148 :: int)::ii))\<close>

definition FEAT_MPAMv1p1  :: \<open> int \<close>  where 
     \<open> FEAT_MPAMv1p1 = ( (( 149 :: int)::ii))\<close>

definition FEAT_MTPMU  :: \<open> int \<close>  where 
     \<open> FEAT_MTPMU = ( (( 150 :: int)::ii))\<close>

definition FEAT_PAuth2  :: \<open> int \<close>  where 
     \<open> FEAT_PAuth2 = ( (( 151 :: int)::ii))\<close>

definition FEAT_TWED  :: \<open> int \<close>  where 
     \<open> FEAT_TWED = ( (( 152 :: int)::ii))\<close>

definition FEAT_AFP  :: \<open> int \<close>  where 
     \<open> FEAT_AFP = ( (( 153 :: int)::ii))\<close>

definition FEAT_EBF16  :: \<open> int \<close>  where 
     \<open> FEAT_EBF16 = ( (( 154 :: int)::ii))\<close>

definition FEAT_HCX  :: \<open> int \<close>  where 
     \<open> FEAT_HCX = ( (( 155 :: int)::ii))\<close>

definition FEAT_LPA2  :: \<open> int \<close>  where 
     \<open> FEAT_LPA2 = ( (( 156 :: int)::ii))\<close>

definition FEAT_LS64  :: \<open> int \<close>  where 
     \<open> FEAT_LS64 = ( (( 157 :: int)::ii))\<close>

definition FEAT_LS64_ACCDATA  :: \<open> int \<close>  where 
     \<open> FEAT_LS64_ACCDATA = ( (( 158 :: int)::ii))\<close>

definition FEAT_LS64_V  :: \<open> int \<close>  where 
     \<open> FEAT_LS64_V = ( (( 159 :: int)::ii))\<close>

definition FEAT_MTE3  :: \<open> int \<close>  where 
     \<open> FEAT_MTE3 = ( (( 160 :: int)::ii))\<close>

definition FEAT_PAN3  :: \<open> int \<close>  where 
     \<open> FEAT_PAN3 = ( (( 161 :: int)::ii))\<close>

definition FEAT_PMUv3p7  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3p7 = ( (( 162 :: int)::ii))\<close>

definition FEAT_RPRES  :: \<open> int \<close>  where 
     \<open> FEAT_RPRES = ( (( 163 :: int)::ii))\<close>

definition FEAT_SPEv1p2  :: \<open> int \<close>  where 
     \<open> FEAT_SPEv1p2 = ( (( 164 :: int)::ii))\<close>

definition FEAT_WFxT  :: \<open> int \<close>  where 
     \<open> FEAT_WFxT = ( (( 165 :: int)::ii))\<close>

definition FEAT_XS  :: \<open> int \<close>  where 
     \<open> FEAT_XS = ( (( 166 :: int)::ii))\<close>

definition FEAT_CMOW  :: \<open> int \<close>  where 
     \<open> FEAT_CMOW = ( (( 167 :: int)::ii))\<close>

definition FEAT_Debugv8p8  :: \<open> int \<close>  where 
     \<open> FEAT_Debugv8p8 = ( (( 168 :: int)::ii))\<close>

definition FEAT_GICv3_NMI  :: \<open> int \<close>  where 
     \<open> FEAT_GICv3_NMI = ( (( 169 :: int)::ii))\<close>

definition FEAT_HBC  :: \<open> int \<close>  where 
     \<open> FEAT_HBC = ( (( 170 :: int)::ii))\<close>

definition FEAT_MOPS  :: \<open> int \<close>  where 
     \<open> FEAT_MOPS = ( (( 171 :: int)::ii))\<close>

definition FEAT_NMI  :: \<open> int \<close>  where 
     \<open> FEAT_NMI = ( (( 172 :: int)::ii))\<close>

definition FEAT_PMUv3_EXT64  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3_EXT64 = ( (( 173 :: int)::ii))\<close>

definition FEAT_PMUv3_TH  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3_TH = ( (( 174 :: int)::ii))\<close>

definition FEAT_PMUv3p8  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3p8 = ( (( 175 :: int)::ii))\<close>

definition FEAT_SCTLR2  :: \<open> int \<close>  where 
     \<open> FEAT_SCTLR2 = ( (( 176 :: int)::ii))\<close>

definition FEAT_SPEv1p3  :: \<open> int \<close>  where 
     \<open> FEAT_SPEv1p3 = ( (( 177 :: int)::ii))\<close>

definition FEAT_TCR2  :: \<open> int \<close>  where 
     \<open> FEAT_TCR2 = ( (( 178 :: int)::ii))\<close>

definition FEAT_TIDCP1  :: \<open> int \<close>  where 
     \<open> FEAT_TIDCP1 = ( (( 179 :: int)::ii))\<close>

definition FEAT_ADERR  :: \<open> int \<close>  where 
     \<open> FEAT_ADERR = ( (( 180 :: int)::ii))\<close>

definition FEAT_AIE  :: \<open> int \<close>  where 
     \<open> FEAT_AIE = ( (( 181 :: int)::ii))\<close>

definition FEAT_ANERR  :: \<open> int \<close>  where 
     \<open> FEAT_ANERR = ( (( 182 :: int)::ii))\<close>

definition FEAT_CLRBHB  :: \<open> int \<close>  where 
     \<open> FEAT_CLRBHB = ( (( 183 :: int)::ii))\<close>

definition FEAT_CSSC  :: \<open> int \<close>  where 
     \<open> FEAT_CSSC = ( (( 184 :: int)::ii))\<close>

definition FEAT_Debugv8p9  :: \<open> int \<close>  where 
     \<open> FEAT_Debugv8p9 = ( (( 185 :: int)::ii))\<close>

definition FEAT_DoubleFault2  :: \<open> int \<close>  where 
     \<open> FEAT_DoubleFault2 = ( (( 186 :: int)::ii))\<close>

definition FEAT_ECBHB  :: \<open> int \<close>  where 
     \<open> FEAT_ECBHB = ( (( 187 :: int)::ii))\<close>

definition FEAT_FGT2  :: \<open> int \<close>  where 
     \<open> FEAT_FGT2 = ( (( 188 :: int)::ii))\<close>

definition FEAT_HAFT  :: \<open> int \<close>  where 
     \<open> FEAT_HAFT = ( (( 189 :: int)::ii))\<close>

definition FEAT_LRCPC3  :: \<open> int \<close>  where 
     \<open> FEAT_LRCPC3 = ( (( 190 :: int)::ii))\<close>

definition FEAT_MTE4  :: \<open> int \<close>  where 
     \<open> FEAT_MTE4 = ( (( 191 :: int)::ii))\<close>

definition FEAT_MTE_ASYM_FAULT  :: \<open> int \<close>  where 
     \<open> FEAT_MTE_ASYM_FAULT = ( (( 192 :: int)::ii))\<close>

definition FEAT_MTE_ASYNC  :: \<open> int \<close>  where 
     \<open> FEAT_MTE_ASYNC = ( (( 193 :: int)::ii))\<close>

definition FEAT_MTE_CANONICAL_TAGS  :: \<open> int \<close>  where 
     \<open> FEAT_MTE_CANONICAL_TAGS = ( (( 194 :: int)::ii))\<close>

definition FEAT_MTE_NO_ADDRESS_TAGS  :: \<open> int \<close>  where 
     \<open> FEAT_MTE_NO_ADDRESS_TAGS = ( (( 195 :: int)::ii))\<close>

definition FEAT_MTE_PERM  :: \<open> int \<close>  where 
     \<open> FEAT_MTE_PERM = ( (( 196 :: int)::ii))\<close>

definition FEAT_MTE_STORE_ONLY  :: \<open> int \<close>  where 
     \<open> FEAT_MTE_STORE_ONLY = ( (( 197 :: int)::ii))\<close>

definition FEAT_MTE_TAGGED_FAR  :: \<open> int \<close>  where 
     \<open> FEAT_MTE_TAGGED_FAR = ( (( 198 :: int)::ii))\<close>

definition FEAT_PCSRv8p9  :: \<open> int \<close>  where 
     \<open> FEAT_PCSRv8p9 = ( (( 199 :: int)::ii))\<close>

definition FEAT_PFAR  :: \<open> int \<close>  where 
     \<open> FEAT_PFAR = ( (( 200 :: int)::ii))\<close>

definition FEAT_PMUv3_EDGE  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3_EDGE = ( (( 201 :: int)::ii))\<close>

definition FEAT_PMUv3_ICNTR  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3_ICNTR = ( (( 202 :: int)::ii))\<close>

definition FEAT_PMUv3_SS  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3_SS = ( (( 203 :: int)::ii))\<close>

definition FEAT_PMUv3p9  :: \<open> int \<close>  where 
     \<open> FEAT_PMUv3p9 = ( (( 204 :: int)::ii))\<close>

definition FEAT_PRFMSLC  :: \<open> int \<close>  where 
     \<open> FEAT_PRFMSLC = ( (( 205 :: int)::ii))\<close>

definition FEAT_RASSAv2  :: \<open> int \<close>  where 
     \<open> FEAT_RASSAv2 = ( (( 206 :: int)::ii))\<close>

definition FEAT_RASv2  :: \<open> int \<close>  where 
     \<open> FEAT_RASv2 = ( (( 207 :: int)::ii))\<close>

definition FEAT_RPRFM  :: \<open> int \<close>  where 
     \<open> FEAT_RPRFM = ( (( 208 :: int)::ii))\<close>

definition FEAT_S1PIE  :: \<open> int \<close>  where 
     \<open> FEAT_S1PIE = ( (( 209 :: int)::ii))\<close>

definition FEAT_S1POE  :: \<open> int \<close>  where 
     \<open> FEAT_S1POE = ( (( 210 :: int)::ii))\<close>

definition FEAT_S2PIE  :: \<open> int \<close>  where 
     \<open> FEAT_S2PIE = ( (( 211 :: int)::ii))\<close>

definition FEAT_S2POE  :: \<open> int \<close>  where 
     \<open> FEAT_S2POE = ( (( 212 :: int)::ii))\<close>

definition FEAT_SPECRES2  :: \<open> int \<close>  where 
     \<open> FEAT_SPECRES2 = ( (( 213 :: int)::ii))\<close>

definition FEAT_SPE_CRR  :: \<open> int \<close>  where 
     \<open> FEAT_SPE_CRR = ( (( 214 :: int)::ii))\<close>

definition FEAT_SPE_FDS  :: \<open> int \<close>  where 
     \<open> FEAT_SPE_FDS = ( (( 215 :: int)::ii))\<close>

definition FEAT_SPEv1p4  :: \<open> int \<close>  where 
     \<open> FEAT_SPEv1p4 = ( (( 216 :: int)::ii))\<close>

definition FEAT_SPMU  :: \<open> int \<close>  where 
     \<open> FEAT_SPMU = ( (( 217 :: int)::ii))\<close>

definition FEAT_THE  :: \<open> int \<close>  where 
     \<open> FEAT_THE = ( (( 218 :: int)::ii))\<close>

definition FEAT_DoPD  :: \<open> int \<close>  where 
     \<open> FEAT_DoPD = ( (( 219 :: int)::ii))\<close>

definition FEAT_ETE  :: \<open> int \<close>  where 
     \<open> FEAT_ETE = ( (( 220 :: int)::ii))\<close>

definition FEAT_SVE2  :: \<open> int \<close>  where 
     \<open> FEAT_SVE2 = ( (( 221 :: int)::ii))\<close>

definition FEAT_SVE_AES  :: \<open> int \<close>  where 
     \<open> FEAT_SVE_AES = ( (( 222 :: int)::ii))\<close>

definition FEAT_SVE_BitPerm  :: \<open> int \<close>  where 
     \<open> FEAT_SVE_BitPerm = ( (( 223 :: int)::ii))\<close>

definition FEAT_SVE_PMULL128  :: \<open> int \<close>  where 
     \<open> FEAT_SVE_PMULL128 = ( (( 224 :: int)::ii))\<close>

definition FEAT_SVE_SHA3  :: \<open> int \<close>  where 
     \<open> FEAT_SVE_SHA3 = ( (( 225 :: int)::ii))\<close>

definition FEAT_SVE_SM4  :: \<open> int \<close>  where 
     \<open> FEAT_SVE_SM4 = ( (( 226 :: int)::ii))\<close>

definition FEAT_TME  :: \<open> int \<close>  where 
     \<open> FEAT_TME = ( (( 227 :: int)::ii))\<close>

definition FEAT_TRBE  :: \<open> int \<close>  where 
     \<open> FEAT_TRBE = ( (( 228 :: int)::ii))\<close>

definition FEAT_ETEv1p1  :: \<open> int \<close>  where 
     \<open> FEAT_ETEv1p1 = ( (( 229 :: int)::ii))\<close>

definition FEAT_BRBE  :: \<open> int \<close>  where 
     \<open> FEAT_BRBE = ( (( 230 :: int)::ii))\<close>

definition FEAT_ETEv1p2  :: \<open> int \<close>  where 
     \<open> FEAT_ETEv1p2 = ( (( 231 :: int)::ii))\<close>

definition FEAT_RME  :: \<open> int \<close>  where 
     \<open> FEAT_RME = ( (( 232 :: int)::ii))\<close>

definition FEAT_SME  :: \<open> int \<close>  where 
     \<open> FEAT_SME = ( (( 233 :: int)::ii))\<close>

definition FEAT_SME_F64F64  :: \<open> int \<close>  where 
     \<open> FEAT_SME_F64F64 = ( (( 234 :: int)::ii))\<close>

definition FEAT_SME_FA64  :: \<open> int \<close>  where 
     \<open> FEAT_SME_FA64 = ( (( 235 :: int)::ii))\<close>

definition FEAT_SME_I16I64  :: \<open> int \<close>  where 
     \<open> FEAT_SME_I16I64 = ( (( 236 :: int)::ii))\<close>

definition FEAT_BRBEv1p1  :: \<open> int \<close>  where 
     \<open> FEAT_BRBEv1p1 = ( (( 237 :: int)::ii))\<close>

definition FEAT_MEC  :: \<open> int \<close>  where 
     \<open> FEAT_MEC = ( (( 238 :: int)::ii))\<close>

definition FEAT_SME2  :: \<open> int \<close>  where 
     \<open> FEAT_SME2 = ( (( 239 :: int)::ii))\<close>

definition FEAT_ABLE  :: \<open> int \<close>  where 
     \<open> FEAT_ABLE = ( (( 240 :: int)::ii))\<close>

definition FEAT_CHK  :: \<open> int \<close>  where 
     \<open> FEAT_CHK = ( (( 241 :: int)::ii))\<close>

definition FEAT_D128  :: \<open> int \<close>  where 
     \<open> FEAT_D128 = ( (( 242 :: int)::ii))\<close>

definition FEAT_EBEP  :: \<open> int \<close>  where 
     \<open> FEAT_EBEP = ( (( 243 :: int)::ii))\<close>

definition FEAT_ETEv1p3  :: \<open> int \<close>  where 
     \<open> FEAT_ETEv1p3 = ( (( 244 :: int)::ii))\<close>

definition FEAT_GCS  :: \<open> int \<close>  where 
     \<open> FEAT_GCS = ( (( 245 :: int)::ii))\<close>

definition FEAT_ITE  :: \<open> int \<close>  where 
     \<open> FEAT_ITE = ( (( 246 :: int)::ii))\<close>

definition FEAT_LSE128  :: \<open> int \<close>  where 
     \<open> FEAT_LSE128 = ( (( 247 :: int)::ii))\<close>

definition FEAT_LVA3  :: \<open> int \<close>  where 
     \<open> FEAT_LVA3 = ( (( 248 :: int)::ii))\<close>

definition FEAT_SEBEP  :: \<open> int \<close>  where 
     \<open> FEAT_SEBEP = ( (( 249 :: int)::ii))\<close>

definition FEAT_SME2p1  :: \<open> int \<close>  where 
     \<open> FEAT_SME2p1 = ( (( 250 :: int)::ii))\<close>

definition FEAT_SME_F16F16  :: \<open> int \<close>  where 
     \<open> FEAT_SME_F16F16 = ( (( 251 :: int)::ii))\<close>

definition FEAT_SVE2p1  :: \<open> int \<close>  where 
     \<open> FEAT_SVE2p1 = ( (( 252 :: int)::ii))\<close>

definition FEAT_SVE_B16B16  :: \<open> int \<close>  where 
     \<open> FEAT_SVE_B16B16 = ( (( 253 :: int)::ii))\<close>

definition FEAT_SYSINSTR128  :: \<open> int \<close>  where 
     \<open> FEAT_SYSINSTR128 = ( (( 254 :: int)::ii))\<close>

definition FEAT_SYSREG128  :: \<open> int \<close>  where 
     \<open> FEAT_SYSREG128 = ( (( 255 :: int)::ii))\<close>

definition FEAT_TRBE_EXT  :: \<open> int \<close>  where 
     \<open> FEAT_TRBE_EXT = ( (( 256 :: int)::ii))\<close>

definition FEAT_TRBE_MPAM  :: \<open> int \<close>  where 
     \<open> FEAT_TRBE_MPAM = ( (( 257 :: int)::ii))\<close>


datatype ArchVersion =
    V8Ap0
  | V8Ap1
  | V8Ap2
  | V8Ap3
  | V8Ap4
  | V8Ap5
  | V8Ap6
  | V8Ap7
  | V8Ap8
  | V8Ap9
  | V9Ap0
  | V9Ap1
  | V9Ap2
  | V9Ap3
  | V9Ap4



datatype Signal =   Signal_Low | Signal_High



datatype SecurityState =   SS_NonSecure | SS_Root | SS_Realm | SS_Secure



record (overloaded) ProcState  =
  
 ProcState_N ::" 1 bits " 

     ProcState_Z ::" 1 bits " 

     ProcState_C ::" 1 bits " 

     ProcState_V ::" 1 bits " 

     ProcState_D ::" 1 bits " 

     ProcState_A ::" 1 bits " 

     ProcState_I ::" 1 bits " 

     ProcState_F ::" 1 bits " 

     ProcState_EXLOCK ::" 1 bits " 

     ProcState_PAN ::" 1 bits " 

     ProcState_UAO ::" 1 bits " 

     ProcState_DIT ::" 1 bits " 

     ProcState_TCO ::" 1 bits " 

     ProcState_PM ::" 1 bits " 

     ProcState_PPEND ::" 1 bits " 

     ProcState_BTYPE ::" 2 bits " 

     ProcState_ZA ::" 1 bits " 

     ProcState_SM ::" 1 bits " 

     ProcState_ALLINT ::" 1 bits " 

     ProcState_SS ::" 1 bits " 

     ProcState_IL ::" 1 bits " 

     ProcState_EL ::" 2 bits " 

     ProcState_nRW ::" 1 bits " 

     ProcState_SP ::" 1 bits " 

     ProcState_Q ::" 1 bits " 

     ProcState_GE ::" 4 bits " 

     ProcState_SSBS ::" 1 bits " 

     ProcState_IT ::" 8 bits " 

     ProcState_J ::" 1 bits " 

     ProcState_T ::" 1 bits " 

     ProcState_E ::" 1 bits " 

     ProcState_M ::" 5 bits "  



datatype PrivilegeLevel =   PL3 | PL2 | PL1 | PL0



datatype InstrSet =   InstrSet_A64 | InstrSet_A32 | InstrSet_T32



datatype DSBAlias =   DSBAlias_SSBB | DSBAlias_PSSBB | DSBAlias_DSB



datatype WFxType =   WFxType_WFE | WFxType_WFI | WFxType_WFET | WFxType_WFIT



datatype ExceptionalOccurrenceTargetState =   AArch32_NonDebugState | AArch64_NonDebugState | DebugState



type_synonym PARTIDtype  =" 16 bits "


type_synonym PMGtype  =" 8 bits "


datatype PARTIDspaceType =   PIdSpace_Secure | PIdSpace_Root | PIdSpace_Realm | PIdSpace_NonSecure



record MPAMinfo  =
  
 MPAMinfo_mpam_sp ::" PARTIDspaceType " 
 MPAMinfo_partid ::" PARTIDtype " 
 MPAMinfo_pmg ::" PMGtype "  



datatype AccessType =
    AccessType_IFETCH
  | AccessType_GPR
  | AccessType_ASIMD
  | AccessType_SVE
  | AccessType_SME
  | AccessType_IC
  | AccessType_DC
  | AccessType_DCZero
  | AccessType_AT
  | AccessType_NV2
  | AccessType_SPE
  | AccessType_GCS
  | AccessType_GPTW
  | AccessType_TTW



datatype MemOp =   MemOp_LOAD | MemOp_STORE | MemOp_PREFETCH



datatype VARange =   VARange_LOWER | VARange_UPPER



datatype MemAtomicOp =
    MemAtomicOp_GCSSS1
  | MemAtomicOp_ADD
  | MemAtomicOp_BIC
  | MemAtomicOp_EOR
  | MemAtomicOp_ORR
  | MemAtomicOp_SMAX
  | MemAtomicOp_SMIN
  | MemAtomicOp_UMAX
  | MemAtomicOp_UMIN
  | MemAtomicOp_SWP
  | MemAtomicOp_CAS



datatype CacheOp =   CacheOp_Clean | CacheOp_Invalidate | CacheOp_CleanInvalidate



datatype CacheOpScope =
    CacheOpScope_SetWay
  | CacheOpScope_PoU
  | CacheOpScope_PoC
  | CacheOpScope_PoE
  | CacheOpScope_PoP
  | CacheOpScope_PoDP
  | CacheOpScope_PoPA
  | CacheOpScope_ALLU
  | CacheOpScope_ALLUIS



datatype CacheType =   CacheType_Data | CacheType_Tag | CacheType_Data_Tag | CacheType_Instruction



datatype CachePASpace =
    CPAS_NonSecure
  | CPAS_Any
  | CPAS_RealmNonSecure
  | CPAS_Realm
  | CPAS_Root
  | CPAS_SecureNonSecure
  | CPAS_Secure



record (overloaded) AccessDescriptor  =
  
 AccessDescriptor_acctype ::" AccessType " 

     AccessDescriptor_el ::" 2 bits " 

     AccessDescriptor_ss ::" SecurityState " 

     AccessDescriptor_acqsc ::" bool " 

     AccessDescriptor_acqpc ::" bool " 

     AccessDescriptor_relsc ::" bool " 

     AccessDescriptor_limitedordered ::" bool " 

     AccessDescriptor_exclusive ::" bool " 

     AccessDescriptor_atomicop ::" bool " 

     AccessDescriptor_modop ::" MemAtomicOp " 

     AccessDescriptor_nontemporal ::" bool " 

     AccessDescriptor_read ::" bool " 

     AccessDescriptor_write ::" bool " 

     AccessDescriptor_cacheop ::" CacheOp " 

     AccessDescriptor_opscope ::" CacheOpScope " 

     AccessDescriptor_cachetype ::" CacheType " 

     AccessDescriptor_pan ::" bool " 

     AccessDescriptor_transactional ::" bool " 

     AccessDescriptor_nonfault ::" bool " 

     AccessDescriptor_firstfault ::" bool " 

     AccessDescriptor_first ::" bool " 

     AccessDescriptor_contiguous ::" bool " 

     AccessDescriptor_streamingsve ::" bool " 

     AccessDescriptor_ls64 ::" bool " 

     AccessDescriptor_mops ::" bool " 

     AccessDescriptor_rcw ::" bool " 

     AccessDescriptor_rcws ::" bool " 

     AccessDescriptor_toplevel ::" bool " 

     AccessDescriptor_varange ::" VARange " 

     AccessDescriptor_a32lsmd ::" bool " 

     AccessDescriptor_tagchecked ::" bool " 

     AccessDescriptor_tagaccess ::" bool " 

     AccessDescriptor_mpam ::" MPAMinfo "  



datatype MemType =   MemType_Normal | MemType_Device



datatype DeviceType =   DeviceType_GRE | DeviceType_nGRE | DeviceType_nGnRE | DeviceType_nGnRnE



record (overloaded) MemAttrHints  =
  
 MemAttrHints_attrs ::" 2 bits " 
 MemAttrHints_hints ::" 2 bits " 
 MemAttrHints_transient ::" bool "  



datatype Shareability =   Shareability_NSH | Shareability_ISH | Shareability_OSH



datatype MemTagType =   MemTag_Untagged | MemTag_AllocationTagged | MemTag_CanonicallyTagged



record (overloaded) MemoryAttributes  =
  
 MemoryAttributes_memtype ::" MemType " 

     MemoryAttributes_device ::" DeviceType " 

     MemoryAttributes_inner ::" MemAttrHints " 

     MemoryAttributes_outer ::" MemAttrHints " 

     MemoryAttributes_shareability ::" Shareability " 

     MemoryAttributes_tags ::" MemTagType " 

     MemoryAttributes_notagaccess ::" bool " 

     MemoryAttributes_xs ::" 1 bits "  



datatype PASpace =   PAS_NonSecure | PAS_Secure | PAS_Root | PAS_Realm



record (overloaded) FullAddress  = 
 FullAddress_paspace ::" PASpace " 
 FullAddress_address ::" 56 bits "  



datatype GPCF =   GPCF_None | GPCF_AddressSize | GPCF_Walk | GPCF_EABT | GPCF_Fail



record GPCFRecord  = 
 GPCFRecord_gpf ::" GPCF " 
 GPCFRecord_level ::" ii "  



datatype Fault =
    Fault_None
  | Fault_AccessFlag
  | Fault_Alignment
  | Fault_Background
  | Fault_Domain
  | Fault_Permission
  | Fault_Translation
  | Fault_AddressSize
  | Fault_SyncExternal
  | Fault_SyncExternalOnWalk
  | Fault_SyncParity
  | Fault_SyncParityOnWalk
  | Fault_GPCFOnWalk
  | Fault_GPCFOnOutput
  | Fault_AsyncParity
  | Fault_AsyncExternal
  | Fault_TagCheck
  | Fault_Debug
  | Fault_TLBConflict
  | Fault_BranchTarget
  | Fault_HWUpdateAccessFlag
  | Fault_Lockdown
  | Fault_Exclusive
  | Fault_ICacheMaint



datatype ErrorState =
    ErrorState_UC
  | ErrorState_UEU
  | ErrorState_UEO
  | ErrorState_UER
  | ErrorState_CE
  | ErrorState_Uncategorized
  | ErrorState_IMPDEF



record (overloaded) FaultRecord  =
  
 FaultRecord_statuscode ::" Fault " 

     FaultRecord_access ::" AccessDescriptor " 

     FaultRecord_ipaddress ::" FullAddress " 

     FaultRecord_gpcf ::" GPCFRecord " 

     FaultRecord_paddress ::" FullAddress " 

     FaultRecord_gpcfs2walk ::" bool " 

     FaultRecord_s2fs1walk ::" bool " 

     FaultRecord_write ::" bool " 

     FaultRecord_s1tagnotdata ::" bool " 

     FaultRecord_tagaccess ::" bool " 

     FaultRecord_level ::" ii " 

     FaultRecord_extflag ::" 1 bits " 

     FaultRecord_secondstage ::" bool " 

     FaultRecord_assuredonly ::" bool " 

     FaultRecord_toplevel ::" bool " 

     FaultRecord_overlay ::" bool " 

     FaultRecord_dirtybit ::" bool " 

     FaultRecord_domain ::" 4 bits " 

     FaultRecord_merrorstate ::" ErrorState " 

     FaultRecord_debugmoe ::" 4 bits "  



record (overloaded) PhysMemRetStatus  =
  
 PhysMemRetStatus_statuscode ::" Fault " 

     PhysMemRetStatus_extflag ::" 1 bits " 

     PhysMemRetStatus_merrorstate ::" ErrorState " 

     PhysMemRetStatus_store64bstatus ::" 64 bits "  



record (overloaded) Permissions  =
  
 Permissions_ap_table ::" 2 bits " 

     Permissions_xn_table ::" 1 bits " 

     Permissions_pxn_table ::" 1 bits " 

     Permissions_uxn_table ::" 1 bits " 

     Permissions_ap ::" 3 bits " 

     Permissions_xn ::" 1 bits " 

     Permissions_uxn ::" 1 bits " 

     Permissions_pxn ::" 1 bits " 

     Permissions_ppi ::" 4 bits " 

     Permissions_upi ::" 4 bits " 

     Permissions_ndirty ::" 1 bits " 

     Permissions_s2pi ::" 4 bits " 

     Permissions_s2dirty ::" 1 bits " 

     Permissions_po_index ::" 4 bits " 

     Permissions_s2po_index ::" 4 bits " 

     Permissions_s2ap ::" 2 bits " 

     Permissions_s2tag_na ::" 1 bits " 

     Permissions_s2xnx ::" 1 bits " 

     Permissions_s2xn ::" 1 bits "  



record (overloaded) S1AccessControls  =
  
 S1AccessControls_r ::" 1 bits " 

     S1AccessControls_w ::" 1 bits " 

     S1AccessControls_x ::" 1 bits " 

     S1AccessControls_gcs ::" 1 bits " 

     S1AccessControls_overlay ::" bool " 

     S1AccessControls_or ::" 1 bits " 

     S1AccessControls_ow ::" 1 bits " 

     S1AccessControls_ox ::" 1 bits " 

     S1AccessControls_wxn ::" 1 bits "  



record (overloaded) S2AccessControls  =
  
 S2AccessControls_r ::" 1 bits " 

     S2AccessControls_w ::" 1 bits " 

     S2AccessControls_x ::" 1 bits " 

     S2AccessControls_r_rcw ::" 1 bits " 

     S2AccessControls_w_rcw ::" 1 bits " 

     S2AccessControls_r_mmu ::" 1 bits " 

     S2AccessControls_w_mmu ::" 1 bits " 

     S2AccessControls_toplevel0 ::" 1 bits " 

     S2AccessControls_toplevel1 ::" 1 bits " 

     S2AccessControls_overlay ::" bool " 

     S2AccessControls_or ::" 1 bits " 

     S2AccessControls_ow ::" 1 bits " 

     S2AccessControls_ox ::" 1 bits " 

     S2AccessControls_or_rcw ::" 1 bits " 

     S2AccessControls_ow_rcw ::" 1 bits " 

     S2AccessControls_or_mmu ::" 1 bits " 

     S2AccessControls_ow_mmu ::" 1 bits "  



datatype MBReqDomain =
    MBReqDomain_Nonshareable
  | MBReqDomain_InnerShareable
  | MBReqDomain_OuterShareable
  | MBReqDomain_FullSystem



datatype MBReqTypes =   MBReqTypes_Reads | MBReqTypes_Writes | MBReqTypes_All



datatype PrefetchHint =   Prefetch_READ | Prefetch_WRITE | Prefetch_EXEC



datatype Unpredictable =
    Unpredictable_VMSR
  | Unpredictable_WBOVERLAPLD
  | Unpredictable_WBOVERLAPST
  | Unpredictable_LDPOVERLAP
  | Unpredictable_BASEOVERLAP
  | Unpredictable_DATAOVERLAP
  | Unpredictable_DEVPAGE2
  | Unpredictable_INSTRDEVICE
  | Unpredictable_RESCPACR
  | Unpredictable_RESMAIR
  | Unpredictable_S1CTAGGED
  | Unpredictable_S2RESMEMATTR
  | Unpredictable_RESTEXCB
  | Unpredictable_RESPRRR
  | Unpredictable_RESDACR
  | Unpredictable_RESVTCRS
  | Unpredictable_RESTnSZ
  | Unpredictable_RESTCF
  | Unpredictable_DEVICETAGSTORE
  | Unpredictable_OORTnSZ
  | Unpredictable_LARGEIPA
  | Unpredictable_ESRCONDPASS
  | Unpredictable_ILZEROIT
  | Unpredictable_ILZEROT
  | Unpredictable_BPVECTORCATCHPRI
  | Unpredictable_VCMATCHHALF
  | Unpredictable_VCMATCHDAPA
  | Unpredictable_WPMASKANDBAS
  | Unpredictable_WPBASCONTIGUOUS
  | Unpredictable_RESWPMASK
  | Unpredictable_WPMASKEDBITS
  | Unpredictable_RESBPWPCTRL
  | Unpredictable_BPNOTIMPL
  | Unpredictable_RESBPTYPE
  | Unpredictable_RESMDSELR
  | Unpredictable_BPNOTCTXCMP
  | Unpredictable_BPMATCHHALF
  | Unpredictable_BPMISMATCHHALF
  | Unpredictable_BPLINKINGDISABLED
  | Unpredictable_RESBPMASK
  | Unpredictable_BPMASK
  | Unpredictable_BPMASKEDBITS
  | Unpredictable_BPLINKEDADDRMATCH
  | Unpredictable_RESTARTALIGNPC
  | Unpredictable_RESTARTZEROUPPERPC
  | Unpredictable_ZEROUPPER
  | Unpredictable_ERETZEROUPPERPC
  | Unpredictable_A32FORCEALIGNPC
  | Unpredictable_SMD
  | Unpredictable_NONFAULT
  | Unpredictable_SVEZEROUPPER
  | Unpredictable_SVELDNFDATA
  | Unpredictable_SVELDNFZERO
  | Unpredictable_CHECKSPNONEACTIVE
  | Unpredictable_SMEZEROUPPER
  | Unpredictable_NVNV1
  | Unpredictable_Shareability
  | Unpredictable_AFUPDATE
  | Unpredictable_DBUPDATE
  | Unpredictable_IESBinDebug
  | Unpredictable_BADPMSFCR
  | Unpredictable_ZEROBTYPE
  | Unpredictable_EL2TIMESTAMP
  | Unpredictable_EL1TIMESTAMP
  | Unpredictable_RESERVEDNSxB
  | Unpredictable_WFxTDEBUG
  | Unpredictable_LS64UNSUPPORTED
  | Unpredictable_MISALIGNEDATOMIC
  | Unpredictable_CLEARERRITEZERO
  | Unpredictable_ALUEXCEPTIONRETURN
  | Unpredictable_IGNORETRAPINDEBUG
  | Unpredictable_DBGxVR_RESS
  | Unpredictable_PMUEVENTCOUNTER
  | Unpredictable_PMSCR_PCT
  | Unpredictable_CounterReservedForEL2
  | Unpredictable_BRBFILTRATE
  | Unpredictable_MOPSOVERLAP31
  | Unpredictable_STOREONLYTAGCHECKEDCAS
  | Unpredictable_RESTC



datatype Constraint =
    Constraint_NONE
  | Constraint_UNKNOWN
  | Constraint_UNDEF
  | Constraint_UNDEFEL0
  | Constraint_NOP
  | Constraint_TRUE
  | Constraint_FALSE
  | Constraint_DISABLED
  | Constraint_UNCOND
  | Constraint_COND
  | Constraint_ADDITIONAL_DECODE
  | Constraint_WBSUPPRESS
  | Constraint_FAULT
  | Constraint_LIMITED_ATOMICITY
  | Constraint_NVNV1_00
  | Constraint_NVNV1_01
  | Constraint_NVNV1_11
  | Constraint_EL1TIMESTAMP
  | Constraint_EL2TIMESTAMP
  | Constraint_OSH
  | Constraint_ISH
  | Constraint_NSH
  | Constraint_NC
  | Constraint_WT
  | Constraint_WB
  | Constraint_FORCE
  | Constraint_FORCENOSLCHECK
  | Constraint_MAPTOALLOCATED
  | Constraint_PMSCR_PCT_VIRT



record (overloaded) CacheRecord  =
  
 CacheRecord_acctype ::" AccessType " 

     CacheRecord_cacheop ::" CacheOp " 

     CacheRecord_opscope ::" CacheOpScope " 

     CacheRecord_cachetype ::" CacheType " 

     CacheRecord_regval ::" 64 bits " 

     CacheRecord_paddress ::" FullAddress " 

     CacheRecord_vaddress ::" 64 bits " 

     CacheRecord_setnum ::" ii " 

     CacheRecord_waynum ::" ii " 

     CacheRecord_level ::" ii " 

     CacheRecord_shareability ::" Shareability " 

     CacheRecord_translated ::" bool " 

     CacheRecord_is_vmid_valid ::" bool " 

     CacheRecord_vmid ::" 16 bits " 

     CacheRecord_is_asid_valid ::" bool " 

     CacheRecord_asid ::" 16 bits " 

     CacheRecord_security ::" SecurityState " 

     CacheRecord_cpas ::" CachePASpace "  



datatype RestrictType =
    RestrictType_DataValue
  | RestrictType_ControlFlow
  | RestrictType_CachePrefetch
  | RestrictType_Other



record (overloaded) ExecutionCntxt  =
  
 ExecutionCntxt_is_vmid_valid ::" bool " 

     ExecutionCntxt_all_vmid ::" bool " 

     ExecutionCntxt_vmid ::" 16 bits " 

     ExecutionCntxt_is_asid_valid ::" bool " 

     ExecutionCntxt_all_asid ::" bool " 

     ExecutionCntxt_asid ::" 16 bits " 

     ExecutionCntxt_target_el ::" 2 bits " 

     ExecutionCntxt_security ::" SecurityState " 

     ExecutionCntxt_restriction ::" RestrictType "  



datatype FPExc =
    FPExc_InvalidOp
  | FPExc_DivideByZero
  | FPExc_Overflow
  | FPExc_Underflow
  | FPExc_Inexact
  | FPExc_InputDenorm



datatype FPRounding =
    FPRounding_TIEEVEN
  | FPRounding_POSINF
  | FPRounding_NEGINF
  | FPRounding_ZERO
  | FPRounding_TIEAWAY
  | FPRounding_ODD



datatype FPType =
    FPType_Zero | FPType_Denormal | FPType_Nonzero | FPType_Infinity | FPType_QNaN | FPType_SNaN



datatype BranchType =
    BranchType_DIRCALL
  | BranchType_INDCALL
  | BranchType_ERET
  | BranchType_DBGEXIT
  | BranchType_RET
  | BranchType_DIR
  | BranchType_INDIR
  | BranchType_EXCEPTION
  | BranchType_TMFAIL
  | BranchType_RESET
  | BranchType_UNKNOWN



datatype InterruptID =
    InterruptID_PMUIRQ
  | InterruptID_COMMIRQ
  | InterruptID_CTIIRQ
  | InterruptID_COMMRX
  | InterruptID_COMMTX
  | InterruptID_CNTP
  | InterruptID_CNTHP
  | InterruptID_CNTHPS
  | InterruptID_CNTPS
  | InterruptID_CNTV
  | InterruptID_CNTHV
  | InterruptID_CNTHVS
  | InterruptID_PMBIRQ



datatype Exception =
    Exception_Uncategorized
  | Exception_WFxTrap
  | Exception_CP15RTTrap
  | Exception_CP15RRTTrap
  | Exception_CP14RTTrap
  | Exception_CP14DTTrap
  | Exception_CP14RRTTrap
  | Exception_AdvSIMDFPAccessTrap
  | Exception_FPIDTrap
  | Exception_LDST64BTrap
  | Exception_PACTrap
  | Exception_IllegalState
  | Exception_SupervisorCall
  | Exception_HypervisorCall
  | Exception_MonitorCall
  | Exception_SystemRegisterTrap
  | Exception_ERetTrap
  | Exception_InstructionAbort
  | Exception_PCAlignment
  | Exception_DataAbort
  | Exception_NV2DataAbort
  | Exception_PACFail
  | Exception_SPAlignment
  | Exception_FPTrappedException
  | Exception_SError
  | Exception_Breakpoint
  | Exception_SoftwareStep
  | Exception_Watchpoint
  | Exception_NV2Watchpoint
  | Exception_SoftwareBreakpoint
  | Exception_VectorCatch
  | Exception_IRQ
  | Exception_SVEAccessTrap
  | Exception_SMEAccessTrap
  | Exception_TSTARTAccessTrap
  | Exception_GPC
  | Exception_BranchTarget
  | Exception_MemCpyMemSet
  | Exception_GCSFail
  | Exception_SystemRegister128Trap
  | Exception_FIQ



record (overloaded) ExceptionRecord  =
  
 ExceptionRecord_exceptype ::" Exception " 

     ExceptionRecord_syndrome ::" 25 bits " 

     ExceptionRecord_syndrome2 ::" 24 bits " 

     ExceptionRecord_paddress ::" FullAddress " 

     ExceptionRecord_vaddress ::" 64 bits " 

     ExceptionRecord_ipavalid ::" bool " 

     ExceptionRecord_pavalid ::" bool " 

     ExceptionRecord_NS ::" 1 bits " 

     ExceptionRecord_ipaddress ::" 56 bits " 

     ExceptionRecord_trappedsyscallinst ::" bool "  



datatype TranslationStage =   TranslationStage_1 | TranslationStage_12



datatype ATAccess =   ATAccess_Read | ATAccess_Write | ATAccess_ReadPAN | ATAccess_WritePAN



datatype Regime =   Regime_EL3 | Regime_EL30 | Regime_EL2 | Regime_EL20 | Regime_EL10



datatype TGx =   TGx_4KB | TGx_16KB | TGx_64KB



datatype DescriptorType =   DescriptorType_Table | DescriptorType_Leaf | DescriptorType_Invalid



datatype SDFType =
    SDFType_Table
  | SDFType_Invalid
  | SDFType_Supersection
  | SDFType_Section
  | SDFType_LargePage
  | SDFType_SmallPage



record (overloaded) TTWState  =
  
 TTWState_istable ::" bool " 

     TTWState_level ::" ii " 

     TTWState_baseaddress ::" FullAddress " 

     TTWState_contiguous ::" 1 bits " 

     TTWState_s1assured ::" bool " 

     TTWState_s2assuredonly ::" 1 bits " 

     TTWState_disch ::" 1 bits " 

     TTWState_nG ::" 1 bits " 

     TTWState_guardedpage ::" 1 bits " 

     TTWState_sdftype ::" SDFType " 

     TTWState_domain ::" 4 bits " 

     TTWState_memattrs ::" MemoryAttributes " 

     TTWState_permissions ::" Permissions "  



record (overloaded) S1TTWParams  =
  
 S1TTWParams_ha ::" 1 bits " 

     S1TTWParams_hd ::" 1 bits " 

     S1TTWParams_tbi ::" 1 bits " 

     S1TTWParams_tbid ::" 1 bits " 

     S1TTWParams_nfd ::" 1 bits " 

     S1TTWParams_e0pd ::" 1 bits " 

     S1TTWParams_d128 ::" 1 bits " 

     S1TTWParams_aie ::" 1 bits " 

     S1TTWParams_mair2 ::" MAIRType " 

     S1TTWParams_ds ::" 1 bits " 

     S1TTWParams_ps ::" 3 bits " 

     S1TTWParams_txsz ::" 6 bits " 

     S1TTWParams_epan ::" 1 bits " 

     S1TTWParams_dct ::" 1 bits " 

     S1TTWParams_nv1 ::" 1 bits " 

     S1TTWParams_cmow ::" 1 bits " 

     S1TTWParams_pnch ::" 1 bits " 

     S1TTWParams_disch ::" 1 bits " 

     S1TTWParams_haft ::" 1 bits " 

     S1TTWParams_mtx ::" 1 bits " 

     S1TTWParams_skl ::" 2 bits " 

     S1TTWParams_pie ::" 1 bits " 

     S1TTWParams_pir ::" S1PIRType " 

     S1TTWParams_pire0 ::" S1PIRType " 

     S1TTWParams_emec ::" 1 bits " 

     S1TTWParams_amec ::" 1 bits " 

     S1TTWParams_t0sz ::" 3 bits " 

     S1TTWParams_t1sz ::" 3 bits " 

     S1TTWParams_uwxn ::" 1 bits " 

     S1TTWParams_tgx ::" TGx " 

     S1TTWParams_irgn ::" 2 bits " 

     S1TTWParams_orgn ::" 2 bits " 

     S1TTWParams_sh ::" 2 bits " 

     S1TTWParams_hpd ::" 1 bits " 

     S1TTWParams_ee ::" 1 bits " 

     S1TTWParams_wxn ::" 1 bits " 

     S1TTWParams_ntlsmd ::" 1 bits " 

     S1TTWParams_dc ::" 1 bits " 

     S1TTWParams_sif ::" 1 bits " 

     S1TTWParams_mair ::" MAIRType "  



record (overloaded) S2TTWParams  =
  
 S2TTWParams_ha ::" 1 bits " 

     S2TTWParams_hd ::" 1 bits " 

     S2TTWParams_sl2 ::" 1 bits " 

     S2TTWParams_ds ::" 1 bits " 

     S2TTWParams_d128 ::" 1 bits " 

     S2TTWParams_sw ::" 1 bits " 

     S2TTWParams_nsw ::" 1 bits " 

     S2TTWParams_sa ::" 1 bits " 

     S2TTWParams_nsa ::" 1 bits " 

     S2TTWParams_ps ::" 3 bits " 

     S2TTWParams_txsz ::" 6 bits " 

     S2TTWParams_fwb ::" 1 bits " 

     S2TTWParams_cmow ::" 1 bits " 

     S2TTWParams_skl ::" 2 bits " 

     S2TTWParams_s2pie ::" 1 bits " 

     S2TTWParams_s2pir ::" S2PIRType " 

     S2TTWParams_tl0 ::" 1 bits " 

     S2TTWParams_tl1 ::" 1 bits " 

     S2TTWParams_assuredonly ::" 1 bits " 

     S2TTWParams_haft ::" 1 bits " 

     S2TTWParams_emec ::" 1 bits " 

     S2TTWParams_s ::" 1 bits " 

     S2TTWParams_t0sz ::" 4 bits " 

     S2TTWParams_tgx ::" TGx " 

     S2TTWParams_sl0 ::" 2 bits " 

     S2TTWParams_irgn ::" 2 bits " 

     S2TTWParams_orgn ::" 2 bits " 

     S2TTWParams_sh ::" 2 bits " 

     S2TTWParams_ee ::" 1 bits " 

     S2TTWParams_ptw ::" 1 bits " 

     S2TTWParams_vm ::" 1 bits "  



record (overloaded) TLBContext  =
  
 TLBContext_ss ::" SecurityState " 

     TLBContext_regime ::" Regime " 

     TLBContext_vmid ::" 16 bits " 

     TLBContext_asid ::" 16 bits " 

     TLBContext_nG ::" 1 bits " 

     TLBContext_ipaspace ::" PASpace " 

     TLBContext_includes_s1_name ::" bool " 

     TLBContext_includes_s2_name ::" bool " 

     TLBContext_includes_gpt_name ::" bool " 

     TLBContext_ia ::" 64 bits " 

     TLBContext_tg ::" TGx " 

     TLBContext_cnp ::" 1 bits " 

     TLBContext_level ::" ii " 

     TLBContext_isd128 ::" bool " 

     TLBContext_xs ::" 1 bits "  



record (overloaded) TLBRecord  =
  
 TLBRecord_context ::" TLBContext " 

     TLBRecord_walkstate ::" TTWState " 

     TLBRecord_blocksize ::" ii " 

     TLBRecord_contigsize ::" ii " 

     TLBRecord_s1descriptor ::" 128 bits " 

     TLBRecord_s2descriptor ::" 128 bits "  



record (overloaded) AddressDescriptor  =
  
 AddressDescriptor_fault ::" FaultRecord " 

     AddressDescriptor_memattrs ::" MemoryAttributes " 

     AddressDescriptor_paddress ::" FullAddress " 

     AddressDescriptor_tlbcontext ::" TLBContext " 

     AddressDescriptor_s1assured ::" bool " 

     AddressDescriptor_s2fs1mro ::" bool " 

     AddressDescriptor_mecid ::" 16 bits " 

     AddressDescriptor_vaddress ::" 64 bits "  



record (overloaded) TranslationInfo  =
  
 TranslationInfo_regime ::" Regime " 

     TranslationInfo_vmid ::"  ( 16 bits)option " 

     TranslationInfo_asid ::"  ( 16 bits)option " 

     TranslationInfo_va ::" 64 bits " 

     TranslationInfo_s1level ::"  ii option " 

     TranslationInfo_s2info ::"  (( 64 bits * ii))option " 

     TranslationInfo_s1params ::"  S1TTWParams option " 

     TranslationInfo_s2params ::"  S2TTWParams option " 

     TranslationInfo_memattrs ::" MemoryAttributes "  



datatype SVECmp =   Cmp_EQ | Cmp_NE | Cmp_GE | Cmp_GT | Cmp_LT | Cmp_LE | Cmp_UN







datatype SMEExceptionType =
    SMEExceptionType_AccessTrap
  | SMEExceptionType_Streaming
  | SMEExceptionType_NotStreaming
  | SMEExceptionType_InactiveZA
  | SMEExceptionType_InaccessibleZT0



datatype GCSInstruction =
    GCSInstType_PRET
  | GCSInstType_POPM
  | GCSInstType_PRETAA
  | GCSInstType_PRETAB
  | GCSInstType_SS1
  | GCSInstType_SS2
  | GCSInstType_POPCX
  | GCSInstType_POPX



datatype MOPSStage =   MOPSStage_Prologue | MOPSStage_Main | MOPSStage_Epilogue



record (overloaded) TMState  =
  
 TMState_depth ::" ii " 

     TMState_Rt ::" ii " 

     TMState_nPC ::" 64 bits " 

     TMState_X ::" ( 64 bits) list " 

     TMState_Z ::" ( 2048 bits) list " 

     TMState_P ::" ( 256 bits) list " 

     TMState_FFR ::" 256 bits " 

     TMState_SP ::" 64 bits " 

     TMState_FPCR ::" 64 bits " 

     TMState_FPSR ::" 64 bits " 

     TMState_ICC_PMR_EL1 ::" 64 bits " 

     TMState_GCSPR_ELx ::" 64 bits " 

     TMState_nzcv ::" 4 bits " 

     TMState_D ::" 1 bits " 

     TMState_A ::" 1 bits " 

     TMState_I ::" 1 bits " 

     TMState_F ::" 1 bits "  



datatype TMFailure =
    TMFailure_CNCL
  | TMFailure_DBG
  | TMFailure_ERR
  | TMFailure_NEST
  | TMFailure_SIZE
  | TMFailure_MEM
  | TMFailure_TRIVIAL
  | TMFailure_IMP



datatype PGSe =   PGS_4KB | PGS_16KB | PGS_64KB



record (overloaded) GPTTable  = 
 GPTTable_address ::" 56 bits "  



record (overloaded) GPTEntry  =
  
 GPTEntry_gpi ::" 4 bits " 

     GPTEntry_size ::" ii " 

     GPTEntry_contig_size ::" ii " 

     GPTEntry_level ::" ii " 

     GPTEntry_pa ::" 56 bits "  



datatype TimeStamp =
    TimeStamp_None
  | TimeStamp_CoreSight
  | TimeStamp_Physical
  | TimeStamp_OffsetPhysical
  | TimeStamp_Virtual



datatype OpType =   OpType_Load | OpType_Store | OpType_LoadAtomic | OpType_Branch | OpType_Other



datatype CountOp =   CountOp_CLZ | CountOp_CLS | CountOp_CNT



datatype ExtendType =
    ExtendType_SXTB
  | ExtendType_SXTH
  | ExtendType_SXTW
  | ExtendType_SXTX
  | ExtendType_UXTB
  | ExtendType_UXTH
  | ExtendType_UXTW
  | ExtendType_UXTX



datatype FPMaxMinOp =   FPMaxMinOp_MAX | FPMaxMinOp_MIN | FPMaxMinOp_MAXNUM | FPMaxMinOp_MINNUM



datatype FPUnaryOp =   FPUnaryOp_ABS | FPUnaryOp_MOV | FPUnaryOp_NEG | FPUnaryOp_SQRT



datatype FPConvOp =
    FPConvOp_CVT_FtoI
  | FPConvOp_CVT_ItoF
  | FPConvOp_MOV_FtoI
  | FPConvOp_MOV_ItoF
  | FPConvOp_CVT_FtoI_JS



datatype MoveWideOp =   MoveWideOp_N | MoveWideOp_Z | MoveWideOp_K



datatype ShiftType =   ShiftType_LSL | ShiftType_LSR | ShiftType_ASR | ShiftType_ROR



datatype LogicalOp =   LogicalOp_AND | LogicalOp_EOR | LogicalOp_ORR



datatype SystemHintOp =
    SystemHintOp_NOP
  | SystemHintOp_YIELD
  | SystemHintOp_WFE
  | SystemHintOp_WFI
  | SystemHintOp_SEV
  | SystemHintOp_SEVL
  | SystemHintOp_DGH
  | SystemHintOp_ESB
  | SystemHintOp_PSB
  | SystemHintOp_TSB
  | SystemHintOp_BTI
  | SystemHintOp_WFET
  | SystemHintOp_WFIT
  | SystemHintOp_CLRBHB
  | SystemHintOp_GCSB
  | SystemHintOp_CHKFEAT
  | SystemHintOp_CSDB



datatype PSTATEField =
    PSTATEField_DAIFSet
  | PSTATEField_DAIFClr
  | PSTATEField_PAN
  | PSTATEField_UAO
  | PSTATEField_DIT
  | PSTATEField_SSBS
  | PSTATEField_TCO
  | PSTATEField_SVCRSM
  | PSTATEField_SVCRZA
  | PSTATEField_SVCRSMZA
  | PSTATEField_ALLINT
  | PSTATEField_PM
  | PSTATEField_SP



datatype TLBILevel =   TLBILevel_Any | TLBILevel_Last



datatype TLBIOp =
    TLBIOp_DALL
  | TLBIOp_DASID
  | TLBIOp_DVA
  | TLBIOp_IALL
  | TLBIOp_IASID
  | TLBIOp_IVA
  | TLBIOp_ALL
  | TLBIOp_ASID
  | TLBIOp_IPAS2
  | TLBIPOp_IPAS2
  | TLBIOp_VAA
  | TLBIOp_VA
  | TLBIPOp_VAA
  | TLBIPOp_VA
  | TLBIOp_VMALL
  | TLBIOp_VMALLS12
  | TLBIOp_RIPAS2
  | TLBIPOp_RIPAS2
  | TLBIOp_RVAA
  | TLBIOp_RVA
  | TLBIPOp_RVAA
  | TLBIPOp_RVA
  | TLBIOp_RPA
  | TLBIOp_PAALL



datatype TLBIMemAttr =   TLBI_AllAttr | TLBI_ExcludeXS



record (overloaded) TLBIRecord  =
  
 TLBIRecord_op ::" TLBIOp " 

     TLBIRecord_from_aarch64 ::" bool " 

     TLBIRecord_security ::" SecurityState " 

     TLBIRecord_regime ::" Regime " 

     TLBIRecord_vmid ::" 16 bits " 

     TLBIRecord_asid ::" 16 bits " 

     TLBIRecord_level ::" TLBILevel " 

     TLBIRecord_attr ::" TLBIMemAttr " 

     TLBIRecord_ipaspace ::" PASpace " 

     TLBIRecord_address ::" 64 bits " 

     TLBIRecord_end_address_name ::" 64 bits " 

     TLBIRecord_d64 ::" bool " 

     TLBIRecord_d128 ::" bool " 

     TLBIRecord_ttl ::" 4 bits " 

     TLBIRecord_tg ::" 2 bits "  



datatype VBitOp =   VBitOp_VBIF | VBitOp_VBIT | VBitOp_VBSL | VBitOp_VEOR



datatype CompareOp =   CompareOp_GT | CompareOp_GE | CompareOp_EQ | CompareOp_LE | CompareOp_LT



datatype ImmediateOp =   ImmediateOp_MOVI | ImmediateOp_MVNI | ImmediateOp_ORR | ImmediateOp_BIC



datatype ReduceOp =
    ReduceOp_FMINNUM
  | ReduceOp_FMAXNUM
  | ReduceOp_FMIN
  | ReduceOp_FMAX
  | ReduceOp_FADD
  | ReduceOp_ADD



datatype CrossTriggerIn =
    CrossTriggerIn_CrossHalt
  | CrossTriggerIn_PMUOverflow
  | CrossTriggerIn_RSVD2
  | CrossTriggerIn_RSVD3
  | CrossTriggerIn_TraceExtOut0
  | CrossTriggerIn_TraceExtOut1
  | CrossTriggerIn_TraceExtOut2
  | CrossTriggerIn_TraceExtOut3



record TLBLine  = 
 TLBLine_tlbrecord ::" TLBRecord " 
 TLBLine_valid_name ::" bool "  



record GPTTLBLine  = 
 GPTTLBLine_gpt_entry ::" GPTEntry " 
 GPTTLBLine_valid_name ::" bool "  



record InterruptReq  =
  
 InterruptReq_take_SE ::" bool " 

     InterruptReq_take_vSE ::" bool " 

     InterruptReq_take_IRQ ::" bool " 

     InterruptReq_take_vIRQ ::" bool " 

     InterruptReq_take_FIQ ::" bool " 

     InterruptReq_take_vFIQ ::" bool " 

     InterruptReq_iesb_req ::" bool "  



datatype InstrEnc =   A64 | A32 | T16 | T32



datatype SRType =   SRType_LSL | SRType_LSR | SRType_ASR | SRType_ROR | SRType_RRX



datatype VCGEType =   VCGEType_signed | VCGEType_unsigned | VCGEType_fp



datatype VFPNegMul =   VFPNegMul_VNMLA | VFPNegMul_VNMLS | VFPNegMul_VNMUL



datatype VCGTtype =   VCGTtype_signed | VCGTtype_unsigned | VCGTtype_fp



datatype VBitOps =   VBitOps_VBIF | VBitOps_VBIT | VBitOps_VBSL



type_synonym CNTPOFF_EL2_Type  =" 64 bits "


type_synonym CNTVOFF_EL2_Type  =" 64 bits "


type_synonym DLR_EL0_Type  =" 64 bits "


type_synonym DLR_Type  =" 32 bits "


type_synonym SP_EL0_Type  =" 64 bits "


type_synonym SP_EL1_Type  =" 64 bits "


type_synonym SP_EL2_Type  =" 64 bits "


type_synonym SP_EL3_Type  =" 64 bits "


type_synonym FAR_EL1_Type  =" 64 bits "


type_synonym FAR_EL2_Type  =" 64 bits "


type_synonym FAR_EL3_Type  =" 64 bits "


type_synonym ELR_EL1_Type  =" 64 bits "


type_synonym ELR_EL2_Type  =" 64 bits "


type_synonym ELR_EL3_Type  =" 64 bits "


type_synonym VBAR_EL1_Type  =" 64 bits "


type_synonym VBAR_EL2_Type  =" 64 bits "


type_synonym VBAR_EL3_Type  =" 64 bits "


type_synonym VBAR_Type  =" 32 bits "


type_synonym HDFAR_Type  =" 32 bits "


type_synonym HIFAR_Type  =" 32 bits "


type_synonym ELR_hyp_Type  =" 32 bits "


type_synonym HVBAR_Type  =" 32 bits "


type_synonym DFAR_Type  =" 32 bits "


type_synonym IFAR_Type  =" 32 bits "


datatype arm_acc_type  =
    SAcc_ASIMD " (bool)"
  | SAcc_SVE " (bool)"
  | SAcc_SME " (bool)"
  | SAcc_IC " (unit)"
  | SAcc_DC " (unit)"
  | SAcc_DCZero " (unit)"
  | SAcc_AT " (unit)"
  | SAcc_NV2 " (unit)"
  | SAcc_SPE " (unit)"
  | SAcc_GCS " (unit)"
  | SAcc_GPTW " (unit)"



type_synonym APIAKeyHi_EL1_Type  =" 64 bits "


type_synonym APIAKeyLo_EL1_Type  =" 64 bits "


type_synonym APIBKeyHi_EL1_Type  =" 64 bits "


type_synonym APIBKeyLo_EL1_Type  =" 64 bits "


type_synonym APDAKeyHi_EL1_Type  =" 64 bits "


type_synonym APDAKeyLo_EL1_Type  =" 64 bits "


type_synonym APDBKeyHi_EL1_Type  =" 64 bits "


type_synonym APDBKeyLo_EL1_Type  =" 64 bits "


type_synonym APGAKeyHi_EL1_Type  =" 64 bits "


type_synonym APGAKeyLo_EL1_Type  =" 64 bits "


type_synonym EDWAR_Type  =" 64 bits "


type_synonym CTIDEVID1_Type  =" 32 bits "


type_synonym CTIDEVID2_Type  =" 32 bits "


type_synonym DBGDEVID2_Type  =" 32 bits "


type_synonym DBGDSAR_Type  =" 64 bits "


type_synonym DBGWFAR_Type  =" 32 bits "


type_synonym EDDEVID2_Type  =" 32 bits "


type_synonym FCSEIDR_Type  =" 32 bits "


type_synonym ID_AFR0_EL1_Type  =" 64 bits "


type_synonym ID_AFR0_Type  =" 32 bits "


type_synonym JIDR_Type  =" 32 bits "


type_synonym JMCR_Type  =" 32 bits "


type_synonym JOSCR_Type  =" 32 bits "


type_synonym CNTFRQ_EL0_Type  =" 64 bits "


type_synonym DBGDTRRX_EL0_Type  =" 64 bits "


type_synonym DBGDTRTX_EL0_Type  =" 64 bits "


type_synonym HFGITR2_EL2_Type  =" 64 bits "


type_synonym ID_AA64AFR0_EL1_Type  =" 64 bits "


type_synonym ID_AA64AFR1_EL1_Type  =" 64 bits "


type_synonym OSDTRRX_EL1_Type  =" 64 bits "


type_synonym OSDTRTX_EL1_Type  =" 64 bits "


type_synonym PMEVCNTR_EL0_Type  =" 64 bits "


record TLBIInfo  = 
 TLBIInfo_rec ::" TLBIRecord " 
 TLBIInfo_shareability ::" Shareability "  



type_synonym PMEVCNTR_Type  =" 32 bits "


type_synonym ICC_AP0R_EL1_Type  =" 64 bits "


type_synonym AIDR_EL1_Type  =" 64 bits "


type_synonym REVIDR_EL1_Type  =" 64 bits "


type_synonym TPIDR_EL2_Type  =" 64 bits "


type_synonym ACTLR_EL2_Type  =" 64 bits "


type_synonym TPIDR_EL1_Type  =" 64 bits "


type_synonym ACTLR_EL1_Type  =" 64 bits "


type_synonym AFSR1_EL1_Type  =" 64 bits "


type_synonym AMAIR2_EL2_Type  =" 64 bits "


type_synonym ICV_AP0R_EL1_Type  =" 64 bits "


type_synonym AFSR0_EL3_Type  =" 64 bits "


type_synonym AFSR1_EL2_Type  =" 64 bits "


type_synonym AFSR0_EL1_Type  =" 64 bits "


type_synonym SCXTNUM_EL2_Type  =" 64 bits "


type_synonym TPIDR_EL3_Type  =" 64 bits "


type_synonym ACTLR_EL3_Type  =" 64 bits "


type_synonym AMAIR_EL2_Type  =" 64 bits "


type_synonym AMAIR_EL3_Type  =" 64 bits "


type_synonym SCXTNUM_EL1_Type  =" 64 bits "


type_synonym TPIDRRO_EL0_Type  =" 64 bits "


type_synonym AMAIR_EL1_Type  =" 64 bits "


type_synonym SCXTNUM_EL0_Type  =" 64 bits "


type_synonym TPIDR2_EL0_Type  =" 64 bits "


type_synonym SCXTNUM_EL3_Type  =" 64 bits "


type_synonym TPIDR_EL0_Type  =" 64 bits "


type_synonym HACR_EL2_Type  =" 64 bits "


type_synonym AMAIR2_EL3_Type  =" 64 bits "


type_synonym AFSR1_EL3_Type  =" 64 bits "


type_synonym AFSR0_EL2_Type  =" 64 bits "


type_synonym AMAIR2_EL1_Type  =" 64 bits "


type_synonym CNTVOFF_Type  =" 64 bits "


type_synonym AMEVCNTVOFF0_EL2_Type  =" 64 bits "


type_synonym AMEVCNTVOFF1_EL2_Type  =" 64 bits "


type_synonym ERXADDR_EL1_Type  =" 64 bits "


type_synonym ERXMISC0_EL1_Type  =" 64 bits "


type_synonym ERXPFGCDN_EL1_Type  =" 64 bits "


type_synonym ERXPFGF_EL1_Type  =" 64 bits "


type_synonym ERXMISC1_EL1_Type  =" 64 bits "


type_synonym ERXCTLR_EL1_Type  =" 64 bits "


type_synonym ERXSTATUS_EL1_Type  =" 64 bits "


type_synonym ERXFR_EL1_Type  =" 64 bits "


type_synonym ERXMISC3_EL1_Type  =" 64 bits "


type_synonym ERXMISC2_EL1_Type  =" 64 bits "


type_synonym ERXPFGCTL_EL1_Type  =" 64 bits "


type_synonym AIFSR_Type  =" 32 bits "


type_synonym HACR_Type  =" 32 bits "


type_synonym HACTLR_Type  =" 32 bits "


type_synonym TCMTR_Type  =" 32 bits "


type_synonym ICV_AP0R_Type  =" 32 bits "


type_synonym TPIDRURW_Type  =" 32 bits "


type_synonym ICV_AP1R_Type  =" 32 bits "


type_synonym ADFSR_Type  =" 32 bits "


type_synonym REVIDR_Type  =" 32 bits "


type_synonym TPIDRURO_Type  =" 32 bits "


type_synonym ACTLR_Type  =" 32 bits "


type_synonym ICC_AP1R_Type  =" 32 bits "


type_synonym AMAIR0_Type  =" 32 bits "


type_synonym HAMAIR0_Type  =" 32 bits "


type_synonym AIDR_Type  =" 32 bits "


type_synonym HADFSR_Type  =" 32 bits "


type_synonym CNTFRQ_Type  =" 32 bits "


type_synonym ACTLR2_Type  =" 32 bits "


type_synonym HAMAIR1_Type  =" 32 bits "


type_synonym HAIFSR_Type  =" 32 bits "


type_synonym ICC_AP0R_Type  =" 32 bits "


type_synonym TPIDRPRW_Type  =" 32 bits "


type_synonym HTPIDR_Type  =" 32 bits "


type_synonym AMAIR1_Type  =" 32 bits "


type_synonym ERXFR2_Type  =" 32 bits "


type_synonym ERXMISC2_Type  =" 32 bits "


type_synonym ERXFR_Type  =" 32 bits "


type_synonym ERXADDR_Type  =" 32 bits "


type_synonym ERXMISC0_Type  =" 32 bits "


type_synonym ERXMISC5_Type  =" 32 bits "


type_synonym ERXCTLR2_Type  =" 32 bits "


type_synonym ERXMISC1_Type  =" 32 bits "


type_synonym ERXCTLR_Type  =" 32 bits "


type_synonym ERXMISC6_Type  =" 32 bits "


type_synonym ERXMISC4_Type  =" 32 bits "


type_synonym ERXADDR2_Type  =" 32 bits "


type_synonym ERXMISC7_Type  =" 32 bits "


type_synonym ERXMISC3_Type  =" 32 bits "


type_synonym ERXSTATUS_Type  =" 32 bits "


type_synonym HACTLR2_Type  =" 32 bits "


record DxB  = 
 DxB_domain ::" MBReqDomain " 
 DxB_types ::" MBReqTypes " 
 DxB_nXS ::" bool "  



datatype Barrier  =
    Barrier_DSB0 " (DxB)"
  | Barrier_DMB0 " (DxB)"
  | Barrier_ISB0 " (unit)"
  | Barrier_SSBB " (unit)"
  | Barrier_PSSBB " (unit)"
  | Barrier_SB " (unit)"



context notes [[typedef_overloaded]] begin
datatype register_value  =
    Regval_vector " ( register_value list)"
  | Regval_list " ( register_value list)"
  | Regval_option " ( register_value option)"
  | Regval_bool " (bool)"
  | Regval_int " (ii)"
  | Regval_real " (real)"
  | Regval_string " (string)"
  | Regval_BranchType " (BranchType)"
  | Regval_InterruptID " (InterruptID)"
  | Regval_OpType " (OpType)"
  | Regval_ProcState " (ProcState)"
  | Regval_Signal " (Signal)"
  | Regval_TMState " (TMState)"
  | Regval___InstrEnc " (InstrEnc)"
  | Regval_bit " (bitU)"
  | Regval_bitvector_1 " ( 1 Word.word)"
  | Regval_bitvector_128 " ( 128 Word.word)"
  | Regval_bitvector_16 " ( 16 Word.word)"
  | Regval_bitvector_2 " ( 2 Word.word)"
  | Regval_bitvector_2048 " ( 2048 Word.word)"
  | Regval_bitvector_24 " ( 24 Word.word)"
  | Regval_bitvector_256 " ( 256 Word.word)"
  | Regval_bitvector_3 " ( 3 Word.word)"
  | Regval_bitvector_32 " ( 32 Word.word)"
  | Regval_bitvector_4 " ( 4 Word.word)"
  | Regval_bitvector_512 " ( 512 Word.word)"
  | Regval_bitvector_56 " ( 56 Word.word)"
  | Regval_bitvector_64 " ( 64 Word.word)"
  | Regval_bitvector_8 " ( 8 Word.word)"
  | Regval_bitvector_88 " ( 88 Word.word)"
end



record (overloaded) regstate  =
  
 BranchType_reg ::" string \<Rightarrow> BranchType " 

     OpType_reg ::" string \<Rightarrow> OpType " 

     ProcState_reg ::" string \<Rightarrow> ProcState " 

     Signal_reg ::" string \<Rightarrow> Signal " 

     TMState_reg ::" string \<Rightarrow> TMState " 

     InstrEnc_reg ::" string \<Rightarrow> InstrEnc " 

     bitvector_128_reg ::" string \<Rightarrow>  128 Word.word " 

     bitvector_16_reg ::" string \<Rightarrow>  16 Word.word " 

     bitvector_1_reg ::" string \<Rightarrow>  1 Word.word " 

     bitvector_24_reg ::" string \<Rightarrow>  24 Word.word " 

     bitvector_256_reg ::" string \<Rightarrow>  256 Word.word " 

     bitvector_2_reg ::" string \<Rightarrow>  2 Word.word " 

     bitvector_32_reg ::" string \<Rightarrow>  32 Word.word " 

     bitvector_3_reg ::" string \<Rightarrow>  3 Word.word " 

     bitvector_4_reg ::" string \<Rightarrow>  4 Word.word " 

     bitvector_512_reg ::" string \<Rightarrow>  512 Word.word " 

     bitvector_56_reg ::" string \<Rightarrow>  56 Word.word " 

     bitvector_64_reg ::" string \<Rightarrow>  64 Word.word " 

     bitvector_88_reg ::" string \<Rightarrow>  88 Word.word " 

     bitvector_8_reg ::" string \<Rightarrow>  8 Word.word " 

     bool_reg ::" string \<Rightarrow> bool " 

     int_reg ::" string \<Rightarrow> ii " 

     option_InterruptID_reg ::" string \<Rightarrow>  InterruptID option " 

     option_bitvector_32_reg ::" string \<Rightarrow>  ( 32 Word.word)option " 

     vector_16_AMEVCNTR1_EL0_Type_reg ::" string \<Rightarrow> AMEVCNTR1_EL0_Type list " 

     vector_16_AMEVCNTR1_Type_reg ::" string \<Rightarrow> AMEVCNTR1_Type list " 

     vector_16_AMEVTYPER1_EL0_Type_reg ::" string \<Rightarrow> AMEVTYPER1_EL0_Type list " 

     vector_16_AMEVTYPER1_Type_reg ::" string \<Rightarrow> AMEVTYPER1_Type list " 

     vector_16_DBGBCR_Type_reg ::" string \<Rightarrow> DBGBCR_Type list " 

     vector_16_DBGBVR_Type_reg ::" string \<Rightarrow> DBGBVR_Type list " 

     vector_16_DBGBXVR_Type_reg ::" string \<Rightarrow> DBGBXVR_Type list " 

     vector_16_DBGWCR_Type_reg ::" string \<Rightarrow> DBGWCR_Type list " 

     vector_16_DBGWVR_Type_reg ::" string \<Rightarrow> DBGWVR_Type list " 

     vector_16_ICH_LRC_Type_reg ::" string \<Rightarrow> ICH_LRC_Type list " 

     vector_16_ICH_LR_EL2_Type_reg ::" string \<Rightarrow> ICH_LR_EL2_Type list " 

     vector_16_ICH_LR_Type_reg ::" string \<Rightarrow> ICH_LR_Type list " 

     vector_16_bitvector_256_reg ::" string \<Rightarrow> ( 256 Word.word) list " 

     vector_16_bitvector_64_reg ::" string \<Rightarrow> ( 64 Word.word) list " 

     vector_16_bool_reg ::" string \<Rightarrow> bool list " 

     vector_256_bitvector_2048_reg ::" string \<Rightarrow> ( 2048 Word.word) list " 

     vector_259_bool_reg ::" string \<Rightarrow> bool list " 

     vector_31_PMEVCNTSVR_EL1_Type_reg ::" string \<Rightarrow> PMEVCNTSVR_EL1_Type list " 

     vector_31_PMEVTYPER_Type_reg ::" string \<Rightarrow> PMEVTYPER_Type list " 

     vector_31_bitvector_32_reg ::" string \<Rightarrow> ( 32 Word.word) list " 

     vector_31_bool_reg ::" string \<Rightarrow> bool list " 

     vector_31_int_reg ::" string \<Rightarrow> ii list " 

     vector_32_BRBINF_EL1_Type_reg ::" string \<Rightarrow> BRBINF_EL1_Type list " 

     vector_32_BRBSRC_EL1_Type_reg ::" string \<Rightarrow> BRBSRC_EL1_Type list " 

     vector_32_BRBTGT_EL1_Type_reg ::" string \<Rightarrow> BRBTGT_EL1_Type list " 

     vector_32_PMEVTYPER_EL0_Type_reg ::" string \<Rightarrow> PMEVTYPER_EL0_Type list " 

     vector_32_bitvector_2048_reg ::" string \<Rightarrow> ( 2048 Word.word) list " 

     vector_32_bitvector_64_reg ::" string \<Rightarrow> ( 64 Word.word) list " 

     vector_32_bool_reg ::" string \<Rightarrow> bool list " 

     vector_32_int_reg ::" string \<Rightarrow> ii list " 

     vector_4_AMEVCNTR0_EL0_Type_reg ::" string \<Rightarrow> AMEVCNTR0_EL0_Type list " 

     vector_4_AMEVCNTR0_Type_reg ::" string \<Rightarrow> AMEVCNTR0_Type list " 

     vector_4_AMEVTYPER0_EL0_Type_reg ::" string \<Rightarrow> AMEVTYPER0_EL0_Type list " 

     vector_4_AMEVTYPER0_Type_reg ::" string \<Rightarrow> AMEVTYPER0_Type list " 

     vector_4_ERRnFR_ElemType_reg ::" string \<Rightarrow> ERRnFR_ElemType list " 

     vector_4_ICC_AP1R_EL1_Type_reg ::" string \<Rightarrow> ICC_AP1R_EL1_Type list " 

     vector_4_ICH_AP0R_EL2_Type_reg ::" string \<Rightarrow> ICH_AP0R_EL2_Type list " 

     vector_4_ICH_AP0R_Type_reg ::" string \<Rightarrow> ICH_AP0R_Type list " 

     vector_4_ICH_AP1R_EL2_Type_reg ::" string \<Rightarrow> ICH_AP1R_EL2_Type list " 

     vector_4_ICH_AP1R_Type_reg ::" string \<Rightarrow> ICH_AP1R_Type list " 

     vector_4_ICV_AP1R_EL1_Type_reg ::" string \<Rightarrow> ICV_AP1R_EL1_Type list " 

     vector_4_bitvector_32_reg ::" string \<Rightarrow> ( 32 Word.word) list " 

     vector_4_bitvector_64_reg ::" string \<Rightarrow> ( 64 Word.word) list " 

     vector_5_bitvector_64_reg ::" string \<Rightarrow> ( 64 Word.word) list " 

     vector_64_BRBINFType_reg ::" string \<Rightarrow> BRBINFType list " 

     vector_64_BRBSRCType_reg ::" string \<Rightarrow> BRBSRCType list " 

     vector_64_BRBTGTType_reg ::" string \<Rightarrow> BRBTGTType list " 

     vector_64_DBGBCR_EL1_Type_reg ::" string \<Rightarrow> DBGBCR_EL1_Type list " 

     vector_64_DBGBVR_EL1_Type_reg ::" string \<Rightarrow> DBGBVR_EL1_Type list " 

     vector_64_DBGWCR_EL1_Type_reg ::" string \<Rightarrow> DBGWCR_EL1_Type list " 

     vector_64_DBGWVR_EL1_Type_reg ::" string \<Rightarrow> DBGWVR_EL1_Type list " 

     vector_64_bitvector_8_reg ::" string \<Rightarrow> ( 8 Word.word) list " 

     vector_7_bitvector_64_reg ::" string \<Rightarrow> ( 64 Word.word) list "  





\<comment> \<open>\<open>val ACCDATA_EL1_Type_of_regval : register_value -> (maybe ACCDATA_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ACCDATA_EL1_Type : ACCDATA_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCFGR_EL0_Type_of_regval : register_value -> (maybe AMCFGR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCFGR_EL0_Type : AMCFGR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCFGR_Type_of_regval : register_value -> (maybe AMCFGR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCFGR_Type : AMCFGR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCG1IDR_EL0_Type_of_regval : register_value -> (maybe AMCG1IDR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCG1IDR_EL0_Type : AMCG1IDR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCGCR_EL0_Type_of_regval : register_value -> (maybe AMCGCR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCGCR_EL0_Type : AMCGCR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCGCR_Type_of_regval : register_value -> (maybe AMCGCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCGCR_Type : AMCGCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCIDR0_Type_of_regval : register_value -> (maybe AMCIDR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCIDR0_Type : AMCIDR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCIDR1_Type_of_regval : register_value -> (maybe AMCIDR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCIDR1_Type : AMCIDR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCIDR2_Type_of_regval : register_value -> (maybe AMCIDR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCIDR2_Type : AMCIDR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCIDR3_Type_of_regval : register_value -> (maybe AMCIDR3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCIDR3_Type : AMCIDR3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCNTENCLR0_EL0_Type_of_regval : register_value -> (maybe AMCNTENCLR0_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCNTENCLR0_EL0_Type : AMCNTENCLR0_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCNTENCLR0_Type_of_regval : register_value -> (maybe AMCNTENCLR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCNTENCLR0_Type : AMCNTENCLR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCNTENCLR1_EL0_Type_of_regval : register_value -> (maybe AMCNTENCLR1_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCNTENCLR1_EL0_Type : AMCNTENCLR1_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCNTENCLR1_Type_of_regval : register_value -> (maybe AMCNTENCLR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCNTENCLR1_Type : AMCNTENCLR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCNTENSET0_EL0_Type_of_regval : register_value -> (maybe AMCNTENSET0_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCNTENSET0_EL0_Type : AMCNTENSET0_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCNTENSET0_Type_of_regval : register_value -> (maybe AMCNTENSET0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCNTENSET0_Type : AMCNTENSET0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCNTENSET1_EL0_Type_of_regval : register_value -> (maybe AMCNTENSET1_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCNTENSET1_EL0_Type : AMCNTENSET1_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCNTENSET1_Type_of_regval : register_value -> (maybe AMCNTENSET1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCNTENSET1_Type : AMCNTENSET1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCR_EL0_Type_of_regval : register_value -> (maybe AMCR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCR_EL0_Type : AMCR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMCR_Type_of_regval : register_value -> (maybe AMCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMCR_Type : AMCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMDEVARCH_Type_of_regval : register_value -> (maybe AMDEVARCH_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMDEVARCH_Type : AMDEVARCH_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMDEVTYPE_Type_of_regval : register_value -> (maybe AMDEVTYPE_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMDEVTYPE_Type : AMDEVTYPE_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMEVCNTR0_EL0_Type_of_regval : register_value -> (maybe AMEVCNTR0_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMEVCNTR0_EL0_Type : AMEVCNTR0_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMEVCNTR0_Type_of_regval : register_value -> (maybe AMEVCNTR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMEVCNTR0_Type : AMEVCNTR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMEVCNTR1_EL0_Type_of_regval : register_value -> (maybe AMEVCNTR1_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMEVCNTR1_EL0_Type : AMEVCNTR1_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMEVCNTR1_Type_of_regval : register_value -> (maybe AMEVCNTR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMEVCNTR1_Type : AMEVCNTR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMEVTYPER0_EL0_Type_of_regval : register_value -> (maybe AMEVTYPER0_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMEVTYPER0_EL0_Type : AMEVTYPER0_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMEVTYPER0_Type_of_regval : register_value -> (maybe AMEVTYPER0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMEVTYPER0_Type : AMEVTYPER0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMEVTYPER1_EL0_Type_of_regval : register_value -> (maybe AMEVTYPER1_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMEVTYPER1_EL0_Type : AMEVTYPER1_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMEVTYPER1_Type_of_regval : register_value -> (maybe AMEVTYPER1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMEVTYPER1_Type : AMEVTYPER1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMIIDR_Type_of_regval : register_value -> (maybe AMIIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMIIDR_Type : AMIIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMPIDR0_Type_of_regval : register_value -> (maybe AMPIDR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMPIDR0_Type : AMPIDR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMPIDR1_Type_of_regval : register_value -> (maybe AMPIDR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMPIDR1_Type : AMPIDR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMPIDR2_Type_of_regval : register_value -> (maybe AMPIDR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMPIDR2_Type : AMPIDR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMPIDR3_Type_of_regval : register_value -> (maybe AMPIDR3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMPIDR3_Type : AMPIDR3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMPIDR4_Type_of_regval : register_value -> (maybe AMPIDR4_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMPIDR4_Type : AMPIDR4_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMUSERENR_EL0_Type_of_regval : register_value -> (maybe AMUSERENR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMUSERENR_EL0_Type : AMUSERENR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val AMUSERENR_Type_of_regval : register_value -> (maybe AMUSERENR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_AMUSERENR_Type : AMUSERENR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBCR_EL1_Type_of_regval : register_value -> (maybe BRBCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBCR_EL1_Type : BRBCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBCR_EL2_Type_of_regval : register_value -> (maybe BRBCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBCR_EL2_Type : BRBCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBFCR_EL1_Type_of_regval : register_value -> (maybe BRBFCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBFCR_EL1_Type : BRBFCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBIDR0_EL1_Type_of_regval : register_value -> (maybe BRBIDR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBIDR0_EL1_Type : BRBIDR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBINFINJ_EL1_Type_of_regval : register_value -> (maybe BRBINFINJ_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBINFINJ_EL1_Type : BRBINFINJ_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBINFType_of_regval : register_value -> (maybe BRBINFType)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBINFType : BRBINFType -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBINF_EL1_Type_of_regval : register_value -> (maybe BRBINF_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBINF_EL1_Type : BRBINF_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBSRCINJ_EL1_Type_of_regval : register_value -> (maybe BRBSRCINJ_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBSRCINJ_EL1_Type : BRBSRCINJ_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBSRCType_of_regval : register_value -> (maybe BRBSRCType)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBSRCType : BRBSRCType -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBSRC_EL1_Type_of_regval : register_value -> (maybe BRBSRC_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBSRC_EL1_Type : BRBSRC_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBTGTINJ_EL1_Type_of_regval : register_value -> (maybe BRBTGTINJ_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBTGTINJ_EL1_Type : BRBTGTINJ_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBTGTType_of_regval : register_value -> (maybe BRBTGTType)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBTGTType : BRBTGTType -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBTGT_EL1_Type_of_regval : register_value -> (maybe BRBTGT_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBTGT_EL1_Type : BRBTGT_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BRBTS_EL1_Type_of_regval : register_value -> (maybe BRBTS_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BRBTS_EL1_Type : BRBTS_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val BranchType_of_regval : register_value -> (maybe BranchType)\<close>\<close>

\<comment> \<open>\<open>val regval_of_BranchType : BranchType -> register_value\<close>\<close>

\<comment> \<open>\<open>val CCSIDR2_EL1_Type_of_regval : register_value -> (maybe CCSIDR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CCSIDR2_EL1_Type : CCSIDR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CCSIDR2_Type_of_regval : register_value -> (maybe CCSIDR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CCSIDR2_Type : CCSIDR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CCSIDR_EL1_Type_of_regval : register_value -> (maybe CCSIDR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CCSIDR_EL1_Type : CCSIDR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CCSIDR_Type_of_regval : register_value -> (maybe CCSIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CCSIDR_Type : CCSIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CLIDR_EL1_Type_of_regval : register_value -> (maybe CLIDR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CLIDR_EL1_Type : CLIDR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CLIDR_Type_of_regval : register_value -> (maybe CLIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CLIDR_Type : CLIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTCR_Type_of_regval : register_value -> (maybe CNTCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTCR_Type : CNTCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTEL0ACR_Type_of_regval : register_value -> (maybe CNTEL0ACR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTEL0ACR_Type : CNTEL0ACR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTFID0_Type_of_regval : register_value -> (maybe CNTFID0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTFID0_Type : CNTFID0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHCTL_EL2_Type_of_regval : register_value -> (maybe CNTHCTL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHCTL_EL2_Type : CNTHCTL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHCTL_Type_of_regval : register_value -> (maybe CNTHCTL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHCTL_Type : CNTHCTL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHPS_CTL_EL2_Type_of_regval : register_value -> (maybe CNTHPS_CTL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHPS_CTL_EL2_Type : CNTHPS_CTL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHPS_CTL_Type_of_regval : register_value -> (maybe CNTHPS_CTL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHPS_CTL_Type : CNTHPS_CTL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHPS_CVAL_EL2_Type_of_regval : register_value -> (maybe CNTHPS_CVAL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHPS_CVAL_EL2_Type : CNTHPS_CVAL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHPS_TVAL_EL2_Type_of_regval : register_value -> (maybe CNTHPS_TVAL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHPS_TVAL_EL2_Type : CNTHPS_TVAL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHP_CTL_EL2_Type_of_regval : register_value -> (maybe CNTHP_CTL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHP_CTL_EL2_Type : CNTHP_CTL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHP_CTL_Type_of_regval : register_value -> (maybe CNTHP_CTL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHP_CTL_Type : CNTHP_CTL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHP_CVAL_EL2_Type_of_regval : register_value -> (maybe CNTHP_CVAL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHP_CVAL_EL2_Type : CNTHP_CVAL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHP_CVAL_Type_of_regval : register_value -> (maybe CNTHP_CVAL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHP_CVAL_Type : CNTHP_CVAL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHP_TVAL_EL2_Type_of_regval : register_value -> (maybe CNTHP_TVAL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHP_TVAL_EL2_Type : CNTHP_TVAL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHVS_CTL_EL2_Type_of_regval : register_value -> (maybe CNTHVS_CTL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHVS_CTL_EL2_Type : CNTHVS_CTL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHVS_CTL_Type_of_regval : register_value -> (maybe CNTHVS_CTL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHVS_CTL_Type : CNTHVS_CTL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHVS_CVAL_EL2_Type_of_regval : register_value -> (maybe CNTHVS_CVAL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHVS_CVAL_EL2_Type : CNTHVS_CVAL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHVS_TVAL_EL2_Type_of_regval : register_value -> (maybe CNTHVS_TVAL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHVS_TVAL_EL2_Type : CNTHVS_TVAL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHV_CTL_EL2_Type_of_regval : register_value -> (maybe CNTHV_CTL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHV_CTL_EL2_Type : CNTHV_CTL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHV_CTL_Type_of_regval : register_value -> (maybe CNTHV_CTL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHV_CTL_Type : CNTHV_CTL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHV_CVAL_EL2_Type_of_regval : register_value -> (maybe CNTHV_CVAL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHV_CVAL_EL2_Type : CNTHV_CVAL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTHV_TVAL_EL2_Type_of_regval : register_value -> (maybe CNTHV_TVAL_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTHV_TVAL_EL2_Type : CNTHV_TVAL_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTID_Type_of_regval : register_value -> (maybe CNTID_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTID_Type : CNTID_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTKCTL_EL1_Type_of_regval : register_value -> (maybe CNTKCTL_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTKCTL_EL1_Type : CNTKCTL_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTKCTL_Type_of_regval : register_value -> (maybe CNTKCTL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTKCTL_Type : CNTKCTL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTNSAR_Type_of_regval : register_value -> (maybe CNTNSAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTNSAR_Type : CNTNSAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTPS_CTL_EL1_Type_of_regval : register_value -> (maybe CNTPS_CTL_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTPS_CTL_EL1_Type : CNTPS_CTL_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTPS_CVAL_EL1_Type_of_regval : register_value -> (maybe CNTPS_CVAL_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTPS_CVAL_EL1_Type : CNTPS_CVAL_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTPS_TVAL_EL1_Type_of_regval : register_value -> (maybe CNTPS_TVAL_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTPS_TVAL_EL1_Type : CNTPS_TVAL_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTP_CTL_EL0_Type_of_regval : register_value -> (maybe CNTP_CTL_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTP_CTL_EL0_Type : CNTP_CTL_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTP_CTL_Type_of_regval : register_value -> (maybe CNTP_CTL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTP_CTL_Type : CNTP_CTL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTP_CVAL_EL0_Type_of_regval : register_value -> (maybe CNTP_CVAL_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTP_CVAL_EL0_Type : CNTP_CVAL_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTP_CVAL_Type_of_regval : register_value -> (maybe CNTP_CVAL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTP_CVAL_Type : CNTP_CVAL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTP_TVAL_EL0_Type_of_regval : register_value -> (maybe CNTP_TVAL_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTP_TVAL_EL0_Type : CNTP_TVAL_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTSCR_Type_of_regval : register_value -> (maybe CNTSCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTSCR_Type : CNTSCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTSR_Type_of_regval : register_value -> (maybe CNTSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTSR_Type : CNTSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTV_CTL_EL0_Type_of_regval : register_value -> (maybe CNTV_CTL_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTV_CTL_EL0_Type : CNTV_CTL_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTV_CTL_Type_of_regval : register_value -> (maybe CNTV_CTL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTV_CTL_Type : CNTV_CTL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTV_CVAL_EL0_Type_of_regval : register_value -> (maybe CNTV_CVAL_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTV_CVAL_EL0_Type : CNTV_CVAL_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTV_CVAL_Type_of_regval : register_value -> (maybe CNTV_CVAL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTV_CVAL_Type : CNTV_CVAL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CNTV_TVAL_EL0_Type_of_regval : register_value -> (maybe CNTV_TVAL_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CNTV_TVAL_EL0_Type : CNTV_TVAL_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CONTEXTIDR_EL1_Type_of_regval : register_value -> (maybe CONTEXTIDR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CONTEXTIDR_EL1_Type : CONTEXTIDR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CONTEXTIDR_EL2_Type_of_regval : register_value -> (maybe CONTEXTIDR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CONTEXTIDR_EL2_Type : CONTEXTIDR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CONTEXTIDR_Type_of_regval : register_value -> (maybe CONTEXTIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CONTEXTIDR_Type : CONTEXTIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CPACR_EL1_Type_of_regval : register_value -> (maybe CPACR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CPACR_EL1_Type : CPACR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CPACR_Type_of_regval : register_value -> (maybe CPACR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CPACR_Type : CPACR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CPTR_EL2_Type_of_regval : register_value -> (maybe CPTR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CPTR_EL2_Type : CPTR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CPTR_EL3_Type_of_regval : register_value -> (maybe CPTR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CPTR_EL3_Type : CPTR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CSSELR_EL1_Type_of_regval : register_value -> (maybe CSSELR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CSSELR_EL1_Type : CSSELR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CSSELR_Type_of_regval : register_value -> (maybe CSSELR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CSSELR_Type : CSSELR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIAUTHSTATUS_Type_of_regval : register_value -> (maybe CTIAUTHSTATUS_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIAUTHSTATUS_Type : CTIAUTHSTATUS_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTICIDR0_Type_of_regval : register_value -> (maybe CTICIDR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTICIDR0_Type : CTICIDR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTICIDR1_Type_of_regval : register_value -> (maybe CTICIDR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTICIDR1_Type : CTICIDR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTICIDR2_Type_of_regval : register_value -> (maybe CTICIDR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTICIDR2_Type : CTICIDR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTICIDR3_Type_of_regval : register_value -> (maybe CTICIDR3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTICIDR3_Type : CTICIDR3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTICONTROL_Type_of_regval : register_value -> (maybe CTICONTROL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTICONTROL_Type : CTICONTROL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIDEVARCH_Type_of_regval : register_value -> (maybe CTIDEVARCH_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIDEVARCH_Type : CTIDEVARCH_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIDEVCTL_Type_of_regval : register_value -> (maybe CTIDEVCTL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIDEVCTL_Type : CTIDEVCTL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIDEVID_Type_of_regval : register_value -> (maybe CTIDEVID_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIDEVID_Type : CTIDEVID_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIDEVTYPE_Type_of_regval : register_value -> (maybe CTIDEVTYPE_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIDEVTYPE_Type : CTIDEVTYPE_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIITCTRL_Type_of_regval : register_value -> (maybe CTIITCTRL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIITCTRL_Type : CTIITCTRL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTILAR_Type_of_regval : register_value -> (maybe CTILAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTILAR_Type : CTILAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTILSR_Type_of_regval : register_value -> (maybe CTILSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTILSR_Type : CTILSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIPIDR0_Type_of_regval : register_value -> (maybe CTIPIDR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIPIDR0_Type : CTIPIDR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIPIDR1_Type_of_regval : register_value -> (maybe CTIPIDR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIPIDR1_Type : CTIPIDR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIPIDR2_Type_of_regval : register_value -> (maybe CTIPIDR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIPIDR2_Type : CTIPIDR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIPIDR3_Type_of_regval : register_value -> (maybe CTIPIDR3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIPIDR3_Type : CTIPIDR3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTIPIDR4_Type_of_regval : register_value -> (maybe CTIPIDR4_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTIPIDR4_Type : CTIPIDR4_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTR_EL0_Type_of_regval : register_value -> (maybe CTR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTR_EL0_Type : CTR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val CTR_Type_of_regval : register_value -> (maybe CTR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_CTR_Type : CTR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val Configuration_Type_of_regval : register_value -> (maybe Configuration_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_Configuration_Type : Configuration_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DACR32_EL2_Type_of_regval : register_value -> (maybe DACR32_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DACR32_EL2_Type : DACR32_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DACR_Type_of_regval : register_value -> (maybe DACR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DACR_Type : DACR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGAUTHSTATUS_EL1_Type_of_regval : register_value -> (maybe DBGAUTHSTATUS_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGAUTHSTATUS_EL1_Type : DBGAUTHSTATUS_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGAUTHSTATUS_Type_of_regval : register_value -> (maybe DBGAUTHSTATUS_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGAUTHSTATUS_Type : DBGAUTHSTATUS_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGBCR_EL1_Type_of_regval : register_value -> (maybe DBGBCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGBCR_EL1_Type : DBGBCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGBCR_Type_of_regval : register_value -> (maybe DBGBCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGBCR_Type : DBGBCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGBVR_EL1_Type_of_regval : register_value -> (maybe DBGBVR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGBVR_EL1_Type : DBGBVR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGBVR_Type_of_regval : register_value -> (maybe DBGBVR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGBVR_Type : DBGBVR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGBXVR_Type_of_regval : register_value -> (maybe DBGBXVR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGBXVR_Type : DBGBXVR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGCLAIMCLR_EL1_Type_of_regval : register_value -> (maybe DBGCLAIMCLR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGCLAIMCLR_EL1_Type : DBGCLAIMCLR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGCLAIMCLR_Type_of_regval : register_value -> (maybe DBGCLAIMCLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGCLAIMCLR_Type : DBGCLAIMCLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGCLAIMSET_EL1_Type_of_regval : register_value -> (maybe DBGCLAIMSET_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGCLAIMSET_EL1_Type : DBGCLAIMSET_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGCLAIMSET_Type_of_regval : register_value -> (maybe DBGCLAIMSET_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGCLAIMSET_Type : DBGCLAIMSET_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDCCINT_Type_of_regval : register_value -> (maybe DBGDCCINT_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDCCINT_Type : DBGDCCINT_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDEVID1_Type_of_regval : register_value -> (maybe DBGDEVID1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDEVID1_Type : DBGDEVID1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDEVID_Type_of_regval : register_value -> (maybe DBGDEVID_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDEVID_Type : DBGDEVID_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDIDR_Type_of_regval : register_value -> (maybe DBGDIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDIDR_Type : DBGDIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDRAR_Type_of_regval : register_value -> (maybe DBGDRAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDRAR_Type : DBGDRAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDSCRext_Type_of_regval : register_value -> (maybe DBGDSCRext_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDSCRext_Type : DBGDSCRext_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDSCRint_Type_of_regval : register_value -> (maybe DBGDSCRint_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDSCRint_Type : DBGDSCRint_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDTRRXext_Type_of_regval : register_value -> (maybe DBGDTRRXext_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDTRRXext_Type : DBGDTRRXext_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDTRRXint_Type_of_regval : register_value -> (maybe DBGDTRRXint_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDTRRXint_Type : DBGDTRRXint_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDTRTXext_Type_of_regval : register_value -> (maybe DBGDTRTXext_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDTRTXext_Type : DBGDTRTXext_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDTRTXint_Type_of_regval : register_value -> (maybe DBGDTRTXint_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDTRTXint_Type : DBGDTRTXint_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGDTR_EL0_Type_of_regval : register_value -> (maybe DBGDTR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGDTR_EL0_Type : DBGDTR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGOSDLR_Type_of_regval : register_value -> (maybe DBGOSDLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGOSDLR_Type : DBGOSDLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGOSECCR_Type_of_regval : register_value -> (maybe DBGOSECCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGOSECCR_Type : DBGOSECCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGOSLAR_Type_of_regval : register_value -> (maybe DBGOSLAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGOSLAR_Type : DBGOSLAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGOSLSR_Type_of_regval : register_value -> (maybe DBGOSLSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGOSLSR_Type : DBGOSLSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGPRCR_EL1_Type_of_regval : register_value -> (maybe DBGPRCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGPRCR_EL1_Type : DBGPRCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGPRCR_Type_of_regval : register_value -> (maybe DBGPRCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGPRCR_Type : DBGPRCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGVCR32_EL2_Type_of_regval : register_value -> (maybe DBGVCR32_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGVCR32_EL2_Type : DBGVCR32_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGVCR_Type_of_regval : register_value -> (maybe DBGVCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGVCR_Type : DBGVCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGWCR_EL1_Type_of_regval : register_value -> (maybe DBGWCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGWCR_EL1_Type : DBGWCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGWCR_Type_of_regval : register_value -> (maybe DBGWCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGWCR_Type : DBGWCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGWVR_EL1_Type_of_regval : register_value -> (maybe DBGWVR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGWVR_EL1_Type : DBGWVR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DBGWVR_Type_of_regval : register_value -> (maybe DBGWVR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DBGWVR_Type : DBGWVR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DCZID_EL0_Type_of_regval : register_value -> (maybe DCZID_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DCZID_EL0_Type : DCZID_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DFSR_Type_of_regval : register_value -> (maybe DFSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DFSR_Type : DFSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DISR_EL1_Type_of_regval : register_value -> (maybe DISR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DISR_EL1_Type : DISR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DISR_Type_of_regval : register_value -> (maybe DISR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DISR_Type : DISR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DSPSR2_Type_of_regval : register_value -> (maybe DSPSR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DSPSR2_Type : DSPSR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DSPSR_EL0_Type_of_regval : register_value -> (maybe DSPSR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DSPSR_EL0_Type : DSPSR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DSPSR_Type_of_regval : register_value -> (maybe DSPSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DSPSR_Type : DSPSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val DormantCtl_Type_of_regval : register_value -> (maybe DormantCtl_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_DormantCtl_Type : DormantCtl_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDAA32PFR_Type_of_regval : register_value -> (maybe EDAA32PFR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDAA32PFR_Type : EDAA32PFR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDCIDR0_Type_of_regval : register_value -> (maybe EDCIDR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDCIDR0_Type : EDCIDR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDCIDR1_Type_of_regval : register_value -> (maybe EDCIDR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDCIDR1_Type : EDCIDR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDCIDR2_Type_of_regval : register_value -> (maybe EDCIDR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDCIDR2_Type : EDCIDR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDCIDR3_Type_of_regval : register_value -> (maybe EDCIDR3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDCIDR3_Type : EDCIDR3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDDEVARCH_Type_of_regval : register_value -> (maybe EDDEVARCH_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDDEVARCH_Type : EDDEVARCH_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDDEVID1_Type_of_regval : register_value -> (maybe EDDEVID1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDDEVID1_Type : EDDEVID1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDDEVID_Type_of_regval : register_value -> (maybe EDDEVID_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDDEVID_Type : EDDEVID_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDDEVTYPE_Type_of_regval : register_value -> (maybe EDDEVTYPE_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDDEVTYPE_Type : EDDEVTYPE_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDDFR1_Type_of_regval : register_value -> (maybe EDDFR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDDFR1_Type : EDDFR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDDFR_Type_of_regval : register_value -> (maybe EDDFR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDDFR_Type : EDDFR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDECCR_Type_of_regval : register_value -> (maybe EDECCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDECCR_Type : EDECCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDECR_Type_of_regval : register_value -> (maybe EDECR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDECR_Type : EDECR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDESR_Type_of_regval : register_value -> (maybe EDESR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDESR_Type : EDESR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDHSR_Type_of_regval : register_value -> (maybe EDHSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDHSR_Type : EDHSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDITCTRL_Type_of_regval : register_value -> (maybe EDITCTRL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDITCTRL_Type : EDITCTRL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDLAR_Type_of_regval : register_value -> (maybe EDLAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDLAR_Type : EDLAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDLSR_Type_of_regval : register_value -> (maybe EDLSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDLSR_Type : EDLSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDPCSR_Type_of_regval : register_value -> (maybe EDPCSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDPCSR_Type : EDPCSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDPFR_Type_of_regval : register_value -> (maybe EDPFR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDPFR_Type : EDPFR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDPIDR0_Type_of_regval : register_value -> (maybe EDPIDR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDPIDR0_Type : EDPIDR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDPIDR1_Type_of_regval : register_value -> (maybe EDPIDR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDPIDR1_Type : EDPIDR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDPIDR2_Type_of_regval : register_value -> (maybe EDPIDR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDPIDR2_Type : EDPIDR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDPIDR3_Type_of_regval : register_value -> (maybe EDPIDR3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDPIDR3_Type : EDPIDR3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDPIDR4_Type_of_regval : register_value -> (maybe EDPIDR4_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDPIDR4_Type : EDPIDR4_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDPRCR_Type_of_regval : register_value -> (maybe EDPRCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDPRCR_Type : EDPRCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDPRSR_Type_of_regval : register_value -> (maybe EDPRSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDPRSR_Type : EDPRSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDRCR_Type_of_regval : register_value -> (maybe EDRCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDRCR_Type : EDRCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDSCR2_Type_of_regval : register_value -> (maybe EDSCR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDSCR2_Type : EDSCR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDSCR_Type_of_regval : register_value -> (maybe EDSCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDSCR_Type : EDSCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val EDVIDSR_Type_of_regval : register_value -> (maybe EDVIDSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_EDVIDSR_Type : EDVIDSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ERRIDR_EL1_Type_of_regval : register_value -> (maybe ERRIDR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ERRIDR_EL1_Type : ERRIDR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ERRIDR_Type_of_regval : register_value -> (maybe ERRIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ERRIDR_Type : ERRIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ERRSELR_EL1_Type_of_regval : register_value -> (maybe ERRSELR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ERRSELR_EL1_Type : ERRSELR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ERRSELR_Type_of_regval : register_value -> (maybe ERRSELR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ERRSELR_Type : ERRSELR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ERRnFR_ElemType_of_regval : register_value -> (maybe ERRnFR_ElemType)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ERRnFR_ElemType : ERRnFR_ElemType -> register_value\<close>\<close>

\<comment> \<open>\<open>val ERXGSR_EL1_Type_of_regval : register_value -> (maybe ERXGSR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ERXGSR_EL1_Type : ERXGSR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ESR_EL1_Type_of_regval : register_value -> (maybe ESR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ESR_EL1_Type : ESR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ESR_EL2_Type_of_regval : register_value -> (maybe ESR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ESR_EL2_Type : ESR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ESR_EL3_Type_of_regval : register_value -> (maybe ESR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ESR_EL3_Type : ESR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val FPCR_Type_of_regval : register_value -> (maybe FPCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_FPCR_Type : FPCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val FPEXC32_EL2_Type_of_regval : register_value -> (maybe FPEXC32_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_FPEXC32_EL2_Type : FPEXC32_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val FPEXC_Type_of_regval : register_value -> (maybe FPEXC_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_FPEXC_Type : FPEXC_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val FPSCR_Type_of_regval : register_value -> (maybe FPSCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_FPSCR_Type : FPSCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val FPSID_Type_of_regval : register_value -> (maybe FPSID_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_FPSID_Type : FPSID_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val FPSR_Type_of_regval : register_value -> (maybe FPSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_FPSR_Type : FPSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GCR_EL1_Type_of_regval : register_value -> (maybe GCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GCR_EL1_Type : GCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GCSCRE0_EL1_Type_of_regval : register_value -> (maybe GCSCRE0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GCSCRE0_EL1_Type : GCSCRE0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GCSCR_EL1_Type_of_regval : register_value -> (maybe GCSCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GCSCR_EL1_Type : GCSCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GCSCR_EL2_Type_of_regval : register_value -> (maybe GCSCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GCSCR_EL2_Type : GCSCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GCSCR_EL3_Type_of_regval : register_value -> (maybe GCSCR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GCSCR_EL3_Type : GCSCR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GCSPR_EL0_Type_of_regval : register_value -> (maybe GCSPR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GCSPR_EL0_Type : GCSPR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GCSPR_EL1_Type_of_regval : register_value -> (maybe GCSPR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GCSPR_EL1_Type : GCSPR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GCSPR_EL2_Type_of_regval : register_value -> (maybe GCSPR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GCSPR_EL2_Type : GCSPR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GCSPR_EL3_Type_of_regval : register_value -> (maybe GCSPR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GCSPR_EL3_Type : GCSPR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_ABPR_Type_of_regval : register_value -> (maybe GICC_ABPR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_ABPR_Type : GICC_ABPR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_AEOIR_Type_of_regval : register_value -> (maybe GICC_AEOIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_AEOIR_Type : GICC_AEOIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_AHPPIR_Type_of_regval : register_value -> (maybe GICC_AHPPIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_AHPPIR_Type : GICC_AHPPIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_AIAR_Type_of_regval : register_value -> (maybe GICC_AIAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_AIAR_Type : GICC_AIAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_BPR_Type_of_regval : register_value -> (maybe GICC_BPR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_BPR_Type : GICC_BPR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_CTLR_Type_of_regval : register_value -> (maybe GICC_CTLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_CTLR_Type : GICC_CTLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_DIR_Type_of_regval : register_value -> (maybe GICC_DIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_DIR_Type : GICC_DIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_EOIR_Type_of_regval : register_value -> (maybe GICC_EOIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_EOIR_Type : GICC_EOIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_HPPIR_Type_of_regval : register_value -> (maybe GICC_HPPIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_HPPIR_Type : GICC_HPPIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_IAR_Type_of_regval : register_value -> (maybe GICC_IAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_IAR_Type : GICC_IAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_PMR_Type_of_regval : register_value -> (maybe GICC_PMR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_PMR_Type : GICC_PMR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_RPR_Type_of_regval : register_value -> (maybe GICC_RPR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_RPR_Type : GICC_RPR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICC_STATUSR_Type_of_regval : register_value -> (maybe GICC_STATUSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICC_STATUSR_Type : GICC_STATUSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICD_CLRSPI_NSR_Type_of_regval : register_value -> (maybe GICD_CLRSPI_NSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICD_CLRSPI_NSR_Type : GICD_CLRSPI_NSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICD_CLRSPI_SR_Type_of_regval : register_value -> (maybe GICD_CLRSPI_SR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICD_CLRSPI_SR_Type : GICD_CLRSPI_SR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICD_CTLR_Type_of_regval : register_value -> (maybe GICD_CTLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICD_CTLR_Type : GICD_CTLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICD_IIDR_Type_of_regval : register_value -> (maybe GICD_IIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICD_IIDR_Type : GICD_IIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICD_SETSPI_NSR_Type_of_regval : register_value -> (maybe GICD_SETSPI_NSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICD_SETSPI_NSR_Type : GICD_SETSPI_NSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICD_SETSPI_SR_Type_of_regval : register_value -> (maybe GICD_SETSPI_SR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICD_SETSPI_SR_Type : GICD_SETSPI_SR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICD_SGIR_Type_of_regval : register_value -> (maybe GICD_SGIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICD_SGIR_Type : GICD_SGIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICD_STATUSR_Type_of_regval : register_value -> (maybe GICD_STATUSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICD_STATUSR_Type : GICD_STATUSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICD_TYPER2_Type_of_regval : register_value -> (maybe GICD_TYPER2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICD_TYPER2_Type : GICD_TYPER2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICD_TYPER_Type_of_regval : register_value -> (maybe GICD_TYPER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICD_TYPER_Type : GICD_TYPER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICH_EISR_Type_of_regval : register_value -> (maybe GICH_EISR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICH_EISR_Type : GICH_EISR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICH_ELRSR_Type_of_regval : register_value -> (maybe GICH_ELRSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICH_ELRSR_Type : GICH_ELRSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICH_HCR_Type_of_regval : register_value -> (maybe GICH_HCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICH_HCR_Type : GICH_HCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICH_MISR_Type_of_regval : register_value -> (maybe GICH_MISR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICH_MISR_Type : GICH_MISR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICH_VMCR_Type_of_regval : register_value -> (maybe GICH_VMCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICH_VMCR_Type : GICH_VMCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICH_VTR_Type_of_regval : register_value -> (maybe GICH_VTR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICH_VTR_Type : GICH_VTR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICM_CLRSPI_NSR_Type_of_regval : register_value -> (maybe GICM_CLRSPI_NSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICM_CLRSPI_NSR_Type : GICM_CLRSPI_NSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICM_CLRSPI_SR_Type_of_regval : register_value -> (maybe GICM_CLRSPI_SR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICM_CLRSPI_SR_Type : GICM_CLRSPI_SR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICM_IIDR_Type_of_regval : register_value -> (maybe GICM_IIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICM_IIDR_Type : GICM_IIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICM_SETSPI_NSR_Type_of_regval : register_value -> (maybe GICM_SETSPI_NSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICM_SETSPI_NSR_Type : GICM_SETSPI_NSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICM_SETSPI_SR_Type_of_regval : register_value -> (maybe GICM_SETSPI_SR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICM_SETSPI_SR_Type : GICM_SETSPI_SR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICM_TYPER_Type_of_regval : register_value -> (maybe GICM_TYPER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICM_TYPER_Type : GICM_TYPER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_CLRLPIR_Type_of_regval : register_value -> (maybe GICR_CLRLPIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_CLRLPIR_Type : GICR_CLRLPIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_CTLR_Type_of_regval : register_value -> (maybe GICR_CTLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_CTLR_Type : GICR_CTLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_IIDR_Type_of_regval : register_value -> (maybe GICR_IIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_IIDR_Type : GICR_IIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_INMIR0_Type_of_regval : register_value -> (maybe GICR_INMIR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_INMIR0_Type : GICR_INMIR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_INVALLR_Type_of_regval : register_value -> (maybe GICR_INVALLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_INVALLR_Type : GICR_INVALLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_INVLPIR_Type_of_regval : register_value -> (maybe GICR_INVLPIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_INVLPIR_Type : GICR_INVLPIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_ISENABLER0_Type_of_regval : register_value -> (maybe GICR_ISENABLER0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_ISENABLER0_Type : GICR_ISENABLER0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_MPAMIDR_Type_of_regval : register_value -> (maybe GICR_MPAMIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_MPAMIDR_Type : GICR_MPAMIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_PARTIDR_Type_of_regval : register_value -> (maybe GICR_PARTIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_PARTIDR_Type : GICR_PARTIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_PENDBASER_Type_of_regval : register_value -> (maybe GICR_PENDBASER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_PENDBASER_Type : GICR_PENDBASER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_PROPBASER_Type_of_regval : register_value -> (maybe GICR_PROPBASER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_PROPBASER_Type : GICR_PROPBASER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_SETLPIR_Type_of_regval : register_value -> (maybe GICR_SETLPIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_SETLPIR_Type : GICR_SETLPIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_STATUSR_Type_of_regval : register_value -> (maybe GICR_STATUSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_STATUSR_Type : GICR_STATUSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_SYNCR_Type_of_regval : register_value -> (maybe GICR_SYNCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_SYNCR_Type : GICR_SYNCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_VPENDBASER_Type_of_regval : register_value -> (maybe GICR_VPENDBASER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_VPENDBASER_Type : GICR_VPENDBASER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_VPROPBASER_Type_of_regval : register_value -> (maybe GICR_VPROPBASER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_VPROPBASER_Type : GICR_VPROPBASER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_VSGIPENDR_Type_of_regval : register_value -> (maybe GICR_VSGIPENDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_VSGIPENDR_Type : GICR_VSGIPENDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_VSGIR_Type_of_regval : register_value -> (maybe GICR_VSGIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_VSGIR_Type : GICR_VSGIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICR_WAKER_Type_of_regval : register_value -> (maybe GICR_WAKER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICR_WAKER_Type : GICR_WAKER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_ABPR_Type_of_regval : register_value -> (maybe GICV_ABPR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_ABPR_Type : GICV_ABPR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_AEOIR_Type_of_regval : register_value -> (maybe GICV_AEOIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_AEOIR_Type : GICV_AEOIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_AHPPIR_Type_of_regval : register_value -> (maybe GICV_AHPPIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_AHPPIR_Type : GICV_AHPPIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_AIAR_Type_of_regval : register_value -> (maybe GICV_AIAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_AIAR_Type : GICV_AIAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_BPR_Type_of_regval : register_value -> (maybe GICV_BPR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_BPR_Type : GICV_BPR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_CTLR_Type_of_regval : register_value -> (maybe GICV_CTLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_CTLR_Type : GICV_CTLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_DIR_Type_of_regval : register_value -> (maybe GICV_DIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_DIR_Type : GICV_DIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_EOIR_Type_of_regval : register_value -> (maybe GICV_EOIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_EOIR_Type : GICV_EOIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_HPPIR_Type_of_regval : register_value -> (maybe GICV_HPPIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_HPPIR_Type : GICV_HPPIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_IAR_Type_of_regval : register_value -> (maybe GICV_IAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_IAR_Type : GICV_IAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_PMR_Type_of_regval : register_value -> (maybe GICV_PMR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_PMR_Type : GICV_PMR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_RPR_Type_of_regval : register_value -> (maybe GICV_RPR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_RPR_Type : GICV_RPR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GICV_STATUSR_Type_of_regval : register_value -> (maybe GICV_STATUSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GICV_STATUSR_Type : GICV_STATUSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_CBASER_Type_of_regval : register_value -> (maybe GITS_CBASER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_CBASER_Type : GITS_CBASER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_CREADR_Type_of_regval : register_value -> (maybe GITS_CREADR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_CREADR_Type : GITS_CREADR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_CTLR_Type_of_regval : register_value -> (maybe GITS_CTLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_CTLR_Type : GITS_CTLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_CWRITER_Type_of_regval : register_value -> (maybe GITS_CWRITER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_CWRITER_Type : GITS_CWRITER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_IIDR_Type_of_regval : register_value -> (maybe GITS_IIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_IIDR_Type : GITS_IIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_MPAMIDR_Type_of_regval : register_value -> (maybe GITS_MPAMIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_MPAMIDR_Type : GITS_MPAMIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_MPIDR_Type_of_regval : register_value -> (maybe GITS_MPIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_MPIDR_Type : GITS_MPIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_PARTIDR_Type_of_regval : register_value -> (maybe GITS_PARTIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_PARTIDR_Type : GITS_PARTIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_SGIR_Type_of_regval : register_value -> (maybe GITS_SGIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_SGIR_Type : GITS_SGIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_STATUSR_Type_of_regval : register_value -> (maybe GITS_STATUSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_STATUSR_Type : GITS_STATUSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GITS_TYPER_Type_of_regval : register_value -> (maybe GITS_TYPER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GITS_TYPER_Type : GITS_TYPER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GMID_EL1_Type_of_regval : register_value -> (maybe GMID_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GMID_EL1_Type : GMID_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GPCCR_EL3_Type_of_regval : register_value -> (maybe GPCCR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GPCCR_EL3_Type : GPCCR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val GPTBR_EL3_Type_of_regval : register_value -> (maybe GPTBR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_GPTBR_EL3_Type : GPTBR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HAFGRTR_EL2_Type_of_regval : register_value -> (maybe HAFGRTR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HAFGRTR_EL2_Type : HAFGRTR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HCPTR_Type_of_regval : register_value -> (maybe HCPTR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HCPTR_Type : HCPTR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HCR2_Type_of_regval : register_value -> (maybe HCR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HCR2_Type : HCR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HCRX_EL2_Type_of_regval : register_value -> (maybe HCRX_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HCRX_EL2_Type : HCRX_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HCR_EL2_Type_of_regval : register_value -> (maybe HCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HCR_EL2_Type : HCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HCR_Type_of_regval : register_value -> (maybe HCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HCR_Type : HCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HDCR_Type_of_regval : register_value -> (maybe HDCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HDCR_Type : HDCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HDFGRTR2_EL2_Type_of_regval : register_value -> (maybe HDFGRTR2_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HDFGRTR2_EL2_Type : HDFGRTR2_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HDFGRTR_EL2_Type_of_regval : register_value -> (maybe HDFGRTR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HDFGRTR_EL2_Type : HDFGRTR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HDFGWTR2_EL2_Type_of_regval : register_value -> (maybe HDFGWTR2_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HDFGWTR2_EL2_Type : HDFGWTR2_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HDFGWTR_EL2_Type_of_regval : register_value -> (maybe HDFGWTR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HDFGWTR_EL2_Type : HDFGWTR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HFGITR_EL2_Type_of_regval : register_value -> (maybe HFGITR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HFGITR_EL2_Type : HFGITR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HFGRTR2_EL2_Type_of_regval : register_value -> (maybe HFGRTR2_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HFGRTR2_EL2_Type : HFGRTR2_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HFGRTR_EL2_Type_of_regval : register_value -> (maybe HFGRTR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HFGRTR_EL2_Type : HFGRTR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HFGWTR2_EL2_Type_of_regval : register_value -> (maybe HFGWTR2_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HFGWTR2_EL2_Type : HFGWTR2_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HFGWTR_EL2_Type_of_regval : register_value -> (maybe HFGWTR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HFGWTR_EL2_Type : HFGWTR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HMAIR0_Type_of_regval : register_value -> (maybe HMAIR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HMAIR0_Type : HMAIR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HMAIR1_Type_of_regval : register_value -> (maybe HMAIR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HMAIR1_Type : HMAIR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HPFAR_EL2_Type_of_regval : register_value -> (maybe HPFAR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HPFAR_EL2_Type : HPFAR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HPFAR_Type_of_regval : register_value -> (maybe HPFAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HPFAR_Type : HPFAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HRMR_Type_of_regval : register_value -> (maybe HRMR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HRMR_Type : HRMR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HSCTLR_Type_of_regval : register_value -> (maybe HSCTLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HSCTLR_Type : HSCTLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HSR_Type_of_regval : register_value -> (maybe HSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HSR_Type : HSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HSTR_EL2_Type_of_regval : register_value -> (maybe HSTR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HSTR_EL2_Type : HSTR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HSTR_Type_of_regval : register_value -> (maybe HSTR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HSTR_Type : HSTR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HTCR_Type_of_regval : register_value -> (maybe HTCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HTCR_Type : HTCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HTRFCR_Type_of_regval : register_value -> (maybe HTRFCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HTRFCR_Type : HTRFCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val HTTBR_Type_of_regval : register_value -> (maybe HTTBR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_HTTBR_Type : HTTBR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_AP1R_EL1_Type_of_regval : register_value -> (maybe ICC_AP1R_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_AP1R_EL1_Type : ICC_AP1R_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_ASGI1R_EL1_Type_of_regval : register_value -> (maybe ICC_ASGI1R_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_ASGI1R_EL1_Type : ICC_ASGI1R_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_ASGI1R_Type_of_regval : register_value -> (maybe ICC_ASGI1R_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_ASGI1R_Type : ICC_ASGI1R_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_BPR0_EL1_Type_of_regval : register_value -> (maybe ICC_BPR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_BPR0_EL1_Type : ICC_BPR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_BPR0_Type_of_regval : register_value -> (maybe ICC_BPR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_BPR0_Type : ICC_BPR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_BPR1_EL1_Type_of_regval : register_value -> (maybe ICC_BPR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_BPR1_EL1_Type : ICC_BPR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_BPR1_Type_of_regval : register_value -> (maybe ICC_BPR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_BPR1_Type : ICC_BPR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_CTLR_EL1_Type_of_regval : register_value -> (maybe ICC_CTLR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_CTLR_EL1_Type : ICC_CTLR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_CTLR_EL3_Type_of_regval : register_value -> (maybe ICC_CTLR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_CTLR_EL3_Type : ICC_CTLR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_CTLR_Type_of_regval : register_value -> (maybe ICC_CTLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_CTLR_Type : ICC_CTLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_DIR_EL1_Type_of_regval : register_value -> (maybe ICC_DIR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_DIR_EL1_Type : ICC_DIR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_DIR_Type_of_regval : register_value -> (maybe ICC_DIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_DIR_Type : ICC_DIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_EOIR0_EL1_Type_of_regval : register_value -> (maybe ICC_EOIR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_EOIR0_EL1_Type : ICC_EOIR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_EOIR0_Type_of_regval : register_value -> (maybe ICC_EOIR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_EOIR0_Type : ICC_EOIR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_EOIR1_EL1_Type_of_regval : register_value -> (maybe ICC_EOIR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_EOIR1_EL1_Type : ICC_EOIR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_EOIR1_Type_of_regval : register_value -> (maybe ICC_EOIR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_EOIR1_Type : ICC_EOIR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_HPPIR0_EL1_Type_of_regval : register_value -> (maybe ICC_HPPIR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_HPPIR0_EL1_Type : ICC_HPPIR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_HPPIR0_Type_of_regval : register_value -> (maybe ICC_HPPIR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_HPPIR0_Type : ICC_HPPIR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_HPPIR1_EL1_Type_of_regval : register_value -> (maybe ICC_HPPIR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_HPPIR1_EL1_Type : ICC_HPPIR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_HPPIR1_Type_of_regval : register_value -> (maybe ICC_HPPIR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_HPPIR1_Type : ICC_HPPIR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_HSRE_Type_of_regval : register_value -> (maybe ICC_HSRE_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_HSRE_Type : ICC_HSRE_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_IAR0_EL1_Type_of_regval : register_value -> (maybe ICC_IAR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_IAR0_EL1_Type : ICC_IAR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_IAR0_Type_of_regval : register_value -> (maybe ICC_IAR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_IAR0_Type : ICC_IAR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_IAR1_EL1_Type_of_regval : register_value -> (maybe ICC_IAR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_IAR1_EL1_Type : ICC_IAR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_IAR1_Type_of_regval : register_value -> (maybe ICC_IAR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_IAR1_Type : ICC_IAR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_IGRPEN0_EL1_Type_of_regval : register_value -> (maybe ICC_IGRPEN0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_IGRPEN0_EL1_Type : ICC_IGRPEN0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_IGRPEN0_Type_of_regval : register_value -> (maybe ICC_IGRPEN0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_IGRPEN0_Type : ICC_IGRPEN0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_IGRPEN1_EL1_Type_of_regval : register_value -> (maybe ICC_IGRPEN1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_IGRPEN1_EL1_Type : ICC_IGRPEN1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_IGRPEN1_EL3_Type_of_regval : register_value -> (maybe ICC_IGRPEN1_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_IGRPEN1_EL3_Type : ICC_IGRPEN1_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_IGRPEN1_Type_of_regval : register_value -> (maybe ICC_IGRPEN1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_IGRPEN1_Type : ICC_IGRPEN1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_MCTLR_Type_of_regval : register_value -> (maybe ICC_MCTLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_MCTLR_Type : ICC_MCTLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_MGRPEN1_Type_of_regval : register_value -> (maybe ICC_MGRPEN1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_MGRPEN1_Type : ICC_MGRPEN1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_MSRE_Type_of_regval : register_value -> (maybe ICC_MSRE_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_MSRE_Type : ICC_MSRE_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_NMIAR1_EL1_Type_of_regval : register_value -> (maybe ICC_NMIAR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_NMIAR1_EL1_Type : ICC_NMIAR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_PMR_EL1_Type_of_regval : register_value -> (maybe ICC_PMR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_PMR_EL1_Type : ICC_PMR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_PMR_Type_of_regval : register_value -> (maybe ICC_PMR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_PMR_Type : ICC_PMR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_RPR_EL1_Type_of_regval : register_value -> (maybe ICC_RPR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_RPR_EL1_Type : ICC_RPR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_RPR_Type_of_regval : register_value -> (maybe ICC_RPR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_RPR_Type : ICC_RPR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_SGI0R_EL1_Type_of_regval : register_value -> (maybe ICC_SGI0R_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_SGI0R_EL1_Type : ICC_SGI0R_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_SGI0R_Type_of_regval : register_value -> (maybe ICC_SGI0R_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_SGI0R_Type : ICC_SGI0R_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_SGI1R_EL1_Type_of_regval : register_value -> (maybe ICC_SGI1R_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_SGI1R_EL1_Type : ICC_SGI1R_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_SGI1R_Type_of_regval : register_value -> (maybe ICC_SGI1R_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_SGI1R_Type : ICC_SGI1R_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_SRE_EL1_Type_of_regval : register_value -> (maybe ICC_SRE_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_SRE_EL1_Type : ICC_SRE_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_SRE_EL2_Type_of_regval : register_value -> (maybe ICC_SRE_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_SRE_EL2_Type : ICC_SRE_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_SRE_EL3_Type_of_regval : register_value -> (maybe ICC_SRE_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_SRE_EL3_Type : ICC_SRE_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICC_SRE_Type_of_regval : register_value -> (maybe ICC_SRE_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICC_SRE_Type : ICC_SRE_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_AP0R_EL2_Type_of_regval : register_value -> (maybe ICH_AP0R_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_AP0R_EL2_Type : ICH_AP0R_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_AP0R_Type_of_regval : register_value -> (maybe ICH_AP0R_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_AP0R_Type : ICH_AP0R_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_AP1R_EL2_Type_of_regval : register_value -> (maybe ICH_AP1R_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_AP1R_EL2_Type : ICH_AP1R_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_AP1R_Type_of_regval : register_value -> (maybe ICH_AP1R_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_AP1R_Type : ICH_AP1R_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_EISR_EL2_Type_of_regval : register_value -> (maybe ICH_EISR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_EISR_EL2_Type : ICH_EISR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_EISR_Type_of_regval : register_value -> (maybe ICH_EISR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_EISR_Type : ICH_EISR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_ELRSR_EL2_Type_of_regval : register_value -> (maybe ICH_ELRSR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_ELRSR_EL2_Type : ICH_ELRSR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_ELRSR_Type_of_regval : register_value -> (maybe ICH_ELRSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_ELRSR_Type : ICH_ELRSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_HCR_EL2_Type_of_regval : register_value -> (maybe ICH_HCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_HCR_EL2_Type : ICH_HCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_HCR_Type_of_regval : register_value -> (maybe ICH_HCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_HCR_Type : ICH_HCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_LRC_Type_of_regval : register_value -> (maybe ICH_LRC_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_LRC_Type : ICH_LRC_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_LR_EL2_Type_of_regval : register_value -> (maybe ICH_LR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_LR_EL2_Type : ICH_LR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_LR_Type_of_regval : register_value -> (maybe ICH_LR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_LR_Type : ICH_LR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_MISR_EL2_Type_of_regval : register_value -> (maybe ICH_MISR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_MISR_EL2_Type : ICH_MISR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_MISR_Type_of_regval : register_value -> (maybe ICH_MISR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_MISR_Type : ICH_MISR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_VMCR_EL2_Type_of_regval : register_value -> (maybe ICH_VMCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_VMCR_EL2_Type : ICH_VMCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_VMCR_Type_of_regval : register_value -> (maybe ICH_VMCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_VMCR_Type : ICH_VMCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_VTR_EL2_Type_of_regval : register_value -> (maybe ICH_VTR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_VTR_EL2_Type : ICH_VTR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICH_VTR_Type_of_regval : register_value -> (maybe ICH_VTR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICH_VTR_Type : ICH_VTR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_AP1R_EL1_Type_of_regval : register_value -> (maybe ICV_AP1R_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_AP1R_EL1_Type : ICV_AP1R_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_BPR0_EL1_Type_of_regval : register_value -> (maybe ICV_BPR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_BPR0_EL1_Type : ICV_BPR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_BPR0_Type_of_regval : register_value -> (maybe ICV_BPR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_BPR0_Type : ICV_BPR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_BPR1_EL1_Type_of_regval : register_value -> (maybe ICV_BPR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_BPR1_EL1_Type : ICV_BPR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_BPR1_Type_of_regval : register_value -> (maybe ICV_BPR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_BPR1_Type : ICV_BPR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_CTLR_EL1_Type_of_regval : register_value -> (maybe ICV_CTLR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_CTLR_EL1_Type : ICV_CTLR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_CTLR_Type_of_regval : register_value -> (maybe ICV_CTLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_CTLR_Type : ICV_CTLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_DIR_EL1_Type_of_regval : register_value -> (maybe ICV_DIR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_DIR_EL1_Type : ICV_DIR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_DIR_Type_of_regval : register_value -> (maybe ICV_DIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_DIR_Type : ICV_DIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_EOIR0_EL1_Type_of_regval : register_value -> (maybe ICV_EOIR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_EOIR0_EL1_Type : ICV_EOIR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_EOIR0_Type_of_regval : register_value -> (maybe ICV_EOIR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_EOIR0_Type : ICV_EOIR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_EOIR1_EL1_Type_of_regval : register_value -> (maybe ICV_EOIR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_EOIR1_EL1_Type : ICV_EOIR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_EOIR1_Type_of_regval : register_value -> (maybe ICV_EOIR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_EOIR1_Type : ICV_EOIR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_HPPIR0_EL1_Type_of_regval : register_value -> (maybe ICV_HPPIR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_HPPIR0_EL1_Type : ICV_HPPIR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_HPPIR0_Type_of_regval : register_value -> (maybe ICV_HPPIR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_HPPIR0_Type : ICV_HPPIR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_HPPIR1_EL1_Type_of_regval : register_value -> (maybe ICV_HPPIR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_HPPIR1_EL1_Type : ICV_HPPIR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_HPPIR1_Type_of_regval : register_value -> (maybe ICV_HPPIR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_HPPIR1_Type : ICV_HPPIR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_IAR0_EL1_Type_of_regval : register_value -> (maybe ICV_IAR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_IAR0_EL1_Type : ICV_IAR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_IAR0_Type_of_regval : register_value -> (maybe ICV_IAR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_IAR0_Type : ICV_IAR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_IAR1_EL1_Type_of_regval : register_value -> (maybe ICV_IAR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_IAR1_EL1_Type : ICV_IAR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_IAR1_Type_of_regval : register_value -> (maybe ICV_IAR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_IAR1_Type : ICV_IAR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_IGRPEN0_EL1_Type_of_regval : register_value -> (maybe ICV_IGRPEN0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_IGRPEN0_EL1_Type : ICV_IGRPEN0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_IGRPEN0_Type_of_regval : register_value -> (maybe ICV_IGRPEN0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_IGRPEN0_Type : ICV_IGRPEN0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_IGRPEN1_EL1_Type_of_regval : register_value -> (maybe ICV_IGRPEN1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_IGRPEN1_EL1_Type : ICV_IGRPEN1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_IGRPEN1_Type_of_regval : register_value -> (maybe ICV_IGRPEN1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_IGRPEN1_Type : ICV_IGRPEN1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_NMIAR1_EL1_Type_of_regval : register_value -> (maybe ICV_NMIAR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_NMIAR1_EL1_Type : ICV_NMIAR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_PMR_EL1_Type_of_regval : register_value -> (maybe ICV_PMR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_PMR_EL1_Type : ICV_PMR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_PMR_Type_of_regval : register_value -> (maybe ICV_PMR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_PMR_Type : ICV_PMR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_RPR_EL1_Type_of_regval : register_value -> (maybe ICV_RPR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_RPR_EL1_Type : ICV_RPR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ICV_RPR_Type_of_regval : register_value -> (maybe ICV_RPR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ICV_RPR_Type : ICV_RPR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64DFR0_EL1_Type_of_regval : register_value -> (maybe ID_AA64DFR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64DFR0_EL1_Type : ID_AA64DFR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64DFR1_EL1_Type_of_regval : register_value -> (maybe ID_AA64DFR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64DFR1_EL1_Type : ID_AA64DFR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64ISAR0_EL1_Type_of_regval : register_value -> (maybe ID_AA64ISAR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64ISAR0_EL1_Type : ID_AA64ISAR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64ISAR1_EL1_Type_of_regval : register_value -> (maybe ID_AA64ISAR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64ISAR1_EL1_Type : ID_AA64ISAR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64ISAR2_EL1_Type_of_regval : register_value -> (maybe ID_AA64ISAR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64ISAR2_EL1_Type : ID_AA64ISAR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64MMFR0_EL1_Type_of_regval : register_value -> (maybe ID_AA64MMFR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64MMFR0_EL1_Type : ID_AA64MMFR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64MMFR1_EL1_Type_of_regval : register_value -> (maybe ID_AA64MMFR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64MMFR1_EL1_Type : ID_AA64MMFR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64MMFR2_EL1_Type_of_regval : register_value -> (maybe ID_AA64MMFR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64MMFR2_EL1_Type : ID_AA64MMFR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64MMFR3_EL1_Type_of_regval : register_value -> (maybe ID_AA64MMFR3_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64MMFR3_EL1_Type : ID_AA64MMFR3_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64MMFR4_EL1_Type_of_regval : register_value -> (maybe ID_AA64MMFR4_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64MMFR4_EL1_Type : ID_AA64MMFR4_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64PFR0_EL1_Type_of_regval : register_value -> (maybe ID_AA64PFR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64PFR0_EL1_Type : ID_AA64PFR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64PFR1_EL1_Type_of_regval : register_value -> (maybe ID_AA64PFR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64PFR1_EL1_Type : ID_AA64PFR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64PFR2_EL1_Type_of_regval : register_value -> (maybe ID_AA64PFR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64PFR2_EL1_Type : ID_AA64PFR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64SMFR0_EL1_Type_of_regval : register_value -> (maybe ID_AA64SMFR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64SMFR0_EL1_Type : ID_AA64SMFR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_AA64ZFR0_EL1_Type_of_regval : register_value -> (maybe ID_AA64ZFR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_AA64ZFR0_EL1_Type : ID_AA64ZFR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_DFR0_EL1_Type_of_regval : register_value -> (maybe ID_DFR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_DFR0_EL1_Type : ID_DFR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_DFR0_Type_of_regval : register_value -> (maybe ID_DFR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_DFR0_Type : ID_DFR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_DFR1_EL1_Type_of_regval : register_value -> (maybe ID_DFR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_DFR1_EL1_Type : ID_DFR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_DFR1_Type_of_regval : register_value -> (maybe ID_DFR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_DFR1_Type : ID_DFR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR0_EL1_Type_of_regval : register_value -> (maybe ID_ISAR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR0_EL1_Type : ID_ISAR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR0_Type_of_regval : register_value -> (maybe ID_ISAR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR0_Type : ID_ISAR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR1_EL1_Type_of_regval : register_value -> (maybe ID_ISAR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR1_EL1_Type : ID_ISAR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR1_Type_of_regval : register_value -> (maybe ID_ISAR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR1_Type : ID_ISAR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR2_EL1_Type_of_regval : register_value -> (maybe ID_ISAR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR2_EL1_Type : ID_ISAR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR2_Type_of_regval : register_value -> (maybe ID_ISAR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR2_Type : ID_ISAR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR3_EL1_Type_of_regval : register_value -> (maybe ID_ISAR3_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR3_EL1_Type : ID_ISAR3_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR3_Type_of_regval : register_value -> (maybe ID_ISAR3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR3_Type : ID_ISAR3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR4_EL1_Type_of_regval : register_value -> (maybe ID_ISAR4_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR4_EL1_Type : ID_ISAR4_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR4_Type_of_regval : register_value -> (maybe ID_ISAR4_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR4_Type : ID_ISAR4_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR5_EL1_Type_of_regval : register_value -> (maybe ID_ISAR5_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR5_EL1_Type : ID_ISAR5_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR5_Type_of_regval : register_value -> (maybe ID_ISAR5_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR5_Type : ID_ISAR5_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR6_EL1_Type_of_regval : register_value -> (maybe ID_ISAR6_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR6_EL1_Type : ID_ISAR6_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_ISAR6_Type_of_regval : register_value -> (maybe ID_ISAR6_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_ISAR6_Type : ID_ISAR6_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR0_EL1_Type_of_regval : register_value -> (maybe ID_MMFR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR0_EL1_Type : ID_MMFR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR0_Type_of_regval : register_value -> (maybe ID_MMFR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR0_Type : ID_MMFR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR1_EL1_Type_of_regval : register_value -> (maybe ID_MMFR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR1_EL1_Type : ID_MMFR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR1_Type_of_regval : register_value -> (maybe ID_MMFR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR1_Type : ID_MMFR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR2_EL1_Type_of_regval : register_value -> (maybe ID_MMFR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR2_EL1_Type : ID_MMFR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR2_Type_of_regval : register_value -> (maybe ID_MMFR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR2_Type : ID_MMFR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR3_EL1_Type_of_regval : register_value -> (maybe ID_MMFR3_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR3_EL1_Type : ID_MMFR3_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR3_Type_of_regval : register_value -> (maybe ID_MMFR3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR3_Type : ID_MMFR3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR4_EL1_Type_of_regval : register_value -> (maybe ID_MMFR4_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR4_EL1_Type : ID_MMFR4_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR4_Type_of_regval : register_value -> (maybe ID_MMFR4_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR4_Type : ID_MMFR4_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR5_EL1_Type_of_regval : register_value -> (maybe ID_MMFR5_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR5_EL1_Type : ID_MMFR5_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_MMFR5_Type_of_regval : register_value -> (maybe ID_MMFR5_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_MMFR5_Type : ID_MMFR5_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_PFR0_EL1_Type_of_regval : register_value -> (maybe ID_PFR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_PFR0_EL1_Type : ID_PFR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_PFR0_Type_of_regval : register_value -> (maybe ID_PFR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_PFR0_Type : ID_PFR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_PFR1_EL1_Type_of_regval : register_value -> (maybe ID_PFR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_PFR1_EL1_Type : ID_PFR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_PFR1_Type_of_regval : register_value -> (maybe ID_PFR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_PFR1_Type : ID_PFR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_PFR2_EL1_Type_of_regval : register_value -> (maybe ID_PFR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_PFR2_EL1_Type : ID_PFR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ID_PFR2_Type_of_regval : register_value -> (maybe ID_PFR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ID_PFR2_Type : ID_PFR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val IFSR32_EL2_Type_of_regval : register_value -> (maybe IFSR32_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_IFSR32_EL2_Type : IFSR32_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val IFSR_Type_of_regval : register_value -> (maybe IFSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_IFSR_Type : IFSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ISR_EL1_Type_of_regval : register_value -> (maybe ISR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ISR_EL1_Type : ISR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ISR_Type_of_regval : register_value -> (maybe ISR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ISR_Type : ISR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val InterruptID_of_regval : register_value -> (maybe InterruptID)\<close>\<close>

\<comment> \<open>\<open>val regval_of_InterruptID : InterruptID -> register_value\<close>\<close>

\<comment> \<open>\<open>val LORC_EL1_Type_of_regval : register_value -> (maybe LORC_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_LORC_EL1_Type : LORC_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val LOREA_EL1_Type_of_regval : register_value -> (maybe LOREA_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_LOREA_EL1_Type : LOREA_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val LORID_EL1_Type_of_regval : register_value -> (maybe LORID_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_LORID_EL1_Type : LORID_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val LORN_EL1_Type_of_regval : register_value -> (maybe LORN_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_LORN_EL1_Type : LORN_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val LORSA_EL1_Type_of_regval : register_value -> (maybe LORSA_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_LORSA_EL1_Type : LORSA_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MAIR0_Type_of_regval : register_value -> (maybe MAIR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MAIR0_Type : MAIR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MAIR1_Type_of_regval : register_value -> (maybe MAIR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MAIR1_Type : MAIR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MAIR2_EL1_Type_of_regval : register_value -> (maybe MAIR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MAIR2_EL1_Type : MAIR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MAIR2_EL2_Type_of_regval : register_value -> (maybe MAIR2_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MAIR2_EL2_Type : MAIR2_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MAIR2_EL3_Type_of_regval : register_value -> (maybe MAIR2_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MAIR2_EL3_Type : MAIR2_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MAIR_EL1_Type_of_regval : register_value -> (maybe MAIR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MAIR_EL1_Type : MAIR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MAIR_EL2_Type_of_regval : register_value -> (maybe MAIR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MAIR_EL2_Type : MAIR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MAIR_EL3_Type_of_regval : register_value -> (maybe MAIR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MAIR_EL3_Type : MAIR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MDCCINT_EL1_Type_of_regval : register_value -> (maybe MDCCINT_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MDCCINT_EL1_Type : MDCCINT_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MDCCSR_EL0_Type_of_regval : register_value -> (maybe MDCCSR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MDCCSR_EL0_Type : MDCCSR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MDCR_EL2_Type_of_regval : register_value -> (maybe MDCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MDCR_EL2_Type : MDCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MDCR_EL3_Type_of_regval : register_value -> (maybe MDCR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MDCR_EL3_Type : MDCR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MDRAR_EL1_Type_of_regval : register_value -> (maybe MDRAR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MDRAR_EL1_Type : MDRAR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MDSCR_EL1_Type_of_regval : register_value -> (maybe MDSCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MDSCR_EL1_Type : MDSCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MDSELR_EL1_Type_of_regval : register_value -> (maybe MDSELR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MDSELR_EL1_Type : MDSELR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MECIDR_EL2_Type_of_regval : register_value -> (maybe MECIDR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MECIDR_EL2_Type : MECIDR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MECID_A0_EL2_Type_of_regval : register_value -> (maybe MECID_A0_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MECID_A0_EL2_Type : MECID_A0_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MECID_A1_EL2_Type_of_regval : register_value -> (maybe MECID_A1_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MECID_A1_EL2_Type : MECID_A1_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MECID_P0_EL2_Type_of_regval : register_value -> (maybe MECID_P0_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MECID_P0_EL2_Type : MECID_P0_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MECID_P1_EL2_Type_of_regval : register_value -> (maybe MECID_P1_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MECID_P1_EL2_Type : MECID_P1_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MECID_RL_A_EL3_Type_of_regval : register_value -> (maybe MECID_RL_A_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MECID_RL_A_EL3_Type : MECID_RL_A_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MFAR_EL3_Type_of_regval : register_value -> (maybe MFAR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MFAR_EL3_Type : MFAR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MIDR_EL1_Type_of_regval : register_value -> (maybe MIDR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MIDR_EL1_Type : MIDR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MIDR_Type_of_regval : register_value -> (maybe MIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MIDR_Type : MIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAM0_EL1_Type_of_regval : register_value -> (maybe MPAM0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAM0_EL1_Type : MPAM0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAM1_EL1_Type_of_regval : register_value -> (maybe MPAM1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAM1_EL1_Type : MPAM1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAM2_EL2_Type_of_regval : register_value -> (maybe MPAM2_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAM2_EL2_Type : MPAM2_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAM3_EL3_Type_of_regval : register_value -> (maybe MPAM3_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAM3_EL3_Type : MPAM3_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMHCR_EL2_Type_of_regval : register_value -> (maybe MPAMHCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMHCR_EL2_Type : MPAMHCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMIDR_EL1_Type_of_regval : register_value -> (maybe MPAMIDR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMIDR_EL1_Type : MPAMIDR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMSM_EL1_Type_of_regval : register_value -> (maybe MPAMSM_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMSM_EL1_Type : MPAMSM_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMVPM0_EL2_Type_of_regval : register_value -> (maybe MPAMVPM0_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMVPM0_EL2_Type : MPAMVPM0_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMVPM1_EL2_Type_of_regval : register_value -> (maybe MPAMVPM1_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMVPM1_EL2_Type : MPAMVPM1_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMVPM2_EL2_Type_of_regval : register_value -> (maybe MPAMVPM2_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMVPM2_EL2_Type : MPAMVPM2_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMVPM3_EL2_Type_of_regval : register_value -> (maybe MPAMVPM3_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMVPM3_EL2_Type : MPAMVPM3_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMVPM4_EL2_Type_of_regval : register_value -> (maybe MPAMVPM4_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMVPM4_EL2_Type : MPAMVPM4_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMVPM5_EL2_Type_of_regval : register_value -> (maybe MPAMVPM5_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMVPM5_EL2_Type : MPAMVPM5_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMVPM6_EL2_Type_of_regval : register_value -> (maybe MPAMVPM6_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMVPM6_EL2_Type : MPAMVPM6_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMVPM7_EL2_Type_of_regval : register_value -> (maybe MPAMVPM7_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMVPM7_EL2_Type : MPAMVPM7_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPAMVPMV_EL2_Type_of_regval : register_value -> (maybe MPAMVPMV_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPAMVPMV_EL2_Type : MPAMVPMV_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPIDR_EL1_Type_of_regval : register_value -> (maybe MPIDR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPIDR_EL1_Type : MPIDR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MPIDR_Type_of_regval : register_value -> (maybe MPIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MPIDR_Type : MPIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MVBAR_Type_of_regval : register_value -> (maybe MVBAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MVBAR_Type : MVBAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MVFR0_EL1_Type_of_regval : register_value -> (maybe MVFR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MVFR0_EL1_Type : MVFR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MVFR0_Type_of_regval : register_value -> (maybe MVFR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MVFR0_Type : MVFR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MVFR1_EL1_Type_of_regval : register_value -> (maybe MVFR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MVFR1_EL1_Type : MVFR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MVFR1_Type_of_regval : register_value -> (maybe MVFR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MVFR1_Type : MVFR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MVFR2_EL1_Type_of_regval : register_value -> (maybe MVFR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MVFR2_EL1_Type : MVFR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val MVFR2_Type_of_regval : register_value -> (maybe MVFR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_MVFR2_Type : MVFR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val NMRR_Type_of_regval : register_value -> (maybe NMRR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_NMRR_Type : NMRR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val NSACR_Type_of_regval : register_value -> (maybe NSACR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_NSACR_Type : NSACR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val OSDLR_EL1_Type_of_regval : register_value -> (maybe OSDLR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_OSDLR_EL1_Type : OSDLR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val OSECCR_EL1_Type_of_regval : register_value -> (maybe OSECCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_OSECCR_EL1_Type : OSECCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val OSLAR_EL1_Type_of_regval : register_value -> (maybe OSLAR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_OSLAR_EL1_Type : OSLAR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val OSLSR_EL1_Type_of_regval : register_value -> (maybe OSLSR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_OSLSR_EL1_Type : OSLSR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val OpType_of_regval : register_value -> (maybe OpType)\<close>\<close>

\<comment> \<open>\<open>val regval_of_OpType : OpType -> register_value\<close>\<close>

\<comment> \<open>\<open>val PAR_EL1_Type_of_regval : register_value -> (maybe PAR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PAR_EL1_Type : PAR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PAR_Type_of_regval : register_value -> (maybe PAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PAR_Type : PAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PFAR_EL1_Type_of_regval : register_value -> (maybe PFAR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PFAR_EL1_Type : PFAR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PFAR_EL2_Type_of_regval : register_value -> (maybe PFAR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PFAR_EL2_Type : PFAR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PIRE0_EL1_Type_of_regval : register_value -> (maybe PIRE0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PIRE0_EL1_Type : PIRE0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PIRE0_EL2_Type_of_regval : register_value -> (maybe PIRE0_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PIRE0_EL2_Type : PIRE0_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PIR_EL1_Type_of_regval : register_value -> (maybe PIR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PIR_EL1_Type : PIR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PIR_EL2_Type_of_regval : register_value -> (maybe PIR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PIR_EL2_Type : PIR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PIR_EL3_Type_of_regval : register_value -> (maybe PIR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PIR_EL3_Type : PIR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMAUTHSTATUS_Type_of_regval : register_value -> (maybe PMAUTHSTATUS_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMAUTHSTATUS_Type : PMAUTHSTATUS_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMBIDR_EL1_Type_of_regval : register_value -> (maybe PMBIDR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMBIDR_EL1_Type : PMBIDR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMBLIMITR_EL1_Type_of_regval : register_value -> (maybe PMBLIMITR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMBLIMITR_EL1_Type : PMBLIMITR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMBPTR_EL1_Type_of_regval : register_value -> (maybe PMBPTR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMBPTR_EL1_Type : PMBPTR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMBSR_EL1_Type_of_regval : register_value -> (maybe PMBSR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMBSR_EL1_Type : PMBSR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCCFILTR_EL0_Type_of_regval : register_value -> (maybe PMCCFILTR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCCFILTR_EL0_Type : PMCCFILTR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCCFILTR_Type_of_regval : register_value -> (maybe PMCCFILTR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCCFILTR_Type : PMCCFILTR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCCNTR_EL0_Type_of_regval : register_value -> (maybe PMCCNTR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCCNTR_EL0_Type : PMCCNTR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCCNTR_Type_of_regval : register_value -> (maybe PMCCNTR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCCNTR_Type : PMCCNTR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCCNTSVR_EL1_Type_of_regval : register_value -> (maybe PMCCNTSVR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCCNTSVR_EL1_Type : PMCCNTSVR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCEID0_EL0_Type_of_regval : register_value -> (maybe PMCEID0_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCEID0_EL0_Type : PMCEID0_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCEID0_Type_of_regval : register_value -> (maybe PMCEID0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCEID0_Type : PMCEID0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCEID1_EL0_Type_of_regval : register_value -> (maybe PMCEID1_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCEID1_EL0_Type : PMCEID1_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCEID1_Type_of_regval : register_value -> (maybe PMCEID1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCEID1_Type : PMCEID1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCEID2_Type_of_regval : register_value -> (maybe PMCEID2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCEID2_Type : PMCEID2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCEID3_Type_of_regval : register_value -> (maybe PMCEID3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCEID3_Type : PMCEID3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCFGR_Type_of_regval : register_value -> (maybe PMCFGR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCFGR_Type : PMCFGR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCGCR0_Type_of_regval : register_value -> (maybe PMCGCR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCGCR0_Type : PMCGCR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCIDR0_Type_of_regval : register_value -> (maybe PMCIDR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCIDR0_Type : PMCIDR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCIDR1_Type_of_regval : register_value -> (maybe PMCIDR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCIDR1_Type : PMCIDR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCIDR2_Type_of_regval : register_value -> (maybe PMCIDR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCIDR2_Type : PMCIDR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCIDR3_Type_of_regval : register_value -> (maybe PMCIDR3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCIDR3_Type : PMCIDR3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCNTENCLR_EL0_Type_of_regval : register_value -> (maybe PMCNTENCLR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCNTENCLR_EL0_Type : PMCNTENCLR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCNTENCLR_Type_of_regval : register_value -> (maybe PMCNTENCLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCNTENCLR_Type : PMCNTENCLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCNTENSET_EL0_Type_of_regval : register_value -> (maybe PMCNTENSET_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCNTENSET_EL0_Type : PMCNTENSET_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCNTENSET_Type_of_regval : register_value -> (maybe PMCNTENSET_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCNTENSET_Type : PMCNTENSET_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCNTEN_Type_of_regval : register_value -> (maybe PMCNTEN_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCNTEN_Type : PMCNTEN_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCR_EL0_Type_of_regval : register_value -> (maybe PMCR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCR_EL0_Type : PMCR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMCR_Type_of_regval : register_value -> (maybe PMCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMCR_Type : PMCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMDEVID_Type_of_regval : register_value -> (maybe PMDEVID_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMDEVID_Type : PMDEVID_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMDEVTYPE_Type_of_regval : register_value -> (maybe PMDEVTYPE_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMDEVTYPE_Type : PMDEVTYPE_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMECR_EL1_Type_of_regval : register_value -> (maybe PMECR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMECR_EL1_Type : PMECR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMEVCNTSVR_EL1_Type_of_regval : register_value -> (maybe PMEVCNTSVR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMEVCNTSVR_EL1_Type : PMEVCNTSVR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMEVTYPER_EL0_Type_of_regval : register_value -> (maybe PMEVTYPER_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMEVTYPER_EL0_Type : PMEVTYPER_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMEVTYPER_Type_of_regval : register_value -> (maybe PMEVTYPER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMEVTYPER_Type : PMEVTYPER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMIAR_EL1_Type_of_regval : register_value -> (maybe PMIAR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMIAR_EL1_Type : PMIAR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMICFILTR_EL0_Type_of_regval : register_value -> (maybe PMICFILTR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMICFILTR_EL0_Type : PMICFILTR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMICNTR_EL0_Type_of_regval : register_value -> (maybe PMICNTR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMICNTR_EL0_Type : PMICNTR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMICNTSVR_EL1_Type_of_regval : register_value -> (maybe PMICNTSVR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMICNTSVR_EL1_Type : PMICNTSVR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMIIDR_Type_of_regval : register_value -> (maybe PMIIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMIIDR_Type : PMIIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMINTENCLR_EL1_Type_of_regval : register_value -> (maybe PMINTENCLR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMINTENCLR_EL1_Type : PMINTENCLR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMINTENCLR_Type_of_regval : register_value -> (maybe PMINTENCLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMINTENCLR_Type : PMINTENCLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMINTENSET_EL1_Type_of_regval : register_value -> (maybe PMINTENSET_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMINTENSET_EL1_Type : PMINTENSET_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMINTENSET_Type_of_regval : register_value -> (maybe PMINTENSET_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMINTENSET_Type : PMINTENSET_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMINTEN_Type_of_regval : register_value -> (maybe PMINTEN_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMINTEN_Type : PMINTEN_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMITCTRL_Type_of_regval : register_value -> (maybe PMITCTRL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMITCTRL_Type : PMITCTRL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMLAR_Type_of_regval : register_value -> (maybe PMLAR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMLAR_Type : PMLAR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMLSR_Type_of_regval : register_value -> (maybe PMLSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMLSR_Type : PMLSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMMIR_EL1_Type_of_regval : register_value -> (maybe PMMIR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMMIR_EL1_Type : PMMIR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMMIR_Type_of_regval : register_value -> (maybe PMMIR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMMIR_Type : PMMIR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMOVSCLR_EL0_Type_of_regval : register_value -> (maybe PMOVSCLR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMOVSCLR_EL0_Type : PMOVSCLR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMOVSR_Type_of_regval : register_value -> (maybe PMOVSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMOVSR_Type : PMOVSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMOVSSET_EL0_Type_of_regval : register_value -> (maybe PMOVSSET_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMOVSSET_EL0_Type : PMOVSSET_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMOVSSET_Type_of_regval : register_value -> (maybe PMOVSSET_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMOVSSET_Type : PMOVSSET_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMOVS_Type_of_regval : register_value -> (maybe PMOVS_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMOVS_Type : PMOVS_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMPCSCTL_Type_of_regval : register_value -> (maybe PMPCSCTL_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMPCSCTL_Type : PMPCSCTL_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMPCSR_Type_of_regval : register_value -> (maybe PMPCSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMPCSR_Type : PMPCSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMPIDR0_Type_of_regval : register_value -> (maybe PMPIDR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMPIDR0_Type : PMPIDR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMPIDR1_Type_of_regval : register_value -> (maybe PMPIDR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMPIDR1_Type : PMPIDR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMPIDR2_Type_of_regval : register_value -> (maybe PMPIDR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMPIDR2_Type : PMPIDR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMPIDR3_Type_of_regval : register_value -> (maybe PMPIDR3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMPIDR3_Type : PMPIDR3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMPIDR4_Type_of_regval : register_value -> (maybe PMPIDR4_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMPIDR4_Type : PMPIDR4_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSCR_EL1_Type_of_regval : register_value -> (maybe PMSCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSCR_EL1_Type : PMSCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSCR_EL2_Type_of_regval : register_value -> (maybe PMSCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSCR_EL2_Type : PMSCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSDSFR_EL1_Type_of_regval : register_value -> (maybe PMSDSFR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSDSFR_EL1_Type : PMSDSFR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSELR_EL0_Type_of_regval : register_value -> (maybe PMSELR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSELR_EL0_Type : PMSELR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSELR_Type_of_regval : register_value -> (maybe PMSELR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSELR_Type : PMSELR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSEVFR_EL1_Type_of_regval : register_value -> (maybe PMSEVFR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSEVFR_EL1_Type : PMSEVFR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSFCR_EL1_Type_of_regval : register_value -> (maybe PMSFCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSFCR_EL1_Type : PMSFCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSICR_EL1_Type_of_regval : register_value -> (maybe PMSICR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSICR_EL1_Type : PMSICR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSIDR_EL1_Type_of_regval : register_value -> (maybe PMSIDR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSIDR_EL1_Type : PMSIDR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSIRR_EL1_Type_of_regval : register_value -> (maybe PMSIRR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSIRR_EL1_Type : PMSIRR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSLATFR_EL1_Type_of_regval : register_value -> (maybe PMSLATFR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSLATFR_EL1_Type : PMSLATFR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSNEVFR_EL1_Type_of_regval : register_value -> (maybe PMSNEVFR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSNEVFR_EL1_Type : PMSNEVFR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSSCR_EL1_Type_of_regval : register_value -> (maybe PMSSCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSSCR_EL1_Type : PMSSCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSWINC_EL0_Type_of_regval : register_value -> (maybe PMSWINC_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSWINC_EL0_Type : PMSWINC_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMSWINC_Type_of_regval : register_value -> (maybe PMSWINC_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMSWINC_Type : PMSWINC_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMUACR_EL1_Type_of_regval : register_value -> (maybe PMUACR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMUACR_EL1_Type : PMUACR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMUSERENR_EL0_Type_of_regval : register_value -> (maybe PMUSERENR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMUSERENR_EL0_Type : PMUSERENR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMUSERENR_Type_of_regval : register_value -> (maybe PMUSERENR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMUSERENR_Type : PMUSERENR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMVCIDSR_Type_of_regval : register_value -> (maybe PMVCIDSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMVCIDSR_Type : PMVCIDSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMVIDSR_Type_of_regval : register_value -> (maybe PMVIDSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMVIDSR_Type : PMVIDSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMXEVCNTR_EL0_Type_of_regval : register_value -> (maybe PMXEVCNTR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMXEVCNTR_EL0_Type : PMXEVCNTR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PMZR_EL0_Type_of_regval : register_value -> (maybe PMZR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PMZR_EL0_Type : PMZR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val POR_EL0_Type_of_regval : register_value -> (maybe POR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_POR_EL0_Type : POR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val POR_EL1_Type_of_regval : register_value -> (maybe POR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_POR_EL1_Type : POR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val POR_EL2_Type_of_regval : register_value -> (maybe POR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_POR_EL2_Type : POR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val POR_EL3_Type_of_regval : register_value -> (maybe POR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_POR_EL3_Type : POR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val PRRR_Type_of_regval : register_value -> (maybe PRRR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_PRRR_Type : PRRR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ProcState_of_regval : register_value -> (maybe ProcState)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ProcState : ProcState -> register_value\<close>\<close>

\<comment> \<open>\<open>val RCWMASK_EL1_Type_of_regval : register_value -> (maybe RCWMASK_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RCWMASK_EL1_Type : RCWMASK_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RCWSMASK_EL1_Type_of_regval : register_value -> (maybe RCWSMASK_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RCWSMASK_EL1_Type : RCWSMASK_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RGSR_EL1_Type_of_regval : register_value -> (maybe RGSR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RGSR_EL1_Type : RGSR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RMR_EL1_Type_of_regval : register_value -> (maybe RMR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RMR_EL1_Type : RMR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RMR_EL2_Type_of_regval : register_value -> (maybe RMR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RMR_EL2_Type : RMR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RMR_EL3_Type_of_regval : register_value -> (maybe RMR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RMR_EL3_Type : RMR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RMR_Type_of_regval : register_value -> (maybe RMR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RMR_Type : RMR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RNDRRS_Type_of_regval : register_value -> (maybe RNDRRS_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RNDRRS_Type : RNDRRS_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RNDR_Type_of_regval : register_value -> (maybe RNDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RNDR_Type : RNDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RVBAR_EL1_Type_of_regval : register_value -> (maybe RVBAR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RVBAR_EL1_Type : RVBAR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RVBAR_EL2_Type_of_regval : register_value -> (maybe RVBAR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RVBAR_EL2_Type : RVBAR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val RVBAR_EL3_Type_of_regval : register_value -> (maybe RVBAR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_RVBAR_EL3_Type : RVBAR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val S2PIR_EL2_Type_of_regval : register_value -> (maybe S2PIR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_S2PIR_EL2_Type : S2PIR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val S2POR_EL1_Type_of_regval : register_value -> (maybe S2POR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_S2POR_EL1_Type : S2POR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SCR_EL3_Type_of_regval : register_value -> (maybe SCR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SCR_EL3_Type : SCR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SCR_Type_of_regval : register_value -> (maybe SCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SCR_Type : SCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SCTLR2_EL1_Type_of_regval : register_value -> (maybe SCTLR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SCTLR2_EL1_Type : SCTLR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SCTLR2_EL2_Type_of_regval : register_value -> (maybe SCTLR2_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SCTLR2_EL2_Type : SCTLR2_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SCTLR2_EL3_Type_of_regval : register_value -> (maybe SCTLR2_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SCTLR2_EL3_Type : SCTLR2_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SCTLR_EL1_Type_of_regval : register_value -> (maybe SCTLR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SCTLR_EL1_Type : SCTLR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SCTLR_EL2_Type_of_regval : register_value -> (maybe SCTLR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SCTLR_EL2_Type : SCTLR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SCTLR_EL3_Type_of_regval : register_value -> (maybe SCTLR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SCTLR_EL3_Type : SCTLR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SCTLR_Type_of_regval : register_value -> (maybe SCTLR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SCTLR_Type : SCTLR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SDCR_Type_of_regval : register_value -> (maybe SDCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SDCR_Type : SDCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SDER32_EL2_Type_of_regval : register_value -> (maybe SDER32_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SDER32_EL2_Type : SDER32_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SDER32_EL3_Type_of_regval : register_value -> (maybe SDER32_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SDER32_EL3_Type : SDER32_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SDER_Type_of_regval : register_value -> (maybe SDER_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SDER_Type : SDER_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SMCR_EL1_Type_of_regval : register_value -> (maybe SMCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SMCR_EL1_Type : SMCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SMCR_EL2_Type_of_regval : register_value -> (maybe SMCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SMCR_EL2_Type : SMCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SMCR_EL3_Type_of_regval : register_value -> (maybe SMCR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SMCR_EL3_Type : SMCR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SMIDR_EL1_Type_of_regval : register_value -> (maybe SMIDR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SMIDR_EL1_Type : SMIDR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SMPRIMAP_EL2_Type_of_regval : register_value -> (maybe SMPRIMAP_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SMPRIMAP_EL2_Type : SMPRIMAP_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SMPRI_EL1_Type_of_regval : register_value -> (maybe SMPRI_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SMPRI_EL1_Type : SMPRI_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPMACCESSR_EL1_Type_of_regval : register_value -> (maybe SPMACCESSR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPMACCESSR_EL1_Type : SPMACCESSR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPMACCESSR_EL2_Type_of_regval : register_value -> (maybe SPMACCESSR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPMACCESSR_EL2_Type : SPMACCESSR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPMACCESSR_EL3_Type_of_regval : register_value -> (maybe SPMACCESSR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPMACCESSR_EL3_Type : SPMACCESSR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPMSELR_EL0_Type_of_regval : register_value -> (maybe SPMSELR_EL0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPMSELR_EL0_Type : SPMSELR_EL0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPSR_EL1_Type_of_regval : register_value -> (maybe SPSR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPSR_EL1_Type : SPSR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPSR_EL2_Type_of_regval : register_value -> (maybe SPSR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPSR_EL2_Type : SPSR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPSR_EL3_Type_of_regval : register_value -> (maybe SPSR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPSR_EL3_Type : SPSR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPSR_abt_Type_of_regval : register_value -> (maybe SPSR_abt_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPSR_abt_Type : SPSR_abt_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPSR_fiq_Type_of_regval : register_value -> (maybe SPSR_fiq_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPSR_fiq_Type : SPSR_fiq_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPSR_hyp_Type_of_regval : register_value -> (maybe SPSR_hyp_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPSR_hyp_Type : SPSR_hyp_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPSR_irq_Type_of_regval : register_value -> (maybe SPSR_irq_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPSR_irq_Type : SPSR_irq_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPSR_mon_Type_of_regval : register_value -> (maybe SPSR_mon_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPSR_mon_Type : SPSR_mon_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPSR_svc_Type_of_regval : register_value -> (maybe SPSR_svc_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPSR_svc_Type : SPSR_svc_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val SPSR_und_Type_of_regval : register_value -> (maybe SPSR_und_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_SPSR_und_Type : SPSR_und_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val Signal_of_regval : register_value -> (maybe Signal)\<close>\<close>

\<comment> \<open>\<open>val regval_of_Signal : Signal -> register_value\<close>\<close>

\<comment> \<open>\<open>val TCR2_EL1_Type_of_regval : register_value -> (maybe TCR2_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TCR2_EL1_Type : TCR2_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TCR2_EL2_Type_of_regval : register_value -> (maybe TCR2_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TCR2_EL2_Type : TCR2_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TCR_EL1_Type_of_regval : register_value -> (maybe TCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TCR_EL1_Type : TCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TCR_EL2_Type_of_regval : register_value -> (maybe TCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TCR_EL2_Type : TCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TCR_EL3_Type_of_regval : register_value -> (maybe TCR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TCR_EL3_Type : TCR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TFSRE0_EL1_Type_of_regval : register_value -> (maybe TFSRE0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TFSRE0_EL1_Type : TFSRE0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TFSR_EL1_Type_of_regval : register_value -> (maybe TFSR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TFSR_EL1_Type : TFSR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TFSR_EL2_Type_of_regval : register_value -> (maybe TFSR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TFSR_EL2_Type : TFSR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TFSR_EL3_Type_of_regval : register_value -> (maybe TFSR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TFSR_EL3_Type : TFSR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TLBTR_Type_of_regval : register_value -> (maybe TLBTR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TLBTR_Type : TLBTR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TMState_of_regval : register_value -> (maybe TMState)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TMState : TMState -> register_value\<close>\<close>

\<comment> \<open>\<open>val TRFCR_EL1_Type_of_regval : register_value -> (maybe TRFCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TRFCR_EL1_Type : TRFCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TRFCR_EL2_Type_of_regval : register_value -> (maybe TRFCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TRFCR_EL2_Type : TRFCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TRFCR_Type_of_regval : register_value -> (maybe TRFCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TRFCR_Type : TRFCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TTBCR2_Type_of_regval : register_value -> (maybe TTBCR2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TTBCR2_Type : TTBCR2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TTBCR_Type_of_regval : register_value -> (maybe TTBCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TTBCR_Type : TTBCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TTBR0_EL1_Type_of_regval : register_value -> (maybe TTBR0_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TTBR0_EL1_Type : TTBR0_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TTBR0_EL2_Type_of_regval : register_value -> (maybe TTBR0_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TTBR0_EL2_Type : TTBR0_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TTBR0_EL3_Type_of_regval : register_value -> (maybe TTBR0_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TTBR0_EL3_Type : TTBR0_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TTBR0_Type_of_regval : register_value -> (maybe TTBR0_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TTBR0_Type : TTBR0_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TTBR1_EL1_Type_of_regval : register_value -> (maybe TTBR1_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TTBR1_EL1_Type : TTBR1_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TTBR1_EL2_Type_of_regval : register_value -> (maybe TTBR1_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TTBR1_EL2_Type : TTBR1_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val TTBR1_Type_of_regval : register_value -> (maybe TTBR1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_TTBR1_Type : TTBR1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VDFSR_Type_of_regval : register_value -> (maybe VDFSR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VDFSR_Type : VDFSR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VDISR_EL2_Type_of_regval : register_value -> (maybe VDISR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VDISR_EL2_Type : VDISR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VDISR_Type_of_regval : register_value -> (maybe VDISR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VDISR_Type : VDISR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VMECID_A_EL2_Type_of_regval : register_value -> (maybe VMECID_A_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VMECID_A_EL2_Type : VMECID_A_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VMECID_P_EL2_Type_of_regval : register_value -> (maybe VMECID_P_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VMECID_P_EL2_Type : VMECID_P_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VMPIDR_EL2_Type_of_regval : register_value -> (maybe VMPIDR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VMPIDR_EL2_Type : VMPIDR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VMPIDR_Type_of_regval : register_value -> (maybe VMPIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VMPIDR_Type : VMPIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VNCR_EL2_Type_of_regval : register_value -> (maybe VNCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VNCR_EL2_Type : VNCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VPIDR_EL2_Type_of_regval : register_value -> (maybe VPIDR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VPIDR_EL2_Type : VPIDR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VPIDR_Type_of_regval : register_value -> (maybe VPIDR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VPIDR_Type : VPIDR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VSESR_EL2_Type_of_regval : register_value -> (maybe VSESR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VSESR_EL2_Type : VSESR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VSTCR_EL2_Type_of_regval : register_value -> (maybe VSTCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VSTCR_EL2_Type : VSTCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VSTTBR_EL2_Type_of_regval : register_value -> (maybe VSTTBR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VSTTBR_EL2_Type : VSTTBR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VTCR_EL2_Type_of_regval : register_value -> (maybe VTCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VTCR_EL2_Type : VTCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VTCR_Type_of_regval : register_value -> (maybe VTCR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VTCR_Type : VTCR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VTTBR_EL2_Type_of_regval : register_value -> (maybe VTTBR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VTTBR_EL2_Type : VTTBR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val VTTBR_Type_of_regval : register_value -> (maybe VTTBR_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_VTTBR_Type : VTTBR_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ZCR_EL1_Type_of_regval : register_value -> (maybe ZCR_EL1_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ZCR_EL1_Type : ZCR_EL1_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ZCR_EL2_Type_of_regval : register_value -> (maybe ZCR_EL2_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ZCR_EL2_Type : ZCR_EL2_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val ZCR_EL3_Type_of_regval : register_value -> (maybe ZCR_EL3_Type)\<close>\<close>

\<comment> \<open>\<open>val regval_of_ZCR_EL3_Type : ZCR_EL3_Type -> register_value\<close>\<close>

\<comment> \<open>\<open>val __InstrEnc_of_regval : register_value -> (maybe __InstrEnc)\<close>\<close>

\<comment> \<open>\<open>val regval_of___InstrEnc : __InstrEnc -> register_value\<close>\<close>

\<comment> \<open>\<open>val bit_of_regval : register_value -> (maybe bitU)\<close>\<close>

\<comment> \<open>\<open>val regval_of_bit : bitU -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_1_of_regval : register_value -> (maybe (mword ty1))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_1 : mword ty1 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_128_of_regval : register_value -> (maybe (mword ty128))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_128 : mword ty128 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_16_of_regval : register_value -> (maybe (mword ty16))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_16 : mword ty16 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_2_of_regval : register_value -> (maybe (mword ty2))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_2 : mword ty2 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_2048_of_regval : register_value -> (maybe (mword ty2048))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_2048 : mword ty2048 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_24_of_regval : register_value -> (maybe (mword ty24))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_24 : mword ty24 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_256_of_regval : register_value -> (maybe (mword ty256))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_256 : mword ty256 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_3_of_regval : register_value -> (maybe (mword ty3))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_3 : mword ty3 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_32_of_regval : register_value -> (maybe (mword ty32))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_32 : mword ty32 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_4_of_regval : register_value -> (maybe (mword ty4))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_4 : mword ty4 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_512_of_regval : register_value -> (maybe (mword ty512))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_512 : mword ty512 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_56_of_regval : register_value -> (maybe (mword ty56))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_56 : mword ty56 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_64_of_regval : register_value -> (maybe (mword ty64))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_64 : mword ty64 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_8_of_regval : register_value -> (maybe (mword ty8))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_8 : mword ty8 -> register_value\<close>\<close>

\<comment> \<open>\<open>val bitvector_88_of_regval : register_value -> (maybe (mword ty88))\<close>\<close>

\<comment> \<open>\<open>val regval_of_bitvector_88 : mword ty88 -> register_value\<close>\<close>

fun bitvector_64_of_regval  :: \<open> register_value \<Rightarrow>((64)Word.word)option \<close>  where 
     \<open> bitvector_64_of_regval (Regval_bitvector_64 (v)) = ( Some v )\<close> 
  for  "v"  :: "(64)Word.word "
|\<open> bitvector_64_of_regval _ = ( None )\<close>


definition ACCDATA_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ACCDATA_EL1_Type)option \<close>  where 
     \<open> ACCDATA_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ACCDATA_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_bitvector_64  :: \<open>(64)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_64 v = ( Regval_bitvector_64 v )\<close> 
  for  "v"  :: "(64)Word.word "


definition regval_of_ACCDATA_EL1_Type  :: \<open> ACCDATA_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ACCDATA_EL1_Type v = ( regval_of_bitvector_64(ACCDATA_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ACCDATA_EL1_Type "


definition AMCFGR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCFGR_EL0_Type)option \<close>  where 
     \<open> AMCFGR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMCFGR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCFGR_EL0_Type  :: \<open> AMCFGR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCFGR_EL0_Type v = ( regval_of_bitvector_64(AMCFGR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMCFGR_EL0_Type "


fun bitvector_32_of_regval  :: \<open> register_value \<Rightarrow>((32)Word.word)option \<close>  where 
     \<open> bitvector_32_of_regval (Regval_bitvector_32 (v)) = ( Some v )\<close> 
  for  "v"  :: "(32)Word.word "
|\<open> bitvector_32_of_regval _ = ( None )\<close>


definition AMCFGR_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCFGR_Type)option \<close>  where 
     \<open> AMCFGR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCFGR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_bitvector_32  :: \<open>(32)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_32 v = ( Regval_bitvector_32 v )\<close> 
  for  "v"  :: "(32)Word.word "


definition regval_of_AMCFGR_Type  :: \<open> AMCFGR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCFGR_Type v = ( regval_of_bitvector_32(AMCFGR_Type_bits   v))\<close> 
  for  "v"  :: " AMCFGR_Type "


definition AMCG1IDR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCG1IDR_EL0_Type)option \<close>  where 
     \<open> AMCG1IDR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMCG1IDR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCG1IDR_EL0_Type  :: \<open> AMCG1IDR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCG1IDR_EL0_Type v = ( regval_of_bitvector_64(AMCG1IDR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMCG1IDR_EL0_Type "


definition AMCGCR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCGCR_EL0_Type)option \<close>  where 
     \<open> AMCGCR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMCGCR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCGCR_EL0_Type  :: \<open> AMCGCR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCGCR_EL0_Type v = ( regval_of_bitvector_64(AMCGCR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMCGCR_EL0_Type "


definition AMCGCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCGCR_Type)option \<close>  where 
     \<open> AMCGCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCGCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCGCR_Type  :: \<open> AMCGCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCGCR_Type v = ( regval_of_bitvector_32(AMCGCR_Type_bits   v))\<close> 
  for  "v"  :: " AMCGCR_Type "


definition AMCIDR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCIDR0_Type)option \<close>  where 
     \<open> AMCIDR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCIDR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCIDR0_Type  :: \<open> AMCIDR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCIDR0_Type v = ( regval_of_bitvector_32(AMCIDR0_Type_bits   v))\<close> 
  for  "v"  :: " AMCIDR0_Type "


definition AMCIDR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCIDR1_Type)option \<close>  where 
     \<open> AMCIDR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCIDR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCIDR1_Type  :: \<open> AMCIDR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCIDR1_Type v = ( regval_of_bitvector_32(AMCIDR1_Type_bits   v))\<close> 
  for  "v"  :: " AMCIDR1_Type "


definition AMCIDR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCIDR2_Type)option \<close>  where 
     \<open> AMCIDR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCIDR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCIDR2_Type  :: \<open> AMCIDR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCIDR2_Type v = ( regval_of_bitvector_32(AMCIDR2_Type_bits   v))\<close> 
  for  "v"  :: " AMCIDR2_Type "


definition AMCIDR3_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCIDR3_Type)option \<close>  where 
     \<open> AMCIDR3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCIDR3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCIDR3_Type  :: \<open> AMCIDR3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCIDR3_Type v = ( regval_of_bitvector_32(AMCIDR3_Type_bits   v))\<close> 
  for  "v"  :: " AMCIDR3_Type "


definition AMCNTENCLR0_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCNTENCLR0_EL0_Type)option \<close>  where 
     \<open> AMCNTENCLR0_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMCNTENCLR0_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCNTENCLR0_EL0_Type  :: \<open> AMCNTENCLR0_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCNTENCLR0_EL0_Type v = ( regval_of_bitvector_64(AMCNTENCLR0_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMCNTENCLR0_EL0_Type "


definition AMCNTENCLR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCNTENCLR0_Type)option \<close>  where 
     \<open> AMCNTENCLR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCNTENCLR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCNTENCLR0_Type  :: \<open> AMCNTENCLR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCNTENCLR0_Type v = ( regval_of_bitvector_32(AMCNTENCLR0_Type_bits   v))\<close> 
  for  "v"  :: " AMCNTENCLR0_Type "


definition AMCNTENCLR1_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCNTENCLR1_EL0_Type)option \<close>  where 
     \<open> AMCNTENCLR1_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMCNTENCLR1_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCNTENCLR1_EL0_Type  :: \<open> AMCNTENCLR1_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCNTENCLR1_EL0_Type v = ( regval_of_bitvector_64(AMCNTENCLR1_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMCNTENCLR1_EL0_Type "


definition AMCNTENCLR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCNTENCLR1_Type)option \<close>  where 
     \<open> AMCNTENCLR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCNTENCLR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCNTENCLR1_Type  :: \<open> AMCNTENCLR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCNTENCLR1_Type v = ( regval_of_bitvector_32(AMCNTENCLR1_Type_bits   v))\<close> 
  for  "v"  :: " AMCNTENCLR1_Type "


definition AMCNTENSET0_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCNTENSET0_EL0_Type)option \<close>  where 
     \<open> AMCNTENSET0_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMCNTENSET0_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCNTENSET0_EL0_Type  :: \<open> AMCNTENSET0_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCNTENSET0_EL0_Type v = ( regval_of_bitvector_64(AMCNTENSET0_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMCNTENSET0_EL0_Type "


definition AMCNTENSET0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCNTENSET0_Type)option \<close>  where 
     \<open> AMCNTENSET0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCNTENSET0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCNTENSET0_Type  :: \<open> AMCNTENSET0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCNTENSET0_Type v = ( regval_of_bitvector_32(AMCNTENSET0_Type_bits   v))\<close> 
  for  "v"  :: " AMCNTENSET0_Type "


definition AMCNTENSET1_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCNTENSET1_EL0_Type)option \<close>  where 
     \<open> AMCNTENSET1_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMCNTENSET1_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCNTENSET1_EL0_Type  :: \<open> AMCNTENSET1_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCNTENSET1_EL0_Type v = ( regval_of_bitvector_64(AMCNTENSET1_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMCNTENSET1_EL0_Type "


definition AMCNTENSET1_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCNTENSET1_Type)option \<close>  where 
     \<open> AMCNTENSET1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCNTENSET1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCNTENSET1_Type  :: \<open> AMCNTENSET1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCNTENSET1_Type v = ( regval_of_bitvector_32(AMCNTENSET1_Type_bits   v))\<close> 
  for  "v"  :: " AMCNTENSET1_Type "


definition AMCR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCR_EL0_Type)option \<close>  where 
     \<open> AMCR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMCR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCR_EL0_Type  :: \<open> AMCR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCR_EL0_Type v = ( regval_of_bitvector_64(AMCR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMCR_EL0_Type "


definition AMCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMCR_Type)option \<close>  where 
     \<open> AMCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMCR_Type  :: \<open> AMCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMCR_Type v = ( regval_of_bitvector_32(AMCR_Type_bits   v))\<close> 
  for  "v"  :: " AMCR_Type "


definition AMDEVARCH_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMDEVARCH_Type)option \<close>  where 
     \<open> AMDEVARCH_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMDEVARCH_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMDEVARCH_Type  :: \<open> AMDEVARCH_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMDEVARCH_Type v = ( regval_of_bitvector_32(AMDEVARCH_Type_bits   v))\<close> 
  for  "v"  :: " AMDEVARCH_Type "


definition AMDEVTYPE_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMDEVTYPE_Type)option \<close>  where 
     \<open> AMDEVTYPE_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMDEVTYPE_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMDEVTYPE_Type  :: \<open> AMDEVTYPE_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMDEVTYPE_Type v = ( regval_of_bitvector_32(AMDEVTYPE_Type_bits   v))\<close> 
  for  "v"  :: " AMDEVTYPE_Type "


definition AMEVCNTR0_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMEVCNTR0_EL0_Type)option \<close>  where 
     \<open> AMEVCNTR0_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMEVCNTR0_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMEVCNTR0_EL0_Type  :: \<open> AMEVCNTR0_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMEVCNTR0_EL0_Type v = ( regval_of_bitvector_64(AMEVCNTR0_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMEVCNTR0_EL0_Type "


definition AMEVCNTR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMEVCNTR0_Type)option \<close>  where 
     \<open> AMEVCNTR0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMEVCNTR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMEVCNTR0_Type  :: \<open> AMEVCNTR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMEVCNTR0_Type v = ( regval_of_bitvector_64(AMEVCNTR0_Type_bits   v))\<close> 
  for  "v"  :: " AMEVCNTR0_Type "


definition AMEVCNTR1_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMEVCNTR1_EL0_Type)option \<close>  where 
     \<open> AMEVCNTR1_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMEVCNTR1_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMEVCNTR1_EL0_Type  :: \<open> AMEVCNTR1_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMEVCNTR1_EL0_Type v = ( regval_of_bitvector_64(AMEVCNTR1_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMEVCNTR1_EL0_Type "


definition AMEVCNTR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMEVCNTR1_Type)option \<close>  where 
     \<open> AMEVCNTR1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMEVCNTR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMEVCNTR1_Type  :: \<open> AMEVCNTR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMEVCNTR1_Type v = ( regval_of_bitvector_64(AMEVCNTR1_Type_bits   v))\<close> 
  for  "v"  :: " AMEVCNTR1_Type "


definition AMEVTYPER0_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMEVTYPER0_EL0_Type)option \<close>  where 
     \<open> AMEVTYPER0_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMEVTYPER0_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMEVTYPER0_EL0_Type  :: \<open> AMEVTYPER0_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMEVTYPER0_EL0_Type v = ( regval_of_bitvector_64(AMEVTYPER0_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMEVTYPER0_EL0_Type "


definition AMEVTYPER0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMEVTYPER0_Type)option \<close>  where 
     \<open> AMEVTYPER0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMEVTYPER0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMEVTYPER0_Type  :: \<open> AMEVTYPER0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMEVTYPER0_Type v = ( regval_of_bitvector_32(AMEVTYPER0_Type_bits   v))\<close> 
  for  "v"  :: " AMEVTYPER0_Type "


definition AMEVTYPER1_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMEVTYPER1_EL0_Type)option \<close>  where 
     \<open> AMEVTYPER1_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMEVTYPER1_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMEVTYPER1_EL0_Type  :: \<open> AMEVTYPER1_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMEVTYPER1_EL0_Type v = ( regval_of_bitvector_64(AMEVTYPER1_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMEVTYPER1_EL0_Type "


definition AMEVTYPER1_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMEVTYPER1_Type)option \<close>  where 
     \<open> AMEVTYPER1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMEVTYPER1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMEVTYPER1_Type  :: \<open> AMEVTYPER1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMEVTYPER1_Type v = ( regval_of_bitvector_32(AMEVTYPER1_Type_bits   v))\<close> 
  for  "v"  :: " AMEVTYPER1_Type "


definition AMIIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMIIDR_Type)option \<close>  where 
     \<open> AMIIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMIIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMIIDR_Type  :: \<open> AMIIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMIIDR_Type v = ( regval_of_bitvector_32(AMIIDR_Type_bits   v))\<close> 
  for  "v"  :: " AMIIDR_Type "


definition AMPIDR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMPIDR0_Type)option \<close>  where 
     \<open> AMPIDR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMPIDR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMPIDR0_Type  :: \<open> AMPIDR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMPIDR0_Type v = ( regval_of_bitvector_32(AMPIDR0_Type_bits   v))\<close> 
  for  "v"  :: " AMPIDR0_Type "


definition AMPIDR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMPIDR1_Type)option \<close>  where 
     \<open> AMPIDR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMPIDR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMPIDR1_Type  :: \<open> AMPIDR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMPIDR1_Type v = ( regval_of_bitvector_32(AMPIDR1_Type_bits   v))\<close> 
  for  "v"  :: " AMPIDR1_Type "


definition AMPIDR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMPIDR2_Type)option \<close>  where 
     \<open> AMPIDR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMPIDR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMPIDR2_Type  :: \<open> AMPIDR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMPIDR2_Type v = ( regval_of_bitvector_32(AMPIDR2_Type_bits   v))\<close> 
  for  "v"  :: " AMPIDR2_Type "


definition AMPIDR3_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMPIDR3_Type)option \<close>  where 
     \<open> AMPIDR3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMPIDR3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMPIDR3_Type  :: \<open> AMPIDR3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMPIDR3_Type v = ( regval_of_bitvector_32(AMPIDR3_Type_bits   v))\<close> 
  for  "v"  :: " AMPIDR3_Type "


definition AMPIDR4_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMPIDR4_Type)option \<close>  where 
     \<open> AMPIDR4_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMPIDR4_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMPIDR4_Type  :: \<open> AMPIDR4_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMPIDR4_Type v = ( regval_of_bitvector_32(AMPIDR4_Type_bits   v))\<close> 
  for  "v"  :: " AMPIDR4_Type "


definition AMUSERENR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMUSERENR_EL0_Type)option \<close>  where 
     \<open> AMUSERENR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| AMUSERENR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMUSERENR_EL0_Type  :: \<open> AMUSERENR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMUSERENR_EL0_Type v = ( regval_of_bitvector_64(AMUSERENR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " AMUSERENR_EL0_Type "


definition AMUSERENR_Type_of_regval  :: \<open> register_value \<Rightarrow>(AMUSERENR_Type)option \<close>  where 
     \<open> AMUSERENR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| AMUSERENR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_AMUSERENR_Type  :: \<open> AMUSERENR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_AMUSERENR_Type v = ( regval_of_bitvector_32(AMUSERENR_Type_bits   v))\<close> 
  for  "v"  :: " AMUSERENR_Type "


definition BRBCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBCR_EL1_Type)option \<close>  where 
     \<open> BRBCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBCR_EL1_Type  :: \<open> BRBCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBCR_EL1_Type v = ( regval_of_bitvector_64(BRBCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " BRBCR_EL1_Type "


definition BRBCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBCR_EL2_Type)option \<close>  where 
     \<open> BRBCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBCR_EL2_Type  :: \<open> BRBCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBCR_EL2_Type v = ( regval_of_bitvector_64(BRBCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " BRBCR_EL2_Type "


definition BRBFCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBFCR_EL1_Type)option \<close>  where 
     \<open> BRBFCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBFCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBFCR_EL1_Type  :: \<open> BRBFCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBFCR_EL1_Type v = ( regval_of_bitvector_64(BRBFCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " BRBFCR_EL1_Type "


definition BRBIDR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBIDR0_EL1_Type)option \<close>  where 
     \<open> BRBIDR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBIDR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBIDR0_EL1_Type  :: \<open> BRBIDR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBIDR0_EL1_Type v = ( regval_of_bitvector_64(BRBIDR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " BRBIDR0_EL1_Type "


definition BRBINFINJ_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBINFINJ_EL1_Type)option \<close>  where 
     \<open> BRBINFINJ_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBINFINJ_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBINFINJ_EL1_Type  :: \<open> BRBINFINJ_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBINFINJ_EL1_Type v = ( regval_of_bitvector_64(BRBINFINJ_EL1_Type_bits   v))\<close> 
  for  "v"  :: " BRBINFINJ_EL1_Type "


definition BRBINFType_of_regval  :: \<open> register_value \<Rightarrow>(BRBINFType)option \<close>  where 
     \<open> BRBINFType_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBINFType_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBINFType  :: \<open> BRBINFType \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBINFType v = ( regval_of_bitvector_64(BRBINFType_bits   v))\<close> 
  for  "v"  :: " BRBINFType "


definition BRBINF_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBINF_EL1_Type)option \<close>  where 
     \<open> BRBINF_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBINF_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBINF_EL1_Type  :: \<open> BRBINF_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBINF_EL1_Type v = ( regval_of_bitvector_64(BRBINF_EL1_Type_bits   v))\<close> 
  for  "v"  :: " BRBINF_EL1_Type "


definition BRBSRCINJ_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBSRCINJ_EL1_Type)option \<close>  where 
     \<open> BRBSRCINJ_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBSRCINJ_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBSRCINJ_EL1_Type  :: \<open> BRBSRCINJ_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBSRCINJ_EL1_Type v = ( regval_of_bitvector_64(BRBSRCINJ_EL1_Type_bits   v))\<close> 
  for  "v"  :: " BRBSRCINJ_EL1_Type "


definition BRBSRCType_of_regval  :: \<open> register_value \<Rightarrow>(BRBSRCType)option \<close>  where 
     \<open> BRBSRCType_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBSRCType_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBSRCType  :: \<open> BRBSRCType \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBSRCType v = ( regval_of_bitvector_64(BRBSRCType_bits   v))\<close> 
  for  "v"  :: " BRBSRCType "


definition BRBSRC_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBSRC_EL1_Type)option \<close>  where 
     \<open> BRBSRC_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBSRC_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBSRC_EL1_Type  :: \<open> BRBSRC_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBSRC_EL1_Type v = ( regval_of_bitvector_64(BRBSRC_EL1_Type_bits   v))\<close> 
  for  "v"  :: " BRBSRC_EL1_Type "


definition BRBTGTINJ_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBTGTINJ_EL1_Type)option \<close>  where 
     \<open> BRBTGTINJ_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBTGTINJ_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBTGTINJ_EL1_Type  :: \<open> BRBTGTINJ_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBTGTINJ_EL1_Type v = ( regval_of_bitvector_64(BRBTGTINJ_EL1_Type_bits   v))\<close> 
  for  "v"  :: " BRBTGTINJ_EL1_Type "


definition BRBTGTType_of_regval  :: \<open> register_value \<Rightarrow>(BRBTGTType)option \<close>  where 
     \<open> BRBTGTType_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBTGTType_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBTGTType  :: \<open> BRBTGTType \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBTGTType v = ( regval_of_bitvector_64(BRBTGTType_bits   v))\<close> 
  for  "v"  :: " BRBTGTType "


definition BRBTGT_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBTGT_EL1_Type)option \<close>  where 
     \<open> BRBTGT_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBTGT_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBTGT_EL1_Type  :: \<open> BRBTGT_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBTGT_EL1_Type v = ( regval_of_bitvector_64(BRBTGT_EL1_Type_bits   v))\<close> 
  for  "v"  :: " BRBTGT_EL1_Type "


definition BRBTS_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(BRBTS_EL1_Type)option \<close>  where 
     \<open> BRBTS_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| BRBTS_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_BRBTS_EL1_Type  :: \<open> BRBTS_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BRBTS_EL1_Type v = ( regval_of_bitvector_64(BRBTS_EL1_Type_bits   v))\<close> 
  for  "v"  :: " BRBTS_EL1_Type "


fun BranchType_of_regval  :: \<open> register_value \<Rightarrow>(BranchType)option \<close>  where 
     \<open> BranchType_of_regval (Regval_BranchType (v)) = ( Some v )\<close> 
  for  "v"  :: " BranchType "
|\<open> BranchType_of_regval _ = ( None )\<close>


definition regval_of_BranchType  :: \<open> BranchType \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_BranchType v = ( Regval_BranchType v )\<close> 
  for  "v"  :: " BranchType "


definition CCSIDR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CCSIDR2_EL1_Type)option \<close>  where 
     \<open> CCSIDR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CCSIDR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CCSIDR2_EL1_Type  :: \<open> CCSIDR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CCSIDR2_EL1_Type v = ( regval_of_bitvector_64(CCSIDR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " CCSIDR2_EL1_Type "


definition CCSIDR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CCSIDR2_Type)option \<close>  where 
     \<open> CCSIDR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CCSIDR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CCSIDR2_Type  :: \<open> CCSIDR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CCSIDR2_Type v = ( regval_of_bitvector_32(CCSIDR2_Type_bits   v))\<close> 
  for  "v"  :: " CCSIDR2_Type "


definition CCSIDR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CCSIDR_EL1_Type)option \<close>  where 
     \<open> CCSIDR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CCSIDR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CCSIDR_EL1_Type  :: \<open> CCSIDR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CCSIDR_EL1_Type v = ( regval_of_bitvector_64(CCSIDR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " CCSIDR_EL1_Type "


definition CCSIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CCSIDR_Type)option \<close>  where 
     \<open> CCSIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CCSIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CCSIDR_Type  :: \<open> CCSIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CCSIDR_Type v = ( regval_of_bitvector_32(CCSIDR_Type_bits   v))\<close> 
  for  "v"  :: " CCSIDR_Type "


definition CLIDR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CLIDR_EL1_Type)option \<close>  where 
     \<open> CLIDR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CLIDR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CLIDR_EL1_Type  :: \<open> CLIDR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CLIDR_EL1_Type v = ( regval_of_bitvector_64(CLIDR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " CLIDR_EL1_Type "


definition CLIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CLIDR_Type)option \<close>  where 
     \<open> CLIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CLIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CLIDR_Type  :: \<open> CLIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CLIDR_Type v = ( regval_of_bitvector_32(CLIDR_Type_bits   v))\<close> 
  for  "v"  :: " CLIDR_Type "


definition CNTCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTCR_Type)option \<close>  where 
     \<open> CNTCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTCR_Type  :: \<open> CNTCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTCR_Type v = ( regval_of_bitvector_32(CNTCR_Type_bits   v))\<close> 
  for  "v"  :: " CNTCR_Type "


definition CNTEL0ACR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTEL0ACR_Type)option \<close>  where 
     \<open> CNTEL0ACR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTEL0ACR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTEL0ACR_Type  :: \<open> CNTEL0ACR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTEL0ACR_Type v = ( regval_of_bitvector_32(CNTEL0ACR_Type_bits   v))\<close> 
  for  "v"  :: " CNTEL0ACR_Type "


definition CNTFID0_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTFID0_Type)option \<close>  where 
     \<open> CNTFID0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTFID0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTFID0_Type  :: \<open> CNTFID0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTFID0_Type v = ( regval_of_bitvector_32(CNTFID0_Type_bits   v))\<close> 
  for  "v"  :: " CNTFID0_Type "


definition CNTHCTL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHCTL_EL2_Type)option \<close>  where 
     \<open> CNTHCTL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHCTL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHCTL_EL2_Type  :: \<open> CNTHCTL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHCTL_EL2_Type v = ( regval_of_bitvector_64(CNTHCTL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHCTL_EL2_Type "


definition CNTHCTL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHCTL_Type)option \<close>  where 
     \<open> CNTHCTL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTHCTL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHCTL_Type  :: \<open> CNTHCTL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHCTL_Type v = ( regval_of_bitvector_32(CNTHCTL_Type_bits   v))\<close> 
  for  "v"  :: " CNTHCTL_Type "


definition CNTHPS_CTL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHPS_CTL_EL2_Type)option \<close>  where 
     \<open> CNTHPS_CTL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHPS_CTL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHPS_CTL_EL2_Type  :: \<open> CNTHPS_CTL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHPS_CTL_EL2_Type v = ( regval_of_bitvector_64(CNTHPS_CTL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHPS_CTL_EL2_Type "


definition CNTHPS_CTL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHPS_CTL_Type)option \<close>  where 
     \<open> CNTHPS_CTL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTHPS_CTL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHPS_CTL_Type  :: \<open> CNTHPS_CTL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHPS_CTL_Type v = ( regval_of_bitvector_32(CNTHPS_CTL_Type_bits   v))\<close> 
  for  "v"  :: " CNTHPS_CTL_Type "


definition CNTHPS_CVAL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHPS_CVAL_EL2_Type)option \<close>  where 
     \<open> CNTHPS_CVAL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHPS_CVAL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHPS_CVAL_EL2_Type  :: \<open> CNTHPS_CVAL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHPS_CVAL_EL2_Type v = ( regval_of_bitvector_64(CNTHPS_CVAL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHPS_CVAL_EL2_Type "


definition CNTHPS_TVAL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHPS_TVAL_EL2_Type)option \<close>  where 
     \<open> CNTHPS_TVAL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHPS_TVAL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHPS_TVAL_EL2_Type  :: \<open> CNTHPS_TVAL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHPS_TVAL_EL2_Type v = ( regval_of_bitvector_64(CNTHPS_TVAL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHPS_TVAL_EL2_Type "


definition CNTHP_CTL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHP_CTL_EL2_Type)option \<close>  where 
     \<open> CNTHP_CTL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHP_CTL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHP_CTL_EL2_Type  :: \<open> CNTHP_CTL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHP_CTL_EL2_Type v = ( regval_of_bitvector_64(CNTHP_CTL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHP_CTL_EL2_Type "


definition CNTHP_CTL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHP_CTL_Type)option \<close>  where 
     \<open> CNTHP_CTL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTHP_CTL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHP_CTL_Type  :: \<open> CNTHP_CTL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHP_CTL_Type v = ( regval_of_bitvector_32(CNTHP_CTL_Type_bits   v))\<close> 
  for  "v"  :: " CNTHP_CTL_Type "


definition CNTHP_CVAL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHP_CVAL_EL2_Type)option \<close>  where 
     \<open> CNTHP_CVAL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHP_CVAL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHP_CVAL_EL2_Type  :: \<open> CNTHP_CVAL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHP_CVAL_EL2_Type v = ( regval_of_bitvector_64(CNTHP_CVAL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHP_CVAL_EL2_Type "


definition CNTHP_CVAL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHP_CVAL_Type)option \<close>  where 
     \<open> CNTHP_CVAL_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHP_CVAL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHP_CVAL_Type  :: \<open> CNTHP_CVAL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHP_CVAL_Type v = ( regval_of_bitvector_64(CNTHP_CVAL_Type_bits   v))\<close> 
  for  "v"  :: " CNTHP_CVAL_Type "


definition CNTHP_TVAL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHP_TVAL_EL2_Type)option \<close>  where 
     \<open> CNTHP_TVAL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHP_TVAL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHP_TVAL_EL2_Type  :: \<open> CNTHP_TVAL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHP_TVAL_EL2_Type v = ( regval_of_bitvector_64(CNTHP_TVAL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHP_TVAL_EL2_Type "


definition CNTHVS_CTL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHVS_CTL_EL2_Type)option \<close>  where 
     \<open> CNTHVS_CTL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHVS_CTL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHVS_CTL_EL2_Type  :: \<open> CNTHVS_CTL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHVS_CTL_EL2_Type v = ( regval_of_bitvector_64(CNTHVS_CTL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHVS_CTL_EL2_Type "


definition CNTHVS_CTL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHVS_CTL_Type)option \<close>  where 
     \<open> CNTHVS_CTL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTHVS_CTL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHVS_CTL_Type  :: \<open> CNTHVS_CTL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHVS_CTL_Type v = ( regval_of_bitvector_32(CNTHVS_CTL_Type_bits   v))\<close> 
  for  "v"  :: " CNTHVS_CTL_Type "


definition CNTHVS_CVAL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHVS_CVAL_EL2_Type)option \<close>  where 
     \<open> CNTHVS_CVAL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHVS_CVAL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHVS_CVAL_EL2_Type  :: \<open> CNTHVS_CVAL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHVS_CVAL_EL2_Type v = ( regval_of_bitvector_64(CNTHVS_CVAL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHVS_CVAL_EL2_Type "


definition CNTHVS_TVAL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHVS_TVAL_EL2_Type)option \<close>  where 
     \<open> CNTHVS_TVAL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHVS_TVAL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHVS_TVAL_EL2_Type  :: \<open> CNTHVS_TVAL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHVS_TVAL_EL2_Type v = ( regval_of_bitvector_64(CNTHVS_TVAL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHVS_TVAL_EL2_Type "


definition CNTHV_CTL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHV_CTL_EL2_Type)option \<close>  where 
     \<open> CNTHV_CTL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHV_CTL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHV_CTL_EL2_Type  :: \<open> CNTHV_CTL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHV_CTL_EL2_Type v = ( regval_of_bitvector_64(CNTHV_CTL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHV_CTL_EL2_Type "


definition CNTHV_CTL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHV_CTL_Type)option \<close>  where 
     \<open> CNTHV_CTL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTHV_CTL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHV_CTL_Type  :: \<open> CNTHV_CTL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHV_CTL_Type v = ( regval_of_bitvector_32(CNTHV_CTL_Type_bits   v))\<close> 
  for  "v"  :: " CNTHV_CTL_Type "


definition CNTHV_CVAL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHV_CVAL_EL2_Type)option \<close>  where 
     \<open> CNTHV_CVAL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHV_CVAL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHV_CVAL_EL2_Type  :: \<open> CNTHV_CVAL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHV_CVAL_EL2_Type v = ( regval_of_bitvector_64(CNTHV_CVAL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHV_CVAL_EL2_Type "


definition CNTHV_TVAL_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTHV_TVAL_EL2_Type)option \<close>  where 
     \<open> CNTHV_TVAL_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTHV_TVAL_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTHV_TVAL_EL2_Type  :: \<open> CNTHV_TVAL_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTHV_TVAL_EL2_Type v = ( regval_of_bitvector_64(CNTHV_TVAL_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CNTHV_TVAL_EL2_Type "


definition CNTID_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTID_Type)option \<close>  where 
     \<open> CNTID_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTID_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTID_Type  :: \<open> CNTID_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTID_Type v = ( regval_of_bitvector_32(CNTID_Type_bits   v))\<close> 
  for  "v"  :: " CNTID_Type "


definition CNTKCTL_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTKCTL_EL1_Type)option \<close>  where 
     \<open> CNTKCTL_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTKCTL_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTKCTL_EL1_Type  :: \<open> CNTKCTL_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTKCTL_EL1_Type v = ( regval_of_bitvector_64(CNTKCTL_EL1_Type_bits   v))\<close> 
  for  "v"  :: " CNTKCTL_EL1_Type "


definition CNTKCTL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTKCTL_Type)option \<close>  where 
     \<open> CNTKCTL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTKCTL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTKCTL_Type  :: \<open> CNTKCTL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTKCTL_Type v = ( regval_of_bitvector_32(CNTKCTL_Type_bits   v))\<close> 
  for  "v"  :: " CNTKCTL_Type "


definition CNTNSAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTNSAR_Type)option \<close>  where 
     \<open> CNTNSAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTNSAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTNSAR_Type  :: \<open> CNTNSAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTNSAR_Type v = ( regval_of_bitvector_32(CNTNSAR_Type_bits   v))\<close> 
  for  "v"  :: " CNTNSAR_Type "


definition CNTPS_CTL_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTPS_CTL_EL1_Type)option \<close>  where 
     \<open> CNTPS_CTL_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTPS_CTL_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTPS_CTL_EL1_Type  :: \<open> CNTPS_CTL_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTPS_CTL_EL1_Type v = ( regval_of_bitvector_64(CNTPS_CTL_EL1_Type_bits   v))\<close> 
  for  "v"  :: " CNTPS_CTL_EL1_Type "


definition CNTPS_CVAL_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTPS_CVAL_EL1_Type)option \<close>  where 
     \<open> CNTPS_CVAL_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTPS_CVAL_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTPS_CVAL_EL1_Type  :: \<open> CNTPS_CVAL_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTPS_CVAL_EL1_Type v = ( regval_of_bitvector_64(CNTPS_CVAL_EL1_Type_bits   v))\<close> 
  for  "v"  :: " CNTPS_CVAL_EL1_Type "


definition CNTPS_TVAL_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTPS_TVAL_EL1_Type)option \<close>  where 
     \<open> CNTPS_TVAL_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTPS_TVAL_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTPS_TVAL_EL1_Type  :: \<open> CNTPS_TVAL_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTPS_TVAL_EL1_Type v = ( regval_of_bitvector_64(CNTPS_TVAL_EL1_Type_bits   v))\<close> 
  for  "v"  :: " CNTPS_TVAL_EL1_Type "


definition CNTP_CTL_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTP_CTL_EL0_Type)option \<close>  where 
     \<open> CNTP_CTL_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTP_CTL_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTP_CTL_EL0_Type  :: \<open> CNTP_CTL_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTP_CTL_EL0_Type v = ( regval_of_bitvector_64(CNTP_CTL_EL0_Type_bits   v))\<close> 
  for  "v"  :: " CNTP_CTL_EL0_Type "


definition CNTP_CTL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTP_CTL_Type)option \<close>  where 
     \<open> CNTP_CTL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTP_CTL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTP_CTL_Type  :: \<open> CNTP_CTL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTP_CTL_Type v = ( regval_of_bitvector_32(CNTP_CTL_Type_bits   v))\<close> 
  for  "v"  :: " CNTP_CTL_Type "


definition CNTP_CVAL_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTP_CVAL_EL0_Type)option \<close>  where 
     \<open> CNTP_CVAL_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTP_CVAL_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTP_CVAL_EL0_Type  :: \<open> CNTP_CVAL_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTP_CVAL_EL0_Type v = ( regval_of_bitvector_64(CNTP_CVAL_EL0_Type_bits   v))\<close> 
  for  "v"  :: " CNTP_CVAL_EL0_Type "


definition CNTP_CVAL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTP_CVAL_Type)option \<close>  where 
     \<open> CNTP_CVAL_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTP_CVAL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTP_CVAL_Type  :: \<open> CNTP_CVAL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTP_CVAL_Type v = ( regval_of_bitvector_64(CNTP_CVAL_Type_bits   v))\<close> 
  for  "v"  :: " CNTP_CVAL_Type "


definition CNTP_TVAL_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTP_TVAL_EL0_Type)option \<close>  where 
     \<open> CNTP_TVAL_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTP_TVAL_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTP_TVAL_EL0_Type  :: \<open> CNTP_TVAL_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTP_TVAL_EL0_Type v = ( regval_of_bitvector_64(CNTP_TVAL_EL0_Type_bits   v))\<close> 
  for  "v"  :: " CNTP_TVAL_EL0_Type "


definition CNTSCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTSCR_Type)option \<close>  where 
     \<open> CNTSCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTSCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTSCR_Type  :: \<open> CNTSCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTSCR_Type v = ( regval_of_bitvector_32(CNTSCR_Type_bits   v))\<close> 
  for  "v"  :: " CNTSCR_Type "


definition CNTSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTSR_Type)option \<close>  where 
     \<open> CNTSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTSR_Type  :: \<open> CNTSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTSR_Type v = ( regval_of_bitvector_32(CNTSR_Type_bits   v))\<close> 
  for  "v"  :: " CNTSR_Type "


definition CNTV_CTL_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTV_CTL_EL0_Type)option \<close>  where 
     \<open> CNTV_CTL_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTV_CTL_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTV_CTL_EL0_Type  :: \<open> CNTV_CTL_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTV_CTL_EL0_Type v = ( regval_of_bitvector_64(CNTV_CTL_EL0_Type_bits   v))\<close> 
  for  "v"  :: " CNTV_CTL_EL0_Type "


definition CNTV_CTL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTV_CTL_Type)option \<close>  where 
     \<open> CNTV_CTL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CNTV_CTL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTV_CTL_Type  :: \<open> CNTV_CTL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTV_CTL_Type v = ( regval_of_bitvector_32(CNTV_CTL_Type_bits   v))\<close> 
  for  "v"  :: " CNTV_CTL_Type "


definition CNTV_CVAL_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTV_CVAL_EL0_Type)option \<close>  where 
     \<open> CNTV_CVAL_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTV_CVAL_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTV_CVAL_EL0_Type  :: \<open> CNTV_CVAL_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTV_CVAL_EL0_Type v = ( regval_of_bitvector_64(CNTV_CVAL_EL0_Type_bits   v))\<close> 
  for  "v"  :: " CNTV_CVAL_EL0_Type "


definition CNTV_CVAL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTV_CVAL_Type)option \<close>  where 
     \<open> CNTV_CVAL_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTV_CVAL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTV_CVAL_Type  :: \<open> CNTV_CVAL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTV_CVAL_Type v = ( regval_of_bitvector_64(CNTV_CVAL_Type_bits   v))\<close> 
  for  "v"  :: " CNTV_CVAL_Type "


definition CNTV_TVAL_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(CNTV_TVAL_EL0_Type)option \<close>  where 
     \<open> CNTV_TVAL_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CNTV_TVAL_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CNTV_TVAL_EL0_Type  :: \<open> CNTV_TVAL_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CNTV_TVAL_EL0_Type v = ( regval_of_bitvector_64(CNTV_TVAL_EL0_Type_bits   v))\<close> 
  for  "v"  :: " CNTV_TVAL_EL0_Type "


definition CONTEXTIDR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CONTEXTIDR_EL1_Type)option \<close>  where 
     \<open> CONTEXTIDR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CONTEXTIDR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CONTEXTIDR_EL1_Type  :: \<open> CONTEXTIDR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CONTEXTIDR_EL1_Type v = ( regval_of_bitvector_64(CONTEXTIDR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " CONTEXTIDR_EL1_Type "


definition CONTEXTIDR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CONTEXTIDR_EL2_Type)option \<close>  where 
     \<open> CONTEXTIDR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CONTEXTIDR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CONTEXTIDR_EL2_Type  :: \<open> CONTEXTIDR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CONTEXTIDR_EL2_Type v = ( regval_of_bitvector_64(CONTEXTIDR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CONTEXTIDR_EL2_Type "


definition CONTEXTIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CONTEXTIDR_Type)option \<close>  where 
     \<open> CONTEXTIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CONTEXTIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CONTEXTIDR_Type  :: \<open> CONTEXTIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CONTEXTIDR_Type v = ( regval_of_bitvector_32(CONTEXTIDR_Type_bits   v))\<close> 
  for  "v"  :: " CONTEXTIDR_Type "


definition CPACR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CPACR_EL1_Type)option \<close>  where 
     \<open> CPACR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CPACR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CPACR_EL1_Type  :: \<open> CPACR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CPACR_EL1_Type v = ( regval_of_bitvector_64(CPACR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " CPACR_EL1_Type "


definition CPACR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CPACR_Type)option \<close>  where 
     \<open> CPACR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CPACR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CPACR_Type  :: \<open> CPACR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CPACR_Type v = ( regval_of_bitvector_32(CPACR_Type_bits   v))\<close> 
  for  "v"  :: " CPACR_Type "


definition CPTR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CPTR_EL2_Type)option \<close>  where 
     \<open> CPTR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CPTR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CPTR_EL2_Type  :: \<open> CPTR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CPTR_EL2_Type v = ( regval_of_bitvector_64(CPTR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " CPTR_EL2_Type "


definition CPTR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(CPTR_EL3_Type)option \<close>  where 
     \<open> CPTR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CPTR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CPTR_EL3_Type  :: \<open> CPTR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CPTR_EL3_Type v = ( regval_of_bitvector_64(CPTR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " CPTR_EL3_Type "


definition CSSELR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CSSELR_EL1_Type)option \<close>  where 
     \<open> CSSELR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CSSELR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CSSELR_EL1_Type  :: \<open> CSSELR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CSSELR_EL1_Type v = ( regval_of_bitvector_64(CSSELR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " CSSELR_EL1_Type "


definition CSSELR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CSSELR_Type)option \<close>  where 
     \<open> CSSELR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CSSELR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CSSELR_Type  :: \<open> CSSELR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CSSELR_Type v = ( regval_of_bitvector_32(CSSELR_Type_bits   v))\<close> 
  for  "v"  :: " CSSELR_Type "


definition CTIAUTHSTATUS_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIAUTHSTATUS_Type)option \<close>  where 
     \<open> CTIAUTHSTATUS_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIAUTHSTATUS_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIAUTHSTATUS_Type  :: \<open> CTIAUTHSTATUS_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIAUTHSTATUS_Type v = ( regval_of_bitvector_32(CTIAUTHSTATUS_Type_bits   v))\<close> 
  for  "v"  :: " CTIAUTHSTATUS_Type "


definition CTICIDR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTICIDR0_Type)option \<close>  where 
     \<open> CTICIDR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTICIDR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTICIDR0_Type  :: \<open> CTICIDR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTICIDR0_Type v = ( regval_of_bitvector_32(CTICIDR0_Type_bits   v))\<close> 
  for  "v"  :: " CTICIDR0_Type "


definition CTICIDR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTICIDR1_Type)option \<close>  where 
     \<open> CTICIDR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTICIDR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTICIDR1_Type  :: \<open> CTICIDR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTICIDR1_Type v = ( regval_of_bitvector_32(CTICIDR1_Type_bits   v))\<close> 
  for  "v"  :: " CTICIDR1_Type "


definition CTICIDR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTICIDR2_Type)option \<close>  where 
     \<open> CTICIDR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTICIDR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTICIDR2_Type  :: \<open> CTICIDR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTICIDR2_Type v = ( regval_of_bitvector_32(CTICIDR2_Type_bits   v))\<close> 
  for  "v"  :: " CTICIDR2_Type "


definition CTICIDR3_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTICIDR3_Type)option \<close>  where 
     \<open> CTICIDR3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTICIDR3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTICIDR3_Type  :: \<open> CTICIDR3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTICIDR3_Type v = ( regval_of_bitvector_32(CTICIDR3_Type_bits   v))\<close> 
  for  "v"  :: " CTICIDR3_Type "


definition CTICONTROL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTICONTROL_Type)option \<close>  where 
     \<open> CTICONTROL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTICONTROL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTICONTROL_Type  :: \<open> CTICONTROL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTICONTROL_Type v = ( regval_of_bitvector_32(CTICONTROL_Type_bits   v))\<close> 
  for  "v"  :: " CTICONTROL_Type "


definition CTIDEVARCH_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIDEVARCH_Type)option \<close>  where 
     \<open> CTIDEVARCH_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIDEVARCH_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIDEVARCH_Type  :: \<open> CTIDEVARCH_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIDEVARCH_Type v = ( regval_of_bitvector_32(CTIDEVARCH_Type_bits   v))\<close> 
  for  "v"  :: " CTIDEVARCH_Type "


definition CTIDEVCTL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIDEVCTL_Type)option \<close>  where 
     \<open> CTIDEVCTL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIDEVCTL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIDEVCTL_Type  :: \<open> CTIDEVCTL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIDEVCTL_Type v = ( regval_of_bitvector_32(CTIDEVCTL_Type_bits   v))\<close> 
  for  "v"  :: " CTIDEVCTL_Type "


definition CTIDEVID_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIDEVID_Type)option \<close>  where 
     \<open> CTIDEVID_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIDEVID_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIDEVID_Type  :: \<open> CTIDEVID_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIDEVID_Type v = ( regval_of_bitvector_32(CTIDEVID_Type_bits   v))\<close> 
  for  "v"  :: " CTIDEVID_Type "


definition CTIDEVTYPE_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIDEVTYPE_Type)option \<close>  where 
     \<open> CTIDEVTYPE_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIDEVTYPE_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIDEVTYPE_Type  :: \<open> CTIDEVTYPE_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIDEVTYPE_Type v = ( regval_of_bitvector_32(CTIDEVTYPE_Type_bits   v))\<close> 
  for  "v"  :: " CTIDEVTYPE_Type "


definition CTIITCTRL_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIITCTRL_Type)option \<close>  where 
     \<open> CTIITCTRL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIITCTRL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIITCTRL_Type  :: \<open> CTIITCTRL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIITCTRL_Type v = ( regval_of_bitvector_32(CTIITCTRL_Type_bits   v))\<close> 
  for  "v"  :: " CTIITCTRL_Type "


definition CTILAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTILAR_Type)option \<close>  where 
     \<open> CTILAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTILAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTILAR_Type  :: \<open> CTILAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTILAR_Type v = ( regval_of_bitvector_32(CTILAR_Type_bits   v))\<close> 
  for  "v"  :: " CTILAR_Type "


definition CTILSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTILSR_Type)option \<close>  where 
     \<open> CTILSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTILSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTILSR_Type  :: \<open> CTILSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTILSR_Type v = ( regval_of_bitvector_32(CTILSR_Type_bits   v))\<close> 
  for  "v"  :: " CTILSR_Type "


definition CTIPIDR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIPIDR0_Type)option \<close>  where 
     \<open> CTIPIDR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIPIDR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIPIDR0_Type  :: \<open> CTIPIDR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIPIDR0_Type v = ( regval_of_bitvector_32(CTIPIDR0_Type_bits   v))\<close> 
  for  "v"  :: " CTIPIDR0_Type "


definition CTIPIDR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIPIDR1_Type)option \<close>  where 
     \<open> CTIPIDR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIPIDR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIPIDR1_Type  :: \<open> CTIPIDR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIPIDR1_Type v = ( regval_of_bitvector_32(CTIPIDR1_Type_bits   v))\<close> 
  for  "v"  :: " CTIPIDR1_Type "


definition CTIPIDR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIPIDR2_Type)option \<close>  where 
     \<open> CTIPIDR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIPIDR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIPIDR2_Type  :: \<open> CTIPIDR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIPIDR2_Type v = ( regval_of_bitvector_32(CTIPIDR2_Type_bits   v))\<close> 
  for  "v"  :: " CTIPIDR2_Type "


definition CTIPIDR3_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIPIDR3_Type)option \<close>  where 
     \<open> CTIPIDR3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIPIDR3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIPIDR3_Type  :: \<open> CTIPIDR3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIPIDR3_Type v = ( regval_of_bitvector_32(CTIPIDR3_Type_bits   v))\<close> 
  for  "v"  :: " CTIPIDR3_Type "


definition CTIPIDR4_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTIPIDR4_Type)option \<close>  where 
     \<open> CTIPIDR4_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTIPIDR4_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTIPIDR4_Type  :: \<open> CTIPIDR4_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTIPIDR4_Type v = ( regval_of_bitvector_32(CTIPIDR4_Type_bits   v))\<close> 
  for  "v"  :: " CTIPIDR4_Type "


definition CTR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTR_EL0_Type)option \<close>  where 
     \<open> CTR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| CTR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTR_EL0_Type  :: \<open> CTR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTR_EL0_Type v = ( regval_of_bitvector_64(CTR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " CTR_EL0_Type "


definition CTR_Type_of_regval  :: \<open> register_value \<Rightarrow>(CTR_Type)option \<close>  where 
     \<open> CTR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| CTR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_CTR_Type  :: \<open> CTR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_CTR_Type v = ( regval_of_bitvector_32(CTR_Type_bits   v))\<close> 
  for  "v"  :: " CTR_Type "


definition Configuration_Type_of_regval  :: \<open> register_value \<Rightarrow>(Configuration_Type)option \<close>  where 
     \<open> Configuration_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| Configuration_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_Configuration_Type  :: \<open> Configuration_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_Configuration_Type v = ( regval_of_bitvector_32(Configuration_Type_bits   v))\<close> 
  for  "v"  :: " Configuration_Type "


definition DACR32_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(DACR32_EL2_Type)option \<close>  where 
     \<open> DACR32_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DACR32_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DACR32_EL2_Type  :: \<open> DACR32_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DACR32_EL2_Type v = ( regval_of_bitvector_64(DACR32_EL2_Type_bits   v))\<close> 
  for  "v"  :: " DACR32_EL2_Type "


definition DACR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DACR_Type)option \<close>  where 
     \<open> DACR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DACR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DACR_Type  :: \<open> DACR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DACR_Type v = ( regval_of_bitvector_32(DACR_Type_bits   v))\<close> 
  for  "v"  :: " DACR_Type "


definition DBGAUTHSTATUS_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGAUTHSTATUS_EL1_Type)option \<close>  where 
     \<open> DBGAUTHSTATUS_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGAUTHSTATUS_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGAUTHSTATUS_EL1_Type  :: \<open> DBGAUTHSTATUS_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGAUTHSTATUS_EL1_Type v = ( regval_of_bitvector_64(DBGAUTHSTATUS_EL1_Type_bits   v))\<close> 
  for  "v"  :: " DBGAUTHSTATUS_EL1_Type "


definition DBGAUTHSTATUS_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGAUTHSTATUS_Type)option \<close>  where 
     \<open> DBGAUTHSTATUS_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGAUTHSTATUS_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGAUTHSTATUS_Type  :: \<open> DBGAUTHSTATUS_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGAUTHSTATUS_Type v = ( regval_of_bitvector_32(DBGAUTHSTATUS_Type_bits   v))\<close> 
  for  "v"  :: " DBGAUTHSTATUS_Type "


definition DBGBCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGBCR_EL1_Type)option \<close>  where 
     \<open> DBGBCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGBCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGBCR_EL1_Type  :: \<open> DBGBCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGBCR_EL1_Type v = ( regval_of_bitvector_64(DBGBCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " DBGBCR_EL1_Type "


definition DBGBCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGBCR_Type)option \<close>  where 
     \<open> DBGBCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGBCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGBCR_Type  :: \<open> DBGBCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGBCR_Type v = ( regval_of_bitvector_32(DBGBCR_Type_bits   v))\<close> 
  for  "v"  :: " DBGBCR_Type "


definition DBGBVR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGBVR_EL1_Type)option \<close>  where 
     \<open> DBGBVR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGBVR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGBVR_EL1_Type  :: \<open> DBGBVR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGBVR_EL1_Type v = ( regval_of_bitvector_64(DBGBVR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " DBGBVR_EL1_Type "


definition DBGBVR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGBVR_Type)option \<close>  where 
     \<open> DBGBVR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGBVR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGBVR_Type  :: \<open> DBGBVR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGBVR_Type v = ( regval_of_bitvector_32(DBGBVR_Type_bits   v))\<close> 
  for  "v"  :: " DBGBVR_Type "


definition DBGBXVR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGBXVR_Type)option \<close>  where 
     \<open> DBGBXVR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGBXVR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGBXVR_Type  :: \<open> DBGBXVR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGBXVR_Type v = ( regval_of_bitvector_32(DBGBXVR_Type_bits   v))\<close> 
  for  "v"  :: " DBGBXVR_Type "


definition DBGCLAIMCLR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGCLAIMCLR_EL1_Type)option \<close>  where 
     \<open> DBGCLAIMCLR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGCLAIMCLR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGCLAIMCLR_EL1_Type  :: \<open> DBGCLAIMCLR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGCLAIMCLR_EL1_Type v = ( regval_of_bitvector_64(DBGCLAIMCLR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " DBGCLAIMCLR_EL1_Type "


definition DBGCLAIMCLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGCLAIMCLR_Type)option \<close>  where 
     \<open> DBGCLAIMCLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGCLAIMCLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGCLAIMCLR_Type  :: \<open> DBGCLAIMCLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGCLAIMCLR_Type v = ( regval_of_bitvector_32(DBGCLAIMCLR_Type_bits   v))\<close> 
  for  "v"  :: " DBGCLAIMCLR_Type "


definition DBGCLAIMSET_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGCLAIMSET_EL1_Type)option \<close>  where 
     \<open> DBGCLAIMSET_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGCLAIMSET_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGCLAIMSET_EL1_Type  :: \<open> DBGCLAIMSET_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGCLAIMSET_EL1_Type v = ( regval_of_bitvector_64(DBGCLAIMSET_EL1_Type_bits   v))\<close> 
  for  "v"  :: " DBGCLAIMSET_EL1_Type "


definition DBGCLAIMSET_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGCLAIMSET_Type)option \<close>  where 
     \<open> DBGCLAIMSET_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGCLAIMSET_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGCLAIMSET_Type  :: \<open> DBGCLAIMSET_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGCLAIMSET_Type v = ( regval_of_bitvector_32(DBGCLAIMSET_Type_bits   v))\<close> 
  for  "v"  :: " DBGCLAIMSET_Type "


definition DBGDCCINT_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDCCINT_Type)option \<close>  where 
     \<open> DBGDCCINT_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGDCCINT_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDCCINT_Type  :: \<open> DBGDCCINT_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDCCINT_Type v = ( regval_of_bitvector_32(DBGDCCINT_Type_bits   v))\<close> 
  for  "v"  :: " DBGDCCINT_Type "


definition DBGDEVID1_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDEVID1_Type)option \<close>  where 
     \<open> DBGDEVID1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGDEVID1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDEVID1_Type  :: \<open> DBGDEVID1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDEVID1_Type v = ( regval_of_bitvector_32(DBGDEVID1_Type_bits   v))\<close> 
  for  "v"  :: " DBGDEVID1_Type "


definition DBGDEVID_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDEVID_Type)option \<close>  where 
     \<open> DBGDEVID_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGDEVID_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDEVID_Type  :: \<open> DBGDEVID_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDEVID_Type v = ( regval_of_bitvector_32(DBGDEVID_Type_bits   v))\<close> 
  for  "v"  :: " DBGDEVID_Type "


definition DBGDIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDIDR_Type)option \<close>  where 
     \<open> DBGDIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGDIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDIDR_Type  :: \<open> DBGDIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDIDR_Type v = ( regval_of_bitvector_32(DBGDIDR_Type_bits   v))\<close> 
  for  "v"  :: " DBGDIDR_Type "


definition DBGDRAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDRAR_Type)option \<close>  where 
     \<open> DBGDRAR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGDRAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDRAR_Type  :: \<open> DBGDRAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDRAR_Type v = ( regval_of_bitvector_64(DBGDRAR_Type_bits   v))\<close> 
  for  "v"  :: " DBGDRAR_Type "


definition DBGDSCRext_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDSCRext_Type)option \<close>  where 
     \<open> DBGDSCRext_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGDSCRext_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDSCRext_Type  :: \<open> DBGDSCRext_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDSCRext_Type v = ( regval_of_bitvector_32(DBGDSCRext_Type_bits   v))\<close> 
  for  "v"  :: " DBGDSCRext_Type "


definition DBGDSCRint_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDSCRint_Type)option \<close>  where 
     \<open> DBGDSCRint_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGDSCRint_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDSCRint_Type  :: \<open> DBGDSCRint_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDSCRint_Type v = ( regval_of_bitvector_32(DBGDSCRint_Type_bits   v))\<close> 
  for  "v"  :: " DBGDSCRint_Type "


definition DBGDTRRXext_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDTRRXext_Type)option \<close>  where 
     \<open> DBGDTRRXext_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGDTRRXext_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDTRRXext_Type  :: \<open> DBGDTRRXext_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDTRRXext_Type v = ( regval_of_bitvector_32(DBGDTRRXext_Type_bits   v))\<close> 
  for  "v"  :: " DBGDTRRXext_Type "


definition DBGDTRRXint_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDTRRXint_Type)option \<close>  where 
     \<open> DBGDTRRXint_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGDTRRXint_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDTRRXint_Type  :: \<open> DBGDTRRXint_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDTRRXint_Type v = ( regval_of_bitvector_32(DBGDTRRXint_Type_bits   v))\<close> 
  for  "v"  :: " DBGDTRRXint_Type "


definition DBGDTRTXext_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDTRTXext_Type)option \<close>  where 
     \<open> DBGDTRTXext_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGDTRTXext_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDTRTXext_Type  :: \<open> DBGDTRTXext_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDTRTXext_Type v = ( regval_of_bitvector_32(DBGDTRTXext_Type_bits   v))\<close> 
  for  "v"  :: " DBGDTRTXext_Type "


definition DBGDTRTXint_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDTRTXint_Type)option \<close>  where 
     \<open> DBGDTRTXint_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGDTRTXint_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDTRTXint_Type  :: \<open> DBGDTRTXint_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDTRTXint_Type v = ( regval_of_bitvector_32(DBGDTRTXint_Type_bits   v))\<close> 
  for  "v"  :: " DBGDTRTXint_Type "


definition DBGDTR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGDTR_EL0_Type)option \<close>  where 
     \<open> DBGDTR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGDTR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGDTR_EL0_Type  :: \<open> DBGDTR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGDTR_EL0_Type v = ( regval_of_bitvector_64(DBGDTR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " DBGDTR_EL0_Type "


definition DBGOSDLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGOSDLR_Type)option \<close>  where 
     \<open> DBGOSDLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGOSDLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGOSDLR_Type  :: \<open> DBGOSDLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGOSDLR_Type v = ( regval_of_bitvector_32(DBGOSDLR_Type_bits   v))\<close> 
  for  "v"  :: " DBGOSDLR_Type "


definition DBGOSECCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGOSECCR_Type)option \<close>  where 
     \<open> DBGOSECCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGOSECCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGOSECCR_Type  :: \<open> DBGOSECCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGOSECCR_Type v = ( regval_of_bitvector_32(DBGOSECCR_Type_bits   v))\<close> 
  for  "v"  :: " DBGOSECCR_Type "


definition DBGOSLAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGOSLAR_Type)option \<close>  where 
     \<open> DBGOSLAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGOSLAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGOSLAR_Type  :: \<open> DBGOSLAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGOSLAR_Type v = ( regval_of_bitvector_32(DBGOSLAR_Type_bits   v))\<close> 
  for  "v"  :: " DBGOSLAR_Type "


definition DBGOSLSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGOSLSR_Type)option \<close>  where 
     \<open> DBGOSLSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGOSLSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGOSLSR_Type  :: \<open> DBGOSLSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGOSLSR_Type v = ( regval_of_bitvector_32(DBGOSLSR_Type_bits   v))\<close> 
  for  "v"  :: " DBGOSLSR_Type "


definition DBGPRCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGPRCR_EL1_Type)option \<close>  where 
     \<open> DBGPRCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGPRCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGPRCR_EL1_Type  :: \<open> DBGPRCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGPRCR_EL1_Type v = ( regval_of_bitvector_64(DBGPRCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " DBGPRCR_EL1_Type "


definition DBGPRCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGPRCR_Type)option \<close>  where 
     \<open> DBGPRCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGPRCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGPRCR_Type  :: \<open> DBGPRCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGPRCR_Type v = ( regval_of_bitvector_32(DBGPRCR_Type_bits   v))\<close> 
  for  "v"  :: " DBGPRCR_Type "


definition DBGVCR32_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGVCR32_EL2_Type)option \<close>  where 
     \<open> DBGVCR32_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGVCR32_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGVCR32_EL2_Type  :: \<open> DBGVCR32_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGVCR32_EL2_Type v = ( regval_of_bitvector_64(DBGVCR32_EL2_Type_bits   v))\<close> 
  for  "v"  :: " DBGVCR32_EL2_Type "


definition DBGVCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGVCR_Type)option \<close>  where 
     \<open> DBGVCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGVCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGVCR_Type  :: \<open> DBGVCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGVCR_Type v = ( regval_of_bitvector_32(DBGVCR_Type_bits   v))\<close> 
  for  "v"  :: " DBGVCR_Type "


definition DBGWCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGWCR_EL1_Type)option \<close>  where 
     \<open> DBGWCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGWCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGWCR_EL1_Type  :: \<open> DBGWCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGWCR_EL1_Type v = ( regval_of_bitvector_64(DBGWCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " DBGWCR_EL1_Type "


definition DBGWCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGWCR_Type)option \<close>  where 
     \<open> DBGWCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGWCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGWCR_Type  :: \<open> DBGWCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGWCR_Type v = ( regval_of_bitvector_32(DBGWCR_Type_bits   v))\<close> 
  for  "v"  :: " DBGWCR_Type "


definition DBGWVR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGWVR_EL1_Type)option \<close>  where 
     \<open> DBGWVR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DBGWVR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGWVR_EL1_Type  :: \<open> DBGWVR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGWVR_EL1_Type v = ( regval_of_bitvector_64(DBGWVR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " DBGWVR_EL1_Type "


definition DBGWVR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DBGWVR_Type)option \<close>  where 
     \<open> DBGWVR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DBGWVR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DBGWVR_Type  :: \<open> DBGWVR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DBGWVR_Type v = ( regval_of_bitvector_32(DBGWVR_Type_bits   v))\<close> 
  for  "v"  :: " DBGWVR_Type "


definition DCZID_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(DCZID_EL0_Type)option \<close>  where 
     \<open> DCZID_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DCZID_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DCZID_EL0_Type  :: \<open> DCZID_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DCZID_EL0_Type v = ( regval_of_bitvector_64(DCZID_EL0_Type_bits   v))\<close> 
  for  "v"  :: " DCZID_EL0_Type "


definition DFSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DFSR_Type)option \<close>  where 
     \<open> DFSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DFSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DFSR_Type  :: \<open> DFSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DFSR_Type v = ( regval_of_bitvector_32(DFSR_Type_bits   v))\<close> 
  for  "v"  :: " DFSR_Type "


definition DISR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(DISR_EL1_Type)option \<close>  where 
     \<open> DISR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DISR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DISR_EL1_Type  :: \<open> DISR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DISR_EL1_Type v = ( regval_of_bitvector_64(DISR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " DISR_EL1_Type "


definition DISR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DISR_Type)option \<close>  where 
     \<open> DISR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DISR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DISR_Type  :: \<open> DISR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DISR_Type v = ( regval_of_bitvector_32(DISR_Type_bits   v))\<close> 
  for  "v"  :: " DISR_Type "


definition DSPSR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(DSPSR2_Type)option \<close>  where 
     \<open> DSPSR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DSPSR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DSPSR2_Type  :: \<open> DSPSR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DSPSR2_Type v = ( regval_of_bitvector_32(DSPSR2_Type_bits   v))\<close> 
  for  "v"  :: " DSPSR2_Type "


definition DSPSR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(DSPSR_EL0_Type)option \<close>  where 
     \<open> DSPSR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| DSPSR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DSPSR_EL0_Type  :: \<open> DSPSR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DSPSR_EL0_Type v = ( regval_of_bitvector_64(DSPSR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " DSPSR_EL0_Type "


definition DSPSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(DSPSR_Type)option \<close>  where 
     \<open> DSPSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DSPSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DSPSR_Type  :: \<open> DSPSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DSPSR_Type v = ( regval_of_bitvector_32(DSPSR_Type_bits   v))\<close> 
  for  "v"  :: " DSPSR_Type "


definition DormantCtl_Type_of_regval  :: \<open> register_value \<Rightarrow>(DormantCtl_Type)option \<close>  where 
     \<open> DormantCtl_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| DormantCtl_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_DormantCtl_Type  :: \<open> DormantCtl_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_DormantCtl_Type v = ( regval_of_bitvector_32(DormantCtl_Type_bits   v))\<close> 
  for  "v"  :: " DormantCtl_Type "


definition EDAA32PFR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDAA32PFR_Type)option \<close>  where 
     \<open> EDAA32PFR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| EDAA32PFR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDAA32PFR_Type  :: \<open> EDAA32PFR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDAA32PFR_Type v = ( regval_of_bitvector_64(EDAA32PFR_Type_bits   v))\<close> 
  for  "v"  :: " EDAA32PFR_Type "


definition EDCIDR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDCIDR0_Type)option \<close>  where 
     \<open> EDCIDR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDCIDR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDCIDR0_Type  :: \<open> EDCIDR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDCIDR0_Type v = ( regval_of_bitvector_32(EDCIDR0_Type_bits   v))\<close> 
  for  "v"  :: " EDCIDR0_Type "


definition EDCIDR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDCIDR1_Type)option \<close>  where 
     \<open> EDCIDR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDCIDR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDCIDR1_Type  :: \<open> EDCIDR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDCIDR1_Type v = ( regval_of_bitvector_32(EDCIDR1_Type_bits   v))\<close> 
  for  "v"  :: " EDCIDR1_Type "


definition EDCIDR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDCIDR2_Type)option \<close>  where 
     \<open> EDCIDR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDCIDR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDCIDR2_Type  :: \<open> EDCIDR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDCIDR2_Type v = ( regval_of_bitvector_32(EDCIDR2_Type_bits   v))\<close> 
  for  "v"  :: " EDCIDR2_Type "


definition EDCIDR3_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDCIDR3_Type)option \<close>  where 
     \<open> EDCIDR3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDCIDR3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDCIDR3_Type  :: \<open> EDCIDR3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDCIDR3_Type v = ( regval_of_bitvector_32(EDCIDR3_Type_bits   v))\<close> 
  for  "v"  :: " EDCIDR3_Type "


definition EDDEVARCH_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDDEVARCH_Type)option \<close>  where 
     \<open> EDDEVARCH_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDDEVARCH_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDDEVARCH_Type  :: \<open> EDDEVARCH_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDDEVARCH_Type v = ( regval_of_bitvector_32(EDDEVARCH_Type_bits   v))\<close> 
  for  "v"  :: " EDDEVARCH_Type "


definition EDDEVID1_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDDEVID1_Type)option \<close>  where 
     \<open> EDDEVID1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDDEVID1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDDEVID1_Type  :: \<open> EDDEVID1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDDEVID1_Type v = ( regval_of_bitvector_32(EDDEVID1_Type_bits   v))\<close> 
  for  "v"  :: " EDDEVID1_Type "


definition EDDEVID_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDDEVID_Type)option \<close>  where 
     \<open> EDDEVID_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDDEVID_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDDEVID_Type  :: \<open> EDDEVID_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDDEVID_Type v = ( regval_of_bitvector_32(EDDEVID_Type_bits   v))\<close> 
  for  "v"  :: " EDDEVID_Type "


definition EDDEVTYPE_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDDEVTYPE_Type)option \<close>  where 
     \<open> EDDEVTYPE_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDDEVTYPE_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDDEVTYPE_Type  :: \<open> EDDEVTYPE_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDDEVTYPE_Type v = ( regval_of_bitvector_32(EDDEVTYPE_Type_bits   v))\<close> 
  for  "v"  :: " EDDEVTYPE_Type "


definition EDDFR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDDFR1_Type)option \<close>  where 
     \<open> EDDFR1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| EDDFR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDDFR1_Type  :: \<open> EDDFR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDDFR1_Type v = ( regval_of_bitvector_64(EDDFR1_Type_bits   v))\<close> 
  for  "v"  :: " EDDFR1_Type "


definition EDDFR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDDFR_Type)option \<close>  where 
     \<open> EDDFR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| EDDFR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDDFR_Type  :: \<open> EDDFR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDDFR_Type v = ( regval_of_bitvector_64(EDDFR_Type_bits   v))\<close> 
  for  "v"  :: " EDDFR_Type "


definition EDECCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDECCR_Type)option \<close>  where 
     \<open> EDECCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDECCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDECCR_Type  :: \<open> EDECCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDECCR_Type v = ( regval_of_bitvector_32(EDECCR_Type_bits   v))\<close> 
  for  "v"  :: " EDECCR_Type "


definition EDECR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDECR_Type)option \<close>  where 
     \<open> EDECR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDECR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDECR_Type  :: \<open> EDECR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDECR_Type v = ( regval_of_bitvector_32(EDECR_Type_bits   v))\<close> 
  for  "v"  :: " EDECR_Type "


definition EDESR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDESR_Type)option \<close>  where 
     \<open> EDESR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDESR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDESR_Type  :: \<open> EDESR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDESR_Type v = ( regval_of_bitvector_32(EDESR_Type_bits   v))\<close> 
  for  "v"  :: " EDESR_Type "


definition EDHSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDHSR_Type)option \<close>  where 
     \<open> EDHSR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| EDHSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDHSR_Type  :: \<open> EDHSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDHSR_Type v = ( regval_of_bitvector_64(EDHSR_Type_bits   v))\<close> 
  for  "v"  :: " EDHSR_Type "


definition EDITCTRL_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDITCTRL_Type)option \<close>  where 
     \<open> EDITCTRL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDITCTRL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDITCTRL_Type  :: \<open> EDITCTRL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDITCTRL_Type v = ( regval_of_bitvector_32(EDITCTRL_Type_bits   v))\<close> 
  for  "v"  :: " EDITCTRL_Type "


definition EDLAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDLAR_Type)option \<close>  where 
     \<open> EDLAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDLAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDLAR_Type  :: \<open> EDLAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDLAR_Type v = ( regval_of_bitvector_32(EDLAR_Type_bits   v))\<close> 
  for  "v"  :: " EDLAR_Type "


definition EDLSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDLSR_Type)option \<close>  where 
     \<open> EDLSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDLSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDLSR_Type  :: \<open> EDLSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDLSR_Type v = ( regval_of_bitvector_32(EDLSR_Type_bits   v))\<close> 
  for  "v"  :: " EDLSR_Type "


definition EDPCSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDPCSR_Type)option \<close>  where 
     \<open> EDPCSR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| EDPCSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDPCSR_Type  :: \<open> EDPCSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDPCSR_Type v = ( regval_of_bitvector_64(EDPCSR_Type_bits   v))\<close> 
  for  "v"  :: " EDPCSR_Type "


definition EDPFR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDPFR_Type)option \<close>  where 
     \<open> EDPFR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| EDPFR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDPFR_Type  :: \<open> EDPFR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDPFR_Type v = ( regval_of_bitvector_64(EDPFR_Type_bits   v))\<close> 
  for  "v"  :: " EDPFR_Type "


definition EDPIDR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDPIDR0_Type)option \<close>  where 
     \<open> EDPIDR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDPIDR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDPIDR0_Type  :: \<open> EDPIDR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDPIDR0_Type v = ( regval_of_bitvector_32(EDPIDR0_Type_bits   v))\<close> 
  for  "v"  :: " EDPIDR0_Type "


definition EDPIDR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDPIDR1_Type)option \<close>  where 
     \<open> EDPIDR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDPIDR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDPIDR1_Type  :: \<open> EDPIDR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDPIDR1_Type v = ( regval_of_bitvector_32(EDPIDR1_Type_bits   v))\<close> 
  for  "v"  :: " EDPIDR1_Type "


definition EDPIDR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDPIDR2_Type)option \<close>  where 
     \<open> EDPIDR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDPIDR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDPIDR2_Type  :: \<open> EDPIDR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDPIDR2_Type v = ( regval_of_bitvector_32(EDPIDR2_Type_bits   v))\<close> 
  for  "v"  :: " EDPIDR2_Type "


definition EDPIDR3_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDPIDR3_Type)option \<close>  where 
     \<open> EDPIDR3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDPIDR3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDPIDR3_Type  :: \<open> EDPIDR3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDPIDR3_Type v = ( regval_of_bitvector_32(EDPIDR3_Type_bits   v))\<close> 
  for  "v"  :: " EDPIDR3_Type "


definition EDPIDR4_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDPIDR4_Type)option \<close>  where 
     \<open> EDPIDR4_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDPIDR4_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDPIDR4_Type  :: \<open> EDPIDR4_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDPIDR4_Type v = ( regval_of_bitvector_32(EDPIDR4_Type_bits   v))\<close> 
  for  "v"  :: " EDPIDR4_Type "


definition EDPRCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDPRCR_Type)option \<close>  where 
     \<open> EDPRCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDPRCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDPRCR_Type  :: \<open> EDPRCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDPRCR_Type v = ( regval_of_bitvector_32(EDPRCR_Type_bits   v))\<close> 
  for  "v"  :: " EDPRCR_Type "


definition EDPRSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDPRSR_Type)option \<close>  where 
     \<open> EDPRSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDPRSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDPRSR_Type  :: \<open> EDPRSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDPRSR_Type v = ( regval_of_bitvector_32(EDPRSR_Type_bits   v))\<close> 
  for  "v"  :: " EDPRSR_Type "


definition EDRCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDRCR_Type)option \<close>  where 
     \<open> EDRCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDRCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDRCR_Type  :: \<open> EDRCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDRCR_Type v = ( regval_of_bitvector_32(EDRCR_Type_bits   v))\<close> 
  for  "v"  :: " EDRCR_Type "


definition EDSCR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDSCR2_Type)option \<close>  where 
     \<open> EDSCR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDSCR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDSCR2_Type  :: \<open> EDSCR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDSCR2_Type v = ( regval_of_bitvector_32(EDSCR2_Type_bits   v))\<close> 
  for  "v"  :: " EDSCR2_Type "


definition EDSCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDSCR_Type)option \<close>  where 
     \<open> EDSCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDSCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDSCR_Type  :: \<open> EDSCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDSCR_Type v = ( regval_of_bitvector_32(EDSCR_Type_bits   v))\<close> 
  for  "v"  :: " EDSCR_Type "


definition EDVIDSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(EDVIDSR_Type)option \<close>  where 
     \<open> EDVIDSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| EDVIDSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_EDVIDSR_Type  :: \<open> EDVIDSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_EDVIDSR_Type v = ( regval_of_bitvector_32(EDVIDSR_Type_bits   v))\<close> 
  for  "v"  :: " EDVIDSR_Type "


definition ERRIDR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ERRIDR_EL1_Type)option \<close>  where 
     \<open> ERRIDR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ERRIDR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ERRIDR_EL1_Type  :: \<open> ERRIDR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ERRIDR_EL1_Type v = ( regval_of_bitvector_64(ERRIDR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ERRIDR_EL1_Type "


definition ERRIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ERRIDR_Type)option \<close>  where 
     \<open> ERRIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ERRIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ERRIDR_Type  :: \<open> ERRIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ERRIDR_Type v = ( regval_of_bitvector_32(ERRIDR_Type_bits   v))\<close> 
  for  "v"  :: " ERRIDR_Type "


definition ERRSELR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ERRSELR_EL1_Type)option \<close>  where 
     \<open> ERRSELR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ERRSELR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ERRSELR_EL1_Type  :: \<open> ERRSELR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ERRSELR_EL1_Type v = ( regval_of_bitvector_64(ERRSELR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ERRSELR_EL1_Type "


definition ERRSELR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ERRSELR_Type)option \<close>  where 
     \<open> ERRSELR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ERRSELR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ERRSELR_Type  :: \<open> ERRSELR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ERRSELR_Type v = ( regval_of_bitvector_32(ERRSELR_Type_bits   v))\<close> 
  for  "v"  :: " ERRSELR_Type "


definition ERRnFR_ElemType_of_regval  :: \<open> register_value \<Rightarrow>(ERRnFR_ElemType)option \<close>  where 
     \<open> ERRnFR_ElemType_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ERRnFR_ElemType_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ERRnFR_ElemType  :: \<open> ERRnFR_ElemType \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ERRnFR_ElemType v = ( regval_of_bitvector_64(ERRnFR_ElemType_bits   v))\<close> 
  for  "v"  :: " ERRnFR_ElemType "


definition ERXGSR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ERXGSR_EL1_Type)option \<close>  where 
     \<open> ERXGSR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ERXGSR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ERXGSR_EL1_Type  :: \<open> ERXGSR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ERXGSR_EL1_Type v = ( regval_of_bitvector_64(ERXGSR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ERXGSR_EL1_Type "


definition ESR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ESR_EL1_Type)option \<close>  where 
     \<open> ESR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ESR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ESR_EL1_Type  :: \<open> ESR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ESR_EL1_Type v = ( regval_of_bitvector_64(ESR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ESR_EL1_Type "


definition ESR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ESR_EL2_Type)option \<close>  where 
     \<open> ESR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ESR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ESR_EL2_Type  :: \<open> ESR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ESR_EL2_Type v = ( regval_of_bitvector_64(ESR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ESR_EL2_Type "


definition ESR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(ESR_EL3_Type)option \<close>  where 
     \<open> ESR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ESR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ESR_EL3_Type  :: \<open> ESR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ESR_EL3_Type v = ( regval_of_bitvector_64(ESR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " ESR_EL3_Type "


definition FPCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(FPCR_Type)option \<close>  where 
     \<open> FPCR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| FPCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_FPCR_Type  :: \<open> FPCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_FPCR_Type v = ( regval_of_bitvector_64(FPCR_Type_bits   v))\<close> 
  for  "v"  :: " FPCR_Type "


definition FPEXC32_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(FPEXC32_EL2_Type)option \<close>  where 
     \<open> FPEXC32_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| FPEXC32_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_FPEXC32_EL2_Type  :: \<open> FPEXC32_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_FPEXC32_EL2_Type v = ( regval_of_bitvector_64(FPEXC32_EL2_Type_bits   v))\<close> 
  for  "v"  :: " FPEXC32_EL2_Type "


definition FPEXC_Type_of_regval  :: \<open> register_value \<Rightarrow>(FPEXC_Type)option \<close>  where 
     \<open> FPEXC_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| FPEXC_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_FPEXC_Type  :: \<open> FPEXC_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_FPEXC_Type v = ( regval_of_bitvector_32(FPEXC_Type_bits   v))\<close> 
  for  "v"  :: " FPEXC_Type "


definition FPSCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(FPSCR_Type)option \<close>  where 
     \<open> FPSCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| FPSCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_FPSCR_Type  :: \<open> FPSCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_FPSCR_Type v = ( regval_of_bitvector_32(FPSCR_Type_bits   v))\<close> 
  for  "v"  :: " FPSCR_Type "


definition FPSID_Type_of_regval  :: \<open> register_value \<Rightarrow>(FPSID_Type)option \<close>  where 
     \<open> FPSID_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| FPSID_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_FPSID_Type  :: \<open> FPSID_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_FPSID_Type v = ( regval_of_bitvector_32(FPSID_Type_bits   v))\<close> 
  for  "v"  :: " FPSID_Type "


definition FPSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(FPSR_Type)option \<close>  where 
     \<open> FPSR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| FPSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_FPSR_Type  :: \<open> FPSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_FPSR_Type v = ( regval_of_bitvector_64(FPSR_Type_bits   v))\<close> 
  for  "v"  :: " FPSR_Type "


definition GCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(GCR_EL1_Type)option \<close>  where 
     \<open> GCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GCR_EL1_Type  :: \<open> GCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GCR_EL1_Type v = ( regval_of_bitvector_64(GCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " GCR_EL1_Type "


definition GCSCRE0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(GCSCRE0_EL1_Type)option \<close>  where 
     \<open> GCSCRE0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GCSCRE0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GCSCRE0_EL1_Type  :: \<open> GCSCRE0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GCSCRE0_EL1_Type v = ( regval_of_bitvector_64(GCSCRE0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " GCSCRE0_EL1_Type "


definition GCSCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(GCSCR_EL1_Type)option \<close>  where 
     \<open> GCSCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GCSCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GCSCR_EL1_Type  :: \<open> GCSCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GCSCR_EL1_Type v = ( regval_of_bitvector_64(GCSCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " GCSCR_EL1_Type "


definition GCSCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(GCSCR_EL2_Type)option \<close>  where 
     \<open> GCSCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GCSCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GCSCR_EL2_Type  :: \<open> GCSCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GCSCR_EL2_Type v = ( regval_of_bitvector_64(GCSCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " GCSCR_EL2_Type "


definition GCSCR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(GCSCR_EL3_Type)option \<close>  where 
     \<open> GCSCR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GCSCR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GCSCR_EL3_Type  :: \<open> GCSCR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GCSCR_EL3_Type v = ( regval_of_bitvector_64(GCSCR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " GCSCR_EL3_Type "


definition GCSPR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(GCSPR_EL0_Type)option \<close>  where 
     \<open> GCSPR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GCSPR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GCSPR_EL0_Type  :: \<open> GCSPR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GCSPR_EL0_Type v = ( regval_of_bitvector_64(GCSPR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " GCSPR_EL0_Type "


definition GCSPR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(GCSPR_EL1_Type)option \<close>  where 
     \<open> GCSPR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GCSPR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GCSPR_EL1_Type  :: \<open> GCSPR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GCSPR_EL1_Type v = ( regval_of_bitvector_64(GCSPR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " GCSPR_EL1_Type "


definition GCSPR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(GCSPR_EL2_Type)option \<close>  where 
     \<open> GCSPR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GCSPR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GCSPR_EL2_Type  :: \<open> GCSPR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GCSPR_EL2_Type v = ( regval_of_bitvector_64(GCSPR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " GCSPR_EL2_Type "


definition GCSPR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(GCSPR_EL3_Type)option \<close>  where 
     \<open> GCSPR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GCSPR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GCSPR_EL3_Type  :: \<open> GCSPR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GCSPR_EL3_Type v = ( regval_of_bitvector_64(GCSPR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " GCSPR_EL3_Type "


definition GICC_ABPR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_ABPR_Type)option \<close>  where 
     \<open> GICC_ABPR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_ABPR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_ABPR_Type  :: \<open> GICC_ABPR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_ABPR_Type v = ( regval_of_bitvector_32(GICC_ABPR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_ABPR_Type "


definition GICC_AEOIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_AEOIR_Type)option \<close>  where 
     \<open> GICC_AEOIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_AEOIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_AEOIR_Type  :: \<open> GICC_AEOIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_AEOIR_Type v = ( regval_of_bitvector_32(GICC_AEOIR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_AEOIR_Type "


definition GICC_AHPPIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_AHPPIR_Type)option \<close>  where 
     \<open> GICC_AHPPIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_AHPPIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_AHPPIR_Type  :: \<open> GICC_AHPPIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_AHPPIR_Type v = ( regval_of_bitvector_32(GICC_AHPPIR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_AHPPIR_Type "


definition GICC_AIAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_AIAR_Type)option \<close>  where 
     \<open> GICC_AIAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_AIAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_AIAR_Type  :: \<open> GICC_AIAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_AIAR_Type v = ( regval_of_bitvector_32(GICC_AIAR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_AIAR_Type "


definition GICC_BPR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_BPR_Type)option \<close>  where 
     \<open> GICC_BPR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_BPR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_BPR_Type  :: \<open> GICC_BPR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_BPR_Type v = ( regval_of_bitvector_32(GICC_BPR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_BPR_Type "


definition GICC_CTLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_CTLR_Type)option \<close>  where 
     \<open> GICC_CTLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_CTLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_CTLR_Type  :: \<open> GICC_CTLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_CTLR_Type v = ( regval_of_bitvector_32(GICC_CTLR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_CTLR_Type "


definition GICC_DIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_DIR_Type)option \<close>  where 
     \<open> GICC_DIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_DIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_DIR_Type  :: \<open> GICC_DIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_DIR_Type v = ( regval_of_bitvector_32(GICC_DIR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_DIR_Type "


definition GICC_EOIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_EOIR_Type)option \<close>  where 
     \<open> GICC_EOIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_EOIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_EOIR_Type  :: \<open> GICC_EOIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_EOIR_Type v = ( regval_of_bitvector_32(GICC_EOIR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_EOIR_Type "


definition GICC_HPPIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_HPPIR_Type)option \<close>  where 
     \<open> GICC_HPPIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_HPPIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_HPPIR_Type  :: \<open> GICC_HPPIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_HPPIR_Type v = ( regval_of_bitvector_32(GICC_HPPIR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_HPPIR_Type "


definition GICC_IAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_IAR_Type)option \<close>  where 
     \<open> GICC_IAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_IAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_IAR_Type  :: \<open> GICC_IAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_IAR_Type v = ( regval_of_bitvector_32(GICC_IAR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_IAR_Type "


definition GICC_PMR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_PMR_Type)option \<close>  where 
     \<open> GICC_PMR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_PMR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_PMR_Type  :: \<open> GICC_PMR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_PMR_Type v = ( regval_of_bitvector_32(GICC_PMR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_PMR_Type "


definition GICC_RPR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_RPR_Type)option \<close>  where 
     \<open> GICC_RPR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_RPR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_RPR_Type  :: \<open> GICC_RPR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_RPR_Type v = ( regval_of_bitvector_32(GICC_RPR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_RPR_Type "


definition GICC_STATUSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICC_STATUSR_Type)option \<close>  where 
     \<open> GICC_STATUSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICC_STATUSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICC_STATUSR_Type  :: \<open> GICC_STATUSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICC_STATUSR_Type v = ( regval_of_bitvector_32(GICC_STATUSR_Type_bits   v))\<close> 
  for  "v"  :: " GICC_STATUSR_Type "


definition GICD_CLRSPI_NSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICD_CLRSPI_NSR_Type)option \<close>  where 
     \<open> GICD_CLRSPI_NSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICD_CLRSPI_NSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICD_CLRSPI_NSR_Type  :: \<open> GICD_CLRSPI_NSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICD_CLRSPI_NSR_Type v = ( regval_of_bitvector_32(GICD_CLRSPI_NSR_Type_bits   v))\<close> 
  for  "v"  :: " GICD_CLRSPI_NSR_Type "


definition GICD_CLRSPI_SR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICD_CLRSPI_SR_Type)option \<close>  where 
     \<open> GICD_CLRSPI_SR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICD_CLRSPI_SR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICD_CLRSPI_SR_Type  :: \<open> GICD_CLRSPI_SR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICD_CLRSPI_SR_Type v = ( regval_of_bitvector_32(GICD_CLRSPI_SR_Type_bits   v))\<close> 
  for  "v"  :: " GICD_CLRSPI_SR_Type "


definition GICD_CTLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICD_CTLR_Type)option \<close>  where 
     \<open> GICD_CTLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICD_CTLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICD_CTLR_Type  :: \<open> GICD_CTLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICD_CTLR_Type v = ( regval_of_bitvector_32(GICD_CTLR_Type_bits   v))\<close> 
  for  "v"  :: " GICD_CTLR_Type "


definition GICD_IIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICD_IIDR_Type)option \<close>  where 
     \<open> GICD_IIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICD_IIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICD_IIDR_Type  :: \<open> GICD_IIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICD_IIDR_Type v = ( regval_of_bitvector_32(GICD_IIDR_Type_bits   v))\<close> 
  for  "v"  :: " GICD_IIDR_Type "


definition GICD_SETSPI_NSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICD_SETSPI_NSR_Type)option \<close>  where 
     \<open> GICD_SETSPI_NSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICD_SETSPI_NSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICD_SETSPI_NSR_Type  :: \<open> GICD_SETSPI_NSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICD_SETSPI_NSR_Type v = ( regval_of_bitvector_32(GICD_SETSPI_NSR_Type_bits   v))\<close> 
  for  "v"  :: " GICD_SETSPI_NSR_Type "


definition GICD_SETSPI_SR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICD_SETSPI_SR_Type)option \<close>  where 
     \<open> GICD_SETSPI_SR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICD_SETSPI_SR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICD_SETSPI_SR_Type  :: \<open> GICD_SETSPI_SR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICD_SETSPI_SR_Type v = ( regval_of_bitvector_32(GICD_SETSPI_SR_Type_bits   v))\<close> 
  for  "v"  :: " GICD_SETSPI_SR_Type "


definition GICD_SGIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICD_SGIR_Type)option \<close>  where 
     \<open> GICD_SGIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICD_SGIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICD_SGIR_Type  :: \<open> GICD_SGIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICD_SGIR_Type v = ( regval_of_bitvector_32(GICD_SGIR_Type_bits   v))\<close> 
  for  "v"  :: " GICD_SGIR_Type "


definition GICD_STATUSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICD_STATUSR_Type)option \<close>  where 
     \<open> GICD_STATUSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICD_STATUSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICD_STATUSR_Type  :: \<open> GICD_STATUSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICD_STATUSR_Type v = ( regval_of_bitvector_32(GICD_STATUSR_Type_bits   v))\<close> 
  for  "v"  :: " GICD_STATUSR_Type "


definition GICD_TYPER2_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICD_TYPER2_Type)option \<close>  where 
     \<open> GICD_TYPER2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICD_TYPER2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICD_TYPER2_Type  :: \<open> GICD_TYPER2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICD_TYPER2_Type v = ( regval_of_bitvector_32(GICD_TYPER2_Type_bits   v))\<close> 
  for  "v"  :: " GICD_TYPER2_Type "


definition GICD_TYPER_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICD_TYPER_Type)option \<close>  where 
     \<open> GICD_TYPER_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICD_TYPER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICD_TYPER_Type  :: \<open> GICD_TYPER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICD_TYPER_Type v = ( regval_of_bitvector_32(GICD_TYPER_Type_bits   v))\<close> 
  for  "v"  :: " GICD_TYPER_Type "


definition GICH_EISR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICH_EISR_Type)option \<close>  where 
     \<open> GICH_EISR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICH_EISR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICH_EISR_Type  :: \<open> GICH_EISR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICH_EISR_Type v = ( regval_of_bitvector_32(GICH_EISR_Type_bits   v))\<close> 
  for  "v"  :: " GICH_EISR_Type "


definition GICH_ELRSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICH_ELRSR_Type)option \<close>  where 
     \<open> GICH_ELRSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICH_ELRSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICH_ELRSR_Type  :: \<open> GICH_ELRSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICH_ELRSR_Type v = ( regval_of_bitvector_32(GICH_ELRSR_Type_bits   v))\<close> 
  for  "v"  :: " GICH_ELRSR_Type "


definition GICH_HCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICH_HCR_Type)option \<close>  where 
     \<open> GICH_HCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICH_HCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICH_HCR_Type  :: \<open> GICH_HCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICH_HCR_Type v = ( regval_of_bitvector_32(GICH_HCR_Type_bits   v))\<close> 
  for  "v"  :: " GICH_HCR_Type "


definition GICH_MISR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICH_MISR_Type)option \<close>  where 
     \<open> GICH_MISR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICH_MISR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICH_MISR_Type  :: \<open> GICH_MISR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICH_MISR_Type v = ( regval_of_bitvector_32(GICH_MISR_Type_bits   v))\<close> 
  for  "v"  :: " GICH_MISR_Type "


definition GICH_VMCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICH_VMCR_Type)option \<close>  where 
     \<open> GICH_VMCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICH_VMCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICH_VMCR_Type  :: \<open> GICH_VMCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICH_VMCR_Type v = ( regval_of_bitvector_32(GICH_VMCR_Type_bits   v))\<close> 
  for  "v"  :: " GICH_VMCR_Type "


definition GICH_VTR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICH_VTR_Type)option \<close>  where 
     \<open> GICH_VTR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICH_VTR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICH_VTR_Type  :: \<open> GICH_VTR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICH_VTR_Type v = ( regval_of_bitvector_32(GICH_VTR_Type_bits   v))\<close> 
  for  "v"  :: " GICH_VTR_Type "


definition GICM_CLRSPI_NSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICM_CLRSPI_NSR_Type)option \<close>  where 
     \<open> GICM_CLRSPI_NSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICM_CLRSPI_NSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICM_CLRSPI_NSR_Type  :: \<open> GICM_CLRSPI_NSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICM_CLRSPI_NSR_Type v = ( regval_of_bitvector_32(GICM_CLRSPI_NSR_Type_bits   v))\<close> 
  for  "v"  :: " GICM_CLRSPI_NSR_Type "


definition GICM_CLRSPI_SR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICM_CLRSPI_SR_Type)option \<close>  where 
     \<open> GICM_CLRSPI_SR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICM_CLRSPI_SR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICM_CLRSPI_SR_Type  :: \<open> GICM_CLRSPI_SR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICM_CLRSPI_SR_Type v = ( regval_of_bitvector_32(GICM_CLRSPI_SR_Type_bits   v))\<close> 
  for  "v"  :: " GICM_CLRSPI_SR_Type "


definition GICM_IIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICM_IIDR_Type)option \<close>  where 
     \<open> GICM_IIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICM_IIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICM_IIDR_Type  :: \<open> GICM_IIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICM_IIDR_Type v = ( regval_of_bitvector_32(GICM_IIDR_Type_bits   v))\<close> 
  for  "v"  :: " GICM_IIDR_Type "


definition GICM_SETSPI_NSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICM_SETSPI_NSR_Type)option \<close>  where 
     \<open> GICM_SETSPI_NSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICM_SETSPI_NSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICM_SETSPI_NSR_Type  :: \<open> GICM_SETSPI_NSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICM_SETSPI_NSR_Type v = ( regval_of_bitvector_32(GICM_SETSPI_NSR_Type_bits   v))\<close> 
  for  "v"  :: " GICM_SETSPI_NSR_Type "


definition GICM_SETSPI_SR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICM_SETSPI_SR_Type)option \<close>  where 
     \<open> GICM_SETSPI_SR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICM_SETSPI_SR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICM_SETSPI_SR_Type  :: \<open> GICM_SETSPI_SR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICM_SETSPI_SR_Type v = ( regval_of_bitvector_32(GICM_SETSPI_SR_Type_bits   v))\<close> 
  for  "v"  :: " GICM_SETSPI_SR_Type "


definition GICM_TYPER_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICM_TYPER_Type)option \<close>  where 
     \<open> GICM_TYPER_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICM_TYPER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICM_TYPER_Type  :: \<open> GICM_TYPER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICM_TYPER_Type v = ( regval_of_bitvector_32(GICM_TYPER_Type_bits   v))\<close> 
  for  "v"  :: " GICM_TYPER_Type "


definition GICR_CLRLPIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_CLRLPIR_Type)option \<close>  where 
     \<open> GICR_CLRLPIR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GICR_CLRLPIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_CLRLPIR_Type  :: \<open> GICR_CLRLPIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_CLRLPIR_Type v = ( regval_of_bitvector_64(GICR_CLRLPIR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_CLRLPIR_Type "


definition GICR_CTLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_CTLR_Type)option \<close>  where 
     \<open> GICR_CTLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_CTLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_CTLR_Type  :: \<open> GICR_CTLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_CTLR_Type v = ( regval_of_bitvector_32(GICR_CTLR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_CTLR_Type "


definition GICR_IIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_IIDR_Type)option \<close>  where 
     \<open> GICR_IIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_IIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_IIDR_Type  :: \<open> GICR_IIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_IIDR_Type v = ( regval_of_bitvector_32(GICR_IIDR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_IIDR_Type "


definition GICR_INMIR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_INMIR0_Type)option \<close>  where 
     \<open> GICR_INMIR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_INMIR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_INMIR0_Type  :: \<open> GICR_INMIR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_INMIR0_Type v = ( regval_of_bitvector_32(GICR_INMIR0_Type_bits   v))\<close> 
  for  "v"  :: " GICR_INMIR0_Type "


definition GICR_INVALLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_INVALLR_Type)option \<close>  where 
     \<open> GICR_INVALLR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GICR_INVALLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_INVALLR_Type  :: \<open> GICR_INVALLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_INVALLR_Type v = ( regval_of_bitvector_64(GICR_INVALLR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_INVALLR_Type "


definition GICR_INVLPIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_INVLPIR_Type)option \<close>  where 
     \<open> GICR_INVLPIR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GICR_INVLPIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_INVLPIR_Type  :: \<open> GICR_INVLPIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_INVLPIR_Type v = ( regval_of_bitvector_64(GICR_INVLPIR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_INVLPIR_Type "


definition GICR_ISENABLER0_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_ISENABLER0_Type)option \<close>  where 
     \<open> GICR_ISENABLER0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_ISENABLER0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_ISENABLER0_Type  :: \<open> GICR_ISENABLER0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_ISENABLER0_Type v = ( regval_of_bitvector_32(GICR_ISENABLER0_Type_bits   v))\<close> 
  for  "v"  :: " GICR_ISENABLER0_Type "


definition GICR_MPAMIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_MPAMIDR_Type)option \<close>  where 
     \<open> GICR_MPAMIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_MPAMIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_MPAMIDR_Type  :: \<open> GICR_MPAMIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_MPAMIDR_Type v = ( regval_of_bitvector_32(GICR_MPAMIDR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_MPAMIDR_Type "


definition GICR_PARTIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_PARTIDR_Type)option \<close>  where 
     \<open> GICR_PARTIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_PARTIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_PARTIDR_Type  :: \<open> GICR_PARTIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_PARTIDR_Type v = ( regval_of_bitvector_32(GICR_PARTIDR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_PARTIDR_Type "


definition GICR_PENDBASER_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_PENDBASER_Type)option \<close>  where 
     \<open> GICR_PENDBASER_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GICR_PENDBASER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_PENDBASER_Type  :: \<open> GICR_PENDBASER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_PENDBASER_Type v = ( regval_of_bitvector_64(GICR_PENDBASER_Type_bits   v))\<close> 
  for  "v"  :: " GICR_PENDBASER_Type "


definition GICR_PROPBASER_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_PROPBASER_Type)option \<close>  where 
     \<open> GICR_PROPBASER_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GICR_PROPBASER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_PROPBASER_Type  :: \<open> GICR_PROPBASER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_PROPBASER_Type v = ( regval_of_bitvector_64(GICR_PROPBASER_Type_bits   v))\<close> 
  for  "v"  :: " GICR_PROPBASER_Type "


definition GICR_SETLPIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_SETLPIR_Type)option \<close>  where 
     \<open> GICR_SETLPIR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GICR_SETLPIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_SETLPIR_Type  :: \<open> GICR_SETLPIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_SETLPIR_Type v = ( regval_of_bitvector_64(GICR_SETLPIR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_SETLPIR_Type "


definition GICR_STATUSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_STATUSR_Type)option \<close>  where 
     \<open> GICR_STATUSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_STATUSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_STATUSR_Type  :: \<open> GICR_STATUSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_STATUSR_Type v = ( regval_of_bitvector_32(GICR_STATUSR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_STATUSR_Type "


definition GICR_SYNCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_SYNCR_Type)option \<close>  where 
     \<open> GICR_SYNCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_SYNCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_SYNCR_Type  :: \<open> GICR_SYNCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_SYNCR_Type v = ( regval_of_bitvector_32(GICR_SYNCR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_SYNCR_Type "


definition GICR_VPENDBASER_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_VPENDBASER_Type)option \<close>  where 
     \<open> GICR_VPENDBASER_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GICR_VPENDBASER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_VPENDBASER_Type  :: \<open> GICR_VPENDBASER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_VPENDBASER_Type v = ( regval_of_bitvector_64(GICR_VPENDBASER_Type_bits   v))\<close> 
  for  "v"  :: " GICR_VPENDBASER_Type "


definition GICR_VPROPBASER_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_VPROPBASER_Type)option \<close>  where 
     \<open> GICR_VPROPBASER_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GICR_VPROPBASER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_VPROPBASER_Type  :: \<open> GICR_VPROPBASER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_VPROPBASER_Type v = ( regval_of_bitvector_64(GICR_VPROPBASER_Type_bits   v))\<close> 
  for  "v"  :: " GICR_VPROPBASER_Type "


definition GICR_VSGIPENDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_VSGIPENDR_Type)option \<close>  where 
     \<open> GICR_VSGIPENDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_VSGIPENDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_VSGIPENDR_Type  :: \<open> GICR_VSGIPENDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_VSGIPENDR_Type v = ( regval_of_bitvector_32(GICR_VSGIPENDR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_VSGIPENDR_Type "


definition GICR_VSGIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_VSGIR_Type)option \<close>  where 
     \<open> GICR_VSGIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_VSGIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_VSGIR_Type  :: \<open> GICR_VSGIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_VSGIR_Type v = ( regval_of_bitvector_32(GICR_VSGIR_Type_bits   v))\<close> 
  for  "v"  :: " GICR_VSGIR_Type "


definition GICR_WAKER_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICR_WAKER_Type)option \<close>  where 
     \<open> GICR_WAKER_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICR_WAKER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICR_WAKER_Type  :: \<open> GICR_WAKER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICR_WAKER_Type v = ( regval_of_bitvector_32(GICR_WAKER_Type_bits   v))\<close> 
  for  "v"  :: " GICR_WAKER_Type "


definition GICV_ABPR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_ABPR_Type)option \<close>  where 
     \<open> GICV_ABPR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_ABPR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_ABPR_Type  :: \<open> GICV_ABPR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_ABPR_Type v = ( regval_of_bitvector_32(GICV_ABPR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_ABPR_Type "


definition GICV_AEOIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_AEOIR_Type)option \<close>  where 
     \<open> GICV_AEOIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_AEOIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_AEOIR_Type  :: \<open> GICV_AEOIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_AEOIR_Type v = ( regval_of_bitvector_32(GICV_AEOIR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_AEOIR_Type "


definition GICV_AHPPIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_AHPPIR_Type)option \<close>  where 
     \<open> GICV_AHPPIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_AHPPIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_AHPPIR_Type  :: \<open> GICV_AHPPIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_AHPPIR_Type v = ( regval_of_bitvector_32(GICV_AHPPIR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_AHPPIR_Type "


definition GICV_AIAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_AIAR_Type)option \<close>  where 
     \<open> GICV_AIAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_AIAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_AIAR_Type  :: \<open> GICV_AIAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_AIAR_Type v = ( regval_of_bitvector_32(GICV_AIAR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_AIAR_Type "


definition GICV_BPR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_BPR_Type)option \<close>  where 
     \<open> GICV_BPR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_BPR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_BPR_Type  :: \<open> GICV_BPR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_BPR_Type v = ( regval_of_bitvector_32(GICV_BPR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_BPR_Type "


definition GICV_CTLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_CTLR_Type)option \<close>  where 
     \<open> GICV_CTLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_CTLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_CTLR_Type  :: \<open> GICV_CTLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_CTLR_Type v = ( regval_of_bitvector_32(GICV_CTLR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_CTLR_Type "


definition GICV_DIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_DIR_Type)option \<close>  where 
     \<open> GICV_DIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_DIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_DIR_Type  :: \<open> GICV_DIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_DIR_Type v = ( regval_of_bitvector_32(GICV_DIR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_DIR_Type "


definition GICV_EOIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_EOIR_Type)option \<close>  where 
     \<open> GICV_EOIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_EOIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_EOIR_Type  :: \<open> GICV_EOIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_EOIR_Type v = ( regval_of_bitvector_32(GICV_EOIR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_EOIR_Type "


definition GICV_HPPIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_HPPIR_Type)option \<close>  where 
     \<open> GICV_HPPIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_HPPIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_HPPIR_Type  :: \<open> GICV_HPPIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_HPPIR_Type v = ( regval_of_bitvector_32(GICV_HPPIR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_HPPIR_Type "


definition GICV_IAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_IAR_Type)option \<close>  where 
     \<open> GICV_IAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_IAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_IAR_Type  :: \<open> GICV_IAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_IAR_Type v = ( regval_of_bitvector_32(GICV_IAR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_IAR_Type "


definition GICV_PMR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_PMR_Type)option \<close>  where 
     \<open> GICV_PMR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_PMR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_PMR_Type  :: \<open> GICV_PMR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_PMR_Type v = ( regval_of_bitvector_32(GICV_PMR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_PMR_Type "


definition GICV_RPR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_RPR_Type)option \<close>  where 
     \<open> GICV_RPR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_RPR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_RPR_Type  :: \<open> GICV_RPR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_RPR_Type v = ( regval_of_bitvector_32(GICV_RPR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_RPR_Type "


definition GICV_STATUSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GICV_STATUSR_Type)option \<close>  where 
     \<open> GICV_STATUSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GICV_STATUSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GICV_STATUSR_Type  :: \<open> GICV_STATUSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GICV_STATUSR_Type v = ( regval_of_bitvector_32(GICV_STATUSR_Type_bits   v))\<close> 
  for  "v"  :: " GICV_STATUSR_Type "


definition GITS_CBASER_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_CBASER_Type)option \<close>  where 
     \<open> GITS_CBASER_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GITS_CBASER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_CBASER_Type  :: \<open> GITS_CBASER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_CBASER_Type v = ( regval_of_bitvector_64(GITS_CBASER_Type_bits   v))\<close> 
  for  "v"  :: " GITS_CBASER_Type "


definition GITS_CREADR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_CREADR_Type)option \<close>  where 
     \<open> GITS_CREADR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GITS_CREADR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_CREADR_Type  :: \<open> GITS_CREADR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_CREADR_Type v = ( regval_of_bitvector_64(GITS_CREADR_Type_bits   v))\<close> 
  for  "v"  :: " GITS_CREADR_Type "


definition GITS_CTLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_CTLR_Type)option \<close>  where 
     \<open> GITS_CTLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GITS_CTLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_CTLR_Type  :: \<open> GITS_CTLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_CTLR_Type v = ( regval_of_bitvector_32(GITS_CTLR_Type_bits   v))\<close> 
  for  "v"  :: " GITS_CTLR_Type "


definition GITS_CWRITER_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_CWRITER_Type)option \<close>  where 
     \<open> GITS_CWRITER_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GITS_CWRITER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_CWRITER_Type  :: \<open> GITS_CWRITER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_CWRITER_Type v = ( regval_of_bitvector_64(GITS_CWRITER_Type_bits   v))\<close> 
  for  "v"  :: " GITS_CWRITER_Type "


definition GITS_IIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_IIDR_Type)option \<close>  where 
     \<open> GITS_IIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GITS_IIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_IIDR_Type  :: \<open> GITS_IIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_IIDR_Type v = ( regval_of_bitvector_32(GITS_IIDR_Type_bits   v))\<close> 
  for  "v"  :: " GITS_IIDR_Type "


definition GITS_MPAMIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_MPAMIDR_Type)option \<close>  where 
     \<open> GITS_MPAMIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GITS_MPAMIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_MPAMIDR_Type  :: \<open> GITS_MPAMIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_MPAMIDR_Type v = ( regval_of_bitvector_32(GITS_MPAMIDR_Type_bits   v))\<close> 
  for  "v"  :: " GITS_MPAMIDR_Type "


definition GITS_MPIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_MPIDR_Type)option \<close>  where 
     \<open> GITS_MPIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GITS_MPIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_MPIDR_Type  :: \<open> GITS_MPIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_MPIDR_Type v = ( regval_of_bitvector_32(GITS_MPIDR_Type_bits   v))\<close> 
  for  "v"  :: " GITS_MPIDR_Type "


definition GITS_PARTIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_PARTIDR_Type)option \<close>  where 
     \<open> GITS_PARTIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GITS_PARTIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_PARTIDR_Type  :: \<open> GITS_PARTIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_PARTIDR_Type v = ( regval_of_bitvector_32(GITS_PARTIDR_Type_bits   v))\<close> 
  for  "v"  :: " GITS_PARTIDR_Type "


definition GITS_SGIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_SGIR_Type)option \<close>  where 
     \<open> GITS_SGIR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GITS_SGIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_SGIR_Type  :: \<open> GITS_SGIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_SGIR_Type v = ( regval_of_bitvector_64(GITS_SGIR_Type_bits   v))\<close> 
  for  "v"  :: " GITS_SGIR_Type "


definition GITS_STATUSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_STATUSR_Type)option \<close>  where 
     \<open> GITS_STATUSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| GITS_STATUSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_STATUSR_Type  :: \<open> GITS_STATUSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_STATUSR_Type v = ( regval_of_bitvector_32(GITS_STATUSR_Type_bits   v))\<close> 
  for  "v"  :: " GITS_STATUSR_Type "


definition GITS_TYPER_Type_of_regval  :: \<open> register_value \<Rightarrow>(GITS_TYPER_Type)option \<close>  where 
     \<open> GITS_TYPER_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GITS_TYPER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GITS_TYPER_Type  :: \<open> GITS_TYPER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GITS_TYPER_Type v = ( regval_of_bitvector_64(GITS_TYPER_Type_bits   v))\<close> 
  for  "v"  :: " GITS_TYPER_Type "


definition GMID_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(GMID_EL1_Type)option \<close>  where 
     \<open> GMID_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GMID_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GMID_EL1_Type  :: \<open> GMID_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GMID_EL1_Type v = ( regval_of_bitvector_64(GMID_EL1_Type_bits   v))\<close> 
  for  "v"  :: " GMID_EL1_Type "


definition GPCCR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(GPCCR_EL3_Type)option \<close>  where 
     \<open> GPCCR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GPCCR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GPCCR_EL3_Type  :: \<open> GPCCR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GPCCR_EL3_Type v = ( regval_of_bitvector_64(GPCCR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " GPCCR_EL3_Type "


definition GPTBR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(GPTBR_EL3_Type)option \<close>  where 
     \<open> GPTBR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| GPTBR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_GPTBR_EL3_Type  :: \<open> GPTBR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_GPTBR_EL3_Type v = ( regval_of_bitvector_64(GPTBR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " GPTBR_EL3_Type "


definition HAFGRTR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HAFGRTR_EL2_Type)option \<close>  where 
     \<open> HAFGRTR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HAFGRTR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HAFGRTR_EL2_Type  :: \<open> HAFGRTR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HAFGRTR_EL2_Type v = ( regval_of_bitvector_64(HAFGRTR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HAFGRTR_EL2_Type "


definition HCPTR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HCPTR_Type)option \<close>  where 
     \<open> HCPTR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HCPTR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HCPTR_Type  :: \<open> HCPTR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HCPTR_Type v = ( regval_of_bitvector_32(HCPTR_Type_bits   v))\<close> 
  for  "v"  :: " HCPTR_Type "


definition HCR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HCR2_Type)option \<close>  where 
     \<open> HCR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HCR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HCR2_Type  :: \<open> HCR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HCR2_Type v = ( regval_of_bitvector_32(HCR2_Type_bits   v))\<close> 
  for  "v"  :: " HCR2_Type "


definition HCRX_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HCRX_EL2_Type)option \<close>  where 
     \<open> HCRX_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HCRX_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HCRX_EL2_Type  :: \<open> HCRX_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HCRX_EL2_Type v = ( regval_of_bitvector_64(HCRX_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HCRX_EL2_Type "


definition HCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HCR_EL2_Type)option \<close>  where 
     \<open> HCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HCR_EL2_Type  :: \<open> HCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HCR_EL2_Type v = ( regval_of_bitvector_64(HCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HCR_EL2_Type "


definition HCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HCR_Type)option \<close>  where 
     \<open> HCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HCR_Type  :: \<open> HCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HCR_Type v = ( regval_of_bitvector_32(HCR_Type_bits   v))\<close> 
  for  "v"  :: " HCR_Type "


definition HDCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HDCR_Type)option \<close>  where 
     \<open> HDCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HDCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HDCR_Type  :: \<open> HDCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HDCR_Type v = ( regval_of_bitvector_32(HDCR_Type_bits   v))\<close> 
  for  "v"  :: " HDCR_Type "


definition HDFGRTR2_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HDFGRTR2_EL2_Type)option \<close>  where 
     \<open> HDFGRTR2_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HDFGRTR2_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HDFGRTR2_EL2_Type  :: \<open> HDFGRTR2_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HDFGRTR2_EL2_Type v = ( regval_of_bitvector_64(HDFGRTR2_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HDFGRTR2_EL2_Type "


definition HDFGRTR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HDFGRTR_EL2_Type)option \<close>  where 
     \<open> HDFGRTR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HDFGRTR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HDFGRTR_EL2_Type  :: \<open> HDFGRTR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HDFGRTR_EL2_Type v = ( regval_of_bitvector_64(HDFGRTR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HDFGRTR_EL2_Type "


definition HDFGWTR2_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HDFGWTR2_EL2_Type)option \<close>  where 
     \<open> HDFGWTR2_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HDFGWTR2_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HDFGWTR2_EL2_Type  :: \<open> HDFGWTR2_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HDFGWTR2_EL2_Type v = ( regval_of_bitvector_64(HDFGWTR2_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HDFGWTR2_EL2_Type "


definition HDFGWTR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HDFGWTR_EL2_Type)option \<close>  where 
     \<open> HDFGWTR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HDFGWTR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HDFGWTR_EL2_Type  :: \<open> HDFGWTR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HDFGWTR_EL2_Type v = ( regval_of_bitvector_64(HDFGWTR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HDFGWTR_EL2_Type "


definition HFGITR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HFGITR_EL2_Type)option \<close>  where 
     \<open> HFGITR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HFGITR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HFGITR_EL2_Type  :: \<open> HFGITR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HFGITR_EL2_Type v = ( regval_of_bitvector_64(HFGITR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HFGITR_EL2_Type "


definition HFGRTR2_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HFGRTR2_EL2_Type)option \<close>  where 
     \<open> HFGRTR2_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HFGRTR2_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HFGRTR2_EL2_Type  :: \<open> HFGRTR2_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HFGRTR2_EL2_Type v = ( regval_of_bitvector_64(HFGRTR2_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HFGRTR2_EL2_Type "


definition HFGRTR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HFGRTR_EL2_Type)option \<close>  where 
     \<open> HFGRTR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HFGRTR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HFGRTR_EL2_Type  :: \<open> HFGRTR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HFGRTR_EL2_Type v = ( regval_of_bitvector_64(HFGRTR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HFGRTR_EL2_Type "


definition HFGWTR2_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HFGWTR2_EL2_Type)option \<close>  where 
     \<open> HFGWTR2_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HFGWTR2_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HFGWTR2_EL2_Type  :: \<open> HFGWTR2_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HFGWTR2_EL2_Type v = ( regval_of_bitvector_64(HFGWTR2_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HFGWTR2_EL2_Type "


definition HFGWTR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HFGWTR_EL2_Type)option \<close>  where 
     \<open> HFGWTR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HFGWTR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HFGWTR_EL2_Type  :: \<open> HFGWTR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HFGWTR_EL2_Type v = ( regval_of_bitvector_64(HFGWTR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HFGWTR_EL2_Type "


definition HMAIR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(HMAIR0_Type)option \<close>  where 
     \<open> HMAIR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HMAIR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HMAIR0_Type  :: \<open> HMAIR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HMAIR0_Type v = ( regval_of_bitvector_32(HMAIR0_Type_bits   v))\<close> 
  for  "v"  :: " HMAIR0_Type "


definition HMAIR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(HMAIR1_Type)option \<close>  where 
     \<open> HMAIR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HMAIR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HMAIR1_Type  :: \<open> HMAIR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HMAIR1_Type v = ( regval_of_bitvector_32(HMAIR1_Type_bits   v))\<close> 
  for  "v"  :: " HMAIR1_Type "


definition HPFAR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HPFAR_EL2_Type)option \<close>  where 
     \<open> HPFAR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HPFAR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HPFAR_EL2_Type  :: \<open> HPFAR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HPFAR_EL2_Type v = ( regval_of_bitvector_64(HPFAR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HPFAR_EL2_Type "


definition HPFAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HPFAR_Type)option \<close>  where 
     \<open> HPFAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HPFAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HPFAR_Type  :: \<open> HPFAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HPFAR_Type v = ( regval_of_bitvector_32(HPFAR_Type_bits   v))\<close> 
  for  "v"  :: " HPFAR_Type "


definition HRMR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HRMR_Type)option \<close>  where 
     \<open> HRMR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HRMR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HRMR_Type  :: \<open> HRMR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HRMR_Type v = ( regval_of_bitvector_32(HRMR_Type_bits   v))\<close> 
  for  "v"  :: " HRMR_Type "


definition HSCTLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HSCTLR_Type)option \<close>  where 
     \<open> HSCTLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HSCTLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HSCTLR_Type  :: \<open> HSCTLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HSCTLR_Type v = ( regval_of_bitvector_32(HSCTLR_Type_bits   v))\<close> 
  for  "v"  :: " HSCTLR_Type "


definition HSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HSR_Type)option \<close>  where 
     \<open> HSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HSR_Type  :: \<open> HSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HSR_Type v = ( regval_of_bitvector_32(HSR_Type_bits   v))\<close> 
  for  "v"  :: " HSR_Type "


definition HSTR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(HSTR_EL2_Type)option \<close>  where 
     \<open> HSTR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HSTR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HSTR_EL2_Type  :: \<open> HSTR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HSTR_EL2_Type v = ( regval_of_bitvector_64(HSTR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " HSTR_EL2_Type "


definition HSTR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HSTR_Type)option \<close>  where 
     \<open> HSTR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HSTR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HSTR_Type  :: \<open> HSTR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HSTR_Type v = ( regval_of_bitvector_32(HSTR_Type_bits   v))\<close> 
  for  "v"  :: " HSTR_Type "


definition HTCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HTCR_Type)option \<close>  where 
     \<open> HTCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HTCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HTCR_Type  :: \<open> HTCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HTCR_Type v = ( regval_of_bitvector_32(HTCR_Type_bits   v))\<close> 
  for  "v"  :: " HTCR_Type "


definition HTRFCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HTRFCR_Type)option \<close>  where 
     \<open> HTRFCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| HTRFCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HTRFCR_Type  :: \<open> HTRFCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HTRFCR_Type v = ( regval_of_bitvector_32(HTRFCR_Type_bits   v))\<close> 
  for  "v"  :: " HTRFCR_Type "


definition HTTBR_Type_of_regval  :: \<open> register_value \<Rightarrow>(HTTBR_Type)option \<close>  where 
     \<open> HTTBR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| HTTBR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_HTTBR_Type  :: \<open> HTTBR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_HTTBR_Type v = ( regval_of_bitvector_64(HTTBR_Type_bits   v))\<close> 
  for  "v"  :: " HTTBR_Type "


definition ICC_AP1R_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_AP1R_EL1_Type)option \<close>  where 
     \<open> ICC_AP1R_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_AP1R_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_AP1R_EL1_Type  :: \<open> ICC_AP1R_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_AP1R_EL1_Type v = ( regval_of_bitvector_64(ICC_AP1R_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_AP1R_EL1_Type "


definition ICC_ASGI1R_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_ASGI1R_EL1_Type)option \<close>  where 
     \<open> ICC_ASGI1R_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_ASGI1R_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_ASGI1R_EL1_Type  :: \<open> ICC_ASGI1R_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_ASGI1R_EL1_Type v = ( regval_of_bitvector_64(ICC_ASGI1R_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_ASGI1R_EL1_Type "


definition ICC_ASGI1R_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_ASGI1R_Type)option \<close>  where 
     \<open> ICC_ASGI1R_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_ASGI1R_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_ASGI1R_Type  :: \<open> ICC_ASGI1R_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_ASGI1R_Type v = ( regval_of_bitvector_64(ICC_ASGI1R_Type_bits   v))\<close> 
  for  "v"  :: " ICC_ASGI1R_Type "


definition ICC_BPR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_BPR0_EL1_Type)option \<close>  where 
     \<open> ICC_BPR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_BPR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_BPR0_EL1_Type  :: \<open> ICC_BPR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_BPR0_EL1_Type v = ( regval_of_bitvector_64(ICC_BPR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_BPR0_EL1_Type "


definition ICC_BPR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_BPR0_Type)option \<close>  where 
     \<open> ICC_BPR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_BPR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_BPR0_Type  :: \<open> ICC_BPR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_BPR0_Type v = ( regval_of_bitvector_32(ICC_BPR0_Type_bits   v))\<close> 
  for  "v"  :: " ICC_BPR0_Type "


definition ICC_BPR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_BPR1_EL1_Type)option \<close>  where 
     \<open> ICC_BPR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_BPR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_BPR1_EL1_Type  :: \<open> ICC_BPR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_BPR1_EL1_Type v = ( regval_of_bitvector_64(ICC_BPR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_BPR1_EL1_Type "


definition ICC_BPR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_BPR1_Type)option \<close>  where 
     \<open> ICC_BPR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_BPR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_BPR1_Type  :: \<open> ICC_BPR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_BPR1_Type v = ( regval_of_bitvector_32(ICC_BPR1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_BPR1_Type "


definition ICC_CTLR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_CTLR_EL1_Type)option \<close>  where 
     \<open> ICC_CTLR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_CTLR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_CTLR_EL1_Type  :: \<open> ICC_CTLR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_CTLR_EL1_Type v = ( regval_of_bitvector_64(ICC_CTLR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_CTLR_EL1_Type "


definition ICC_CTLR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_CTLR_EL3_Type)option \<close>  where 
     \<open> ICC_CTLR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_CTLR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_CTLR_EL3_Type  :: \<open> ICC_CTLR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_CTLR_EL3_Type v = ( regval_of_bitvector_64(ICC_CTLR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " ICC_CTLR_EL3_Type "


definition ICC_CTLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_CTLR_Type)option \<close>  where 
     \<open> ICC_CTLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_CTLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_CTLR_Type  :: \<open> ICC_CTLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_CTLR_Type v = ( regval_of_bitvector_32(ICC_CTLR_Type_bits   v))\<close> 
  for  "v"  :: " ICC_CTLR_Type "


definition ICC_DIR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_DIR_EL1_Type)option \<close>  where 
     \<open> ICC_DIR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_DIR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_DIR_EL1_Type  :: \<open> ICC_DIR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_DIR_EL1_Type v = ( regval_of_bitvector_64(ICC_DIR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_DIR_EL1_Type "


definition ICC_DIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_DIR_Type)option \<close>  where 
     \<open> ICC_DIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_DIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_DIR_Type  :: \<open> ICC_DIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_DIR_Type v = ( regval_of_bitvector_32(ICC_DIR_Type_bits   v))\<close> 
  for  "v"  :: " ICC_DIR_Type "


definition ICC_EOIR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_EOIR0_EL1_Type)option \<close>  where 
     \<open> ICC_EOIR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_EOIR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_EOIR0_EL1_Type  :: \<open> ICC_EOIR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_EOIR0_EL1_Type v = ( regval_of_bitvector_64(ICC_EOIR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_EOIR0_EL1_Type "


definition ICC_EOIR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_EOIR0_Type)option \<close>  where 
     \<open> ICC_EOIR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_EOIR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_EOIR0_Type  :: \<open> ICC_EOIR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_EOIR0_Type v = ( regval_of_bitvector_32(ICC_EOIR0_Type_bits   v))\<close> 
  for  "v"  :: " ICC_EOIR0_Type "


definition ICC_EOIR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_EOIR1_EL1_Type)option \<close>  where 
     \<open> ICC_EOIR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_EOIR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_EOIR1_EL1_Type  :: \<open> ICC_EOIR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_EOIR1_EL1_Type v = ( regval_of_bitvector_64(ICC_EOIR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_EOIR1_EL1_Type "


definition ICC_EOIR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_EOIR1_Type)option \<close>  where 
     \<open> ICC_EOIR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_EOIR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_EOIR1_Type  :: \<open> ICC_EOIR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_EOIR1_Type v = ( regval_of_bitvector_32(ICC_EOIR1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_EOIR1_Type "


definition ICC_HPPIR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_HPPIR0_EL1_Type)option \<close>  where 
     \<open> ICC_HPPIR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_HPPIR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_HPPIR0_EL1_Type  :: \<open> ICC_HPPIR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_HPPIR0_EL1_Type v = ( regval_of_bitvector_64(ICC_HPPIR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_HPPIR0_EL1_Type "


definition ICC_HPPIR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_HPPIR0_Type)option \<close>  where 
     \<open> ICC_HPPIR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_HPPIR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_HPPIR0_Type  :: \<open> ICC_HPPIR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_HPPIR0_Type v = ( regval_of_bitvector_32(ICC_HPPIR0_Type_bits   v))\<close> 
  for  "v"  :: " ICC_HPPIR0_Type "


definition ICC_HPPIR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_HPPIR1_EL1_Type)option \<close>  where 
     \<open> ICC_HPPIR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_HPPIR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_HPPIR1_EL1_Type  :: \<open> ICC_HPPIR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_HPPIR1_EL1_Type v = ( regval_of_bitvector_64(ICC_HPPIR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_HPPIR1_EL1_Type "


definition ICC_HPPIR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_HPPIR1_Type)option \<close>  where 
     \<open> ICC_HPPIR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_HPPIR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_HPPIR1_Type  :: \<open> ICC_HPPIR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_HPPIR1_Type v = ( regval_of_bitvector_32(ICC_HPPIR1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_HPPIR1_Type "


definition ICC_HSRE_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_HSRE_Type)option \<close>  where 
     \<open> ICC_HSRE_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_HSRE_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_HSRE_Type  :: \<open> ICC_HSRE_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_HSRE_Type v = ( regval_of_bitvector_32(ICC_HSRE_Type_bits   v))\<close> 
  for  "v"  :: " ICC_HSRE_Type "


definition ICC_IAR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_IAR0_EL1_Type)option \<close>  where 
     \<open> ICC_IAR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_IAR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_IAR0_EL1_Type  :: \<open> ICC_IAR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_IAR0_EL1_Type v = ( regval_of_bitvector_64(ICC_IAR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_IAR0_EL1_Type "


definition ICC_IAR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_IAR0_Type)option \<close>  where 
     \<open> ICC_IAR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_IAR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_IAR0_Type  :: \<open> ICC_IAR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_IAR0_Type v = ( regval_of_bitvector_32(ICC_IAR0_Type_bits   v))\<close> 
  for  "v"  :: " ICC_IAR0_Type "


definition ICC_IAR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_IAR1_EL1_Type)option \<close>  where 
     \<open> ICC_IAR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_IAR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_IAR1_EL1_Type  :: \<open> ICC_IAR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_IAR1_EL1_Type v = ( regval_of_bitvector_64(ICC_IAR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_IAR1_EL1_Type "


definition ICC_IAR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_IAR1_Type)option \<close>  where 
     \<open> ICC_IAR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_IAR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_IAR1_Type  :: \<open> ICC_IAR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_IAR1_Type v = ( regval_of_bitvector_32(ICC_IAR1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_IAR1_Type "


definition ICC_IGRPEN0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_IGRPEN0_EL1_Type)option \<close>  where 
     \<open> ICC_IGRPEN0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_IGRPEN0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_IGRPEN0_EL1_Type  :: \<open> ICC_IGRPEN0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_IGRPEN0_EL1_Type v = ( regval_of_bitvector_64(ICC_IGRPEN0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_IGRPEN0_EL1_Type "


definition ICC_IGRPEN0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_IGRPEN0_Type)option \<close>  where 
     \<open> ICC_IGRPEN0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_IGRPEN0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_IGRPEN0_Type  :: \<open> ICC_IGRPEN0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_IGRPEN0_Type v = ( regval_of_bitvector_32(ICC_IGRPEN0_Type_bits   v))\<close> 
  for  "v"  :: " ICC_IGRPEN0_Type "


definition ICC_IGRPEN1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_IGRPEN1_EL1_Type)option \<close>  where 
     \<open> ICC_IGRPEN1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_IGRPEN1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_IGRPEN1_EL1_Type  :: \<open> ICC_IGRPEN1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_IGRPEN1_EL1_Type v = ( regval_of_bitvector_64(ICC_IGRPEN1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_IGRPEN1_EL1_Type "


definition ICC_IGRPEN1_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_IGRPEN1_EL3_Type)option \<close>  where 
     \<open> ICC_IGRPEN1_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_IGRPEN1_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_IGRPEN1_EL3_Type  :: \<open> ICC_IGRPEN1_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_IGRPEN1_EL3_Type v = ( regval_of_bitvector_64(ICC_IGRPEN1_EL3_Type_bits   v))\<close> 
  for  "v"  :: " ICC_IGRPEN1_EL3_Type "


definition ICC_IGRPEN1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_IGRPEN1_Type)option \<close>  where 
     \<open> ICC_IGRPEN1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_IGRPEN1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_IGRPEN1_Type  :: \<open> ICC_IGRPEN1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_IGRPEN1_Type v = ( regval_of_bitvector_32(ICC_IGRPEN1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_IGRPEN1_Type "


definition ICC_MCTLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_MCTLR_Type)option \<close>  where 
     \<open> ICC_MCTLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_MCTLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_MCTLR_Type  :: \<open> ICC_MCTLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_MCTLR_Type v = ( regval_of_bitvector_32(ICC_MCTLR_Type_bits   v))\<close> 
  for  "v"  :: " ICC_MCTLR_Type "


definition ICC_MGRPEN1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_MGRPEN1_Type)option \<close>  where 
     \<open> ICC_MGRPEN1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_MGRPEN1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_MGRPEN1_Type  :: \<open> ICC_MGRPEN1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_MGRPEN1_Type v = ( regval_of_bitvector_32(ICC_MGRPEN1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_MGRPEN1_Type "


definition ICC_MSRE_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_MSRE_Type)option \<close>  where 
     \<open> ICC_MSRE_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_MSRE_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_MSRE_Type  :: \<open> ICC_MSRE_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_MSRE_Type v = ( regval_of_bitvector_32(ICC_MSRE_Type_bits   v))\<close> 
  for  "v"  :: " ICC_MSRE_Type "


definition ICC_NMIAR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_NMIAR1_EL1_Type)option \<close>  where 
     \<open> ICC_NMIAR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_NMIAR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_NMIAR1_EL1_Type  :: \<open> ICC_NMIAR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_NMIAR1_EL1_Type v = ( regval_of_bitvector_64(ICC_NMIAR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_NMIAR1_EL1_Type "


definition ICC_PMR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_PMR_EL1_Type)option \<close>  where 
     \<open> ICC_PMR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_PMR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_PMR_EL1_Type  :: \<open> ICC_PMR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_PMR_EL1_Type v = ( regval_of_bitvector_64(ICC_PMR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_PMR_EL1_Type "


definition ICC_PMR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_PMR_Type)option \<close>  where 
     \<open> ICC_PMR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_PMR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_PMR_Type  :: \<open> ICC_PMR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_PMR_Type v = ( regval_of_bitvector_32(ICC_PMR_Type_bits   v))\<close> 
  for  "v"  :: " ICC_PMR_Type "


definition ICC_RPR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_RPR_EL1_Type)option \<close>  where 
     \<open> ICC_RPR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_RPR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_RPR_EL1_Type  :: \<open> ICC_RPR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_RPR_EL1_Type v = ( regval_of_bitvector_64(ICC_RPR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_RPR_EL1_Type "


definition ICC_RPR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_RPR_Type)option \<close>  where 
     \<open> ICC_RPR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_RPR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_RPR_Type  :: \<open> ICC_RPR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_RPR_Type v = ( regval_of_bitvector_32(ICC_RPR_Type_bits   v))\<close> 
  for  "v"  :: " ICC_RPR_Type "


definition ICC_SGI0R_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_SGI0R_EL1_Type)option \<close>  where 
     \<open> ICC_SGI0R_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_SGI0R_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_SGI0R_EL1_Type  :: \<open> ICC_SGI0R_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_SGI0R_EL1_Type v = ( regval_of_bitvector_64(ICC_SGI0R_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_SGI0R_EL1_Type "


definition ICC_SGI0R_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_SGI0R_Type)option \<close>  where 
     \<open> ICC_SGI0R_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_SGI0R_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_SGI0R_Type  :: \<open> ICC_SGI0R_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_SGI0R_Type v = ( regval_of_bitvector_64(ICC_SGI0R_Type_bits   v))\<close> 
  for  "v"  :: " ICC_SGI0R_Type "


definition ICC_SGI1R_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_SGI1R_EL1_Type)option \<close>  where 
     \<open> ICC_SGI1R_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_SGI1R_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_SGI1R_EL1_Type  :: \<open> ICC_SGI1R_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_SGI1R_EL1_Type v = ( regval_of_bitvector_64(ICC_SGI1R_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_SGI1R_EL1_Type "


definition ICC_SGI1R_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_SGI1R_Type)option \<close>  where 
     \<open> ICC_SGI1R_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_SGI1R_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_SGI1R_Type  :: \<open> ICC_SGI1R_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_SGI1R_Type v = ( regval_of_bitvector_64(ICC_SGI1R_Type_bits   v))\<close> 
  for  "v"  :: " ICC_SGI1R_Type "


definition ICC_SRE_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_SRE_EL1_Type)option \<close>  where 
     \<open> ICC_SRE_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_SRE_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_SRE_EL1_Type  :: \<open> ICC_SRE_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_SRE_EL1_Type v = ( regval_of_bitvector_64(ICC_SRE_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICC_SRE_EL1_Type "


definition ICC_SRE_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_SRE_EL2_Type)option \<close>  where 
     \<open> ICC_SRE_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_SRE_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_SRE_EL2_Type  :: \<open> ICC_SRE_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_SRE_EL2_Type v = ( regval_of_bitvector_64(ICC_SRE_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ICC_SRE_EL2_Type "


definition ICC_SRE_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_SRE_EL3_Type)option \<close>  where 
     \<open> ICC_SRE_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICC_SRE_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_SRE_EL3_Type  :: \<open> ICC_SRE_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_SRE_EL3_Type v = ( regval_of_bitvector_64(ICC_SRE_EL3_Type_bits   v))\<close> 
  for  "v"  :: " ICC_SRE_EL3_Type "


definition ICC_SRE_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICC_SRE_Type)option \<close>  where 
     \<open> ICC_SRE_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICC_SRE_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICC_SRE_Type  :: \<open> ICC_SRE_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICC_SRE_Type v = ( regval_of_bitvector_32(ICC_SRE_Type_bits   v))\<close> 
  for  "v"  :: " ICC_SRE_Type "


definition ICH_AP0R_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_AP0R_EL2_Type)option \<close>  where 
     \<open> ICH_AP0R_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICH_AP0R_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_AP0R_EL2_Type  :: \<open> ICH_AP0R_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_AP0R_EL2_Type v = ( regval_of_bitvector_64(ICH_AP0R_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ICH_AP0R_EL2_Type "


definition ICH_AP0R_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_AP0R_Type)option \<close>  where 
     \<open> ICH_AP0R_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICH_AP0R_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_AP0R_Type  :: \<open> ICH_AP0R_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_AP0R_Type v = ( regval_of_bitvector_32(ICH_AP0R_Type_bits   v))\<close> 
  for  "v"  :: " ICH_AP0R_Type "


definition ICH_AP1R_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_AP1R_EL2_Type)option \<close>  where 
     \<open> ICH_AP1R_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICH_AP1R_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_AP1R_EL2_Type  :: \<open> ICH_AP1R_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_AP1R_EL2_Type v = ( regval_of_bitvector_64(ICH_AP1R_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ICH_AP1R_EL2_Type "


definition ICH_AP1R_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_AP1R_Type)option \<close>  where 
     \<open> ICH_AP1R_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICH_AP1R_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_AP1R_Type  :: \<open> ICH_AP1R_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_AP1R_Type v = ( regval_of_bitvector_32(ICH_AP1R_Type_bits   v))\<close> 
  for  "v"  :: " ICH_AP1R_Type "


definition ICH_EISR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_EISR_EL2_Type)option \<close>  where 
     \<open> ICH_EISR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICH_EISR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_EISR_EL2_Type  :: \<open> ICH_EISR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_EISR_EL2_Type v = ( regval_of_bitvector_64(ICH_EISR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ICH_EISR_EL2_Type "


definition ICH_EISR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_EISR_Type)option \<close>  where 
     \<open> ICH_EISR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICH_EISR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_EISR_Type  :: \<open> ICH_EISR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_EISR_Type v = ( regval_of_bitvector_32(ICH_EISR_Type_bits   v))\<close> 
  for  "v"  :: " ICH_EISR_Type "


definition ICH_ELRSR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_ELRSR_EL2_Type)option \<close>  where 
     \<open> ICH_ELRSR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICH_ELRSR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_ELRSR_EL2_Type  :: \<open> ICH_ELRSR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_ELRSR_EL2_Type v = ( regval_of_bitvector_64(ICH_ELRSR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ICH_ELRSR_EL2_Type "


definition ICH_ELRSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_ELRSR_Type)option \<close>  where 
     \<open> ICH_ELRSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICH_ELRSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_ELRSR_Type  :: \<open> ICH_ELRSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_ELRSR_Type v = ( regval_of_bitvector_32(ICH_ELRSR_Type_bits   v))\<close> 
  for  "v"  :: " ICH_ELRSR_Type "


definition ICH_HCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_HCR_EL2_Type)option \<close>  where 
     \<open> ICH_HCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICH_HCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_HCR_EL2_Type  :: \<open> ICH_HCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_HCR_EL2_Type v = ( regval_of_bitvector_64(ICH_HCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ICH_HCR_EL2_Type "


definition ICH_HCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_HCR_Type)option \<close>  where 
     \<open> ICH_HCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICH_HCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_HCR_Type  :: \<open> ICH_HCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_HCR_Type v = ( regval_of_bitvector_32(ICH_HCR_Type_bits   v))\<close> 
  for  "v"  :: " ICH_HCR_Type "


definition ICH_LRC_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_LRC_Type)option \<close>  where 
     \<open> ICH_LRC_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICH_LRC_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_LRC_Type  :: \<open> ICH_LRC_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_LRC_Type v = ( regval_of_bitvector_32(ICH_LRC_Type_bits   v))\<close> 
  for  "v"  :: " ICH_LRC_Type "


definition ICH_LR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_LR_EL2_Type)option \<close>  where 
     \<open> ICH_LR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICH_LR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_LR_EL2_Type  :: \<open> ICH_LR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_LR_EL2_Type v = ( regval_of_bitvector_64(ICH_LR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ICH_LR_EL2_Type "


definition ICH_LR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_LR_Type)option \<close>  where 
     \<open> ICH_LR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICH_LR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_LR_Type  :: \<open> ICH_LR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_LR_Type v = ( regval_of_bitvector_32(ICH_LR_Type_bits   v))\<close> 
  for  "v"  :: " ICH_LR_Type "


definition ICH_MISR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_MISR_EL2_Type)option \<close>  where 
     \<open> ICH_MISR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICH_MISR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_MISR_EL2_Type  :: \<open> ICH_MISR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_MISR_EL2_Type v = ( regval_of_bitvector_64(ICH_MISR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ICH_MISR_EL2_Type "


definition ICH_MISR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_MISR_Type)option \<close>  where 
     \<open> ICH_MISR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICH_MISR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_MISR_Type  :: \<open> ICH_MISR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_MISR_Type v = ( regval_of_bitvector_32(ICH_MISR_Type_bits   v))\<close> 
  for  "v"  :: " ICH_MISR_Type "


definition ICH_VMCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_VMCR_EL2_Type)option \<close>  where 
     \<open> ICH_VMCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICH_VMCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_VMCR_EL2_Type  :: \<open> ICH_VMCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_VMCR_EL2_Type v = ( regval_of_bitvector_64(ICH_VMCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ICH_VMCR_EL2_Type "


definition ICH_VMCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_VMCR_Type)option \<close>  where 
     \<open> ICH_VMCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICH_VMCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_VMCR_Type  :: \<open> ICH_VMCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_VMCR_Type v = ( regval_of_bitvector_32(ICH_VMCR_Type_bits   v))\<close> 
  for  "v"  :: " ICH_VMCR_Type "


definition ICH_VTR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_VTR_EL2_Type)option \<close>  where 
     \<open> ICH_VTR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICH_VTR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_VTR_EL2_Type  :: \<open> ICH_VTR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_VTR_EL2_Type v = ( regval_of_bitvector_64(ICH_VTR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ICH_VTR_EL2_Type "


definition ICH_VTR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICH_VTR_Type)option \<close>  where 
     \<open> ICH_VTR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICH_VTR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICH_VTR_Type  :: \<open> ICH_VTR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICH_VTR_Type v = ( regval_of_bitvector_32(ICH_VTR_Type_bits   v))\<close> 
  for  "v"  :: " ICH_VTR_Type "


definition ICV_AP1R_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_AP1R_EL1_Type)option \<close>  where 
     \<open> ICV_AP1R_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_AP1R_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_AP1R_EL1_Type  :: \<open> ICV_AP1R_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_AP1R_EL1_Type v = ( regval_of_bitvector_64(ICV_AP1R_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_AP1R_EL1_Type "


definition ICV_BPR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_BPR0_EL1_Type)option \<close>  where 
     \<open> ICV_BPR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_BPR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_BPR0_EL1_Type  :: \<open> ICV_BPR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_BPR0_EL1_Type v = ( regval_of_bitvector_64(ICV_BPR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_BPR0_EL1_Type "


definition ICV_BPR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_BPR0_Type)option \<close>  where 
     \<open> ICV_BPR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_BPR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_BPR0_Type  :: \<open> ICV_BPR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_BPR0_Type v = ( regval_of_bitvector_32(ICV_BPR0_Type_bits   v))\<close> 
  for  "v"  :: " ICV_BPR0_Type "


definition ICV_BPR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_BPR1_EL1_Type)option \<close>  where 
     \<open> ICV_BPR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_BPR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_BPR1_EL1_Type  :: \<open> ICV_BPR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_BPR1_EL1_Type v = ( regval_of_bitvector_64(ICV_BPR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_BPR1_EL1_Type "


definition ICV_BPR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_BPR1_Type)option \<close>  where 
     \<open> ICV_BPR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_BPR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_BPR1_Type  :: \<open> ICV_BPR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_BPR1_Type v = ( regval_of_bitvector_32(ICV_BPR1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_BPR1_Type "


definition ICV_CTLR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_CTLR_EL1_Type)option \<close>  where 
     \<open> ICV_CTLR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_CTLR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_CTLR_EL1_Type  :: \<open> ICV_CTLR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_CTLR_EL1_Type v = ( regval_of_bitvector_64(ICV_CTLR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_CTLR_EL1_Type "


definition ICV_CTLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_CTLR_Type)option \<close>  where 
     \<open> ICV_CTLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_CTLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_CTLR_Type  :: \<open> ICV_CTLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_CTLR_Type v = ( regval_of_bitvector_32(ICV_CTLR_Type_bits   v))\<close> 
  for  "v"  :: " ICV_CTLR_Type "


definition ICV_DIR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_DIR_EL1_Type)option \<close>  where 
     \<open> ICV_DIR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_DIR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_DIR_EL1_Type  :: \<open> ICV_DIR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_DIR_EL1_Type v = ( regval_of_bitvector_64(ICV_DIR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_DIR_EL1_Type "


definition ICV_DIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_DIR_Type)option \<close>  where 
     \<open> ICV_DIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_DIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_DIR_Type  :: \<open> ICV_DIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_DIR_Type v = ( regval_of_bitvector_32(ICV_DIR_Type_bits   v))\<close> 
  for  "v"  :: " ICV_DIR_Type "


definition ICV_EOIR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_EOIR0_EL1_Type)option \<close>  where 
     \<open> ICV_EOIR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_EOIR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_EOIR0_EL1_Type  :: \<open> ICV_EOIR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_EOIR0_EL1_Type v = ( regval_of_bitvector_64(ICV_EOIR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_EOIR0_EL1_Type "


definition ICV_EOIR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_EOIR0_Type)option \<close>  where 
     \<open> ICV_EOIR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_EOIR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_EOIR0_Type  :: \<open> ICV_EOIR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_EOIR0_Type v = ( regval_of_bitvector_32(ICV_EOIR0_Type_bits   v))\<close> 
  for  "v"  :: " ICV_EOIR0_Type "


definition ICV_EOIR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_EOIR1_EL1_Type)option \<close>  where 
     \<open> ICV_EOIR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_EOIR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_EOIR1_EL1_Type  :: \<open> ICV_EOIR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_EOIR1_EL1_Type v = ( regval_of_bitvector_64(ICV_EOIR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_EOIR1_EL1_Type "


definition ICV_EOIR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_EOIR1_Type)option \<close>  where 
     \<open> ICV_EOIR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_EOIR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_EOIR1_Type  :: \<open> ICV_EOIR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_EOIR1_Type v = ( regval_of_bitvector_32(ICV_EOIR1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_EOIR1_Type "


definition ICV_HPPIR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_HPPIR0_EL1_Type)option \<close>  where 
     \<open> ICV_HPPIR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_HPPIR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_HPPIR0_EL1_Type  :: \<open> ICV_HPPIR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_HPPIR0_EL1_Type v = ( regval_of_bitvector_64(ICV_HPPIR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_HPPIR0_EL1_Type "


definition ICV_HPPIR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_HPPIR0_Type)option \<close>  where 
     \<open> ICV_HPPIR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_HPPIR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_HPPIR0_Type  :: \<open> ICV_HPPIR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_HPPIR0_Type v = ( regval_of_bitvector_32(ICV_HPPIR0_Type_bits   v))\<close> 
  for  "v"  :: " ICV_HPPIR0_Type "


definition ICV_HPPIR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_HPPIR1_EL1_Type)option \<close>  where 
     \<open> ICV_HPPIR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_HPPIR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_HPPIR1_EL1_Type  :: \<open> ICV_HPPIR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_HPPIR1_EL1_Type v = ( regval_of_bitvector_64(ICV_HPPIR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_HPPIR1_EL1_Type "


definition ICV_HPPIR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_HPPIR1_Type)option \<close>  where 
     \<open> ICV_HPPIR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_HPPIR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_HPPIR1_Type  :: \<open> ICV_HPPIR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_HPPIR1_Type v = ( regval_of_bitvector_32(ICV_HPPIR1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_HPPIR1_Type "


definition ICV_IAR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_IAR0_EL1_Type)option \<close>  where 
     \<open> ICV_IAR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_IAR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_IAR0_EL1_Type  :: \<open> ICV_IAR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_IAR0_EL1_Type v = ( regval_of_bitvector_64(ICV_IAR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_IAR0_EL1_Type "


definition ICV_IAR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_IAR0_Type)option \<close>  where 
     \<open> ICV_IAR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_IAR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_IAR0_Type  :: \<open> ICV_IAR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_IAR0_Type v = ( regval_of_bitvector_32(ICV_IAR0_Type_bits   v))\<close> 
  for  "v"  :: " ICV_IAR0_Type "


definition ICV_IAR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_IAR1_EL1_Type)option \<close>  where 
     \<open> ICV_IAR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_IAR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_IAR1_EL1_Type  :: \<open> ICV_IAR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_IAR1_EL1_Type v = ( regval_of_bitvector_64(ICV_IAR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_IAR1_EL1_Type "


definition ICV_IAR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_IAR1_Type)option \<close>  where 
     \<open> ICV_IAR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_IAR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_IAR1_Type  :: \<open> ICV_IAR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_IAR1_Type v = ( regval_of_bitvector_32(ICV_IAR1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_IAR1_Type "


definition ICV_IGRPEN0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_IGRPEN0_EL1_Type)option \<close>  where 
     \<open> ICV_IGRPEN0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_IGRPEN0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_IGRPEN0_EL1_Type  :: \<open> ICV_IGRPEN0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_IGRPEN0_EL1_Type v = ( regval_of_bitvector_64(ICV_IGRPEN0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_IGRPEN0_EL1_Type "


definition ICV_IGRPEN0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_IGRPEN0_Type)option \<close>  where 
     \<open> ICV_IGRPEN0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_IGRPEN0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_IGRPEN0_Type  :: \<open> ICV_IGRPEN0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_IGRPEN0_Type v = ( regval_of_bitvector_32(ICV_IGRPEN0_Type_bits   v))\<close> 
  for  "v"  :: " ICV_IGRPEN0_Type "


definition ICV_IGRPEN1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_IGRPEN1_EL1_Type)option \<close>  where 
     \<open> ICV_IGRPEN1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_IGRPEN1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_IGRPEN1_EL1_Type  :: \<open> ICV_IGRPEN1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_IGRPEN1_EL1_Type v = ( regval_of_bitvector_64(ICV_IGRPEN1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_IGRPEN1_EL1_Type "


definition ICV_IGRPEN1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_IGRPEN1_Type)option \<close>  where 
     \<open> ICV_IGRPEN1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_IGRPEN1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_IGRPEN1_Type  :: \<open> ICV_IGRPEN1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_IGRPEN1_Type v = ( regval_of_bitvector_32(ICV_IGRPEN1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_IGRPEN1_Type "


definition ICV_NMIAR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_NMIAR1_EL1_Type)option \<close>  where 
     \<open> ICV_NMIAR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_NMIAR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_NMIAR1_EL1_Type  :: \<open> ICV_NMIAR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_NMIAR1_EL1_Type v = ( regval_of_bitvector_64(ICV_NMIAR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_NMIAR1_EL1_Type "


definition ICV_PMR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_PMR_EL1_Type)option \<close>  where 
     \<open> ICV_PMR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_PMR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_PMR_EL1_Type  :: \<open> ICV_PMR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_PMR_EL1_Type v = ( regval_of_bitvector_64(ICV_PMR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_PMR_EL1_Type "


definition ICV_PMR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_PMR_Type)option \<close>  where 
     \<open> ICV_PMR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_PMR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_PMR_Type  :: \<open> ICV_PMR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_PMR_Type v = ( regval_of_bitvector_32(ICV_PMR_Type_bits   v))\<close> 
  for  "v"  :: " ICV_PMR_Type "


definition ICV_RPR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_RPR_EL1_Type)option \<close>  where 
     \<open> ICV_RPR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ICV_RPR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_RPR_EL1_Type  :: \<open> ICV_RPR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_RPR_EL1_Type v = ( regval_of_bitvector_64(ICV_RPR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ICV_RPR_EL1_Type "


definition ICV_RPR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ICV_RPR_Type)option \<close>  where 
     \<open> ICV_RPR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ICV_RPR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ICV_RPR_Type  :: \<open> ICV_RPR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ICV_RPR_Type v = ( regval_of_bitvector_32(ICV_RPR_Type_bits   v))\<close> 
  for  "v"  :: " ICV_RPR_Type "


definition ID_AA64DFR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64DFR0_EL1_Type)option \<close>  where 
     \<open> ID_AA64DFR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64DFR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64DFR0_EL1_Type  :: \<open> ID_AA64DFR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64DFR0_EL1_Type v = ( regval_of_bitvector_64(ID_AA64DFR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64DFR0_EL1_Type "


definition ID_AA64DFR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64DFR1_EL1_Type)option \<close>  where 
     \<open> ID_AA64DFR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64DFR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64DFR1_EL1_Type  :: \<open> ID_AA64DFR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64DFR1_EL1_Type v = ( regval_of_bitvector_64(ID_AA64DFR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64DFR1_EL1_Type "


definition ID_AA64ISAR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64ISAR0_EL1_Type)option \<close>  where 
     \<open> ID_AA64ISAR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64ISAR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64ISAR0_EL1_Type  :: \<open> ID_AA64ISAR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64ISAR0_EL1_Type v = ( regval_of_bitvector_64(ID_AA64ISAR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64ISAR0_EL1_Type "


definition ID_AA64ISAR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64ISAR1_EL1_Type)option \<close>  where 
     \<open> ID_AA64ISAR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64ISAR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64ISAR1_EL1_Type  :: \<open> ID_AA64ISAR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64ISAR1_EL1_Type v = ( regval_of_bitvector_64(ID_AA64ISAR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64ISAR1_EL1_Type "


definition ID_AA64ISAR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64ISAR2_EL1_Type)option \<close>  where 
     \<open> ID_AA64ISAR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64ISAR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64ISAR2_EL1_Type  :: \<open> ID_AA64ISAR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64ISAR2_EL1_Type v = ( regval_of_bitvector_64(ID_AA64ISAR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64ISAR2_EL1_Type "


definition ID_AA64MMFR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64MMFR0_EL1_Type)option \<close>  where 
     \<open> ID_AA64MMFR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64MMFR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64MMFR0_EL1_Type  :: \<open> ID_AA64MMFR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64MMFR0_EL1_Type v = ( regval_of_bitvector_64(ID_AA64MMFR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64MMFR0_EL1_Type "


definition ID_AA64MMFR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64MMFR1_EL1_Type)option \<close>  where 
     \<open> ID_AA64MMFR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64MMFR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64MMFR1_EL1_Type  :: \<open> ID_AA64MMFR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64MMFR1_EL1_Type v = ( regval_of_bitvector_64(ID_AA64MMFR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64MMFR1_EL1_Type "


definition ID_AA64MMFR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64MMFR2_EL1_Type)option \<close>  where 
     \<open> ID_AA64MMFR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64MMFR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64MMFR2_EL1_Type  :: \<open> ID_AA64MMFR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64MMFR2_EL1_Type v = ( regval_of_bitvector_64(ID_AA64MMFR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64MMFR2_EL1_Type "


definition ID_AA64MMFR3_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64MMFR3_EL1_Type)option \<close>  where 
     \<open> ID_AA64MMFR3_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64MMFR3_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64MMFR3_EL1_Type  :: \<open> ID_AA64MMFR3_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64MMFR3_EL1_Type v = ( regval_of_bitvector_64(ID_AA64MMFR3_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64MMFR3_EL1_Type "


definition ID_AA64MMFR4_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64MMFR4_EL1_Type)option \<close>  where 
     \<open> ID_AA64MMFR4_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64MMFR4_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64MMFR4_EL1_Type  :: \<open> ID_AA64MMFR4_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64MMFR4_EL1_Type v = ( regval_of_bitvector_64(ID_AA64MMFR4_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64MMFR4_EL1_Type "


definition ID_AA64PFR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64PFR0_EL1_Type)option \<close>  where 
     \<open> ID_AA64PFR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64PFR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64PFR0_EL1_Type  :: \<open> ID_AA64PFR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64PFR0_EL1_Type v = ( regval_of_bitvector_64(ID_AA64PFR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64PFR0_EL1_Type "


definition ID_AA64PFR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64PFR1_EL1_Type)option \<close>  where 
     \<open> ID_AA64PFR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64PFR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64PFR1_EL1_Type  :: \<open> ID_AA64PFR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64PFR1_EL1_Type v = ( regval_of_bitvector_64(ID_AA64PFR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64PFR1_EL1_Type "


definition ID_AA64PFR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64PFR2_EL1_Type)option \<close>  where 
     \<open> ID_AA64PFR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64PFR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64PFR2_EL1_Type  :: \<open> ID_AA64PFR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64PFR2_EL1_Type v = ( regval_of_bitvector_64(ID_AA64PFR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64PFR2_EL1_Type "


definition ID_AA64SMFR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64SMFR0_EL1_Type)option \<close>  where 
     \<open> ID_AA64SMFR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64SMFR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64SMFR0_EL1_Type  :: \<open> ID_AA64SMFR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64SMFR0_EL1_Type v = ( regval_of_bitvector_64(ID_AA64SMFR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64SMFR0_EL1_Type "


definition ID_AA64ZFR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_AA64ZFR0_EL1_Type)option \<close>  where 
     \<open> ID_AA64ZFR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_AA64ZFR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_AA64ZFR0_EL1_Type  :: \<open> ID_AA64ZFR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_AA64ZFR0_EL1_Type v = ( regval_of_bitvector_64(ID_AA64ZFR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_AA64ZFR0_EL1_Type "


definition ID_DFR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_DFR0_EL1_Type)option \<close>  where 
     \<open> ID_DFR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_DFR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_DFR0_EL1_Type  :: \<open> ID_DFR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_DFR0_EL1_Type v = ( regval_of_bitvector_64(ID_DFR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_DFR0_EL1_Type "


definition ID_DFR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_DFR0_Type)option \<close>  where 
     \<open> ID_DFR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_DFR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_DFR0_Type  :: \<open> ID_DFR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_DFR0_Type v = ( regval_of_bitvector_32(ID_DFR0_Type_bits   v))\<close> 
  for  "v"  :: " ID_DFR0_Type "


definition ID_DFR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_DFR1_EL1_Type)option \<close>  where 
     \<open> ID_DFR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_DFR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_DFR1_EL1_Type  :: \<open> ID_DFR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_DFR1_EL1_Type v = ( regval_of_bitvector_64(ID_DFR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_DFR1_EL1_Type "


definition ID_DFR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_DFR1_Type)option \<close>  where 
     \<open> ID_DFR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_DFR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_DFR1_Type  :: \<open> ID_DFR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_DFR1_Type v = ( regval_of_bitvector_32(ID_DFR1_Type_bits   v))\<close> 
  for  "v"  :: " ID_DFR1_Type "


definition ID_ISAR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR0_EL1_Type)option \<close>  where 
     \<open> ID_ISAR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR0_EL1_Type  :: \<open> ID_ISAR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR0_EL1_Type v = ( regval_of_bitvector_64(ID_ISAR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR0_EL1_Type "


definition ID_ISAR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR0_Type)option \<close>  where 
     \<open> ID_ISAR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR0_Type  :: \<open> ID_ISAR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR0_Type v = ( regval_of_bitvector_32(ID_ISAR0_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR0_Type "


definition ID_ISAR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR1_EL1_Type)option \<close>  where 
     \<open> ID_ISAR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR1_EL1_Type  :: \<open> ID_ISAR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR1_EL1_Type v = ( regval_of_bitvector_64(ID_ISAR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR1_EL1_Type "


definition ID_ISAR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR1_Type)option \<close>  where 
     \<open> ID_ISAR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR1_Type  :: \<open> ID_ISAR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR1_Type v = ( regval_of_bitvector_32(ID_ISAR1_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR1_Type "


definition ID_ISAR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR2_EL1_Type)option \<close>  where 
     \<open> ID_ISAR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR2_EL1_Type  :: \<open> ID_ISAR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR2_EL1_Type v = ( regval_of_bitvector_64(ID_ISAR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR2_EL1_Type "


definition ID_ISAR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR2_Type)option \<close>  where 
     \<open> ID_ISAR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR2_Type  :: \<open> ID_ISAR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR2_Type v = ( regval_of_bitvector_32(ID_ISAR2_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR2_Type "


definition ID_ISAR3_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR3_EL1_Type)option \<close>  where 
     \<open> ID_ISAR3_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR3_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR3_EL1_Type  :: \<open> ID_ISAR3_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR3_EL1_Type v = ( regval_of_bitvector_64(ID_ISAR3_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR3_EL1_Type "


definition ID_ISAR3_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR3_Type)option \<close>  where 
     \<open> ID_ISAR3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR3_Type  :: \<open> ID_ISAR3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR3_Type v = ( regval_of_bitvector_32(ID_ISAR3_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR3_Type "


definition ID_ISAR4_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR4_EL1_Type)option \<close>  where 
     \<open> ID_ISAR4_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR4_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR4_EL1_Type  :: \<open> ID_ISAR4_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR4_EL1_Type v = ( regval_of_bitvector_64(ID_ISAR4_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR4_EL1_Type "


definition ID_ISAR4_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR4_Type)option \<close>  where 
     \<open> ID_ISAR4_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR4_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR4_Type  :: \<open> ID_ISAR4_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR4_Type v = ( regval_of_bitvector_32(ID_ISAR4_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR4_Type "


definition ID_ISAR5_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR5_EL1_Type)option \<close>  where 
     \<open> ID_ISAR5_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR5_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR5_EL1_Type  :: \<open> ID_ISAR5_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR5_EL1_Type v = ( regval_of_bitvector_64(ID_ISAR5_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR5_EL1_Type "


definition ID_ISAR5_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR5_Type)option \<close>  where 
     \<open> ID_ISAR5_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR5_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR5_Type  :: \<open> ID_ISAR5_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR5_Type v = ( regval_of_bitvector_32(ID_ISAR5_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR5_Type "


definition ID_ISAR6_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR6_EL1_Type)option \<close>  where 
     \<open> ID_ISAR6_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR6_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR6_EL1_Type  :: \<open> ID_ISAR6_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR6_EL1_Type v = ( regval_of_bitvector_64(ID_ISAR6_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR6_EL1_Type "


definition ID_ISAR6_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_ISAR6_Type)option \<close>  where 
     \<open> ID_ISAR6_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_ISAR6_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_ISAR6_Type  :: \<open> ID_ISAR6_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_ISAR6_Type v = ( regval_of_bitvector_32(ID_ISAR6_Type_bits   v))\<close> 
  for  "v"  :: " ID_ISAR6_Type "


definition ID_MMFR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR0_EL1_Type)option \<close>  where 
     \<open> ID_MMFR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR0_EL1_Type  :: \<open> ID_MMFR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR0_EL1_Type v = ( regval_of_bitvector_64(ID_MMFR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR0_EL1_Type "


definition ID_MMFR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR0_Type)option \<close>  where 
     \<open> ID_MMFR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR0_Type  :: \<open> ID_MMFR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR0_Type v = ( regval_of_bitvector_32(ID_MMFR0_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR0_Type "


definition ID_MMFR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR1_EL1_Type)option \<close>  where 
     \<open> ID_MMFR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR1_EL1_Type  :: \<open> ID_MMFR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR1_EL1_Type v = ( regval_of_bitvector_64(ID_MMFR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR1_EL1_Type "


definition ID_MMFR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR1_Type)option \<close>  where 
     \<open> ID_MMFR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR1_Type  :: \<open> ID_MMFR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR1_Type v = ( regval_of_bitvector_32(ID_MMFR1_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR1_Type "


definition ID_MMFR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR2_EL1_Type)option \<close>  where 
     \<open> ID_MMFR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR2_EL1_Type  :: \<open> ID_MMFR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR2_EL1_Type v = ( regval_of_bitvector_64(ID_MMFR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR2_EL1_Type "


definition ID_MMFR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR2_Type)option \<close>  where 
     \<open> ID_MMFR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR2_Type  :: \<open> ID_MMFR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR2_Type v = ( regval_of_bitvector_32(ID_MMFR2_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR2_Type "


definition ID_MMFR3_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR3_EL1_Type)option \<close>  where 
     \<open> ID_MMFR3_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR3_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR3_EL1_Type  :: \<open> ID_MMFR3_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR3_EL1_Type v = ( regval_of_bitvector_64(ID_MMFR3_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR3_EL1_Type "


definition ID_MMFR3_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR3_Type)option \<close>  where 
     \<open> ID_MMFR3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR3_Type  :: \<open> ID_MMFR3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR3_Type v = ( regval_of_bitvector_32(ID_MMFR3_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR3_Type "


definition ID_MMFR4_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR4_EL1_Type)option \<close>  where 
     \<open> ID_MMFR4_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR4_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR4_EL1_Type  :: \<open> ID_MMFR4_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR4_EL1_Type v = ( regval_of_bitvector_64(ID_MMFR4_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR4_EL1_Type "


definition ID_MMFR4_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR4_Type)option \<close>  where 
     \<open> ID_MMFR4_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR4_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR4_Type  :: \<open> ID_MMFR4_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR4_Type v = ( regval_of_bitvector_32(ID_MMFR4_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR4_Type "


definition ID_MMFR5_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR5_EL1_Type)option \<close>  where 
     \<open> ID_MMFR5_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR5_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR5_EL1_Type  :: \<open> ID_MMFR5_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR5_EL1_Type v = ( regval_of_bitvector_64(ID_MMFR5_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR5_EL1_Type "


definition ID_MMFR5_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_MMFR5_Type)option \<close>  where 
     \<open> ID_MMFR5_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_MMFR5_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_MMFR5_Type  :: \<open> ID_MMFR5_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_MMFR5_Type v = ( regval_of_bitvector_32(ID_MMFR5_Type_bits   v))\<close> 
  for  "v"  :: " ID_MMFR5_Type "


definition ID_PFR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_PFR0_EL1_Type)option \<close>  where 
     \<open> ID_PFR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_PFR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_PFR0_EL1_Type  :: \<open> ID_PFR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_PFR0_EL1_Type v = ( regval_of_bitvector_64(ID_PFR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_PFR0_EL1_Type "


definition ID_PFR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_PFR0_Type)option \<close>  where 
     \<open> ID_PFR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_PFR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_PFR0_Type  :: \<open> ID_PFR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_PFR0_Type v = ( regval_of_bitvector_32(ID_PFR0_Type_bits   v))\<close> 
  for  "v"  :: " ID_PFR0_Type "


definition ID_PFR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_PFR1_EL1_Type)option \<close>  where 
     \<open> ID_PFR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_PFR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_PFR1_EL1_Type  :: \<open> ID_PFR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_PFR1_EL1_Type v = ( regval_of_bitvector_64(ID_PFR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_PFR1_EL1_Type "


definition ID_PFR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_PFR1_Type)option \<close>  where 
     \<open> ID_PFR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_PFR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_PFR1_Type  :: \<open> ID_PFR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_PFR1_Type v = ( regval_of_bitvector_32(ID_PFR1_Type_bits   v))\<close> 
  for  "v"  :: " ID_PFR1_Type "


definition ID_PFR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_PFR2_EL1_Type)option \<close>  where 
     \<open> ID_PFR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ID_PFR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_PFR2_EL1_Type  :: \<open> ID_PFR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_PFR2_EL1_Type v = ( regval_of_bitvector_64(ID_PFR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ID_PFR2_EL1_Type "


definition ID_PFR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ID_PFR2_Type)option \<close>  where 
     \<open> ID_PFR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ID_PFR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ID_PFR2_Type  :: \<open> ID_PFR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ID_PFR2_Type v = ( regval_of_bitvector_32(ID_PFR2_Type_bits   v))\<close> 
  for  "v"  :: " ID_PFR2_Type "


definition IFSR32_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(IFSR32_EL2_Type)option \<close>  where 
     \<open> IFSR32_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| IFSR32_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_IFSR32_EL2_Type  :: \<open> IFSR32_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_IFSR32_EL2_Type v = ( regval_of_bitvector_64(IFSR32_EL2_Type_bits   v))\<close> 
  for  "v"  :: " IFSR32_EL2_Type "


definition IFSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(IFSR_Type)option \<close>  where 
     \<open> IFSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| IFSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_IFSR_Type  :: \<open> IFSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_IFSR_Type v = ( regval_of_bitvector_32(IFSR_Type_bits   v))\<close> 
  for  "v"  :: " IFSR_Type "


definition ISR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ISR_EL1_Type)option \<close>  where 
     \<open> ISR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ISR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ISR_EL1_Type  :: \<open> ISR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ISR_EL1_Type v = ( regval_of_bitvector_64(ISR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ISR_EL1_Type "


definition ISR_Type_of_regval  :: \<open> register_value \<Rightarrow>(ISR_Type)option \<close>  where 
     \<open> ISR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| ISR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ISR_Type  :: \<open> ISR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ISR_Type v = ( regval_of_bitvector_32(ISR_Type_bits   v))\<close> 
  for  "v"  :: " ISR_Type "


fun InterruptID_of_regval  :: \<open> register_value \<Rightarrow>(InterruptID)option \<close>  where 
     \<open> InterruptID_of_regval (Regval_InterruptID (v)) = ( Some v )\<close> 
  for  "v"  :: " InterruptID "
|\<open> InterruptID_of_regval _ = ( None )\<close>


definition regval_of_InterruptID  :: \<open> InterruptID \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_InterruptID v = ( Regval_InterruptID v )\<close> 
  for  "v"  :: " InterruptID "


definition LORC_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(LORC_EL1_Type)option \<close>  where 
     \<open> LORC_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| LORC_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_LORC_EL1_Type  :: \<open> LORC_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_LORC_EL1_Type v = ( regval_of_bitvector_64(LORC_EL1_Type_bits   v))\<close> 
  for  "v"  :: " LORC_EL1_Type "


definition LOREA_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(LOREA_EL1_Type)option \<close>  where 
     \<open> LOREA_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| LOREA_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_LOREA_EL1_Type  :: \<open> LOREA_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_LOREA_EL1_Type v = ( regval_of_bitvector_64(LOREA_EL1_Type_bits   v))\<close> 
  for  "v"  :: " LOREA_EL1_Type "


definition LORID_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(LORID_EL1_Type)option \<close>  where 
     \<open> LORID_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| LORID_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_LORID_EL1_Type  :: \<open> LORID_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_LORID_EL1_Type v = ( regval_of_bitvector_64(LORID_EL1_Type_bits   v))\<close> 
  for  "v"  :: " LORID_EL1_Type "


definition LORN_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(LORN_EL1_Type)option \<close>  where 
     \<open> LORN_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| LORN_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_LORN_EL1_Type  :: \<open> LORN_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_LORN_EL1_Type v = ( regval_of_bitvector_64(LORN_EL1_Type_bits   v))\<close> 
  for  "v"  :: " LORN_EL1_Type "


definition LORSA_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(LORSA_EL1_Type)option \<close>  where 
     \<open> LORSA_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| LORSA_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_LORSA_EL1_Type  :: \<open> LORSA_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_LORSA_EL1_Type v = ( regval_of_bitvector_64(LORSA_EL1_Type_bits   v))\<close> 
  for  "v"  :: " LORSA_EL1_Type "


definition MAIR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(MAIR0_Type)option \<close>  where 
     \<open> MAIR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| MAIR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MAIR0_Type  :: \<open> MAIR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MAIR0_Type v = ( regval_of_bitvector_32(MAIR0_Type_bits   v))\<close> 
  for  "v"  :: " MAIR0_Type "


definition MAIR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MAIR1_Type)option \<close>  where 
     \<open> MAIR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| MAIR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MAIR1_Type  :: \<open> MAIR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MAIR1_Type v = ( regval_of_bitvector_32(MAIR1_Type_bits   v))\<close> 
  for  "v"  :: " MAIR1_Type "


definition MAIR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MAIR2_EL1_Type)option \<close>  where 
     \<open> MAIR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MAIR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MAIR2_EL1_Type  :: \<open> MAIR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MAIR2_EL1_Type v = ( regval_of_bitvector_64(MAIR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MAIR2_EL1_Type "


definition MAIR2_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MAIR2_EL2_Type)option \<close>  where 
     \<open> MAIR2_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MAIR2_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MAIR2_EL2_Type  :: \<open> MAIR2_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MAIR2_EL2_Type v = ( regval_of_bitvector_64(MAIR2_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MAIR2_EL2_Type "


definition MAIR2_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(MAIR2_EL3_Type)option \<close>  where 
     \<open> MAIR2_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MAIR2_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MAIR2_EL3_Type  :: \<open> MAIR2_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MAIR2_EL3_Type v = ( regval_of_bitvector_64(MAIR2_EL3_Type_bits   v))\<close> 
  for  "v"  :: " MAIR2_EL3_Type "


definition MAIR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MAIR_EL1_Type)option \<close>  where 
     \<open> MAIR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MAIR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MAIR_EL1_Type  :: \<open> MAIR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MAIR_EL1_Type v = ( regval_of_bitvector_64(MAIR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MAIR_EL1_Type "


definition MAIR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MAIR_EL2_Type)option \<close>  where 
     \<open> MAIR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MAIR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MAIR_EL2_Type  :: \<open> MAIR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MAIR_EL2_Type v = ( regval_of_bitvector_64(MAIR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MAIR_EL2_Type "


definition MAIR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(MAIR_EL3_Type)option \<close>  where 
     \<open> MAIR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MAIR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MAIR_EL3_Type  :: \<open> MAIR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MAIR_EL3_Type v = ( regval_of_bitvector_64(MAIR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " MAIR_EL3_Type "


definition MDCCINT_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MDCCINT_EL1_Type)option \<close>  where 
     \<open> MDCCINT_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MDCCINT_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MDCCINT_EL1_Type  :: \<open> MDCCINT_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MDCCINT_EL1_Type v = ( regval_of_bitvector_64(MDCCINT_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MDCCINT_EL1_Type "


definition MDCCSR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(MDCCSR_EL0_Type)option \<close>  where 
     \<open> MDCCSR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MDCCSR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MDCCSR_EL0_Type  :: \<open> MDCCSR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MDCCSR_EL0_Type v = ( regval_of_bitvector_64(MDCCSR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " MDCCSR_EL0_Type "


definition MDCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MDCR_EL2_Type)option \<close>  where 
     \<open> MDCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MDCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MDCR_EL2_Type  :: \<open> MDCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MDCR_EL2_Type v = ( regval_of_bitvector_64(MDCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MDCR_EL2_Type "


definition MDCR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(MDCR_EL3_Type)option \<close>  where 
     \<open> MDCR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MDCR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MDCR_EL3_Type  :: \<open> MDCR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MDCR_EL3_Type v = ( regval_of_bitvector_64(MDCR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " MDCR_EL3_Type "


definition MDRAR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MDRAR_EL1_Type)option \<close>  where 
     \<open> MDRAR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MDRAR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MDRAR_EL1_Type  :: \<open> MDRAR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MDRAR_EL1_Type v = ( regval_of_bitvector_64(MDRAR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MDRAR_EL1_Type "


definition MDSCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MDSCR_EL1_Type)option \<close>  where 
     \<open> MDSCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MDSCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MDSCR_EL1_Type  :: \<open> MDSCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MDSCR_EL1_Type v = ( regval_of_bitvector_64(MDSCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MDSCR_EL1_Type "


definition MDSELR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MDSELR_EL1_Type)option \<close>  where 
     \<open> MDSELR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MDSELR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MDSELR_EL1_Type  :: \<open> MDSELR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MDSELR_EL1_Type v = ( regval_of_bitvector_64(MDSELR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MDSELR_EL1_Type "


definition MECIDR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MECIDR_EL2_Type)option \<close>  where 
     \<open> MECIDR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MECIDR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MECIDR_EL2_Type  :: \<open> MECIDR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MECIDR_EL2_Type v = ( regval_of_bitvector_64(MECIDR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MECIDR_EL2_Type "


definition MECID_A0_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MECID_A0_EL2_Type)option \<close>  where 
     \<open> MECID_A0_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MECID_A0_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MECID_A0_EL2_Type  :: \<open> MECID_A0_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MECID_A0_EL2_Type v = ( regval_of_bitvector_64(MECID_A0_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MECID_A0_EL2_Type "


definition MECID_A1_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MECID_A1_EL2_Type)option \<close>  where 
     \<open> MECID_A1_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MECID_A1_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MECID_A1_EL2_Type  :: \<open> MECID_A1_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MECID_A1_EL2_Type v = ( regval_of_bitvector_64(MECID_A1_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MECID_A1_EL2_Type "


definition MECID_P0_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MECID_P0_EL2_Type)option \<close>  where 
     \<open> MECID_P0_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MECID_P0_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MECID_P0_EL2_Type  :: \<open> MECID_P0_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MECID_P0_EL2_Type v = ( regval_of_bitvector_64(MECID_P0_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MECID_P0_EL2_Type "


definition MECID_P1_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MECID_P1_EL2_Type)option \<close>  where 
     \<open> MECID_P1_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MECID_P1_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MECID_P1_EL2_Type  :: \<open> MECID_P1_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MECID_P1_EL2_Type v = ( regval_of_bitvector_64(MECID_P1_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MECID_P1_EL2_Type "


definition MECID_RL_A_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(MECID_RL_A_EL3_Type)option \<close>  where 
     \<open> MECID_RL_A_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MECID_RL_A_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MECID_RL_A_EL3_Type  :: \<open> MECID_RL_A_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MECID_RL_A_EL3_Type v = ( regval_of_bitvector_64(MECID_RL_A_EL3_Type_bits   v))\<close> 
  for  "v"  :: " MECID_RL_A_EL3_Type "


definition MFAR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(MFAR_EL3_Type)option \<close>  where 
     \<open> MFAR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MFAR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MFAR_EL3_Type  :: \<open> MFAR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MFAR_EL3_Type v = ( regval_of_bitvector_64(MFAR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " MFAR_EL3_Type "


definition MIDR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MIDR_EL1_Type)option \<close>  where 
     \<open> MIDR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MIDR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MIDR_EL1_Type  :: \<open> MIDR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MIDR_EL1_Type v = ( regval_of_bitvector_64(MIDR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MIDR_EL1_Type "


definition MIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(MIDR_Type)option \<close>  where 
     \<open> MIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| MIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MIDR_Type  :: \<open> MIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MIDR_Type v = ( regval_of_bitvector_32(MIDR_Type_bits   v))\<close> 
  for  "v"  :: " MIDR_Type "


definition MPAM0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAM0_EL1_Type)option \<close>  where 
     \<open> MPAM0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAM0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAM0_EL1_Type  :: \<open> MPAM0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAM0_EL1_Type v = ( regval_of_bitvector_64(MPAM0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MPAM0_EL1_Type "


definition MPAM1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAM1_EL1_Type)option \<close>  where 
     \<open> MPAM1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAM1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAM1_EL1_Type  :: \<open> MPAM1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAM1_EL1_Type v = ( regval_of_bitvector_64(MPAM1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MPAM1_EL1_Type "


definition MPAM2_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAM2_EL2_Type)option \<close>  where 
     \<open> MPAM2_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAM2_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAM2_EL2_Type  :: \<open> MPAM2_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAM2_EL2_Type v = ( regval_of_bitvector_64(MPAM2_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAM2_EL2_Type "


definition MPAM3_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAM3_EL3_Type)option \<close>  where 
     \<open> MPAM3_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAM3_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAM3_EL3_Type  :: \<open> MPAM3_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAM3_EL3_Type v = ( regval_of_bitvector_64(MPAM3_EL3_Type_bits   v))\<close> 
  for  "v"  :: " MPAM3_EL3_Type "


definition MPAMHCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMHCR_EL2_Type)option \<close>  where 
     \<open> MPAMHCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMHCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMHCR_EL2_Type  :: \<open> MPAMHCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMHCR_EL2_Type v = ( regval_of_bitvector_64(MPAMHCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAMHCR_EL2_Type "


definition MPAMIDR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMIDR_EL1_Type)option \<close>  where 
     \<open> MPAMIDR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMIDR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMIDR_EL1_Type  :: \<open> MPAMIDR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMIDR_EL1_Type v = ( regval_of_bitvector_64(MPAMIDR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MPAMIDR_EL1_Type "


definition MPAMSM_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMSM_EL1_Type)option \<close>  where 
     \<open> MPAMSM_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMSM_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMSM_EL1_Type  :: \<open> MPAMSM_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMSM_EL1_Type v = ( regval_of_bitvector_64(MPAMSM_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MPAMSM_EL1_Type "


definition MPAMVPM0_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMVPM0_EL2_Type)option \<close>  where 
     \<open> MPAMVPM0_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMVPM0_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMVPM0_EL2_Type  :: \<open> MPAMVPM0_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMVPM0_EL2_Type v = ( regval_of_bitvector_64(MPAMVPM0_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAMVPM0_EL2_Type "


definition MPAMVPM1_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMVPM1_EL2_Type)option \<close>  where 
     \<open> MPAMVPM1_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMVPM1_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMVPM1_EL2_Type  :: \<open> MPAMVPM1_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMVPM1_EL2_Type v = ( regval_of_bitvector_64(MPAMVPM1_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAMVPM1_EL2_Type "


definition MPAMVPM2_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMVPM2_EL2_Type)option \<close>  where 
     \<open> MPAMVPM2_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMVPM2_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMVPM2_EL2_Type  :: \<open> MPAMVPM2_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMVPM2_EL2_Type v = ( regval_of_bitvector_64(MPAMVPM2_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAMVPM2_EL2_Type "


definition MPAMVPM3_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMVPM3_EL2_Type)option \<close>  where 
     \<open> MPAMVPM3_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMVPM3_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMVPM3_EL2_Type  :: \<open> MPAMVPM3_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMVPM3_EL2_Type v = ( regval_of_bitvector_64(MPAMVPM3_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAMVPM3_EL2_Type "


definition MPAMVPM4_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMVPM4_EL2_Type)option \<close>  where 
     \<open> MPAMVPM4_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMVPM4_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMVPM4_EL2_Type  :: \<open> MPAMVPM4_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMVPM4_EL2_Type v = ( regval_of_bitvector_64(MPAMVPM4_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAMVPM4_EL2_Type "


definition MPAMVPM5_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMVPM5_EL2_Type)option \<close>  where 
     \<open> MPAMVPM5_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMVPM5_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMVPM5_EL2_Type  :: \<open> MPAMVPM5_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMVPM5_EL2_Type v = ( regval_of_bitvector_64(MPAMVPM5_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAMVPM5_EL2_Type "


definition MPAMVPM6_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMVPM6_EL2_Type)option \<close>  where 
     \<open> MPAMVPM6_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMVPM6_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMVPM6_EL2_Type  :: \<open> MPAMVPM6_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMVPM6_EL2_Type v = ( regval_of_bitvector_64(MPAMVPM6_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAMVPM6_EL2_Type "


definition MPAMVPM7_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMVPM7_EL2_Type)option \<close>  where 
     \<open> MPAMVPM7_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMVPM7_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMVPM7_EL2_Type  :: \<open> MPAMVPM7_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMVPM7_EL2_Type v = ( regval_of_bitvector_64(MPAMVPM7_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAMVPM7_EL2_Type "


definition MPAMVPMV_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPAMVPMV_EL2_Type)option \<close>  where 
     \<open> MPAMVPMV_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPAMVPMV_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPAMVPMV_EL2_Type  :: \<open> MPAMVPMV_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPAMVPMV_EL2_Type v = ( regval_of_bitvector_64(MPAMVPMV_EL2_Type_bits   v))\<close> 
  for  "v"  :: " MPAMVPMV_EL2_Type "


definition MPIDR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPIDR_EL1_Type)option \<close>  where 
     \<open> MPIDR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MPIDR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPIDR_EL1_Type  :: \<open> MPIDR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPIDR_EL1_Type v = ( regval_of_bitvector_64(MPIDR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MPIDR_EL1_Type "


definition MPIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(MPIDR_Type)option \<close>  where 
     \<open> MPIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| MPIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MPIDR_Type  :: \<open> MPIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MPIDR_Type v = ( regval_of_bitvector_32(MPIDR_Type_bits   v))\<close> 
  for  "v"  :: " MPIDR_Type "


definition MVBAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(MVBAR_Type)option \<close>  where 
     \<open> MVBAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| MVBAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MVBAR_Type  :: \<open> MVBAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MVBAR_Type v = ( regval_of_bitvector_32(MVBAR_Type_bits   v))\<close> 
  for  "v"  :: " MVBAR_Type "


definition MVFR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MVFR0_EL1_Type)option \<close>  where 
     \<open> MVFR0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MVFR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MVFR0_EL1_Type  :: \<open> MVFR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MVFR0_EL1_Type v = ( regval_of_bitvector_64(MVFR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MVFR0_EL1_Type "


definition MVFR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(MVFR0_Type)option \<close>  where 
     \<open> MVFR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| MVFR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MVFR0_Type  :: \<open> MVFR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MVFR0_Type v = ( regval_of_bitvector_32(MVFR0_Type_bits   v))\<close> 
  for  "v"  :: " MVFR0_Type "


definition MVFR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MVFR1_EL1_Type)option \<close>  where 
     \<open> MVFR1_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MVFR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MVFR1_EL1_Type  :: \<open> MVFR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MVFR1_EL1_Type v = ( regval_of_bitvector_64(MVFR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MVFR1_EL1_Type "


definition MVFR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MVFR1_Type)option \<close>  where 
     \<open> MVFR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| MVFR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MVFR1_Type  :: \<open> MVFR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MVFR1_Type v = ( regval_of_bitvector_32(MVFR1_Type_bits   v))\<close> 
  for  "v"  :: " MVFR1_Type "


definition MVFR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(MVFR2_EL1_Type)option \<close>  where 
     \<open> MVFR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| MVFR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MVFR2_EL1_Type  :: \<open> MVFR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MVFR2_EL1_Type v = ( regval_of_bitvector_64(MVFR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " MVFR2_EL1_Type "


definition MVFR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(MVFR2_Type)option \<close>  where 
     \<open> MVFR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| MVFR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_MVFR2_Type  :: \<open> MVFR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_MVFR2_Type v = ( regval_of_bitvector_32(MVFR2_Type_bits   v))\<close> 
  for  "v"  :: " MVFR2_Type "


definition NMRR_Type_of_regval  :: \<open> register_value \<Rightarrow>(NMRR_Type)option \<close>  where 
     \<open> NMRR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| NMRR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_NMRR_Type  :: \<open> NMRR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_NMRR_Type v = ( regval_of_bitvector_32(NMRR_Type_bits   v))\<close> 
  for  "v"  :: " NMRR_Type "


definition NSACR_Type_of_regval  :: \<open> register_value \<Rightarrow>(NSACR_Type)option \<close>  where 
     \<open> NSACR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| NSACR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_NSACR_Type  :: \<open> NSACR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_NSACR_Type v = ( regval_of_bitvector_32(NSACR_Type_bits   v))\<close> 
  for  "v"  :: " NSACR_Type "


definition OSDLR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(OSDLR_EL1_Type)option \<close>  where 
     \<open> OSDLR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| OSDLR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_OSDLR_EL1_Type  :: \<open> OSDLR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_OSDLR_EL1_Type v = ( regval_of_bitvector_64(OSDLR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " OSDLR_EL1_Type "


definition OSECCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(OSECCR_EL1_Type)option \<close>  where 
     \<open> OSECCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| OSECCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_OSECCR_EL1_Type  :: \<open> OSECCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_OSECCR_EL1_Type v = ( regval_of_bitvector_64(OSECCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " OSECCR_EL1_Type "


definition OSLAR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(OSLAR_EL1_Type)option \<close>  where 
     \<open> OSLAR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| OSLAR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_OSLAR_EL1_Type  :: \<open> OSLAR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_OSLAR_EL1_Type v = ( regval_of_bitvector_64(OSLAR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " OSLAR_EL1_Type "


definition OSLSR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(OSLSR_EL1_Type)option \<close>  where 
     \<open> OSLSR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| OSLSR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_OSLSR_EL1_Type  :: \<open> OSLSR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_OSLSR_EL1_Type v = ( regval_of_bitvector_64(OSLSR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " OSLSR_EL1_Type "


fun OpType_of_regval  :: \<open> register_value \<Rightarrow>(OpType)option \<close>  where 
     \<open> OpType_of_regval (Regval_OpType (v)) = ( Some v )\<close> 
  for  "v"  :: " OpType "
|\<open> OpType_of_regval _ = ( None )\<close>


definition regval_of_OpType  :: \<open> OpType \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_OpType v = ( Regval_OpType v )\<close> 
  for  "v"  :: " OpType "


fun bitvector_128_of_regval  :: \<open> register_value \<Rightarrow>((128)Word.word)option \<close>  where 
     \<open> bitvector_128_of_regval (Regval_bitvector_128 (v)) = ( Some v )\<close> 
  for  "v"  :: "(128)Word.word "
|\<open> bitvector_128_of_regval _ = ( None )\<close>


definition PAR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PAR_EL1_Type)option \<close>  where 
     \<open> PAR_EL1_Type_of_regval v = (
   (case  ((bitvector_128_of_regval v  ::  ( 128 Word.word)option)) of
     Some (v) => Some ((| PAR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_bitvector_128  :: \<open>(128)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_128 v = ( Regval_bitvector_128 v )\<close> 
  for  "v"  :: "(128)Word.word "


definition regval_of_PAR_EL1_Type  :: \<open> PAR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PAR_EL1_Type v = ( regval_of_bitvector_128(PAR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PAR_EL1_Type "


definition PAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PAR_Type)option \<close>  where 
     \<open> PAR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PAR_Type  :: \<open> PAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PAR_Type v = ( regval_of_bitvector_64(PAR_Type_bits   v))\<close> 
  for  "v"  :: " PAR_Type "


definition PFAR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PFAR_EL1_Type)option \<close>  where 
     \<open> PFAR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PFAR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PFAR_EL1_Type  :: \<open> PFAR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PFAR_EL1_Type v = ( regval_of_bitvector_64(PFAR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PFAR_EL1_Type "


definition PFAR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(PFAR_EL2_Type)option \<close>  where 
     \<open> PFAR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PFAR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PFAR_EL2_Type  :: \<open> PFAR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PFAR_EL2_Type v = ( regval_of_bitvector_64(PFAR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " PFAR_EL2_Type "


definition PIRE0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PIRE0_EL1_Type)option \<close>  where 
     \<open> PIRE0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PIRE0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PIRE0_EL1_Type  :: \<open> PIRE0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PIRE0_EL1_Type v = ( regval_of_bitvector_64(PIRE0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PIRE0_EL1_Type "


definition PIRE0_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(PIRE0_EL2_Type)option \<close>  where 
     \<open> PIRE0_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PIRE0_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PIRE0_EL2_Type  :: \<open> PIRE0_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PIRE0_EL2_Type v = ( regval_of_bitvector_64(PIRE0_EL2_Type_bits   v))\<close> 
  for  "v"  :: " PIRE0_EL2_Type "


definition PIR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PIR_EL1_Type)option \<close>  where 
     \<open> PIR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PIR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PIR_EL1_Type  :: \<open> PIR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PIR_EL1_Type v = ( regval_of_bitvector_64(PIR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PIR_EL1_Type "


definition PIR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(PIR_EL2_Type)option \<close>  where 
     \<open> PIR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PIR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PIR_EL2_Type  :: \<open> PIR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PIR_EL2_Type v = ( regval_of_bitvector_64(PIR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " PIR_EL2_Type "


definition PIR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(PIR_EL3_Type)option \<close>  where 
     \<open> PIR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PIR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PIR_EL3_Type  :: \<open> PIR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PIR_EL3_Type v = ( regval_of_bitvector_64(PIR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " PIR_EL3_Type "


definition PMAUTHSTATUS_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMAUTHSTATUS_Type)option \<close>  where 
     \<open> PMAUTHSTATUS_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMAUTHSTATUS_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMAUTHSTATUS_Type  :: \<open> PMAUTHSTATUS_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMAUTHSTATUS_Type v = ( regval_of_bitvector_32(PMAUTHSTATUS_Type_bits   v))\<close> 
  for  "v"  :: " PMAUTHSTATUS_Type "


definition PMBIDR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMBIDR_EL1_Type)option \<close>  where 
     \<open> PMBIDR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMBIDR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMBIDR_EL1_Type  :: \<open> PMBIDR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMBIDR_EL1_Type v = ( regval_of_bitvector_64(PMBIDR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMBIDR_EL1_Type "


definition PMBLIMITR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMBLIMITR_EL1_Type)option \<close>  where 
     \<open> PMBLIMITR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMBLIMITR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMBLIMITR_EL1_Type  :: \<open> PMBLIMITR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMBLIMITR_EL1_Type v = ( regval_of_bitvector_64(PMBLIMITR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMBLIMITR_EL1_Type "


definition PMBPTR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMBPTR_EL1_Type)option \<close>  where 
     \<open> PMBPTR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMBPTR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMBPTR_EL1_Type  :: \<open> PMBPTR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMBPTR_EL1_Type v = ( regval_of_bitvector_64(PMBPTR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMBPTR_EL1_Type "


definition PMBSR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMBSR_EL1_Type)option \<close>  where 
     \<open> PMBSR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMBSR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMBSR_EL1_Type  :: \<open> PMBSR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMBSR_EL1_Type v = ( regval_of_bitvector_64(PMBSR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMBSR_EL1_Type "


definition PMCCFILTR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCCFILTR_EL0_Type)option \<close>  where 
     \<open> PMCCFILTR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCCFILTR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCCFILTR_EL0_Type  :: \<open> PMCCFILTR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCCFILTR_EL0_Type v = ( regval_of_bitvector_64(PMCCFILTR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMCCFILTR_EL0_Type "


definition PMCCFILTR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCCFILTR_Type)option \<close>  where 
     \<open> PMCCFILTR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCCFILTR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCCFILTR_Type  :: \<open> PMCCFILTR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCCFILTR_Type v = ( regval_of_bitvector_32(PMCCFILTR_Type_bits   v))\<close> 
  for  "v"  :: " PMCCFILTR_Type "


definition PMCCNTR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCCNTR_EL0_Type)option \<close>  where 
     \<open> PMCCNTR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCCNTR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCCNTR_EL0_Type  :: \<open> PMCCNTR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCCNTR_EL0_Type v = ( regval_of_bitvector_64(PMCCNTR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMCCNTR_EL0_Type "


definition PMCCNTR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCCNTR_Type)option \<close>  where 
     \<open> PMCCNTR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCCNTR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCCNTR_Type  :: \<open> PMCCNTR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCCNTR_Type v = ( regval_of_bitvector_64(PMCCNTR_Type_bits   v))\<close> 
  for  "v"  :: " PMCCNTR_Type "


definition PMCCNTSVR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCCNTSVR_EL1_Type)option \<close>  where 
     \<open> PMCCNTSVR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCCNTSVR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCCNTSVR_EL1_Type  :: \<open> PMCCNTSVR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCCNTSVR_EL1_Type v = ( regval_of_bitvector_64(PMCCNTSVR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMCCNTSVR_EL1_Type "


definition PMCEID0_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCEID0_EL0_Type)option \<close>  where 
     \<open> PMCEID0_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCEID0_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCEID0_EL0_Type  :: \<open> PMCEID0_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCEID0_EL0_Type v = ( regval_of_bitvector_64(PMCEID0_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMCEID0_EL0_Type "


definition PMCEID0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCEID0_Type)option \<close>  where 
     \<open> PMCEID0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCEID0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCEID0_Type  :: \<open> PMCEID0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCEID0_Type v = ( regval_of_bitvector_32(PMCEID0_Type_bits   v))\<close> 
  for  "v"  :: " PMCEID0_Type "


definition PMCEID1_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCEID1_EL0_Type)option \<close>  where 
     \<open> PMCEID1_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCEID1_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCEID1_EL0_Type  :: \<open> PMCEID1_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCEID1_EL0_Type v = ( regval_of_bitvector_64(PMCEID1_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMCEID1_EL0_Type "


definition PMCEID1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCEID1_Type)option \<close>  where 
     \<open> PMCEID1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCEID1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCEID1_Type  :: \<open> PMCEID1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCEID1_Type v = ( regval_of_bitvector_32(PMCEID1_Type_bits   v))\<close> 
  for  "v"  :: " PMCEID1_Type "


definition PMCEID2_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCEID2_Type)option \<close>  where 
     \<open> PMCEID2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCEID2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCEID2_Type  :: \<open> PMCEID2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCEID2_Type v = ( regval_of_bitvector_32(PMCEID2_Type_bits   v))\<close> 
  for  "v"  :: " PMCEID2_Type "


definition PMCEID3_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCEID3_Type)option \<close>  where 
     \<open> PMCEID3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCEID3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCEID3_Type  :: \<open> PMCEID3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCEID3_Type v = ( regval_of_bitvector_32(PMCEID3_Type_bits   v))\<close> 
  for  "v"  :: " PMCEID3_Type "


definition PMCFGR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCFGR_Type)option \<close>  where 
     \<open> PMCFGR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCFGR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCFGR_Type  :: \<open> PMCFGR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCFGR_Type v = ( regval_of_bitvector_64(PMCFGR_Type_bits   v))\<close> 
  for  "v"  :: " PMCFGR_Type "


definition PMCGCR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCGCR0_Type)option \<close>  where 
     \<open> PMCGCR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCGCR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCGCR0_Type  :: \<open> PMCGCR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCGCR0_Type v = ( regval_of_bitvector_32(PMCGCR0_Type_bits   v))\<close> 
  for  "v"  :: " PMCGCR0_Type "


definition PMCIDR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCIDR0_Type)option \<close>  where 
     \<open> PMCIDR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCIDR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCIDR0_Type  :: \<open> PMCIDR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCIDR0_Type v = ( regval_of_bitvector_32(PMCIDR0_Type_bits   v))\<close> 
  for  "v"  :: " PMCIDR0_Type "


definition PMCIDR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCIDR1_Type)option \<close>  where 
     \<open> PMCIDR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCIDR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCIDR1_Type  :: \<open> PMCIDR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCIDR1_Type v = ( regval_of_bitvector_32(PMCIDR1_Type_bits   v))\<close> 
  for  "v"  :: " PMCIDR1_Type "


definition PMCIDR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCIDR2_Type)option \<close>  where 
     \<open> PMCIDR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCIDR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCIDR2_Type  :: \<open> PMCIDR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCIDR2_Type v = ( regval_of_bitvector_32(PMCIDR2_Type_bits   v))\<close> 
  for  "v"  :: " PMCIDR2_Type "


definition PMCIDR3_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCIDR3_Type)option \<close>  where 
     \<open> PMCIDR3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCIDR3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCIDR3_Type  :: \<open> PMCIDR3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCIDR3_Type v = ( regval_of_bitvector_32(PMCIDR3_Type_bits   v))\<close> 
  for  "v"  :: " PMCIDR3_Type "


definition PMCNTENCLR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCNTENCLR_EL0_Type)option \<close>  where 
     \<open> PMCNTENCLR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCNTENCLR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCNTENCLR_EL0_Type  :: \<open> PMCNTENCLR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCNTENCLR_EL0_Type v = ( regval_of_bitvector_64(PMCNTENCLR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMCNTENCLR_EL0_Type "


definition PMCNTENCLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCNTENCLR_Type)option \<close>  where 
     \<open> PMCNTENCLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCNTENCLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCNTENCLR_Type  :: \<open> PMCNTENCLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCNTENCLR_Type v = ( regval_of_bitvector_32(PMCNTENCLR_Type_bits   v))\<close> 
  for  "v"  :: " PMCNTENCLR_Type "


definition PMCNTENSET_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCNTENSET_EL0_Type)option \<close>  where 
     \<open> PMCNTENSET_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCNTENSET_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCNTENSET_EL0_Type  :: \<open> PMCNTENSET_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCNTENSET_EL0_Type v = ( regval_of_bitvector_64(PMCNTENSET_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMCNTENSET_EL0_Type "


definition PMCNTENSET_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCNTENSET_Type)option \<close>  where 
     \<open> PMCNTENSET_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCNTENSET_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCNTENSET_Type  :: \<open> PMCNTENSET_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCNTENSET_Type v = ( regval_of_bitvector_32(PMCNTENSET_Type_bits   v))\<close> 
  for  "v"  :: " PMCNTENSET_Type "


definition PMCNTEN_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCNTEN_Type)option \<close>  where 
     \<open> PMCNTEN_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCNTEN_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCNTEN_Type  :: \<open> PMCNTEN_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCNTEN_Type v = ( regval_of_bitvector_64(PMCNTEN_Type_bits   v))\<close> 
  for  "v"  :: " PMCNTEN_Type "


definition PMCR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCR_EL0_Type)option \<close>  where 
     \<open> PMCR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMCR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCR_EL0_Type  :: \<open> PMCR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCR_EL0_Type v = ( regval_of_bitvector_64(PMCR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMCR_EL0_Type "


definition PMCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMCR_Type)option \<close>  where 
     \<open> PMCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMCR_Type  :: \<open> PMCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMCR_Type v = ( regval_of_bitvector_32(PMCR_Type_bits   v))\<close> 
  for  "v"  :: " PMCR_Type "


definition PMDEVID_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMDEVID_Type)option \<close>  where 
     \<open> PMDEVID_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMDEVID_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMDEVID_Type  :: \<open> PMDEVID_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMDEVID_Type v = ( regval_of_bitvector_32(PMDEVID_Type_bits   v))\<close> 
  for  "v"  :: " PMDEVID_Type "


definition PMDEVTYPE_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMDEVTYPE_Type)option \<close>  where 
     \<open> PMDEVTYPE_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMDEVTYPE_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMDEVTYPE_Type  :: \<open> PMDEVTYPE_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMDEVTYPE_Type v = ( regval_of_bitvector_32(PMDEVTYPE_Type_bits   v))\<close> 
  for  "v"  :: " PMDEVTYPE_Type "


definition PMECR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMECR_EL1_Type)option \<close>  where 
     \<open> PMECR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMECR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMECR_EL1_Type  :: \<open> PMECR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMECR_EL1_Type v = ( regval_of_bitvector_64(PMECR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMECR_EL1_Type "


definition PMEVCNTSVR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMEVCNTSVR_EL1_Type)option \<close>  where 
     \<open> PMEVCNTSVR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMEVCNTSVR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMEVCNTSVR_EL1_Type  :: \<open> PMEVCNTSVR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMEVCNTSVR_EL1_Type v = ( regval_of_bitvector_64(PMEVCNTSVR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMEVCNTSVR_EL1_Type "


definition PMEVTYPER_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMEVTYPER_EL0_Type)option \<close>  where 
     \<open> PMEVTYPER_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMEVTYPER_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMEVTYPER_EL0_Type  :: \<open> PMEVTYPER_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMEVTYPER_EL0_Type v = ( regval_of_bitvector_64(PMEVTYPER_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMEVTYPER_EL0_Type "


definition PMEVTYPER_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMEVTYPER_Type)option \<close>  where 
     \<open> PMEVTYPER_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMEVTYPER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMEVTYPER_Type  :: \<open> PMEVTYPER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMEVTYPER_Type v = ( regval_of_bitvector_32(PMEVTYPER_Type_bits   v))\<close> 
  for  "v"  :: " PMEVTYPER_Type "


definition PMIAR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMIAR_EL1_Type)option \<close>  where 
     \<open> PMIAR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMIAR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMIAR_EL1_Type  :: \<open> PMIAR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMIAR_EL1_Type v = ( regval_of_bitvector_64(PMIAR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMIAR_EL1_Type "


definition PMICFILTR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMICFILTR_EL0_Type)option \<close>  where 
     \<open> PMICFILTR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMICFILTR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMICFILTR_EL0_Type  :: \<open> PMICFILTR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMICFILTR_EL0_Type v = ( regval_of_bitvector_64(PMICFILTR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMICFILTR_EL0_Type "


definition PMICNTR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMICNTR_EL0_Type)option \<close>  where 
     \<open> PMICNTR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMICNTR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMICNTR_EL0_Type  :: \<open> PMICNTR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMICNTR_EL0_Type v = ( regval_of_bitvector_64(PMICNTR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMICNTR_EL0_Type "


definition PMICNTSVR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMICNTSVR_EL1_Type)option \<close>  where 
     \<open> PMICNTSVR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMICNTSVR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMICNTSVR_EL1_Type  :: \<open> PMICNTSVR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMICNTSVR_EL1_Type v = ( regval_of_bitvector_64(PMICNTSVR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMICNTSVR_EL1_Type "


definition PMIIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMIIDR_Type)option \<close>  where 
     \<open> PMIIDR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMIIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMIIDR_Type  :: \<open> PMIIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMIIDR_Type v = ( regval_of_bitvector_64(PMIIDR_Type_bits   v))\<close> 
  for  "v"  :: " PMIIDR_Type "


definition PMINTENCLR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMINTENCLR_EL1_Type)option \<close>  where 
     \<open> PMINTENCLR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMINTENCLR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMINTENCLR_EL1_Type  :: \<open> PMINTENCLR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMINTENCLR_EL1_Type v = ( regval_of_bitvector_64(PMINTENCLR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMINTENCLR_EL1_Type "


definition PMINTENCLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMINTENCLR_Type)option \<close>  where 
     \<open> PMINTENCLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMINTENCLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMINTENCLR_Type  :: \<open> PMINTENCLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMINTENCLR_Type v = ( regval_of_bitvector_32(PMINTENCLR_Type_bits   v))\<close> 
  for  "v"  :: " PMINTENCLR_Type "


definition PMINTENSET_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMINTENSET_EL1_Type)option \<close>  where 
     \<open> PMINTENSET_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMINTENSET_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMINTENSET_EL1_Type  :: \<open> PMINTENSET_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMINTENSET_EL1_Type v = ( regval_of_bitvector_64(PMINTENSET_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMINTENSET_EL1_Type "


definition PMINTENSET_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMINTENSET_Type)option \<close>  where 
     \<open> PMINTENSET_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMINTENSET_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMINTENSET_Type  :: \<open> PMINTENSET_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMINTENSET_Type v = ( regval_of_bitvector_32(PMINTENSET_Type_bits   v))\<close> 
  for  "v"  :: " PMINTENSET_Type "


definition PMINTEN_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMINTEN_Type)option \<close>  where 
     \<open> PMINTEN_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMINTEN_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMINTEN_Type  :: \<open> PMINTEN_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMINTEN_Type v = ( regval_of_bitvector_64(PMINTEN_Type_bits   v))\<close> 
  for  "v"  :: " PMINTEN_Type "


definition PMITCTRL_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMITCTRL_Type)option \<close>  where 
     \<open> PMITCTRL_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMITCTRL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMITCTRL_Type  :: \<open> PMITCTRL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMITCTRL_Type v = ( regval_of_bitvector_32(PMITCTRL_Type_bits   v))\<close> 
  for  "v"  :: " PMITCTRL_Type "


definition PMLAR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMLAR_Type)option \<close>  where 
     \<open> PMLAR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMLAR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMLAR_Type  :: \<open> PMLAR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMLAR_Type v = ( regval_of_bitvector_32(PMLAR_Type_bits   v))\<close> 
  for  "v"  :: " PMLAR_Type "


definition PMLSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMLSR_Type)option \<close>  where 
     \<open> PMLSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMLSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMLSR_Type  :: \<open> PMLSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMLSR_Type v = ( regval_of_bitvector_32(PMLSR_Type_bits   v))\<close> 
  for  "v"  :: " PMLSR_Type "


definition PMMIR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMMIR_EL1_Type)option \<close>  where 
     \<open> PMMIR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMMIR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMMIR_EL1_Type  :: \<open> PMMIR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMMIR_EL1_Type v = ( regval_of_bitvector_64(PMMIR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMMIR_EL1_Type "


definition PMMIR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMMIR_Type)option \<close>  where 
     \<open> PMMIR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMMIR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMMIR_Type  :: \<open> PMMIR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMMIR_Type v = ( regval_of_bitvector_32(PMMIR_Type_bits   v))\<close> 
  for  "v"  :: " PMMIR_Type "


definition PMOVSCLR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMOVSCLR_EL0_Type)option \<close>  where 
     \<open> PMOVSCLR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMOVSCLR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMOVSCLR_EL0_Type  :: \<open> PMOVSCLR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMOVSCLR_EL0_Type v = ( regval_of_bitvector_64(PMOVSCLR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMOVSCLR_EL0_Type "


definition PMOVSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMOVSR_Type)option \<close>  where 
     \<open> PMOVSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMOVSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMOVSR_Type  :: \<open> PMOVSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMOVSR_Type v = ( regval_of_bitvector_32(PMOVSR_Type_bits   v))\<close> 
  for  "v"  :: " PMOVSR_Type "


definition PMOVSSET_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMOVSSET_EL0_Type)option \<close>  where 
     \<open> PMOVSSET_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMOVSSET_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMOVSSET_EL0_Type  :: \<open> PMOVSSET_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMOVSSET_EL0_Type v = ( regval_of_bitvector_64(PMOVSSET_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMOVSSET_EL0_Type "


definition PMOVSSET_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMOVSSET_Type)option \<close>  where 
     \<open> PMOVSSET_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMOVSSET_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMOVSSET_Type  :: \<open> PMOVSSET_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMOVSSET_Type v = ( regval_of_bitvector_32(PMOVSSET_Type_bits   v))\<close> 
  for  "v"  :: " PMOVSSET_Type "


definition PMOVS_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMOVS_Type)option \<close>  where 
     \<open> PMOVS_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMOVS_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMOVS_Type  :: \<open> PMOVS_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMOVS_Type v = ( regval_of_bitvector_64(PMOVS_Type_bits   v))\<close> 
  for  "v"  :: " PMOVS_Type "


definition PMPCSCTL_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMPCSCTL_Type)option \<close>  where 
     \<open> PMPCSCTL_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMPCSCTL_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMPCSCTL_Type  :: \<open> PMPCSCTL_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMPCSCTL_Type v = ( regval_of_bitvector_64(PMPCSCTL_Type_bits   v))\<close> 
  for  "v"  :: " PMPCSCTL_Type "


definition PMPCSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMPCSR_Type)option \<close>  where 
     \<open> PMPCSR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMPCSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMPCSR_Type  :: \<open> PMPCSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMPCSR_Type v = ( regval_of_bitvector_64(PMPCSR_Type_bits   v))\<close> 
  for  "v"  :: " PMPCSR_Type "


definition PMPIDR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMPIDR0_Type)option \<close>  where 
     \<open> PMPIDR0_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMPIDR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMPIDR0_Type  :: \<open> PMPIDR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMPIDR0_Type v = ( regval_of_bitvector_32(PMPIDR0_Type_bits   v))\<close> 
  for  "v"  :: " PMPIDR0_Type "


definition PMPIDR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMPIDR1_Type)option \<close>  where 
     \<open> PMPIDR1_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMPIDR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMPIDR1_Type  :: \<open> PMPIDR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMPIDR1_Type v = ( regval_of_bitvector_32(PMPIDR1_Type_bits   v))\<close> 
  for  "v"  :: " PMPIDR1_Type "


definition PMPIDR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMPIDR2_Type)option \<close>  where 
     \<open> PMPIDR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMPIDR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMPIDR2_Type  :: \<open> PMPIDR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMPIDR2_Type v = ( regval_of_bitvector_32(PMPIDR2_Type_bits   v))\<close> 
  for  "v"  :: " PMPIDR2_Type "


definition PMPIDR3_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMPIDR3_Type)option \<close>  where 
     \<open> PMPIDR3_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMPIDR3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMPIDR3_Type  :: \<open> PMPIDR3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMPIDR3_Type v = ( regval_of_bitvector_32(PMPIDR3_Type_bits   v))\<close> 
  for  "v"  :: " PMPIDR3_Type "


definition PMPIDR4_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMPIDR4_Type)option \<close>  where 
     \<open> PMPIDR4_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMPIDR4_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMPIDR4_Type  :: \<open> PMPIDR4_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMPIDR4_Type v = ( regval_of_bitvector_32(PMPIDR4_Type_bits   v))\<close> 
  for  "v"  :: " PMPIDR4_Type "


definition PMSCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSCR_EL1_Type)option \<close>  where 
     \<open> PMSCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSCR_EL1_Type  :: \<open> PMSCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSCR_EL1_Type v = ( regval_of_bitvector_64(PMSCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMSCR_EL1_Type "


definition PMSCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSCR_EL2_Type)option \<close>  where 
     \<open> PMSCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSCR_EL2_Type  :: \<open> PMSCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSCR_EL2_Type v = ( regval_of_bitvector_64(PMSCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " PMSCR_EL2_Type "


definition PMSDSFR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSDSFR_EL1_Type)option \<close>  where 
     \<open> PMSDSFR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSDSFR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSDSFR_EL1_Type  :: \<open> PMSDSFR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSDSFR_EL1_Type v = ( regval_of_bitvector_64(PMSDSFR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMSDSFR_EL1_Type "


definition PMSELR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSELR_EL0_Type)option \<close>  where 
     \<open> PMSELR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSELR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSELR_EL0_Type  :: \<open> PMSELR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSELR_EL0_Type v = ( regval_of_bitvector_64(PMSELR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMSELR_EL0_Type "


definition PMSELR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSELR_Type)option \<close>  where 
     \<open> PMSELR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMSELR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSELR_Type  :: \<open> PMSELR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSELR_Type v = ( regval_of_bitvector_32(PMSELR_Type_bits   v))\<close> 
  for  "v"  :: " PMSELR_Type "


definition PMSEVFR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSEVFR_EL1_Type)option \<close>  where 
     \<open> PMSEVFR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSEVFR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSEVFR_EL1_Type  :: \<open> PMSEVFR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSEVFR_EL1_Type v = ( regval_of_bitvector_64(PMSEVFR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMSEVFR_EL1_Type "


definition PMSFCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSFCR_EL1_Type)option \<close>  where 
     \<open> PMSFCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSFCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSFCR_EL1_Type  :: \<open> PMSFCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSFCR_EL1_Type v = ( regval_of_bitvector_64(PMSFCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMSFCR_EL1_Type "


definition PMSICR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSICR_EL1_Type)option \<close>  where 
     \<open> PMSICR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSICR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSICR_EL1_Type  :: \<open> PMSICR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSICR_EL1_Type v = ( regval_of_bitvector_64(PMSICR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMSICR_EL1_Type "


definition PMSIDR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSIDR_EL1_Type)option \<close>  where 
     \<open> PMSIDR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSIDR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSIDR_EL1_Type  :: \<open> PMSIDR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSIDR_EL1_Type v = ( regval_of_bitvector_64(PMSIDR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMSIDR_EL1_Type "


definition PMSIRR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSIRR_EL1_Type)option \<close>  where 
     \<open> PMSIRR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSIRR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSIRR_EL1_Type  :: \<open> PMSIRR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSIRR_EL1_Type v = ( regval_of_bitvector_64(PMSIRR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMSIRR_EL1_Type "


definition PMSLATFR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSLATFR_EL1_Type)option \<close>  where 
     \<open> PMSLATFR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSLATFR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSLATFR_EL1_Type  :: \<open> PMSLATFR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSLATFR_EL1_Type v = ( regval_of_bitvector_64(PMSLATFR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMSLATFR_EL1_Type "


definition PMSNEVFR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSNEVFR_EL1_Type)option \<close>  where 
     \<open> PMSNEVFR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSNEVFR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSNEVFR_EL1_Type  :: \<open> PMSNEVFR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSNEVFR_EL1_Type v = ( regval_of_bitvector_64(PMSNEVFR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMSNEVFR_EL1_Type "


definition PMSSCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSSCR_EL1_Type)option \<close>  where 
     \<open> PMSSCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSSCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSSCR_EL1_Type  :: \<open> PMSSCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSSCR_EL1_Type v = ( regval_of_bitvector_64(PMSSCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMSSCR_EL1_Type "


definition PMSWINC_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSWINC_EL0_Type)option \<close>  where 
     \<open> PMSWINC_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMSWINC_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSWINC_EL0_Type  :: \<open> PMSWINC_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSWINC_EL0_Type v = ( regval_of_bitvector_64(PMSWINC_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMSWINC_EL0_Type "


definition PMSWINC_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMSWINC_Type)option \<close>  where 
     \<open> PMSWINC_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMSWINC_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMSWINC_Type  :: \<open> PMSWINC_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMSWINC_Type v = ( regval_of_bitvector_32(PMSWINC_Type_bits   v))\<close> 
  for  "v"  :: " PMSWINC_Type "


definition PMUACR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMUACR_EL1_Type)option \<close>  where 
     \<open> PMUACR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMUACR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMUACR_EL1_Type  :: \<open> PMUACR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMUACR_EL1_Type v = ( regval_of_bitvector_64(PMUACR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " PMUACR_EL1_Type "


definition PMUSERENR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMUSERENR_EL0_Type)option \<close>  where 
     \<open> PMUSERENR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMUSERENR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMUSERENR_EL0_Type  :: \<open> PMUSERENR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMUSERENR_EL0_Type v = ( regval_of_bitvector_64(PMUSERENR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMUSERENR_EL0_Type "


definition PMUSERENR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMUSERENR_Type)option \<close>  where 
     \<open> PMUSERENR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMUSERENR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMUSERENR_Type  :: \<open> PMUSERENR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMUSERENR_Type v = ( regval_of_bitvector_32(PMUSERENR_Type_bits   v))\<close> 
  for  "v"  :: " PMUSERENR_Type "


definition PMVCIDSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMVCIDSR_Type)option \<close>  where 
     \<open> PMVCIDSR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMVCIDSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMVCIDSR_Type  :: \<open> PMVCIDSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMVCIDSR_Type v = ( regval_of_bitvector_64(PMVCIDSR_Type_bits   v))\<close> 
  for  "v"  :: " PMVCIDSR_Type "


definition PMVIDSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMVIDSR_Type)option \<close>  where 
     \<open> PMVIDSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PMVIDSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMVIDSR_Type  :: \<open> PMVIDSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMVIDSR_Type v = ( regval_of_bitvector_32(PMVIDSR_Type_bits   v))\<close> 
  for  "v"  :: " PMVIDSR_Type "


definition PMXEVCNTR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMXEVCNTR_EL0_Type)option \<close>  where 
     \<open> PMXEVCNTR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMXEVCNTR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMXEVCNTR_EL0_Type  :: \<open> PMXEVCNTR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMXEVCNTR_EL0_Type v = ( regval_of_bitvector_64(PMXEVCNTR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMXEVCNTR_EL0_Type "


definition PMZR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(PMZR_EL0_Type)option \<close>  where 
     \<open> PMZR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| PMZR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PMZR_EL0_Type  :: \<open> PMZR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PMZR_EL0_Type v = ( regval_of_bitvector_64(PMZR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " PMZR_EL0_Type "


definition POR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(POR_EL0_Type)option \<close>  where 
     \<open> POR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| POR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_POR_EL0_Type  :: \<open> POR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_POR_EL0_Type v = ( regval_of_bitvector_64(POR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " POR_EL0_Type "


definition POR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(POR_EL1_Type)option \<close>  where 
     \<open> POR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| POR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_POR_EL1_Type  :: \<open> POR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_POR_EL1_Type v = ( regval_of_bitvector_64(POR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " POR_EL1_Type "


definition POR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(POR_EL2_Type)option \<close>  where 
     \<open> POR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| POR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_POR_EL2_Type  :: \<open> POR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_POR_EL2_Type v = ( regval_of_bitvector_64(POR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " POR_EL2_Type "


definition POR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(POR_EL3_Type)option \<close>  where 
     \<open> POR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| POR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_POR_EL3_Type  :: \<open> POR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_POR_EL3_Type v = ( regval_of_bitvector_64(POR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " POR_EL3_Type "


definition PRRR_Type_of_regval  :: \<open> register_value \<Rightarrow>(PRRR_Type)option \<close>  where 
     \<open> PRRR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| PRRR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_PRRR_Type  :: \<open> PRRR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_PRRR_Type v = ( regval_of_bitvector_32(PRRR_Type_bits   v))\<close> 
  for  "v"  :: " PRRR_Type "


fun ProcState_of_regval  :: \<open> register_value \<Rightarrow>(ProcState)option \<close>  where 
     \<open> ProcState_of_regval (Regval_ProcState (v)) = ( Some v )\<close> 
  for  "v"  :: " ProcState "
|\<open> ProcState_of_regval _ = ( None )\<close>


definition regval_of_ProcState  :: \<open> ProcState \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ProcState v = ( Regval_ProcState v )\<close> 
  for  "v"  :: " ProcState "


definition RCWMASK_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(RCWMASK_EL1_Type)option \<close>  where 
     \<open> RCWMASK_EL1_Type_of_regval v = (
   (case  ((bitvector_128_of_regval v  ::  ( 128 Word.word)option)) of
     Some (v) => Some ((| RCWMASK_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RCWMASK_EL1_Type  :: \<open> RCWMASK_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RCWMASK_EL1_Type v = ( regval_of_bitvector_128(RCWMASK_EL1_Type_bits   v))\<close> 
  for  "v"  :: " RCWMASK_EL1_Type "


definition RCWSMASK_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(RCWSMASK_EL1_Type)option \<close>  where 
     \<open> RCWSMASK_EL1_Type_of_regval v = (
   (case  ((bitvector_128_of_regval v  ::  ( 128 Word.word)option)) of
     Some (v) => Some ((| RCWSMASK_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RCWSMASK_EL1_Type  :: \<open> RCWSMASK_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RCWSMASK_EL1_Type v = ( regval_of_bitvector_128(RCWSMASK_EL1_Type_bits   v))\<close> 
  for  "v"  :: " RCWSMASK_EL1_Type "


definition RGSR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(RGSR_EL1_Type)option \<close>  where 
     \<open> RGSR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| RGSR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RGSR_EL1_Type  :: \<open> RGSR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RGSR_EL1_Type v = ( regval_of_bitvector_64(RGSR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " RGSR_EL1_Type "


definition RMR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(RMR_EL1_Type)option \<close>  where 
     \<open> RMR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| RMR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RMR_EL1_Type  :: \<open> RMR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RMR_EL1_Type v = ( regval_of_bitvector_64(RMR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " RMR_EL1_Type "


definition RMR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(RMR_EL2_Type)option \<close>  where 
     \<open> RMR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| RMR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RMR_EL2_Type  :: \<open> RMR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RMR_EL2_Type v = ( regval_of_bitvector_64(RMR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " RMR_EL2_Type "


definition RMR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(RMR_EL3_Type)option \<close>  where 
     \<open> RMR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| RMR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RMR_EL3_Type  :: \<open> RMR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RMR_EL3_Type v = ( regval_of_bitvector_64(RMR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " RMR_EL3_Type "


definition RMR_Type_of_regval  :: \<open> register_value \<Rightarrow>(RMR_Type)option \<close>  where 
     \<open> RMR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| RMR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RMR_Type  :: \<open> RMR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RMR_Type v = ( regval_of_bitvector_32(RMR_Type_bits   v))\<close> 
  for  "v"  :: " RMR_Type "


definition RNDRRS_Type_of_regval  :: \<open> register_value \<Rightarrow>(RNDRRS_Type)option \<close>  where 
     \<open> RNDRRS_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| RNDRRS_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RNDRRS_Type  :: \<open> RNDRRS_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RNDRRS_Type v = ( regval_of_bitvector_64(RNDRRS_Type_bits   v))\<close> 
  for  "v"  :: " RNDRRS_Type "


definition RNDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(RNDR_Type)option \<close>  where 
     \<open> RNDR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| RNDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RNDR_Type  :: \<open> RNDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RNDR_Type v = ( regval_of_bitvector_64(RNDR_Type_bits   v))\<close> 
  for  "v"  :: " RNDR_Type "


definition RVBAR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(RVBAR_EL1_Type)option \<close>  where 
     \<open> RVBAR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| RVBAR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RVBAR_EL1_Type  :: \<open> RVBAR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RVBAR_EL1_Type v = ( regval_of_bitvector_64(RVBAR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " RVBAR_EL1_Type "


definition RVBAR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(RVBAR_EL2_Type)option \<close>  where 
     \<open> RVBAR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| RVBAR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RVBAR_EL2_Type  :: \<open> RVBAR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RVBAR_EL2_Type v = ( regval_of_bitvector_64(RVBAR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " RVBAR_EL2_Type "


definition RVBAR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(RVBAR_EL3_Type)option \<close>  where 
     \<open> RVBAR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| RVBAR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_RVBAR_EL3_Type  :: \<open> RVBAR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_RVBAR_EL3_Type v = ( regval_of_bitvector_64(RVBAR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " RVBAR_EL3_Type "


definition S2PIR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(S2PIR_EL2_Type)option \<close>  where 
     \<open> S2PIR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| S2PIR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_S2PIR_EL2_Type  :: \<open> S2PIR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_S2PIR_EL2_Type v = ( regval_of_bitvector_64(S2PIR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " S2PIR_EL2_Type "


definition S2POR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(S2POR_EL1_Type)option \<close>  where 
     \<open> S2POR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| S2POR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_S2POR_EL1_Type  :: \<open> S2POR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_S2POR_EL1_Type v = ( regval_of_bitvector_64(S2POR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " S2POR_EL1_Type "


definition SCR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(SCR_EL3_Type)option \<close>  where 
     \<open> SCR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SCR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SCR_EL3_Type  :: \<open> SCR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SCR_EL3_Type v = ( regval_of_bitvector_64(SCR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " SCR_EL3_Type "


definition SCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(SCR_Type)option \<close>  where 
     \<open> SCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| SCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SCR_Type  :: \<open> SCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SCR_Type v = ( regval_of_bitvector_32(SCR_Type_bits   v))\<close> 
  for  "v"  :: " SCR_Type "


definition SCTLR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(SCTLR2_EL1_Type)option \<close>  where 
     \<open> SCTLR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SCTLR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SCTLR2_EL1_Type  :: \<open> SCTLR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SCTLR2_EL1_Type v = ( regval_of_bitvector_64(SCTLR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " SCTLR2_EL1_Type "


definition SCTLR2_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(SCTLR2_EL2_Type)option \<close>  where 
     \<open> SCTLR2_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SCTLR2_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SCTLR2_EL2_Type  :: \<open> SCTLR2_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SCTLR2_EL2_Type v = ( regval_of_bitvector_64(SCTLR2_EL2_Type_bits   v))\<close> 
  for  "v"  :: " SCTLR2_EL2_Type "


definition SCTLR2_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(SCTLR2_EL3_Type)option \<close>  where 
     \<open> SCTLR2_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SCTLR2_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SCTLR2_EL3_Type  :: \<open> SCTLR2_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SCTLR2_EL3_Type v = ( regval_of_bitvector_64(SCTLR2_EL3_Type_bits   v))\<close> 
  for  "v"  :: " SCTLR2_EL3_Type "


definition SCTLR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(SCTLR_EL1_Type)option \<close>  where 
     \<open> SCTLR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SCTLR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SCTLR_EL1_Type  :: \<open> SCTLR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SCTLR_EL1_Type v = ( regval_of_bitvector_64(SCTLR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " SCTLR_EL1_Type "


definition SCTLR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(SCTLR_EL2_Type)option \<close>  where 
     \<open> SCTLR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SCTLR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SCTLR_EL2_Type  :: \<open> SCTLR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SCTLR_EL2_Type v = ( regval_of_bitvector_64(SCTLR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " SCTLR_EL2_Type "


definition SCTLR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(SCTLR_EL3_Type)option \<close>  where 
     \<open> SCTLR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SCTLR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SCTLR_EL3_Type  :: \<open> SCTLR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SCTLR_EL3_Type v = ( regval_of_bitvector_64(SCTLR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " SCTLR_EL3_Type "


definition SCTLR_Type_of_regval  :: \<open> register_value \<Rightarrow>(SCTLR_Type)option \<close>  where 
     \<open> SCTLR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| SCTLR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SCTLR_Type  :: \<open> SCTLR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SCTLR_Type v = ( regval_of_bitvector_32(SCTLR_Type_bits   v))\<close> 
  for  "v"  :: " SCTLR_Type "


definition SDCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(SDCR_Type)option \<close>  where 
     \<open> SDCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| SDCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SDCR_Type  :: \<open> SDCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SDCR_Type v = ( regval_of_bitvector_32(SDCR_Type_bits   v))\<close> 
  for  "v"  :: " SDCR_Type "


definition SDER32_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(SDER32_EL2_Type)option \<close>  where 
     \<open> SDER32_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SDER32_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SDER32_EL2_Type  :: \<open> SDER32_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SDER32_EL2_Type v = ( regval_of_bitvector_64(SDER32_EL2_Type_bits   v))\<close> 
  for  "v"  :: " SDER32_EL2_Type "


definition SDER32_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(SDER32_EL3_Type)option \<close>  where 
     \<open> SDER32_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SDER32_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SDER32_EL3_Type  :: \<open> SDER32_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SDER32_EL3_Type v = ( regval_of_bitvector_64(SDER32_EL3_Type_bits   v))\<close> 
  for  "v"  :: " SDER32_EL3_Type "


definition SDER_Type_of_regval  :: \<open> register_value \<Rightarrow>(SDER_Type)option \<close>  where 
     \<open> SDER_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| SDER_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SDER_Type  :: \<open> SDER_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SDER_Type v = ( regval_of_bitvector_32(SDER_Type_bits   v))\<close> 
  for  "v"  :: " SDER_Type "


definition SMCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(SMCR_EL1_Type)option \<close>  where 
     \<open> SMCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SMCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SMCR_EL1_Type  :: \<open> SMCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SMCR_EL1_Type v = ( regval_of_bitvector_64(SMCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " SMCR_EL1_Type "


definition SMCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(SMCR_EL2_Type)option \<close>  where 
     \<open> SMCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SMCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SMCR_EL2_Type  :: \<open> SMCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SMCR_EL2_Type v = ( regval_of_bitvector_64(SMCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " SMCR_EL2_Type "


definition SMCR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(SMCR_EL3_Type)option \<close>  where 
     \<open> SMCR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SMCR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SMCR_EL3_Type  :: \<open> SMCR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SMCR_EL3_Type v = ( regval_of_bitvector_64(SMCR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " SMCR_EL3_Type "


definition SMIDR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(SMIDR_EL1_Type)option \<close>  where 
     \<open> SMIDR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SMIDR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SMIDR_EL1_Type  :: \<open> SMIDR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SMIDR_EL1_Type v = ( regval_of_bitvector_64(SMIDR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " SMIDR_EL1_Type "


definition SMPRIMAP_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(SMPRIMAP_EL2_Type)option \<close>  where 
     \<open> SMPRIMAP_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SMPRIMAP_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SMPRIMAP_EL2_Type  :: \<open> SMPRIMAP_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SMPRIMAP_EL2_Type v = ( regval_of_bitvector_64(SMPRIMAP_EL2_Type_bits   v))\<close> 
  for  "v"  :: " SMPRIMAP_EL2_Type "


definition SMPRI_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(SMPRI_EL1_Type)option \<close>  where 
     \<open> SMPRI_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SMPRI_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SMPRI_EL1_Type  :: \<open> SMPRI_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SMPRI_EL1_Type v = ( regval_of_bitvector_64(SMPRI_EL1_Type_bits   v))\<close> 
  for  "v"  :: " SMPRI_EL1_Type "


definition SPMACCESSR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPMACCESSR_EL1_Type)option \<close>  where 
     \<open> SPMACCESSR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPMACCESSR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPMACCESSR_EL1_Type  :: \<open> SPMACCESSR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPMACCESSR_EL1_Type v = ( regval_of_bitvector_64(SPMACCESSR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " SPMACCESSR_EL1_Type "


definition SPMACCESSR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPMACCESSR_EL2_Type)option \<close>  where 
     \<open> SPMACCESSR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPMACCESSR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPMACCESSR_EL2_Type  :: \<open> SPMACCESSR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPMACCESSR_EL2_Type v = ( regval_of_bitvector_64(SPMACCESSR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " SPMACCESSR_EL2_Type "


definition SPMACCESSR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPMACCESSR_EL3_Type)option \<close>  where 
     \<open> SPMACCESSR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPMACCESSR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPMACCESSR_EL3_Type  :: \<open> SPMACCESSR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPMACCESSR_EL3_Type v = ( regval_of_bitvector_64(SPMACCESSR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " SPMACCESSR_EL3_Type "


definition SPMSELR_EL0_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPMSELR_EL0_Type)option \<close>  where 
     \<open> SPMSELR_EL0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPMSELR_EL0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPMSELR_EL0_Type  :: \<open> SPMSELR_EL0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPMSELR_EL0_Type v = ( regval_of_bitvector_64(SPMSELR_EL0_Type_bits   v))\<close> 
  for  "v"  :: " SPMSELR_EL0_Type "


definition SPSR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPSR_EL1_Type)option \<close>  where 
     \<open> SPSR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPSR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPSR_EL1_Type  :: \<open> SPSR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPSR_EL1_Type v = ( regval_of_bitvector_64(SPSR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " SPSR_EL1_Type "


definition SPSR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPSR_EL2_Type)option \<close>  where 
     \<open> SPSR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPSR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPSR_EL2_Type  :: \<open> SPSR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPSR_EL2_Type v = ( regval_of_bitvector_64(SPSR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " SPSR_EL2_Type "


definition SPSR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPSR_EL3_Type)option \<close>  where 
     \<open> SPSR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPSR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPSR_EL3_Type  :: \<open> SPSR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPSR_EL3_Type v = ( regval_of_bitvector_64(SPSR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " SPSR_EL3_Type "


definition SPSR_abt_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPSR_abt_Type)option \<close>  where 
     \<open> SPSR_abt_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPSR_abt_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPSR_abt_Type  :: \<open> SPSR_abt_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPSR_abt_Type v = ( regval_of_bitvector_64(SPSR_abt_Type_bits   v))\<close> 
  for  "v"  :: " SPSR_abt_Type "


definition SPSR_fiq_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPSR_fiq_Type)option \<close>  where 
     \<open> SPSR_fiq_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPSR_fiq_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPSR_fiq_Type  :: \<open> SPSR_fiq_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPSR_fiq_Type v = ( regval_of_bitvector_64(SPSR_fiq_Type_bits   v))\<close> 
  for  "v"  :: " SPSR_fiq_Type "


definition SPSR_hyp_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPSR_hyp_Type)option \<close>  where 
     \<open> SPSR_hyp_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| SPSR_hyp_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPSR_hyp_Type  :: \<open> SPSR_hyp_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPSR_hyp_Type v = ( regval_of_bitvector_32(SPSR_hyp_Type_bits   v))\<close> 
  for  "v"  :: " SPSR_hyp_Type "


definition SPSR_irq_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPSR_irq_Type)option \<close>  where 
     \<open> SPSR_irq_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPSR_irq_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPSR_irq_Type  :: \<open> SPSR_irq_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPSR_irq_Type v = ( regval_of_bitvector_64(SPSR_irq_Type_bits   v))\<close> 
  for  "v"  :: " SPSR_irq_Type "


definition SPSR_mon_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPSR_mon_Type)option \<close>  where 
     \<open> SPSR_mon_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| SPSR_mon_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPSR_mon_Type  :: \<open> SPSR_mon_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPSR_mon_Type v = ( regval_of_bitvector_32(SPSR_mon_Type_bits   v))\<close> 
  for  "v"  :: " SPSR_mon_Type "


definition SPSR_svc_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPSR_svc_Type)option \<close>  where 
     \<open> SPSR_svc_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| SPSR_svc_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPSR_svc_Type  :: \<open> SPSR_svc_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPSR_svc_Type v = ( regval_of_bitvector_32(SPSR_svc_Type_bits   v))\<close> 
  for  "v"  :: " SPSR_svc_Type "


definition SPSR_und_Type_of_regval  :: \<open> register_value \<Rightarrow>(SPSR_und_Type)option \<close>  where 
     \<open> SPSR_und_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| SPSR_und_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_SPSR_und_Type  :: \<open> SPSR_und_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_SPSR_und_Type v = ( regval_of_bitvector_64(SPSR_und_Type_bits   v))\<close> 
  for  "v"  :: " SPSR_und_Type "


fun Signal_of_regval  :: \<open> register_value \<Rightarrow>(Signal)option \<close>  where 
     \<open> Signal_of_regval (Regval_Signal (v)) = ( Some v )\<close> 
  for  "v"  :: " Signal "
|\<open> Signal_of_regval _ = ( None )\<close>


definition regval_of_Signal  :: \<open> Signal \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_Signal v = ( Regval_Signal v )\<close> 
  for  "v"  :: " Signal "


definition TCR2_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(TCR2_EL1_Type)option \<close>  where 
     \<open> TCR2_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TCR2_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TCR2_EL1_Type  :: \<open> TCR2_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TCR2_EL1_Type v = ( regval_of_bitvector_64(TCR2_EL1_Type_bits   v))\<close> 
  for  "v"  :: " TCR2_EL1_Type "


definition TCR2_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(TCR2_EL2_Type)option \<close>  where 
     \<open> TCR2_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TCR2_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TCR2_EL2_Type  :: \<open> TCR2_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TCR2_EL2_Type v = ( regval_of_bitvector_64(TCR2_EL2_Type_bits   v))\<close> 
  for  "v"  :: " TCR2_EL2_Type "


definition TCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(TCR_EL1_Type)option \<close>  where 
     \<open> TCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TCR_EL1_Type  :: \<open> TCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TCR_EL1_Type v = ( regval_of_bitvector_64(TCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " TCR_EL1_Type "


definition TCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(TCR_EL2_Type)option \<close>  where 
     \<open> TCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TCR_EL2_Type  :: \<open> TCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TCR_EL2_Type v = ( regval_of_bitvector_64(TCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " TCR_EL2_Type "


definition TCR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(TCR_EL3_Type)option \<close>  where 
     \<open> TCR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TCR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TCR_EL3_Type  :: \<open> TCR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TCR_EL3_Type v = ( regval_of_bitvector_64(TCR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " TCR_EL3_Type "


definition TFSRE0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(TFSRE0_EL1_Type)option \<close>  where 
     \<open> TFSRE0_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TFSRE0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TFSRE0_EL1_Type  :: \<open> TFSRE0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TFSRE0_EL1_Type v = ( regval_of_bitvector_64(TFSRE0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " TFSRE0_EL1_Type "


definition TFSR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(TFSR_EL1_Type)option \<close>  where 
     \<open> TFSR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TFSR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TFSR_EL1_Type  :: \<open> TFSR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TFSR_EL1_Type v = ( regval_of_bitvector_64(TFSR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " TFSR_EL1_Type "


definition TFSR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(TFSR_EL2_Type)option \<close>  where 
     \<open> TFSR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TFSR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TFSR_EL2_Type  :: \<open> TFSR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TFSR_EL2_Type v = ( regval_of_bitvector_64(TFSR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " TFSR_EL2_Type "


definition TFSR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(TFSR_EL3_Type)option \<close>  where 
     \<open> TFSR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TFSR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TFSR_EL3_Type  :: \<open> TFSR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TFSR_EL3_Type v = ( regval_of_bitvector_64(TFSR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " TFSR_EL3_Type "


definition TLBTR_Type_of_regval  :: \<open> register_value \<Rightarrow>(TLBTR_Type)option \<close>  where 
     \<open> TLBTR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| TLBTR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TLBTR_Type  :: \<open> TLBTR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TLBTR_Type v = ( regval_of_bitvector_32(TLBTR_Type_bits   v))\<close> 
  for  "v"  :: " TLBTR_Type "


fun TMState_of_regval  :: \<open> register_value \<Rightarrow>(TMState)option \<close>  where 
     \<open> TMState_of_regval (Regval_TMState (v)) = ( Some v )\<close> 
  for  "v"  :: " TMState "
|\<open> TMState_of_regval _ = ( None )\<close>


definition regval_of_TMState  :: \<open> TMState \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TMState v = ( Regval_TMState v )\<close> 
  for  "v"  :: " TMState "


definition TRFCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(TRFCR_EL1_Type)option \<close>  where 
     \<open> TRFCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TRFCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TRFCR_EL1_Type  :: \<open> TRFCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TRFCR_EL1_Type v = ( regval_of_bitvector_64(TRFCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " TRFCR_EL1_Type "


definition TRFCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(TRFCR_EL2_Type)option \<close>  where 
     \<open> TRFCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TRFCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TRFCR_EL2_Type  :: \<open> TRFCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TRFCR_EL2_Type v = ( regval_of_bitvector_64(TRFCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " TRFCR_EL2_Type "


definition TRFCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(TRFCR_Type)option \<close>  where 
     \<open> TRFCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| TRFCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TRFCR_Type  :: \<open> TRFCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TRFCR_Type v = ( regval_of_bitvector_32(TRFCR_Type_bits   v))\<close> 
  for  "v"  :: " TRFCR_Type "


definition TTBCR2_Type_of_regval  :: \<open> register_value \<Rightarrow>(TTBCR2_Type)option \<close>  where 
     \<open> TTBCR2_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| TTBCR2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TTBCR2_Type  :: \<open> TTBCR2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TTBCR2_Type v = ( regval_of_bitvector_32(TTBCR2_Type_bits   v))\<close> 
  for  "v"  :: " TTBCR2_Type "


definition TTBCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(TTBCR_Type)option \<close>  where 
     \<open> TTBCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| TTBCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TTBCR_Type  :: \<open> TTBCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TTBCR_Type v = ( regval_of_bitvector_32(TTBCR_Type_bits   v))\<close> 
  for  "v"  :: " TTBCR_Type "


definition TTBR0_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(TTBR0_EL1_Type)option \<close>  where 
     \<open> TTBR0_EL1_Type_of_regval v = (
   (case  ((bitvector_128_of_regval v  ::  ( 128 Word.word)option)) of
     Some (v) => Some ((| TTBR0_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TTBR0_EL1_Type  :: \<open> TTBR0_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TTBR0_EL1_Type v = ( regval_of_bitvector_128(TTBR0_EL1_Type_bits   v))\<close> 
  for  "v"  :: " TTBR0_EL1_Type "


definition TTBR0_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(TTBR0_EL2_Type)option \<close>  where 
     \<open> TTBR0_EL2_Type_of_regval v = (
   (case  ((bitvector_128_of_regval v  ::  ( 128 Word.word)option)) of
     Some (v) => Some ((| TTBR0_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TTBR0_EL2_Type  :: \<open> TTBR0_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TTBR0_EL2_Type v = ( regval_of_bitvector_128(TTBR0_EL2_Type_bits   v))\<close> 
  for  "v"  :: " TTBR0_EL2_Type "


definition TTBR0_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(TTBR0_EL3_Type)option \<close>  where 
     \<open> TTBR0_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TTBR0_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TTBR0_EL3_Type  :: \<open> TTBR0_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TTBR0_EL3_Type v = ( regval_of_bitvector_64(TTBR0_EL3_Type_bits   v))\<close> 
  for  "v"  :: " TTBR0_EL3_Type "


definition TTBR0_Type_of_regval  :: \<open> register_value \<Rightarrow>(TTBR0_Type)option \<close>  where 
     \<open> TTBR0_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TTBR0_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TTBR0_Type  :: \<open> TTBR0_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TTBR0_Type v = ( regval_of_bitvector_64(TTBR0_Type_bits   v))\<close> 
  for  "v"  :: " TTBR0_Type "


definition TTBR1_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(TTBR1_EL1_Type)option \<close>  where 
     \<open> TTBR1_EL1_Type_of_regval v = (
   (case  ((bitvector_128_of_regval v  ::  ( 128 Word.word)option)) of
     Some (v) => Some ((| TTBR1_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TTBR1_EL1_Type  :: \<open> TTBR1_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TTBR1_EL1_Type v = ( regval_of_bitvector_128(TTBR1_EL1_Type_bits   v))\<close> 
  for  "v"  :: " TTBR1_EL1_Type "


definition TTBR1_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(TTBR1_EL2_Type)option \<close>  where 
     \<open> TTBR1_EL2_Type_of_regval v = (
   (case  ((bitvector_128_of_regval v  ::  ( 128 Word.word)option)) of
     Some (v) => Some ((| TTBR1_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TTBR1_EL2_Type  :: \<open> TTBR1_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TTBR1_EL2_Type v = ( regval_of_bitvector_128(TTBR1_EL2_Type_bits   v))\<close> 
  for  "v"  :: " TTBR1_EL2_Type "


definition TTBR1_Type_of_regval  :: \<open> register_value \<Rightarrow>(TTBR1_Type)option \<close>  where 
     \<open> TTBR1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| TTBR1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_TTBR1_Type  :: \<open> TTBR1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_TTBR1_Type v = ( regval_of_bitvector_64(TTBR1_Type_bits   v))\<close> 
  for  "v"  :: " TTBR1_Type "


definition VDFSR_Type_of_regval  :: \<open> register_value \<Rightarrow>(VDFSR_Type)option \<close>  where 
     \<open> VDFSR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| VDFSR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VDFSR_Type  :: \<open> VDFSR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VDFSR_Type v = ( regval_of_bitvector_32(VDFSR_Type_bits   v))\<close> 
  for  "v"  :: " VDFSR_Type "


definition VDISR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VDISR_EL2_Type)option \<close>  where 
     \<open> VDISR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VDISR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VDISR_EL2_Type  :: \<open> VDISR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VDISR_EL2_Type v = ( regval_of_bitvector_64(VDISR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VDISR_EL2_Type "


definition VDISR_Type_of_regval  :: \<open> register_value \<Rightarrow>(VDISR_Type)option \<close>  where 
     \<open> VDISR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| VDISR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VDISR_Type  :: \<open> VDISR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VDISR_Type v = ( regval_of_bitvector_32(VDISR_Type_bits   v))\<close> 
  for  "v"  :: " VDISR_Type "


definition VMECID_A_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VMECID_A_EL2_Type)option \<close>  where 
     \<open> VMECID_A_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VMECID_A_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VMECID_A_EL2_Type  :: \<open> VMECID_A_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VMECID_A_EL2_Type v = ( regval_of_bitvector_64(VMECID_A_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VMECID_A_EL2_Type "


definition VMECID_P_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VMECID_P_EL2_Type)option \<close>  where 
     \<open> VMECID_P_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VMECID_P_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VMECID_P_EL2_Type  :: \<open> VMECID_P_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VMECID_P_EL2_Type v = ( regval_of_bitvector_64(VMECID_P_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VMECID_P_EL2_Type "


definition VMPIDR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VMPIDR_EL2_Type)option \<close>  where 
     \<open> VMPIDR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VMPIDR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VMPIDR_EL2_Type  :: \<open> VMPIDR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VMPIDR_EL2_Type v = ( regval_of_bitvector_64(VMPIDR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VMPIDR_EL2_Type "


definition VMPIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(VMPIDR_Type)option \<close>  where 
     \<open> VMPIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| VMPIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VMPIDR_Type  :: \<open> VMPIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VMPIDR_Type v = ( regval_of_bitvector_32(VMPIDR_Type_bits   v))\<close> 
  for  "v"  :: " VMPIDR_Type "


definition VNCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VNCR_EL2_Type)option \<close>  where 
     \<open> VNCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VNCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VNCR_EL2_Type  :: \<open> VNCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VNCR_EL2_Type v = ( regval_of_bitvector_64(VNCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VNCR_EL2_Type "


definition VPIDR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VPIDR_EL2_Type)option \<close>  where 
     \<open> VPIDR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VPIDR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VPIDR_EL2_Type  :: \<open> VPIDR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VPIDR_EL2_Type v = ( regval_of_bitvector_64(VPIDR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VPIDR_EL2_Type "


definition VPIDR_Type_of_regval  :: \<open> register_value \<Rightarrow>(VPIDR_Type)option \<close>  where 
     \<open> VPIDR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| VPIDR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VPIDR_Type  :: \<open> VPIDR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VPIDR_Type v = ( regval_of_bitvector_32(VPIDR_Type_bits   v))\<close> 
  for  "v"  :: " VPIDR_Type "


definition VSESR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VSESR_EL2_Type)option \<close>  where 
     \<open> VSESR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VSESR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VSESR_EL2_Type  :: \<open> VSESR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VSESR_EL2_Type v = ( regval_of_bitvector_64(VSESR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VSESR_EL2_Type "


definition VSTCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VSTCR_EL2_Type)option \<close>  where 
     \<open> VSTCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VSTCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VSTCR_EL2_Type  :: \<open> VSTCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VSTCR_EL2_Type v = ( regval_of_bitvector_64(VSTCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VSTCR_EL2_Type "


definition VSTTBR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VSTTBR_EL2_Type)option \<close>  where 
     \<open> VSTTBR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VSTTBR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VSTTBR_EL2_Type  :: \<open> VSTTBR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VSTTBR_EL2_Type v = ( regval_of_bitvector_64(VSTTBR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VSTTBR_EL2_Type "


definition VTCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VTCR_EL2_Type)option \<close>  where 
     \<open> VTCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VTCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VTCR_EL2_Type  :: \<open> VTCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VTCR_EL2_Type v = ( regval_of_bitvector_64(VTCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VTCR_EL2_Type "


definition VTCR_Type_of_regval  :: \<open> register_value \<Rightarrow>(VTCR_Type)option \<close>  where 
     \<open> VTCR_Type_of_regval v = (
   (case  ((bitvector_32_of_regval v  ::  ( 32 Word.word)option)) of
     Some (v) => Some ((| VTCR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VTCR_Type  :: \<open> VTCR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VTCR_Type v = ( regval_of_bitvector_32(VTCR_Type_bits   v))\<close> 
  for  "v"  :: " VTCR_Type "


definition VTTBR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(VTTBR_EL2_Type)option \<close>  where 
     \<open> VTTBR_EL2_Type_of_regval v = (
   (case  ((bitvector_128_of_regval v  ::  ( 128 Word.word)option)) of
     Some (v) => Some ((| VTTBR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VTTBR_EL2_Type  :: \<open> VTTBR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VTTBR_EL2_Type v = ( regval_of_bitvector_128(VTTBR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " VTTBR_EL2_Type "


definition VTTBR_Type_of_regval  :: \<open> register_value \<Rightarrow>(VTTBR_Type)option \<close>  where 
     \<open> VTTBR_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| VTTBR_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_VTTBR_Type  :: \<open> VTTBR_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_VTTBR_Type v = ( regval_of_bitvector_64(VTTBR_Type_bits   v))\<close> 
  for  "v"  :: " VTTBR_Type "


definition ZCR_EL1_Type_of_regval  :: \<open> register_value \<Rightarrow>(ZCR_EL1_Type)option \<close>  where 
     \<open> ZCR_EL1_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ZCR_EL1_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ZCR_EL1_Type  :: \<open> ZCR_EL1_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ZCR_EL1_Type v = ( regval_of_bitvector_64(ZCR_EL1_Type_bits   v))\<close> 
  for  "v"  :: " ZCR_EL1_Type "


definition ZCR_EL2_Type_of_regval  :: \<open> register_value \<Rightarrow>(ZCR_EL2_Type)option \<close>  where 
     \<open> ZCR_EL2_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ZCR_EL2_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ZCR_EL2_Type  :: \<open> ZCR_EL2_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ZCR_EL2_Type v = ( regval_of_bitvector_64(ZCR_EL2_Type_bits   v))\<close> 
  for  "v"  :: " ZCR_EL2_Type "


definition ZCR_EL3_Type_of_regval  :: \<open> register_value \<Rightarrow>(ZCR_EL3_Type)option \<close>  where 
     \<open> ZCR_EL3_Type_of_regval v = (
   (case  ((bitvector_64_of_regval v  ::  ( 64 Word.word)option)) of
     Some (v) => Some ((| ZCR_EL3_Type_bits = v |))
   | None => None
   ))\<close> 
  for  "v"  :: " register_value "


definition regval_of_ZCR_EL3_Type  :: \<open> ZCR_EL3_Type \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_ZCR_EL3_Type v = ( regval_of_bitvector_64(ZCR_EL3_Type_bits   v))\<close> 
  for  "v"  :: " ZCR_EL3_Type "


fun InstrEnc_of_regval  :: \<open> register_value \<Rightarrow>(InstrEnc)option \<close>  where 
     \<open> InstrEnc_of_regval (Regval___InstrEnc (v)) = ( Some v )\<close> 
  for  "v"  :: " InstrEnc "
|\<open> InstrEnc_of_regval _ = ( None )\<close>


definition regval_of___InstrEnc  :: \<open> InstrEnc \<Rightarrow> register_value \<close>  where 
     \<open> regval_of___InstrEnc v = ( Regval___InstrEnc v )\<close> 
  for  "v"  :: " InstrEnc "


fun bit_of_regval  :: \<open> register_value \<Rightarrow>(bitU)option \<close>  where 
     \<open> bit_of_regval (Regval_bit (v)) = ( Some v )\<close> 
  for  "v"  :: " bitU "
|\<open> bit_of_regval _ = ( None )\<close>


definition regval_of_bit  :: \<open> bitU \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bit v = ( Regval_bit v )\<close> 
  for  "v"  :: " bitU "


fun bitvector_1_of_regval  :: \<open> register_value \<Rightarrow>((1)Word.word)option \<close>  where 
     \<open> bitvector_1_of_regval (Regval_bitvector_1 (v)) = ( Some v )\<close> 
  for  "v"  :: "(1)Word.word "
|\<open> bitvector_1_of_regval _ = ( None )\<close>


definition regval_of_bitvector_1  :: \<open>(1)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_1 v = ( Regval_bitvector_1 v )\<close> 
  for  "v"  :: "(1)Word.word "


fun bitvector_16_of_regval  :: \<open> register_value \<Rightarrow>((16)Word.word)option \<close>  where 
     \<open> bitvector_16_of_regval (Regval_bitvector_16 (v)) = ( Some v )\<close> 
  for  "v"  :: "(16)Word.word "
|\<open> bitvector_16_of_regval _ = ( None )\<close>


definition regval_of_bitvector_16  :: \<open>(16)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_16 v = ( Regval_bitvector_16 v )\<close> 
  for  "v"  :: "(16)Word.word "


fun bitvector_2_of_regval  :: \<open> register_value \<Rightarrow>((2)Word.word)option \<close>  where 
     \<open> bitvector_2_of_regval (Regval_bitvector_2 (v)) = ( Some v )\<close> 
  for  "v"  :: "(2)Word.word "
|\<open> bitvector_2_of_regval _ = ( None )\<close>


definition regval_of_bitvector_2  :: \<open>(2)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_2 v = ( Regval_bitvector_2 v )\<close> 
  for  "v"  :: "(2)Word.word "


fun bitvector_2048_of_regval  :: \<open> register_value \<Rightarrow>((2048)Word.word)option \<close>  where 
     \<open> bitvector_2048_of_regval (Regval_bitvector_2048 (v)) = ( Some v )\<close> 
  for  "v"  :: "(2048)Word.word "
|\<open> bitvector_2048_of_regval _ = ( None )\<close>


definition regval_of_bitvector_2048  :: \<open>(2048)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_2048 v = ( Regval_bitvector_2048 v )\<close> 
  for  "v"  :: "(2048)Word.word "


fun bitvector_24_of_regval  :: \<open> register_value \<Rightarrow>((24)Word.word)option \<close>  where 
     \<open> bitvector_24_of_regval (Regval_bitvector_24 (v)) = ( Some v )\<close> 
  for  "v"  :: "(24)Word.word "
|\<open> bitvector_24_of_regval _ = ( None )\<close>


definition regval_of_bitvector_24  :: \<open>(24)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_24 v = ( Regval_bitvector_24 v )\<close> 
  for  "v"  :: "(24)Word.word "


fun bitvector_256_of_regval  :: \<open> register_value \<Rightarrow>((256)Word.word)option \<close>  where 
     \<open> bitvector_256_of_regval (Regval_bitvector_256 (v)) = ( Some v )\<close> 
  for  "v"  :: "(256)Word.word "
|\<open> bitvector_256_of_regval _ = ( None )\<close>


definition regval_of_bitvector_256  :: \<open>(256)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_256 v = ( Regval_bitvector_256 v )\<close> 
  for  "v"  :: "(256)Word.word "


fun bitvector_3_of_regval  :: \<open> register_value \<Rightarrow>((3)Word.word)option \<close>  where 
     \<open> bitvector_3_of_regval (Regval_bitvector_3 (v)) = ( Some v )\<close> 
  for  "v"  :: "(3)Word.word "
|\<open> bitvector_3_of_regval _ = ( None )\<close>


definition regval_of_bitvector_3  :: \<open>(3)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_3 v = ( Regval_bitvector_3 v )\<close> 
  for  "v"  :: "(3)Word.word "


fun bitvector_4_of_regval  :: \<open> register_value \<Rightarrow>((4)Word.word)option \<close>  where 
     \<open> bitvector_4_of_regval (Regval_bitvector_4 (v)) = ( Some v )\<close> 
  for  "v"  :: "(4)Word.word "
|\<open> bitvector_4_of_regval _ = ( None )\<close>


definition regval_of_bitvector_4  :: \<open>(4)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_4 v = ( Regval_bitvector_4 v )\<close> 
  for  "v"  :: "(4)Word.word "


fun bitvector_512_of_regval  :: \<open> register_value \<Rightarrow>((512)Word.word)option \<close>  where 
     \<open> bitvector_512_of_regval (Regval_bitvector_512 (v)) = ( Some v )\<close> 
  for  "v"  :: "(512)Word.word "
|\<open> bitvector_512_of_regval _ = ( None )\<close>


definition regval_of_bitvector_512  :: \<open>(512)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_512 v = ( Regval_bitvector_512 v )\<close> 
  for  "v"  :: "(512)Word.word "


fun bitvector_56_of_regval  :: \<open> register_value \<Rightarrow>((56)Word.word)option \<close>  where 
     \<open> bitvector_56_of_regval (Regval_bitvector_56 (v)) = ( Some v )\<close> 
  for  "v"  :: "(56)Word.word "
|\<open> bitvector_56_of_regval _ = ( None )\<close>


definition regval_of_bitvector_56  :: \<open>(56)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_56 v = ( Regval_bitvector_56 v )\<close> 
  for  "v"  :: "(56)Word.word "


fun bitvector_8_of_regval  :: \<open> register_value \<Rightarrow>((8)Word.word)option \<close>  where 
     \<open> bitvector_8_of_regval (Regval_bitvector_8 (v)) = ( Some v )\<close> 
  for  "v"  :: "(8)Word.word "
|\<open> bitvector_8_of_regval _ = ( None )\<close>


definition regval_of_bitvector_8  :: \<open>(8)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_8 v = ( Regval_bitvector_8 v )\<close> 
  for  "v"  :: "(8)Word.word "


fun bitvector_88_of_regval  :: \<open> register_value \<Rightarrow>((88)Word.word)option \<close>  where 
     \<open> bitvector_88_of_regval (Regval_bitvector_88 (v)) = ( Some v )\<close> 
  for  "v"  :: "(88)Word.word "
|\<open> bitvector_88_of_regval _ = ( None )\<close>


definition regval_of_bitvector_88  :: \<open>(88)Word.word \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_bitvector_88 v = ( Regval_bitvector_88 v )\<close> 
  for  "v"  :: "(88)Word.word "




\<comment> \<open>\<open>val bool_of_register_value : register_value -> maybe bool\<close>\<close>
fun bool_of_register_value  :: \<open> register_value \<Rightarrow>(bool)option \<close>  where 
     \<open> bool_of_register_value (Regval_bool v) = ( Some v )\<close> 
  for  "v"  :: " bool "
|\<open> bool_of_register_value _ = ( None )\<close>

\<comment> \<open>\<open>val register_value_of_bool : bool -> register_value\<close>\<close>
definition register_value_of_bool  :: \<open> bool \<Rightarrow> register_value \<close>  where 
     \<open> register_value_of_bool v = ( Regval_bool v )\<close> 
  for  "v"  :: " bool "

\<comment> \<open>\<open>val int_of_register_value : register_value -> maybe integer\<close>\<close>
fun int_of_register_value  :: \<open> register_value \<Rightarrow>(int)option \<close>  where 
     \<open> int_of_register_value (Regval_int v) = ( Some v )\<close> 
  for  "v"  :: " int "
|\<open> int_of_register_value _ = ( None )\<close>

\<comment> \<open>\<open>val register_value_of_int : integer -> register_value\<close>\<close>
definition register_value_of_int  :: \<open> int \<Rightarrow> register_value \<close>  where 
     \<open> register_value_of_int v = ( Regval_int v )\<close> 
  for  "v"  :: " int "

\<comment> \<open>\<open>val real_of_register_value : register_value -> maybe real\<close>\<close>
fun real_of_register_value  :: \<open> register_value \<Rightarrow>(real)option \<close>  where 
     \<open> real_of_register_value (Regval_real v) = ( Some v )\<close> 
  for  "v"  :: " real "
|\<open> real_of_register_value _ = ( None )\<close>

\<comment> \<open>\<open>val register_value_of_real : real -> register_value\<close>\<close>
definition register_value_of_real  :: \<open> real \<Rightarrow> register_value \<close>  where 
     \<open> register_value_of_real v = ( Regval_real v )\<close> 
  for  "v"  :: " real "

\<comment> \<open>\<open>val string_of_register_value : register_value -> maybe string\<close>\<close>
fun string_of_register_value  :: \<open> register_value \<Rightarrow>(string)option \<close>  where 
     \<open> string_of_register_value (Regval_string v) = ( Some v )\<close> 
  for  "v"  :: " string "
|\<open> string_of_register_value _ = ( None )\<close>

\<comment> \<open>\<open>val register_value_of_string : string -> register_value\<close>\<close>
definition register_value_of_string  :: \<open> string \<Rightarrow> register_value \<close>  where 
     \<open> register_value_of_string v = ( Regval_string v )\<close> 
  for  "v"  :: " string "


definition instance_Sail2_values_Register_Value_Armv9_types_register_value_dict  :: \<open>(register_value)Register_Value_class \<close>  where 
     \<open> instance_Sail2_values_Register_Value_Armv9_types_register_value_dict = ((|

  bool_of_regval_method = bool_of_register_value,

  regval_of_bool_method = register_value_of_bool,

  int_of_regval_method = int_of_register_value,

  regval_of_int_method = register_value_of_int,

  real_of_regval_method = real_of_register_value,

  regval_of_real_method = register_value_of_real,

  string_of_regval_method = string_of_register_value,

  regval_of_string_method = register_value_of_string |) )\<close>

\<comment> \<open>\<open>val vector_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (list 'a)\<close>\<close>
fun vector_of_regval  :: \<open>(register_value \<Rightarrow> 'a option)\<Rightarrow> register_value \<Rightarrow>('a list)option \<close>  where 
     \<open> vector_of_regval of_regval1 (Regval_vector v) = ( just_list (List.map of_regval1 v))\<close> 
  for  "of_regval1"  :: " register_value \<Rightarrow> 'a option " 
  and  "v"  :: "(register_value)list "
|\<open> vector_of_regval of_regval1 _ = ( None )\<close> 
  for  "of_regval1"  :: " register_value \<Rightarrow> 'a option "


\<comment> \<open>\<open>val regval_of_vector : forall 'a. ('a -> register_value) -> list 'a -> register_value\<close>\<close>
definition regval_of_vector  :: \<open>('a \<Rightarrow> register_value)\<Rightarrow> 'a list \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_vector regval_of1 xs = ( Regval_vector (List.map regval_of1 xs))\<close> 
  for  "regval_of1"  :: " 'a \<Rightarrow> register_value " 
  and  "xs"  :: " 'a list "


\<comment> \<open>\<open>val list_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (list 'a)\<close>\<close>
fun list_of_regval  :: \<open>(register_value \<Rightarrow> 'a option)\<Rightarrow> register_value \<Rightarrow>('a list)option \<close>  where 
     \<open> list_of_regval of_regval1 (Regval_list v) = ( just_list (List.map of_regval1 v))\<close> 
  for  "of_regval1"  :: " register_value \<Rightarrow> 'a option " 
  and  "v"  :: "(register_value)list "
|\<open> list_of_regval of_regval1 _ = ( None )\<close> 
  for  "of_regval1"  :: " register_value \<Rightarrow> 'a option "


\<comment> \<open>\<open>val regval_of_list : forall 'a. ('a -> register_value) -> list 'a -> register_value\<close>\<close>
definition regval_of_list  :: \<open>('a \<Rightarrow> register_value)\<Rightarrow> 'a list \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_list regval_of1 xs = ( Regval_list (List.map regval_of1 xs))\<close> 
  for  "regval_of1"  :: " 'a \<Rightarrow> register_value " 
  and  "xs"  :: " 'a list "


\<comment> \<open>\<open>val option_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (maybe 'a)\<close>\<close>
fun option_of_regval  :: \<open>(register_value \<Rightarrow> 'a option)\<Rightarrow> register_value \<Rightarrow>('a option)option \<close>  where 
     \<open> option_of_regval of_regval1 (Regval_option v) = ( Some (Option.bind v of_regval1))\<close> 
  for  "of_regval1"  :: " register_value \<Rightarrow> 'a option " 
  and  "v"  :: "(register_value)option "
|\<open> option_of_regval of_regval1 _ = ( None )\<close> 
  for  "of_regval1"  :: " register_value \<Rightarrow> 'a option "


\<comment> \<open>\<open>val regval_of_option : forall 'a. ('a -> register_value) -> maybe 'a -> register_value\<close>\<close>
definition regval_of_option  :: \<open>('a \<Rightarrow> register_value)\<Rightarrow> 'a option \<Rightarrow> register_value \<close>  where 
     \<open> regval_of_option regval_of1 v = ( Regval_option (map_option regval_of1 v))\<close> 
  for  "regval_of1"  :: " 'a \<Rightarrow> register_value " 
  and  "v"  :: " 'a option "



definition emulator_termination_opcode_ref  :: \<open>((regstate),(register_value),(((32)Word.word)option))register_ref \<close>  where 
     \<open> emulator_termination_opcode_ref = ( (|
  name = (''__emulator_termination_opcode''),
  read_from = ((\<lambda> s . (option_bitvector_32_reg   s) (''__emulator_termination_opcode''))),
  write_to = ((\<lambda> v s .  (( s (| option_bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''__emulator_termination_opcode'') then v else(option_bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  option_of_regval ((\<lambda> v .  bitvector_32_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_option ((\<lambda> v .  regval_of_bitvector_32 v)) v)) |) )\<close>


definition HACTLR2_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HACTLR2_ref = ( (|
  name = (''_HACTLR2''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HACTLR2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HACTLR2'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXSTATUS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXSTATUS_ref = ( (|
  name = (''_ERXSTATUS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXSTATUS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXSTATUS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXMISC3_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXMISC3_ref = ( (|
  name = (''_ERXMISC3''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXMISC3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXMISC3'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXMISC7_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXMISC7_ref = ( (|
  name = (''_ERXMISC7''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXMISC7''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXMISC7'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXADDR2_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXADDR2_ref = ( (|
  name = (''_ERXADDR2''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXADDR2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXADDR2'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXMISC4_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXMISC4_ref = ( (|
  name = (''_ERXMISC4''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXMISC4''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXMISC4'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXMISC6_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXMISC6_ref = ( (|
  name = (''_ERXMISC6''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXMISC6''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXMISC6'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXCTLR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXCTLR_ref = ( (|
  name = (''_ERXCTLR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXCTLR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXCTLR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXMISC1_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXMISC1_ref = ( (|
  name = (''_ERXMISC1''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXMISC1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXMISC1'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXCTLR2_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXCTLR2_ref = ( (|
  name = (''_ERXCTLR2''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXCTLR2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXCTLR2'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXMISC5_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXMISC5_ref = ( (|
  name = (''_ERXMISC5''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXMISC5''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXMISC5'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXMISC0_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXMISC0_ref = ( (|
  name = (''_ERXMISC0''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXMISC0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXMISC0'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXADDR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXADDR_ref = ( (|
  name = (''_ERXADDR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXADDR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXADDR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXFR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXFR_ref = ( (|
  name = (''_ERXFR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXFR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXFR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXMISC2_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXMISC2_ref = ( (|
  name = (''_ERXMISC2''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXMISC2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXMISC2'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERXFR2_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ERXFR2_ref = ( (|
  name = (''_ERXFR2''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ERXFR2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERXFR2'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition AMEVTYPER1_ref  :: \<open>((regstate),(register_value),((AMEVTYPER1_Type)list))register_ref \<close>  where 
     \<open> AMEVTYPER1_ref = ( (|
  name = (''_AMEVTYPER1''),
  read_from = ((\<lambda> s . (vector_16_AMEVTYPER1_Type_reg   s) (''_AMEVTYPER1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_AMEVTYPER1_Type_reg :=
  ((\<lambda> reg .  if reg = (''_AMEVTYPER1'') then v else(vector_16_AMEVTYPER1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  AMEVTYPER1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_AMEVTYPER1_Type v)) v)) |) )\<close>


definition AMEVTYPER0_ref  :: \<open>((regstate),(register_value),((AMEVTYPER0_Type)list))register_ref \<close>  where 
     \<open> AMEVTYPER0_ref = ( (|
  name = (''_AMEVTYPER0''),
  read_from = ((\<lambda> s . (vector_4_AMEVTYPER0_Type_reg   s) (''_AMEVTYPER0''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_AMEVTYPER0_Type_reg :=
  ((\<lambda> reg .  if reg = (''_AMEVTYPER0'') then v else(vector_4_AMEVTYPER0_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  AMEVTYPER0_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_AMEVTYPER0_Type v)) v)) |) )\<close>


definition ICH_LRC_ref  :: \<open>((regstate),(register_value),((ICH_LRC_Type)list))register_ref \<close>  where 
     \<open> ICH_LRC_ref = ( (|
  name = (''_ICH_LRC''),
  read_from = ((\<lambda> s . (vector_16_ICH_LRC_Type_reg   s) (''_ICH_LRC''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_ICH_LRC_Type_reg :=
  ((\<lambda> reg .  if reg = (''_ICH_LRC'') then v else(vector_16_ICH_LRC_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ICH_LRC_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ICH_LRC_Type v)) v)) |) )\<close>


definition AMAIR1_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> AMAIR1_NS_ref = ( (|
  name = (''_AMAIR1_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_AMAIR1_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AMAIR1_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition AMAIR1_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> AMAIR1_S_ref = ( (|
  name = (''AMAIR1_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''AMAIR1_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMAIR1_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition DBGDTRTXint_ref  :: \<open>((regstate),(register_value),(DBGDTRTXint_Type))register_ref \<close>  where 
     \<open> DBGDTRTXint_ref = ( (|
  name = (''_DBGDTRTXint''),
  read_from = ((\<lambda> s .  (| DBGDTRTXint_Type_bits = ((bitvector_32_reg   s) (''_DBGDTRTXint'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGDTRTXint'') then(DBGDTRTXint_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDTRTXint_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDTRTXint_Type v)) |) )\<close>


definition HTPIDR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HTPIDR_ref = ( (|
  name = (''_HTPIDR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HTPIDR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HTPIDR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition DBGDTRRXint_ref  :: \<open>((regstate),(register_value),(DBGDTRRXint_Type))register_ref \<close>  where 
     \<open> DBGDTRRXint_ref = ( (|
  name = (''_DBGDTRRXint''),
  read_from = ((\<lambda> s .  (| DBGDTRRXint_Type_bits = ((bitvector_32_reg   s) (''_DBGDTRRXint'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGDTRRXint'') then(DBGDTRRXint_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDTRRXint_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDTRRXint_Type v)) |) )\<close>


definition TPIDRPRW_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> TPIDRPRW_NS_ref = ( (|
  name = (''_TPIDRPRW_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_TPIDRPRW_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_TPIDRPRW_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition TPIDRPRW_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> TPIDRPRW_S_ref = ( (|
  name = (''TPIDRPRW_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''TPIDRPRW_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''TPIDRPRW_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ICC_AP0R_ref  :: \<open>((regstate),(register_value),(((32)Word.word)list))register_ref \<close>  where 
     \<open> ICC_AP0R_ref = ( (|
  name = (''_ICC_AP0R''),
  read_from = ((\<lambda> s . (vector_4_bitvector_32_reg   s) (''_ICC_AP0R''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_AP0R'') then v else(vector_4_bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_32_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_32 v)) v)) |) )\<close>


definition HAIFSR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HAIFSR_ref = ( (|
  name = (''_HAIFSR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HAIFSR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HAIFSR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition HAMAIR1_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HAMAIR1_ref = ( (|
  name = (''_HAMAIR1''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HAMAIR1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HAMAIR1'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ACTLR2_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ACTLR2_NS_ref = ( (|
  name = (''_ACTLR2_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ACTLR2_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ACTLR2_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ACTLR2_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ACTLR2_S_ref = ( (|
  name = (''ACTLR2_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''ACTLR2_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''ACTLR2_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition DBGOSECCR_ref  :: \<open>((regstate),(register_value),(DBGOSECCR_Type))register_ref \<close>  where 
     \<open> DBGOSECCR_ref = ( (|
  name = (''_DBGOSECCR''),
  read_from = ((\<lambda> s .  (| DBGOSECCR_Type_bits = ((bitvector_32_reg   s) (''_DBGOSECCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGOSECCR'') then(DBGOSECCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGOSECCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGOSECCR_Type v)) |) )\<close>


definition PMINTENSET_ref  :: \<open>((regstate),(register_value),(PMINTENSET_Type))register_ref \<close>  where 
     \<open> PMINTENSET_ref = ( (|
  name = (''_PMINTENSET''),
  read_from = ((\<lambda> s .  (| PMINTENSET_Type_bits = ((bitvector_32_reg   s) (''_PMINTENSET'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMINTENSET'') then(PMINTENSET_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMINTENSET_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMINTENSET_Type v)) |) )\<close>


definition CNTFRQ_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> CNTFRQ_ref = ( (|
  name = (''_CNTFRQ''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_CNTFRQ''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CNTFRQ'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition HADFSR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HADFSR_ref = ( (|
  name = (''_HADFSR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HADFSR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HADFSR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ICH_LR_ref  :: \<open>((regstate),(register_value),((ICH_LR_Type)list))register_ref \<close>  where 
     \<open> ICH_LR_ref = ( (|
  name = (''_ICH_LR''),
  read_from = ((\<lambda> s . (vector_16_ICH_LR_Type_reg   s) (''_ICH_LR''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_ICH_LR_Type_reg :=
  ((\<lambda> reg .  if reg = (''_ICH_LR'') then v else(vector_16_ICH_LR_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ICH_LR_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ICH_LR_Type v)) v)) |) )\<close>


definition AIDR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> AIDR_ref = ( (|
  name = (''_AIDR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_AIDR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AIDR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ICH_AP0R_ref  :: \<open>((regstate),(register_value),((ICH_AP0R_Type)list))register_ref \<close>  where 
     \<open> ICH_AP0R_ref = ( (|
  name = (''_ICH_AP0R''),
  read_from = ((\<lambda> s . (vector_4_ICH_AP0R_Type_reg   s) (''_ICH_AP0R''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_ICH_AP0R_Type_reg :=
  ((\<lambda> reg .  if reg = (''_ICH_AP0R'') then v else(vector_4_ICH_AP0R_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ICH_AP0R_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ICH_AP0R_Type v)) v)) |) )\<close>


definition HAMAIR0_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HAMAIR0_ref = ( (|
  name = (''_HAMAIR0''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HAMAIR0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HAMAIR0'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition AMAIR0_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> AMAIR0_NS_ref = ( (|
  name = (''_AMAIR0_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_AMAIR0_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AMAIR0_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition AMAIR0_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> AMAIR0_S_ref = ( (|
  name = (''AMAIR0_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''AMAIR0_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMAIR0_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ICH_AP1R_ref  :: \<open>((regstate),(register_value),((ICH_AP1R_Type)list))register_ref \<close>  where 
     \<open> ICH_AP1R_ref = ( (|
  name = (''_ICH_AP1R''),
  read_from = ((\<lambda> s . (vector_4_ICH_AP1R_Type_reg   s) (''_ICH_AP1R''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_ICH_AP1R_Type_reg :=
  ((\<lambda> reg .  if reg = (''_ICH_AP1R'') then v else(vector_4_ICH_AP1R_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ICH_AP1R_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ICH_AP1R_Type v)) v)) |) )\<close>


definition ICC_AP1R_NS_ref  :: \<open>((regstate),(register_value),(((32)Word.word)list))register_ref \<close>  where 
     \<open> ICC_AP1R_NS_ref = ( (|
  name = (''_ICC_AP1R_NS''),
  read_from = ((\<lambda> s . (vector_4_bitvector_32_reg   s) (''_ICC_AP1R_NS''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_AP1R_NS'') then v else(vector_4_bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_32_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_32 v)) v)) |) )\<close>


definition ICC_AP1R_S_ref  :: \<open>((regstate),(register_value),(((32)Word.word)list))register_ref \<close>  where 
     \<open> ICC_AP1R_S_ref = ( (|
  name = (''_ICC_AP1R_S''),
  read_from = ((\<lambda> s . (vector_4_bitvector_32_reg   s) (''_ICC_AP1R_S''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_AP1R_S'') then v else(vector_4_bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_32_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_32 v)) v)) |) )\<close>


definition DBGDTRRXext_ref  :: \<open>((regstate),(register_value),(DBGDTRRXext_Type))register_ref \<close>  where 
     \<open> DBGDTRRXext_ref = ( (|
  name = (''_DBGDTRRXext''),
  read_from = ((\<lambda> s .  (| DBGDTRRXext_Type_bits = ((bitvector_32_reg   s) (''_DBGDTRRXext'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGDTRRXext'') then(DBGDTRRXext_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDTRRXext_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDTRRXext_Type v)) |) )\<close>


definition DBGOSLAR_ref  :: \<open>((regstate),(register_value),(DBGOSLAR_Type))register_ref \<close>  where 
     \<open> DBGOSLAR_ref = ( (|
  name = (''DBGOSLAR''),
  read_from = ((\<lambda> s .  (| DBGOSLAR_Type_bits = ((bitvector_32_reg   s) (''DBGOSLAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''DBGOSLAR'') then(DBGOSLAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGOSLAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGOSLAR_Type v)) |) )\<close>


definition ACTLR_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ACTLR_NS_ref = ( (|
  name = (''_ACTLR_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ACTLR_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ACTLR_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ACTLR_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ACTLR_S_ref = ( (|
  name = (''ACTLR_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''ACTLR_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''ACTLR_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition DBGDTRTXext_ref  :: \<open>((regstate),(register_value),(DBGDTRTXext_Type))register_ref \<close>  where 
     \<open> DBGDTRTXext_ref = ( (|
  name = (''_DBGDTRTXext''),
  read_from = ((\<lambda> s .  (| DBGDTRTXext_Type_bits = ((bitvector_32_reg   s) (''_DBGDTRTXext'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGDTRTXext'') then(DBGDTRTXext_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDTRTXext_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDTRTXext_Type v)) |) )\<close>


definition TPIDRURO_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> TPIDRURO_NS_ref = ( (|
  name = (''_TPIDRURO_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_TPIDRURO_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_TPIDRURO_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition TPIDRURO_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> TPIDRURO_S_ref = ( (|
  name = (''TPIDRURO_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''TPIDRURO_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''TPIDRURO_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition REVIDR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> REVIDR_ref = ( (|
  name = (''_REVIDR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_REVIDR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_REVIDR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ADFSR_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ADFSR_NS_ref = ( (|
  name = (''_ADFSR_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ADFSR_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ADFSR_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ADFSR_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ADFSR_S_ref = ( (|
  name = (''ADFSR_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''ADFSR_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''ADFSR_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ICV_AP1R_ref  :: \<open>((regstate),(register_value),(((32)Word.word)list))register_ref \<close>  where 
     \<open> ICV_AP1R_ref = ( (|
  name = (''_ICV_AP1R''),
  read_from = ((\<lambda> s . (vector_4_bitvector_32_reg   s) (''_ICV_AP1R''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_AP1R'') then v else(vector_4_bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_32_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_32 v)) v)) |) )\<close>


definition TPIDRURW_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> TPIDRURW_NS_ref = ( (|
  name = (''_TPIDRURW_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_TPIDRURW_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_TPIDRURW_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition TPIDRURW_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> TPIDRURW_S_ref = ( (|
  name = (''TPIDRURW_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''TPIDRURW_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''TPIDRURW_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ICV_AP0R_ref  :: \<open>((regstate),(register_value),(((32)Word.word)list))register_ref \<close>  where 
     \<open> ICV_AP0R_ref = ( (|
  name = (''_ICV_AP0R''),
  read_from = ((\<lambda> s . (vector_4_bitvector_32_reg   s) (''_ICV_AP0R''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_AP0R'') then v else(vector_4_bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_32_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_32 v)) v)) |) )\<close>


definition TCMTR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> TCMTR_ref = ( (|
  name = (''TCMTR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''TCMTR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''TCMTR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition HACTLR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HACTLR_ref = ( (|
  name = (''_HACTLR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HACTLR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HACTLR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition HACR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HACR_ref = ( (|
  name = (''_HACR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HACR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HACR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition AIFSR_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> AIFSR_NS_ref = ( (|
  name = (''_AIFSR_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_AIFSR_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AIFSR_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition AIFSR_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> AIFSR_S_ref = ( (|
  name = (''AIFSR_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''AIFSR_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AIFSR_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition BRBSRC_EL1_ref  :: \<open>((regstate),(register_value),((BRBSRC_EL1_Type)list))register_ref \<close>  where 
     \<open> BRBSRC_EL1_ref = ( (|
  name = (''BRBSRC_EL1''),
  read_from = ((\<lambda> s . (vector_32_BRBSRC_EL1_Type_reg   s) (''BRBSRC_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_BRBSRC_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''BRBSRC_EL1'') then v else(vector_32_BRBSRC_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  BRBSRC_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_BRBSRC_EL1_Type v)) v)) |) )\<close>


definition BRBTGT_EL1_ref  :: \<open>((regstate),(register_value),((BRBTGT_EL1_Type)list))register_ref \<close>  where 
     \<open> BRBTGT_EL1_ref = ( (|
  name = (''BRBTGT_EL1''),
  read_from = ((\<lambda> s . (vector_32_BRBTGT_EL1_Type_reg   s) (''BRBTGT_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_BRBTGT_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''BRBTGT_EL1'') then v else(vector_32_BRBTGT_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  BRBTGT_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_BRBTGT_EL1_Type v)) v)) |) )\<close>


definition BRBINF_EL1_ref  :: \<open>((regstate),(register_value),((BRBINF_EL1_Type)list))register_ref \<close>  where 
     \<open> BRBINF_EL1_ref = ( (|
  name = (''BRBINF_EL1''),
  read_from = ((\<lambda> s . (vector_32_BRBINF_EL1_Type_reg   s) (''BRBINF_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_BRBINF_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''BRBINF_EL1'') then v else(vector_32_BRBINF_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  BRBINF_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_BRBINF_EL1_Type v)) v)) |) )\<close>


definition ERXPFGCTL_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXPFGCTL_EL1_ref = ( (|
  name = (''ERXPFGCTL_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXPFGCTL_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXPFGCTL_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ERXMISC2_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXMISC2_EL1_ref = ( (|
  name = (''ERXMISC2_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXMISC2_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXMISC2_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ERXMISC3_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXMISC3_EL1_ref = ( (|
  name = (''ERXMISC3_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXMISC3_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXMISC3_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ERXGSR_EL1_ref  :: \<open>((regstate),(register_value),(ERXGSR_EL1_Type))register_ref \<close>  where 
     \<open> ERXGSR_EL1_ref = ( (|
  name = (''ERXGSR_EL1''),
  read_from = ((\<lambda> s .  (| ERXGSR_EL1_Type_bits = ((bitvector_64_reg   s) (''ERXGSR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXGSR_EL1'') then(ERXGSR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ERXGSR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ERXGSR_EL1_Type v)) |) )\<close>


definition ERXFR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXFR_EL1_ref = ( (|
  name = (''ERXFR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXFR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXFR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ERXSTATUS_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXSTATUS_EL1_ref = ( (|
  name = (''ERXSTATUS_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXSTATUS_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXSTATUS_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ERXCTLR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXCTLR_EL1_ref = ( (|
  name = (''ERXCTLR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXCTLR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXCTLR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ERXMISC1_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXMISC1_EL1_ref = ( (|
  name = (''ERXMISC1_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXMISC1_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXMISC1_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ERXPFGF_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXPFGF_EL1_ref = ( (|
  name = (''ERXPFGF_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXPFGF_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXPFGF_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ERXPFGCDN_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXPFGCDN_EL1_ref = ( (|
  name = (''ERXPFGCDN_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXPFGCDN_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXPFGCDN_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ERXMISC0_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXMISC0_EL1_ref = ( (|
  name = (''ERXMISC0_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXMISC0_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXMISC0_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ERXADDR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ERXADDR_EL1_ref = ( (|
  name = (''ERXADDR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ERXADDR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERXADDR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition AMEVTYPER1_EL0_ref  :: \<open>((regstate),(register_value),((AMEVTYPER1_EL0_Type)list))register_ref \<close>  where 
     \<open> AMEVTYPER1_EL0_ref = ( (|
  name = (''AMEVTYPER1_EL0''),
  read_from = ((\<lambda> s . (vector_16_AMEVTYPER1_EL0_Type_reg   s) (''AMEVTYPER1_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_AMEVTYPER1_EL0_Type_reg :=
  ((\<lambda> reg .  if reg = (''AMEVTYPER1_EL0'') then v else(vector_16_AMEVTYPER1_EL0_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  AMEVTYPER1_EL0_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_AMEVTYPER1_EL0_Type v)) v)) |) )\<close>


definition AMEVCNTVOFF1_EL2_ref  :: \<open>((regstate),(register_value),(((64)Word.word)list))register_ref \<close>  where 
     \<open> AMEVCNTVOFF1_EL2_ref = ( (|
  name = (''AMEVCNTVOFF1_EL2''),
  read_from = ((\<lambda> s . (vector_16_bitvector_64_reg   s) (''AMEVCNTVOFF1_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMEVCNTVOFF1_EL2'') then v else(vector_16_bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_64_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_64 v)) v)) |) )\<close>


definition AMEVCNTR0_EL0_ref  :: \<open>((regstate),(register_value),((AMEVCNTR0_EL0_Type)list))register_ref \<close>  where 
     \<open> AMEVCNTR0_EL0_ref = ( (|
  name = (''_AMEVCNTR0_EL0''),
  read_from = ((\<lambda> s . (vector_4_AMEVCNTR0_EL0_Type_reg   s) (''_AMEVCNTR0_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_AMEVCNTR0_EL0_Type_reg :=
  ((\<lambda> reg .  if reg = (''_AMEVCNTR0_EL0'') then v else(vector_4_AMEVCNTR0_EL0_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  AMEVCNTR0_EL0_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_AMEVCNTR0_EL0_Type v)) v)) |) )\<close>


definition AMEVCNTR1_ref  :: \<open>((regstate),(register_value),((AMEVCNTR1_Type)list))register_ref \<close>  where 
     \<open> AMEVCNTR1_ref = ( (|
  name = (''_AMEVCNTR1''),
  read_from = ((\<lambda> s . (vector_16_AMEVCNTR1_Type_reg   s) (''_AMEVCNTR1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_AMEVCNTR1_Type_reg :=
  ((\<lambda> reg .  if reg = (''_AMEVCNTR1'') then v else(vector_16_AMEVCNTR1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  AMEVCNTR1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_AMEVCNTR1_Type v)) v)) |) )\<close>


definition AMEVCNTR0_ref  :: \<open>((regstate),(register_value),((AMEVCNTR0_Type)list))register_ref \<close>  where 
     \<open> AMEVCNTR0_ref = ( (|
  name = (''AMEVCNTR0''),
  read_from = ((\<lambda> s . (vector_4_AMEVCNTR0_Type_reg   s) (''AMEVCNTR0''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_AMEVCNTR0_Type_reg :=
  ((\<lambda> reg .  if reg = (''AMEVCNTR0'') then v else(vector_4_AMEVCNTR0_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  AMEVCNTR0_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_AMEVCNTR0_Type v)) v)) |) )\<close>


definition AMEVCNTVOFF0_EL2_ref  :: \<open>((regstate),(register_value),(((64)Word.word)list))register_ref \<close>  where 
     \<open> AMEVCNTVOFF0_EL2_ref = ( (|
  name = (''AMEVCNTVOFF0_EL2''),
  read_from = ((\<lambda> s . (vector_16_bitvector_64_reg   s) (''AMEVCNTVOFF0_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMEVCNTVOFF0_EL2'') then v else(vector_16_bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_64_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_64 v)) v)) |) )\<close>


definition AMEVCNTR1_EL0_ref  :: \<open>((regstate),(register_value),((AMEVCNTR1_EL0_Type)list))register_ref \<close>  where 
     \<open> AMEVCNTR1_EL0_ref = ( (|
  name = (''AMEVCNTR1_EL0''),
  read_from = ((\<lambda> s . (vector_16_AMEVCNTR1_EL0_Type_reg   s) (''AMEVCNTR1_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_AMEVCNTR1_EL0_Type_reg :=
  ((\<lambda> reg .  if reg = (''AMEVCNTR1_EL0'') then v else(vector_16_AMEVCNTR1_EL0_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  AMEVCNTR1_EL0_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_AMEVCNTR1_EL0_Type v)) v)) |) )\<close>


definition CNTV_CVAL_ref  :: \<open>((regstate),(register_value),(CNTV_CVAL_Type))register_ref \<close>  where 
     \<open> CNTV_CVAL_ref = ( (|
  name = (''_CNTV_CVAL''),
  read_from = ((\<lambda> s .  (| CNTV_CVAL_Type_bits = ((bitvector_64_reg   s) (''_CNTV_CVAL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_CNTV_CVAL'') then(CNTV_CVAL_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTV_CVAL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTV_CVAL_Type v)) |) )\<close>


definition CNTVOFF_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> CNTVOFF_ref = ( (|
  name = (''_CNTVOFF''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''_CNTVOFF''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_CNTVOFF'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition SPMACCESSR_EL3_ref  :: \<open>((regstate),(register_value),(SPMACCESSR_EL3_Type))register_ref \<close>  where 
     \<open> SPMACCESSR_EL3_ref = ( (|
  name = (''SPMACCESSR_EL3''),
  read_from = ((\<lambda> s .  (| SPMACCESSR_EL3_Type_bits = ((bitvector_64_reg   s) (''SPMACCESSR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPMACCESSR_EL3'') then(SPMACCESSR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPMACCESSR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPMACCESSR_EL3_Type v)) |) )\<close>


definition AMAIR2_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AMAIR2_EL1_ref = ( (|
  name = (''AMAIR2_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AMAIR2_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMAIR2_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition AFSR0_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AFSR0_EL2_ref = ( (|
  name = (''AFSR0_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AFSR0_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AFSR0_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ICV_AP1R_EL1_ref  :: \<open>((regstate),(register_value),((ICV_AP1R_EL1_Type)list))register_ref \<close>  where 
     \<open> ICV_AP1R_EL1_ref = ( (|
  name = (''ICV_AP1R_EL1''),
  read_from = ((\<lambda> s . (vector_4_ICV_AP1R_EL1_Type_reg   s) (''ICV_AP1R_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_ICV_AP1R_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''ICV_AP1R_EL1'') then v else(vector_4_ICV_AP1R_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ICV_AP1R_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ICV_AP1R_EL1_Type v)) v)) |) )\<close>


definition AFSR1_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AFSR1_EL3_ref = ( (|
  name = (''AFSR1_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AFSR1_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AFSR1_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition AMAIR2_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AMAIR2_EL3_ref = ( (|
  name = (''AMAIR2_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AMAIR2_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMAIR2_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition HACR_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> HACR_EL2_ref = ( (|
  name = (''HACR_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''HACR_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HACR_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition RNDR_ref  :: \<open>((regstate),(register_value),(RNDR_Type))register_ref \<close>  where 
     \<open> RNDR_ref = ( (|
  name = (''RNDR''),
  read_from = ((\<lambda> s .  (| RNDR_Type_bits = ((bitvector_64_reg   s) (''RNDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''RNDR'') then(RNDR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RNDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RNDR_Type v)) |) )\<close>


definition SMPRIMAP_EL2_ref  :: \<open>((regstate),(register_value),(SMPRIMAP_EL2_Type))register_ref \<close>  where 
     \<open> SMPRIMAP_EL2_ref = ( (|
  name = (''SMPRIMAP_EL2''),
  read_from = ((\<lambda> s .  (| SMPRIMAP_EL2_Type_bits = ((bitvector_64_reg   s) (''SMPRIMAP_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SMPRIMAP_EL2'') then(SMPRIMAP_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SMPRIMAP_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SMPRIMAP_EL2_Type v)) |) )\<close>


definition RNDRRS_ref  :: \<open>((regstate),(register_value),(RNDRRS_Type))register_ref \<close>  where 
     \<open> RNDRRS_ref = ( (|
  name = (''RNDRRS''),
  read_from = ((\<lambda> s .  (| RNDRRS_Type_bits = ((bitvector_64_reg   s) (''RNDRRS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''RNDRRS'') then(RNDRRS_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RNDRRS_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RNDRRS_Type v)) |) )\<close>


definition TPIDR_EL0_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> TPIDR_EL0_ref = ( (|
  name = (''TPIDR_EL0''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''TPIDR_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TPIDR_EL0'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition SCXTNUM_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SCXTNUM_EL3_ref = ( (|
  name = (''SCXTNUM_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SCXTNUM_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCXTNUM_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition TPIDR2_EL0_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> TPIDR2_EL0_ref = ( (|
  name = (''TPIDR2_EL0''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''TPIDR2_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TPIDR2_EL0'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition SCXTNUM_EL0_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SCXTNUM_EL0_ref = ( (|
  name = (''SCXTNUM_EL0''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SCXTNUM_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCXTNUM_EL0'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition AMAIR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AMAIR_EL1_ref = ( (|
  name = (''AMAIR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AMAIR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMAIR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition TPIDRRO_EL0_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> TPIDRRO_EL0_ref = ( (|
  name = (''TPIDRRO_EL0''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''TPIDRRO_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TPIDRRO_EL0'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition SCXTNUM_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SCXTNUM_EL1_ref = ( (|
  name = (''SCXTNUM_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SCXTNUM_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCXTNUM_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition AMAIR_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AMAIR_EL3_ref = ( (|
  name = (''AMAIR_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AMAIR_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMAIR_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition AMAIR_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AMAIR_EL2_ref = ( (|
  name = (''AMAIR_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AMAIR_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMAIR_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ACTLR_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ACTLR_EL3_ref = ( (|
  name = (''ACTLR_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ACTLR_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ACTLR_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition TPIDR_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> TPIDR_EL3_ref = ( (|
  name = (''TPIDR_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''TPIDR_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TPIDR_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition PMIAR_EL1_ref  :: \<open>((regstate),(register_value),(PMIAR_EL1_Type))register_ref \<close>  where 
     \<open> PMIAR_EL1_ref = ( (|
  name = (''PMIAR_EL1''),
  read_from = ((\<lambda> s .  (| PMIAR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMIAR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMIAR_EL1'') then(PMIAR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMIAR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMIAR_EL1_Type v)) |) )\<close>


definition SCXTNUM_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SCXTNUM_EL2_ref = ( (|
  name = (''SCXTNUM_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SCXTNUM_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCXTNUM_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition PMICNTSVR_EL1_ref  :: \<open>((regstate),(register_value),(PMICNTSVR_EL1_Type))register_ref \<close>  where 
     \<open> PMICNTSVR_EL1_ref = ( (|
  name = (''PMICNTSVR_EL1''),
  read_from = ((\<lambda> s .  (| PMICNTSVR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMICNTSVR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMICNTSVR_EL1'') then(PMICNTSVR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMICNTSVR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMICNTSVR_EL1_Type v)) |) )\<close>


definition SPMACCESSR_EL2_ref  :: \<open>((regstate),(register_value),(SPMACCESSR_EL2_Type))register_ref \<close>  where 
     \<open> SPMACCESSR_EL2_ref = ( (|
  name = (''SPMACCESSR_EL2''),
  read_from = ((\<lambda> s .  (| SPMACCESSR_EL2_Type_bits = ((bitvector_64_reg   s) (''SPMACCESSR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPMACCESSR_EL2'') then(SPMACCESSR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPMACCESSR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPMACCESSR_EL2_Type v)) |) )\<close>


definition AFSR0_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AFSR0_EL1_ref = ( (|
  name = (''AFSR0_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AFSR0_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AFSR0_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition AFSR1_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AFSR1_EL2_ref = ( (|
  name = (''AFSR1_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AFSR1_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AFSR1_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition AFSR0_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AFSR0_EL3_ref = ( (|
  name = (''AFSR0_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AFSR0_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AFSR0_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ICV_AP0R_EL1_ref  :: \<open>((regstate),(register_value),(((64)Word.word)list))register_ref \<close>  where 
     \<open> ICV_AP0R_EL1_ref = ( (|
  name = (''ICV_AP0R_EL1''),
  read_from = ((\<lambda> s . (vector_4_bitvector_64_reg   s) (''ICV_AP0R_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_AP0R_EL1'') then v else(vector_4_bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_64_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_64 v)) v)) |) )\<close>


definition AMAIR2_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AMAIR2_EL2_ref = ( (|
  name = (''AMAIR2_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AMAIR2_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMAIR2_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition PMCCNTSVR_EL1_ref  :: \<open>((regstate),(register_value),(PMCCNTSVR_EL1_Type))register_ref \<close>  where 
     \<open> PMCCNTSVR_EL1_ref = ( (|
  name = (''PMCCNTSVR_EL1''),
  read_from = ((\<lambda> s .  (| PMCCNTSVR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMCCNTSVR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMCCNTSVR_EL1'') then(PMCCNTSVR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCCNTSVR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCCNTSVR_EL1_Type v)) |) )\<close>


definition AFSR1_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AFSR1_EL1_ref = ( (|
  name = (''AFSR1_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AFSR1_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AFSR1_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ICC_AP1R_EL1_NS_ref  :: \<open>((regstate),(register_value),((ICC_AP1R_EL1_Type)list))register_ref \<close>  where 
     \<open> ICC_AP1R_EL1_NS_ref = ( (|
  name = (''ICC_AP1R_EL1_NS''),
  read_from = ((\<lambda> s . (vector_4_ICC_AP1R_EL1_Type_reg   s) (''ICC_AP1R_EL1_NS''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_ICC_AP1R_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''ICC_AP1R_EL1_NS'') then v else(vector_4_ICC_AP1R_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ICC_AP1R_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ICC_AP1R_EL1_Type v)) v)) |) )\<close>


definition ICC_AP1R_EL1_S_ref  :: \<open>((regstate),(register_value),((ICC_AP1R_EL1_Type)list))register_ref \<close>  where 
     \<open> ICC_AP1R_EL1_S_ref = ( (|
  name = (''ICC_AP1R_EL1_S''),
  read_from = ((\<lambda> s . (vector_4_ICC_AP1R_EL1_Type_reg   s) (''ICC_AP1R_EL1_S''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_ICC_AP1R_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''ICC_AP1R_EL1_S'') then v else(vector_4_ICC_AP1R_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ICC_AP1R_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ICC_AP1R_EL1_Type v)) v)) |) )\<close>


definition ACTLR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ACTLR_EL1_ref = ( (|
  name = (''ACTLR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ACTLR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ACTLR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition TPIDR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> TPIDR_EL1_ref = ( (|
  name = (''TPIDR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''TPIDR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TPIDR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ICH_AP0R_EL2_ref  :: \<open>((regstate),(register_value),((ICH_AP0R_EL2_Type)list))register_ref \<close>  where 
     \<open> ICH_AP0R_EL2_ref = ( (|
  name = (''ICH_AP0R_EL2''),
  read_from = ((\<lambda> s . (vector_4_ICH_AP0R_EL2_Type_reg   s) (''ICH_AP0R_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_ICH_AP0R_EL2_Type_reg :=
  ((\<lambda> reg .  if reg = (''ICH_AP0R_EL2'') then v else(vector_4_ICH_AP0R_EL2_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ICH_AP0R_EL2_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ICH_AP0R_EL2_Type v)) v)) |) )\<close>


definition PMEVCNTSVR_EL1_ref  :: \<open>((regstate),(register_value),((PMEVCNTSVR_EL1_Type)list))register_ref \<close>  where 
     \<open> PMEVCNTSVR_EL1_ref = ( (|
  name = (''PMEVCNTSVR_EL1''),
  read_from = ((\<lambda> s . (vector_31_PMEVCNTSVR_EL1_Type_reg   s) (''PMEVCNTSVR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_31_PMEVCNTSVR_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''PMEVCNTSVR_EL1'') then v else(vector_31_PMEVCNTSVR_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  PMEVCNTSVR_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_PMEVCNTSVR_EL1_Type v)) v)) |) )\<close>


definition ICH_AP1R_EL2_ref  :: \<open>((regstate),(register_value),((ICH_AP1R_EL2_Type)list))register_ref \<close>  where 
     \<open> ICH_AP1R_EL2_ref = ( (|
  name = (''ICH_AP1R_EL2''),
  read_from = ((\<lambda> s . (vector_4_ICH_AP1R_EL2_Type_reg   s) (''ICH_AP1R_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_ICH_AP1R_EL2_Type_reg :=
  ((\<lambda> reg .  if reg = (''ICH_AP1R_EL2'') then v else(vector_4_ICH_AP1R_EL2_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ICH_AP1R_EL2_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ICH_AP1R_EL2_Type v)) v)) |) )\<close>


definition SPMACCESSR_EL1_ref  :: \<open>((regstate),(register_value),(SPMACCESSR_EL1_Type))register_ref \<close>  where 
     \<open> SPMACCESSR_EL1_ref = ( (|
  name = (''SPMACCESSR_EL1''),
  read_from = ((\<lambda> s .  (| SPMACCESSR_EL1_Type_bits = ((bitvector_64_reg   s) (''SPMACCESSR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPMACCESSR_EL1'') then(SPMACCESSR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPMACCESSR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPMACCESSR_EL1_Type v)) |) )\<close>


definition ACTLR_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ACTLR_EL2_ref = ( (|
  name = (''ACTLR_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ACTLR_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ACTLR_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition TPIDR_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> TPIDR_EL2_ref = ( (|
  name = (''TPIDR_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''TPIDR_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TPIDR_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition REVIDR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> REVIDR_EL1_ref = ( (|
  name = (''REVIDR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''REVIDR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''REVIDR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition AIDR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> AIDR_EL1_ref = ( (|
  name = (''AIDR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''AIDR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AIDR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ICC_AP0R_EL1_ref  :: \<open>((regstate),(register_value),(((64)Word.word)list))register_ref \<close>  where 
     \<open> ICC_AP0R_EL1_ref = ( (|
  name = (''ICC_AP0R_EL1''),
  read_from = ((\<lambda> s . (vector_4_bitvector_64_reg   s) (''ICC_AP0R_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_AP0R_EL1'') then v else(vector_4_bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_64_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_64 v)) v)) |) )\<close>


definition ICH_LR_EL2_ref  :: \<open>((regstate),(register_value),((ICH_LR_EL2_Type)list))register_ref \<close>  where 
     \<open> ICH_LR_EL2_ref = ( (|
  name = (''ICH_LR_EL2''),
  read_from = ((\<lambda> s . (vector_16_ICH_LR_EL2_Type_reg   s) (''ICH_LR_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_ICH_LR_EL2_Type_reg :=
  ((\<lambda> reg .  if reg = (''ICH_LR_EL2'') then v else(vector_16_ICH_LR_EL2_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ICH_LR_EL2_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ICH_LR_EL2_Type v)) v)) |) )\<close>


definition PMCCNTR_ref  :: \<open>((regstate),(register_value),(PMCCNTR_Type))register_ref \<close>  where 
     \<open> PMCCNTR_ref = ( (|
  name = (''_PMCCNTR''),
  read_from = ((\<lambda> s .  (| PMCCNTR_Type_bits = ((bitvector_64_reg   s) (''_PMCCNTR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_PMCCNTR'') then(PMCCNTR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCCNTR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCCNTR_Type v)) |) )\<close>


definition PMOVSSET_ref  :: \<open>((regstate),(register_value),(PMOVSSET_Type))register_ref \<close>  where 
     \<open> PMOVSSET_ref = ( (|
  name = (''_PMOVSSET''),
  read_from = ((\<lambda> s .  (| PMOVSSET_Type_bits = ((bitvector_32_reg   s) (''_PMOVSSET'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMOVSSET'') then(PMOVSSET_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMOVSSET_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMOVSSET_Type v)) |) )\<close>


definition PMEVCNTR_ref  :: \<open>((regstate),(register_value),(((32)Word.word)list))register_ref \<close>  where 
     \<open> PMEVCNTR_ref = ( (|
  name = (''_PMEVCNTR''),
  read_from = ((\<lambda> s . (vector_31_bitvector_32_reg   s) (''_PMEVCNTR''))),
  write_to = ((\<lambda> v s .  (( s (| vector_31_bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMEVCNTR'') then v else(vector_31_bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_32_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_32 v)) v)) |) )\<close>


definition DBGWVR_ref  :: \<open>((regstate),(register_value),((DBGWVR_Type)list))register_ref \<close>  where 
     \<open> DBGWVR_ref = ( (|
  name = (''_DBGWVR''),
  read_from = ((\<lambda> s . (vector_16_DBGWVR_Type_reg   s) (''_DBGWVR''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_DBGWVR_Type_reg :=
  ((\<lambda> reg .  if reg = (''_DBGWVR'') then v else(vector_16_DBGWVR_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  DBGWVR_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_DBGWVR_Type v)) v)) |) )\<close>


definition DBGWCR_ref  :: \<open>((regstate),(register_value),((DBGWCR_Type)list))register_ref \<close>  where 
     \<open> DBGWCR_ref = ( (|
  name = (''_DBGWCR''),
  read_from = ((\<lambda> s . (vector_16_DBGWCR_Type_reg   s) (''_DBGWCR''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_DBGWCR_Type_reg :=
  ((\<lambda> reg .  if reg = (''_DBGWCR'') then v else(vector_16_DBGWCR_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  DBGWCR_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_DBGWCR_Type v)) v)) |) )\<close>


definition DBGBXVR_ref  :: \<open>((regstate),(register_value),((DBGBXVR_Type)list))register_ref \<close>  where 
     \<open> DBGBXVR_ref = ( (|
  name = (''_DBGBXVR''),
  read_from = ((\<lambda> s . (vector_16_DBGBXVR_Type_reg   s) (''_DBGBXVR''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_DBGBXVR_Type_reg :=
  ((\<lambda> reg .  if reg = (''_DBGBXVR'') then v else(vector_16_DBGBXVR_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  DBGBXVR_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_DBGBXVR_Type v)) v)) |) )\<close>


definition DBGBVR_ref  :: \<open>((regstate),(register_value),((DBGBVR_Type)list))register_ref \<close>  where 
     \<open> DBGBVR_ref = ( (|
  name = (''_DBGBVR''),
  read_from = ((\<lambda> s . (vector_16_DBGBVR_Type_reg   s) (''_DBGBVR''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_DBGBVR_Type_reg :=
  ((\<lambda> reg .  if reg = (''_DBGBVR'') then v else(vector_16_DBGBVR_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  DBGBVR_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_DBGBVR_Type v)) v)) |) )\<close>


definition DBGBCR_ref  :: \<open>((regstate),(register_value),((DBGBCR_Type)list))register_ref \<close>  where 
     \<open> DBGBCR_ref = ( (|
  name = (''_DBGBCR''),
  read_from = ((\<lambda> s . (vector_16_DBGBCR_Type_reg   s) (''_DBGBCR''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_DBGBCR_Type_reg :=
  ((\<lambda> reg .  if reg = (''_DBGBCR'') then v else(vector_16_DBGBCR_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  DBGBCR_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_DBGBCR_Type v)) v)) |) )\<close>


definition STACK_LIMIT_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> STACK_LIMIT_ref = ( (|
  name = (''STACK_LIMIT''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''STACK_LIMIT''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''STACK_LIMIT'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition STACK_BASE_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> STACK_BASE_ref = ( (|
  name = (''STACK_BASE''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''STACK_BASE''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''STACK_BASE'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition HEAP_LIMIT_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> HEAP_LIMIT_ref = ( (|
  name = (''HEAP_LIMIT''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''HEAP_LIMIT''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HEAP_LIMIT'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition HEAP_BASE_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> HEAP_BASE_ref = ( (|
  name = (''HEAP_BASE''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''HEAP_BASE''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HEAP_BASE'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition has_spe_pseudo_cycles_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> has_spe_pseudo_cycles_ref = ( (|
  name = (''__has_spe_pseudo_cycles''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__has_spe_pseudo_cycles''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__has_spe_pseudo_cycles'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SMCR_EL3_LEN_VALUE_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> SMCR_EL3_LEN_VALUE_ref = ( (|
  name = (''SMCR_EL3_LEN_VALUE''),
  read_from = ((\<lambda> s . (int_reg   s) (''SMCR_EL3_LEN_VALUE''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''SMCR_EL3_LEN_VALUE'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition CPTR_EL3_ESM_VALUE_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> CPTR_EL3_ESM_VALUE_ref = ( (|
  name = (''CPTR_EL3_ESM_VALUE''),
  read_from = ((\<lambda> s . (int_reg   s) (''CPTR_EL3_ESM_VALUE''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''CPTR_EL3_ESM_VALUE'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition CPTR_EL3_EZ_VALUE_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> CPTR_EL3_EZ_VALUE_ref = ( (|
  name = (''CPTR_EL3_EZ_VALUE''),
  read_from = ((\<lambda> s . (int_reg   s) (''CPTR_EL3_EZ_VALUE''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''CPTR_EL3_EZ_VALUE'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition ZCR_EL3_LEN_VALUE_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> ZCR_EL3_LEN_VALUE_ref = ( (|
  name = (''ZCR_EL3_LEN_VALUE''),
  read_from = ((\<lambda> s . (int_reg   s) (''ZCR_EL3_LEN_VALUE''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''ZCR_EL3_LEN_VALUE'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition CFG_RMR_AA64_ref  :: \<open>((regstate),(register_value),((1)Word.word))register_ref \<close>  where 
     \<open> CFG_RMR_AA64_ref = ( (|
  name = (''CFG_RMR_AA64''),
  read_from = ((\<lambda> s . (bitvector_1_reg   s) (''CFG_RMR_AA64''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_1_reg :=
  ((\<lambda> reg .  if reg = (''CFG_RMR_AA64'') then v else(bitvector_1_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_1_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_1 v)) |) )\<close>


definition DBG_ROM_ADDR_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> DBG_ROM_ADDR_ref = ( (|
  name = (''__DBG_ROM_ADDR''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__DBG_ROM_ADDR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__DBG_ROM_ADDR'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition mops_forward_copy_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> mops_forward_copy_ref = ( (|
  name = (''__mops_forward_copy''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__mops_forward_copy''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__mops_forward_copy'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition trickbox_enabled_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> trickbox_enabled_ref = ( (|
  name = (''__trickbox_enabled''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__trickbox_enabled''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__trickbox_enabled'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition ignore_rvbar_in_aarch32_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> ignore_rvbar_in_aarch32_ref = ( (|
  name = (''__ignore_rvbar_in_aarch32''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__ignore_rvbar_in_aarch32''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__ignore_rvbar_in_aarch32'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition unpred_tsize_aborts_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> unpred_tsize_aborts_ref = ( (|
  name = (''__unpred_tsize_aborts''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__unpred_tsize_aborts''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__unpred_tsize_aborts'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnDeviceWrite_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnDeviceWrite_ref = ( (|
  name = (''__syncAbortOnDeviceWrite''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnDeviceWrite''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnDeviceWrite'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnWriteNormNonCache_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnWriteNormNonCache_ref = ( (|
  name = (''__syncAbortOnWriteNormNonCache''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnWriteNormNonCache''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnWriteNormNonCache'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnWriteNormCache_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnWriteNormCache_ref = ( (|
  name = (''__syncAbortOnWriteNormCache''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnWriteNormCache''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnWriteNormCache'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnTTWNonCache_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnTTWNonCache_ref = ( (|
  name = (''__syncAbortOnTTWNonCache''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnTTWNonCache''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnTTWNonCache'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnTTWCache_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnTTWCache_ref = ( (|
  name = (''__syncAbortOnTTWCache''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnTTWCache''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnTTWCache'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnPrefetch_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnPrefetch_ref = ( (|
  name = (''__syncAbortOnPrefetch''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnPrefetch''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnPrefetch'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnSoWrite_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnSoWrite_ref = ( (|
  name = (''__syncAbortOnSoWrite''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnSoWrite''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnSoWrite'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnSoRead_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnSoRead_ref = ( (|
  name = (''__syncAbortOnSoRead''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnSoRead''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnSoRead'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnDeviceRead_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnDeviceRead_ref = ( (|
  name = (''__syncAbortOnDeviceRead''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnDeviceRead''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnDeviceRead'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnReadNormNonCache_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnReadNormNonCache_ref = ( (|
  name = (''__syncAbortOnReadNormNonCache''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnReadNormNonCache''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnReadNormNonCache'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition syncAbortOnReadNormCache_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> syncAbortOnReadNormCache_ref = ( (|
  name = (''__syncAbortOnReadNormCache''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__syncAbortOnReadNormCache''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__syncAbortOnReadNormCache'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition PMUBase_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> PMUBase_ref = ( (|
  name = (''__PMUBase''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__PMUBase''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__PMUBase'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition GICITSControlBase_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> GICITSControlBase_ref = ( (|
  name = (''__GICITSControlBase''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__GICITSControlBase''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__GICITSControlBase'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition GICDistBase_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> GICDistBase_ref = ( (|
  name = (''__GICDistBase''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__GICDistBase''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__GICDistBase'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition GICCPUInterfaceBase_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> GICCPUInterfaceBase_ref = ( (|
  name = (''__GICCPUInterfaceBase''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__GICCPUInterfaceBase''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__GICCPUInterfaceBase'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition ExtDebugBase_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> ExtDebugBase_ref = ( (|
  name = (''__ExtDebugBase''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__ExtDebugBase''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__ExtDebugBase'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition CNTControlBase_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> CNTControlBase_ref = ( (|
  name = (''__CNTControlBase''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__CNTControlBase''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__CNTControlBase'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition CTIBase_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> CTIBase_ref = ( (|
  name = (''__CTIBase''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__CTIBase''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__CTIBase'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition DBGDTR_EL0_ref  :: \<open>((regstate),(register_value),(DBGDTR_EL0_Type))register_ref \<close>  where 
     \<open> DBGDTR_EL0_ref = ( (|
  name = (''_DBGDTR_EL0''),
  read_from = ((\<lambda> s .  (| DBGDTR_EL0_Type_bits = ((bitvector_64_reg   s) (''_DBGDTR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_DBGDTR_EL0'') then(DBGDTR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDTR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDTR_EL0_Type v)) |) )\<close>


definition DACR_S_ref  :: \<open>((regstate),(register_value),(DACR_Type))register_ref \<close>  where 
     \<open> DACR_S_ref = ( (|
  name = (''DACR_S''),
  read_from = ((\<lambda> s .  (| DACR_Type_bits = ((bitvector_32_reg   s) (''DACR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''DACR_S'') then(DACR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DACR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DACR_Type v)) |) )\<close>


definition DACR_NS_ref  :: \<open>((regstate),(register_value),(DACR_Type))register_ref \<close>  where 
     \<open> DACR_NS_ref = ( (|
  name = (''_DACR_NS''),
  read_from = ((\<lambda> s .  (| DACR_Type_bits = ((bitvector_32_reg   s) (''_DACR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DACR_NS'') then(DACR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DACR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DACR_Type v)) |) )\<close>


definition HMAIR1_ref  :: \<open>((regstate),(register_value),(HMAIR1_Type))register_ref \<close>  where 
     \<open> HMAIR1_ref = ( (|
  name = (''_HMAIR1''),
  read_from = ((\<lambda> s .  (| HMAIR1_Type_bits = ((bitvector_32_reg   s) (''_HMAIR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HMAIR1'') then(HMAIR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HMAIR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HMAIR1_Type v)) |) )\<close>


definition HMAIR0_ref  :: \<open>((regstate),(register_value),(HMAIR0_Type))register_ref \<close>  where 
     \<open> HMAIR0_ref = ( (|
  name = (''_HMAIR0''),
  read_from = ((\<lambda> s .  (| HMAIR0_Type_bits = ((bitvector_32_reg   s) (''_HMAIR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HMAIR0'') then(HMAIR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HMAIR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HMAIR0_Type v)) |) )\<close>


definition MAIR1_S_ref  :: \<open>((regstate),(register_value),(MAIR1_Type))register_ref \<close>  where 
     \<open> MAIR1_S_ref = ( (|
  name = (''_MAIR1_S''),
  read_from = ((\<lambda> s .  (| MAIR1_Type_bits = ((bitvector_32_reg   s) (''_MAIR1_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_MAIR1_S'') then(MAIR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MAIR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MAIR1_Type v)) |) )\<close>


definition MAIR1_NS_ref  :: \<open>((regstate),(register_value),(MAIR1_Type))register_ref \<close>  where 
     \<open> MAIR1_NS_ref = ( (|
  name = (''_MAIR1_NS''),
  read_from = ((\<lambda> s .  (| MAIR1_Type_bits = ((bitvector_32_reg   s) (''_MAIR1_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_MAIR1_NS'') then(MAIR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MAIR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MAIR1_Type v)) |) )\<close>


definition MAIR0_S_ref  :: \<open>((regstate),(register_value),(MAIR0_Type))register_ref \<close>  where 
     \<open> MAIR0_S_ref = ( (|
  name = (''_MAIR0_S''),
  read_from = ((\<lambda> s .  (| MAIR0_Type_bits = ((bitvector_32_reg   s) (''_MAIR0_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_MAIR0_S'') then(MAIR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MAIR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MAIR0_Type v)) |) )\<close>


definition MAIR0_NS_ref  :: \<open>((regstate),(register_value),(MAIR0_Type))register_ref \<close>  where 
     \<open> MAIR0_NS_ref = ( (|
  name = (''_MAIR0_NS''),
  read_from = ((\<lambda> s .  (| MAIR0_Type_bits = ((bitvector_32_reg   s) (''_MAIR0_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_MAIR0_NS'') then(MAIR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MAIR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MAIR0_Type v)) |) )\<close>


definition BRBTGTINJ_EL1_ref  :: \<open>((regstate),(register_value),(BRBTGTINJ_EL1_Type))register_ref \<close>  where 
     \<open> BRBTGTINJ_EL1_ref = ( (|
  name = (''BRBTGTINJ_EL1''),
  read_from = ((\<lambda> s .  (| BRBTGTINJ_EL1_Type_bits = ((bitvector_64_reg   s) (''BRBTGTINJ_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''BRBTGTINJ_EL1'') then(BRBTGTINJ_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  BRBTGTINJ_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_BRBTGTINJ_EL1_Type v)) |) )\<close>


definition BRBSRCINJ_EL1_ref  :: \<open>((regstate),(register_value),(BRBSRCINJ_EL1_Type))register_ref \<close>  where 
     \<open> BRBSRCINJ_EL1_ref = ( (|
  name = (''BRBSRCINJ_EL1''),
  read_from = ((\<lambda> s .  (| BRBSRCINJ_EL1_Type_bits = ((bitvector_64_reg   s) (''BRBSRCINJ_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''BRBSRCINJ_EL1'') then(BRBSRCINJ_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  BRBSRCINJ_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_BRBSRCINJ_EL1_Type v)) |) )\<close>


definition SPESampleCounter_ref  :: \<open>((regstate),(register_value),((ii)list))register_ref \<close>  where 
     \<open> SPESampleCounter_ref = ( (|
  name = (''SPESampleCounter''),
  read_from = ((\<lambda> s . (vector_32_int_reg   s) (''SPESampleCounter''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_int_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleCounter'') then v else(vector_32_int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  int_of_register_value v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  register_value_of_int v)) v)) |) )\<close>


definition SPERecordData_ref  :: \<open>((regstate),(register_value),(((8)Word.word)list))register_ref \<close>  where 
     \<open> SPERecordData_ref = ( (|
  name = (''SPERecordData''),
  read_from = ((\<lambda> s . (vector_64_bitvector_8_reg   s) (''SPERecordData''))),
  write_to = ((\<lambda> v s .  (( s (| vector_64_bitvector_8_reg :=
  ((\<lambda> reg .  if reg = (''SPERecordData'') then v else(vector_64_bitvector_8_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_8_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_8 v)) v)) |) )\<close>


definition PMSDSFR_EL1_ref  :: \<open>((regstate),(register_value),(PMSDSFR_EL1_Type))register_ref \<close>  where 
     \<open> PMSDSFR_EL1_ref = ( (|
  name = (''PMSDSFR_EL1''),
  read_from = ((\<lambda> s .  (| PMSDSFR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMSDSFR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSDSFR_EL1'') then(PMSDSFR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSDSFR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSDSFR_EL1_Type v)) |) )\<close>


definition PMBPTR_EL1_ref  :: \<open>((regstate),(register_value),(PMBPTR_EL1_Type))register_ref \<close>  where 
     \<open> PMBPTR_EL1_ref = ( (|
  name = (''PMBPTR_EL1''),
  read_from = ((\<lambda> s .  (| PMBPTR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMBPTR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMBPTR_EL1'') then(PMBPTR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMBPTR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMBPTR_EL1_Type v)) |) )\<close>


definition PMCCNTR_EL0_ref  :: \<open>((regstate),(register_value),(PMCCNTR_EL0_Type))register_ref \<close>  where 
     \<open> PMCCNTR_EL0_ref = ( (|
  name = (''PMCCNTR_EL0''),
  read_from = ((\<lambda> s .  (| PMCCNTR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMCCNTR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMCCNTR_EL0'') then(PMCCNTR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCCNTR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCCNTR_EL0_Type v)) |) )\<close>


definition PMEVCNTR_EL0_ref  :: \<open>((regstate),(register_value),(((64)Word.word)list))register_ref \<close>  where 
     \<open> PMEVCNTR_EL0_ref = ( (|
  name = (''PMEVCNTR_EL0''),
  read_from = ((\<lambda> s . (vector_32_bitvector_64_reg   s) (''PMEVCNTR_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMEVCNTR_EL0'') then v else(vector_32_bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_64_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_64 v)) v)) |) )\<close>


definition rme_l0gptsz_ref  :: \<open>((regstate),(register_value),((4)Word.word))register_ref \<close>  where 
     \<open> rme_l0gptsz_ref = ( (|
  name = (''__rme_l0gptsz''),
  read_from = ((\<lambda> s . (bitvector_4_reg   s) (''__rme_l0gptsz''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_4_reg :=
  ((\<lambda> reg .  if reg = (''__rme_l0gptsz'') then v else(bitvector_4_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_4_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_4 v)) |) )\<close>


definition mpam_has_altsp_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> mpam_has_altsp_ref = ( (|
  name = (''__mpam_has_altsp''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__mpam_has_altsp''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__mpam_has_altsp'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition mecid_width_ref  :: \<open>((regstate),(register_value),((4)Word.word))register_ref \<close>  where 
     \<open> mecid_width_ref = ( (|
  name = (''__mecid_width''),
  read_from = ((\<lambda> s . (bitvector_4_reg   s) (''__mecid_width''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_4_reg :=
  ((\<lambda> reg .  if reg = (''__mecid_width'') then v else(bitvector_4_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_4_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_4 v)) |) )\<close>


definition gmid_log2_block_size_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> gmid_log2_block_size_ref = ( (|
  name = (''__gmid_log2_block_size''),
  read_from = ((\<lambda> s . (int_reg   s) (''__gmid_log2_block_size''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__gmid_log2_block_size'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition dczid_log2_block_size_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> dczid_log2_block_size_ref = ( (|
  name = (''__dczid_log2_block_size''),
  read_from = ((\<lambda> s . (int_reg   s) (''__dczid_log2_block_size''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__dczid_log2_block_size'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition CNTbase_frequency_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> CNTbase_frequency_ref = ( (|
  name = (''__CNTbase_frequency''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''__CNTbase_frequency''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''__CNTbase_frequency'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition g1_activity_monitor_offset_implemented_ref  :: \<open>((regstate),(register_value),((16)Word.word))register_ref \<close>  where 
     \<open> g1_activity_monitor_offset_implemented_ref = ( (|
  name = (''__g1_activity_monitor_offset_implemented''),
  read_from = ((\<lambda> s . (bitvector_16_reg   s) (''__g1_activity_monitor_offset_implemented''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_16_reg :=
  ((\<lambda> reg .  if reg = (''__g1_activity_monitor_offset_implemented'') then v else(bitvector_16_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_16_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_16 v)) |) )\<close>


definition g1_activity_monitor_implemented_ref  :: \<open>((regstate),(register_value),((16)Word.word))register_ref \<close>  where 
     \<open> g1_activity_monitor_implemented_ref = ( (|
  name = (''__g1_activity_monitor_implemented''),
  read_from = ((\<lambda> s . (bitvector_16_reg   s) (''__g1_activity_monitor_implemented''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_16_reg :=
  ((\<lambda> reg .  if reg = (''__g1_activity_monitor_implemented'') then v else(bitvector_16_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_16_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_16 v)) |) )\<close>


definition ID_AA64PFR0_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64PFR0_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64PFR0_EL1_ref = ( (|
  name = (''ID_AA64PFR0_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64PFR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64PFR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64PFR0_EL1'') then(ID_AA64PFR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64PFR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64PFR0_EL1_Type v)) |) )\<close>


definition ID_AA64MMFR1_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64MMFR1_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64MMFR1_EL1_ref = ( (|
  name = (''ID_AA64MMFR1_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64MMFR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64MMFR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64MMFR1_EL1'') then(ID_AA64MMFR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64MMFR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64MMFR1_EL1_Type v)) |) )\<close>


definition ID_AA64ISAR1_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64ISAR1_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64ISAR1_EL1_ref = ( (|
  name = (''ID_AA64ISAR1_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64ISAR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64ISAR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64ISAR1_EL1'') then(ID_AA64ISAR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64ISAR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64ISAR1_EL1_Type v)) |) )\<close>


definition ID_AA64DFR1_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64DFR1_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64DFR1_EL1_ref = ( (|
  name = (''ID_AA64DFR1_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64DFR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64DFR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64DFR1_EL1'') then(ID_AA64DFR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64DFR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64DFR1_EL1_Type v)) |) )\<close>


definition ID_AA64DFR0_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64DFR0_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64DFR0_EL1_ref = ( (|
  name = (''ID_AA64DFR0_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64DFR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64DFR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64DFR0_EL1'') then(ID_AA64DFR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64DFR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64DFR0_EL1_Type v)) |) )\<close>


definition GICD_TYPER_ref  :: \<open>((regstate),(register_value),(GICD_TYPER_Type))register_ref \<close>  where 
     \<open> GICD_TYPER_ref = ( (|
  name = (''GICD_TYPER''),
  read_from = ((\<lambda> s .  (| GICD_TYPER_Type_bits = ((bitvector_32_reg   s) (''GICD_TYPER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICD_TYPER'') then(GICD_TYPER_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICD_TYPER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICD_TYPER_Type v)) |) )\<close>


definition supported_va_size_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> supported_va_size_ref = ( (|
  name = (''__supported_va_size''),
  read_from = ((\<lambda> s . (int_reg   s) (''__supported_va_size''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__supported_va_size'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition EDDEVARCH_ref  :: \<open>((regstate),(register_value),(EDDEVARCH_Type))register_ref \<close>  where 
     \<open> EDDEVARCH_ref = ( (|
  name = (''EDDEVARCH''),
  read_from = ((\<lambda> s .  (| EDDEVARCH_Type_bits = ((bitvector_32_reg   s) (''EDDEVARCH'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDDEVARCH'') then(EDDEVARCH_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDDEVARCH_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDDEVARCH_Type v)) |) )\<close>


definition CTIDEVARCH_ref  :: \<open>((regstate),(register_value),(CTIDEVARCH_Type))register_ref \<close>  where 
     \<open> CTIDEVARCH_ref = ( (|
  name = (''CTIDEVARCH''),
  read_from = ((\<lambda> s .  (| CTIDEVARCH_Type_bits = ((bitvector_32_reg   s) (''CTIDEVARCH'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIDEVARCH'') then(CTIDEVARCH_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIDEVARCH_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIDEVARCH_Type v)) |) )\<close>


definition CNTFID0_ref  :: \<open>((regstate),(register_value),(CNTFID0_Type))register_ref \<close>  where 
     \<open> CNTFID0_ref = ( (|
  name = (''CNTFID0''),
  read_from = ((\<lambda> s .  (| CNTFID0_Type_bits = ((bitvector_32_reg   s) (''CNTFID0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CNTFID0'') then(CNTFID0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTFID0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTFID0_Type v)) |) )\<close>


definition CFG_MPIDR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> CFG_MPIDR_ref = ( (|
  name = (''CFG_MPIDR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''CFG_MPIDR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CFG_MPIDR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition AMIIDR_ref  :: \<open>((regstate),(register_value),(AMIIDR_Type))register_ref \<close>  where 
     \<open> AMIIDR_ref = ( (|
  name = (''AMIIDR''),
  read_from = ((\<lambda> s .  (| AMIIDR_Type_bits = ((bitvector_32_reg   s) (''AMIIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMIIDR'') then(AMIIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMIIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMIIDR_Type v)) |) )\<close>


definition AMEVTYPER0_EL0_ref  :: \<open>((regstate),(register_value),((AMEVTYPER0_EL0_Type)list))register_ref \<close>  where 
     \<open> AMEVTYPER0_EL0_ref = ( (|
  name = (''AMEVTYPER0_EL0''),
  read_from = ((\<lambda> s . (vector_4_AMEVTYPER0_EL0_Type_reg   s) (''AMEVTYPER0_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_AMEVTYPER0_EL0_Type_reg :=
  ((\<lambda> reg .  if reg = (''AMEVTYPER0_EL0'') then v else(vector_4_AMEVTYPER0_EL0_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  AMEVTYPER0_EL0_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_AMEVTYPER0_EL0_Type v)) v)) |) )\<close>


definition AMDEVARCH_ref  :: \<open>((regstate),(register_value),(AMDEVARCH_Type))register_ref \<close>  where 
     \<open> AMDEVARCH_ref = ( (|
  name = (''AMDEVARCH''),
  read_from = ((\<lambda> s .  (| AMDEVARCH_Type_bits = ((bitvector_32_reg   s) (''AMDEVARCH'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMDEVARCH'') then(AMDEVARCH_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMDEVARCH_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMDEVARCH_Type v)) |) )\<close>


definition SPMSELR_EL0_ref  :: \<open>((regstate),(register_value),(SPMSELR_EL0_Type))register_ref \<close>  where 
     \<open> SPMSELR_EL0_ref = ( (|
  name = (''SPMSELR_EL0''),
  read_from = ((\<lambda> s .  (| SPMSELR_EL0_Type_bits = ((bitvector_64_reg   s) (''SPMSELR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPMSELR_EL0'') then(SPMSELR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPMSELR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPMSELR_EL0_Type v)) |) )\<close>


definition SMPRI_EL1_ref  :: \<open>((regstate),(register_value),(SMPRI_EL1_Type))register_ref \<close>  where 
     \<open> SMPRI_EL1_ref = ( (|
  name = (''SMPRI_EL1''),
  read_from = ((\<lambda> s .  (| SMPRI_EL1_Type_bits = ((bitvector_64_reg   s) (''SMPRI_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SMPRI_EL1'') then(SMPRI_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SMPRI_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SMPRI_EL1_Type v)) |) )\<close>


definition SMIDR_EL1_ref  :: \<open>((regstate),(register_value),(SMIDR_EL1_Type))register_ref \<close>  where 
     \<open> SMIDR_EL1_ref = ( (|
  name = (''SMIDR_EL1''),
  read_from = ((\<lambda> s .  (| SMIDR_EL1_Type_bits = ((bitvector_64_reg   s) (''SMIDR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SMIDR_EL1'') then(SMIDR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SMIDR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SMIDR_EL1_Type v)) |) )\<close>


definition PMZR_EL0_ref  :: \<open>((regstate),(register_value),(PMZR_EL0_Type))register_ref \<close>  where 
     \<open> PMZR_EL0_ref = ( (|
  name = (''PMZR_EL0''),
  read_from = ((\<lambda> s .  (| PMZR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMZR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMZR_EL0'') then(PMZR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMZR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMZR_EL0_Type v)) |) )\<close>


definition PMXEVCNTR_EL0_ref  :: \<open>((regstate),(register_value),(PMXEVCNTR_EL0_Type))register_ref \<close>  where 
     \<open> PMXEVCNTR_EL0_ref = ( (|
  name = (''PMXEVCNTR_EL0''),
  read_from = ((\<lambda> s .  (| PMXEVCNTR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMXEVCNTR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMXEVCNTR_EL0'') then(PMXEVCNTR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMXEVCNTR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMXEVCNTR_EL0_Type v)) |) )\<close>


definition PMUACR_EL1_ref  :: \<open>((regstate),(register_value),(PMUACR_EL1_Type))register_ref \<close>  where 
     \<open> PMUACR_EL1_ref = ( (|
  name = (''PMUACR_EL1''),
  read_from = ((\<lambda> s .  (| PMUACR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMUACR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMUACR_EL1'') then(PMUACR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMUACR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMUACR_EL1_Type v)) |) )\<close>


definition PMSSCR_EL1_ref  :: \<open>((regstate),(register_value),(PMSSCR_EL1_Type))register_ref \<close>  where 
     \<open> PMSSCR_EL1_ref = ( (|
  name = (''PMSSCR_EL1''),
  read_from = ((\<lambda> s .  (| PMSSCR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMSSCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSSCR_EL1'') then(PMSSCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSSCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSSCR_EL1_Type v)) |) )\<close>


definition PMSNEVFR_EL1_ref  :: \<open>((regstate),(register_value),(PMSNEVFR_EL1_Type))register_ref \<close>  where 
     \<open> PMSNEVFR_EL1_ref = ( (|
  name = (''PMSNEVFR_EL1''),
  read_from = ((\<lambda> s .  (| PMSNEVFR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMSNEVFR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSNEVFR_EL1'') then(PMSNEVFR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSNEVFR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSNEVFR_EL1_Type v)) |) )\<close>


definition PMSLATFR_EL1_ref  :: \<open>((regstate),(register_value),(PMSLATFR_EL1_Type))register_ref \<close>  where 
     \<open> PMSLATFR_EL1_ref = ( (|
  name = (''PMSLATFR_EL1''),
  read_from = ((\<lambda> s .  (| PMSLATFR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMSLATFR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSLATFR_EL1'') then(PMSLATFR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSLATFR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSLATFR_EL1_Type v)) |) )\<close>


definition PMSIRR_EL1_ref  :: \<open>((regstate),(register_value),(PMSIRR_EL1_Type))register_ref \<close>  where 
     \<open> PMSIRR_EL1_ref = ( (|
  name = (''PMSIRR_EL1''),
  read_from = ((\<lambda> s .  (| PMSIRR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMSIRR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSIRR_EL1'') then(PMSIRR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSIRR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSIRR_EL1_Type v)) |) )\<close>


definition PMSICR_EL1_ref  :: \<open>((regstate),(register_value),(PMSICR_EL1_Type))register_ref \<close>  where 
     \<open> PMSICR_EL1_ref = ( (|
  name = (''PMSICR_EL1''),
  read_from = ((\<lambda> s .  (| PMSICR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMSICR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSICR_EL1'') then(PMSICR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSICR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSICR_EL1_Type v)) |) )\<close>


definition PMSFCR_EL1_ref  :: \<open>((regstate),(register_value),(PMSFCR_EL1_Type))register_ref \<close>  where 
     \<open> PMSFCR_EL1_ref = ( (|
  name = (''PMSFCR_EL1''),
  read_from = ((\<lambda> s .  (| PMSFCR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMSFCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSFCR_EL1'') then(PMSFCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSFCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSFCR_EL1_Type v)) |) )\<close>


definition PMSEVFR_EL1_ref  :: \<open>((regstate),(register_value),(PMSEVFR_EL1_Type))register_ref \<close>  where 
     \<open> PMSEVFR_EL1_ref = ( (|
  name = (''PMSEVFR_EL1''),
  read_from = ((\<lambda> s .  (| PMSEVFR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMSEVFR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSEVFR_EL1'') then(PMSEVFR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSEVFR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSEVFR_EL1_Type v)) |) )\<close>


definition PMMIR_EL1_ref  :: \<open>((regstate),(register_value),(PMMIR_EL1_Type))register_ref \<close>  where 
     \<open> PMMIR_EL1_ref = ( (|
  name = (''PMMIR_EL1''),
  read_from = ((\<lambda> s .  (| PMMIR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMMIR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMMIR_EL1'') then(PMMIR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMMIR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMMIR_EL1_Type v)) |) )\<close>


definition PMECR_EL1_ref  :: \<open>((regstate),(register_value),(PMECR_EL1_Type))register_ref \<close>  where 
     \<open> PMECR_EL1_ref = ( (|
  name = (''PMECR_EL1''),
  read_from = ((\<lambda> s .  (| PMECR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMECR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMECR_EL1'') then(PMECR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMECR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMECR_EL1_Type v)) |) )\<close>


definition PMBIDR_EL1_ref  :: \<open>((regstate),(register_value),(PMBIDR_EL1_Type))register_ref \<close>  where 
     \<open> PMBIDR_EL1_ref = ( (|
  name = (''PMBIDR_EL1''),
  read_from = ((\<lambda> s .  (| PMBIDR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMBIDR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMBIDR_EL1'') then(PMBIDR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMBIDR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMBIDR_EL1_Type v)) |) )\<close>


definition PAR_EL1_ref  :: \<open>((regstate),(register_value),(PAR_EL1_Type))register_ref \<close>  where 
     \<open> PAR_EL1_ref = ( (|
  name = (''_PAR_EL1''),
  read_from = ((\<lambda> s .  (| PAR_EL1_Type_bits = ((bitvector_128_reg   s) (''_PAR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_128_reg :=
  ((\<lambda> reg .  if reg = (''_PAR_EL1'') then(PAR_EL1_Type_bits   v) else(bitvector_128_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PAR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PAR_EL1_Type v)) |) )\<close>


definition OSLAR_EL1_ref  :: \<open>((regstate),(register_value),(OSLAR_EL1_Type))register_ref \<close>  where 
     \<open> OSLAR_EL1_ref = ( (|
  name = (''OSLAR_EL1''),
  read_from = ((\<lambda> s .  (| OSLAR_EL1_Type_bits = ((bitvector_64_reg   s) (''OSLAR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''OSLAR_EL1'') then(OSLAR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  OSLAR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_OSLAR_EL1_Type v)) |) )\<close>


definition OSDTRTX_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> OSDTRTX_EL1_ref = ( (|
  name = (''OSDTRTX_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''OSDTRTX_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''OSDTRTX_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition OSDTRRX_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> OSDTRRX_EL1_ref = ( (|
  name = (''OSDTRRX_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''OSDTRRX_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''OSDTRRX_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition MECIDR_EL2_ref  :: \<open>((regstate),(register_value),(MECIDR_EL2_Type))register_ref \<close>  where 
     \<open> MECIDR_EL2_ref = ( (|
  name = (''MECIDR_EL2''),
  read_from = ((\<lambda> s .  (| MECIDR_EL2_Type_bits = ((bitvector_64_reg   s) (''MECIDR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MECIDR_EL2'') then(MECIDR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MECIDR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MECIDR_EL2_Type v)) |) )\<close>


definition MDSELR_EL1_ref  :: \<open>((regstate),(register_value),(MDSELR_EL1_Type))register_ref \<close>  where 
     \<open> MDSELR_EL1_ref = ( (|
  name = (''MDSELR_EL1''),
  read_from = ((\<lambda> s .  (| MDSELR_EL1_Type_bits = ((bitvector_64_reg   s) (''MDSELR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MDSELR_EL1'') then(MDSELR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MDSELR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MDSELR_EL1_Type v)) |) )\<close>


definition LORSA_EL1_ref  :: \<open>((regstate),(register_value),(LORSA_EL1_Type))register_ref \<close>  where 
     \<open> LORSA_EL1_ref = ( (|
  name = (''LORSA_EL1''),
  read_from = ((\<lambda> s .  (| LORSA_EL1_Type_bits = ((bitvector_64_reg   s) (''LORSA_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''LORSA_EL1'') then(LORSA_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  LORSA_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_LORSA_EL1_Type v)) |) )\<close>


definition LORN_EL1_ref  :: \<open>((regstate),(register_value),(LORN_EL1_Type))register_ref \<close>  where 
     \<open> LORN_EL1_ref = ( (|
  name = (''LORN_EL1''),
  read_from = ((\<lambda> s .  (| LORN_EL1_Type_bits = ((bitvector_64_reg   s) (''LORN_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''LORN_EL1'') then(LORN_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  LORN_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_LORN_EL1_Type v)) |) )\<close>


definition LORID_EL1_ref  :: \<open>((regstate),(register_value),(LORID_EL1_Type))register_ref \<close>  where 
     \<open> LORID_EL1_ref = ( (|
  name = (''LORID_EL1''),
  read_from = ((\<lambda> s .  (| LORID_EL1_Type_bits = ((bitvector_64_reg   s) (''LORID_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''LORID_EL1'') then(LORID_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  LORID_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_LORID_EL1_Type v)) |) )\<close>


definition LOREA_EL1_ref  :: \<open>((regstate),(register_value),(LOREA_EL1_Type))register_ref \<close>  where 
     \<open> LOREA_EL1_ref = ( (|
  name = (''LOREA_EL1''),
  read_from = ((\<lambda> s .  (| LOREA_EL1_Type_bits = ((bitvector_64_reg   s) (''LOREA_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''LOREA_EL1'') then(LOREA_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  LOREA_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_LOREA_EL1_Type v)) |) )\<close>


definition LORC_EL1_ref  :: \<open>((regstate),(register_value),(LORC_EL1_Type))register_ref \<close>  where 
     \<open> LORC_EL1_ref = ( (|
  name = (''LORC_EL1''),
  read_from = ((\<lambda> s .  (| LORC_EL1_Type_bits = ((bitvector_64_reg   s) (''LORC_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''LORC_EL1'') then(LORC_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  LORC_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_LORC_EL1_Type v)) |) )\<close>


definition ID_AA64ZFR0_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64ZFR0_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64ZFR0_EL1_ref = ( (|
  name = (''ID_AA64ZFR0_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64ZFR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64ZFR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64ZFR0_EL1'') then(ID_AA64ZFR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64ZFR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64ZFR0_EL1_Type v)) |) )\<close>


definition ID_AA64SMFR0_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64SMFR0_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64SMFR0_EL1_ref = ( (|
  name = (''ID_AA64SMFR0_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64SMFR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64SMFR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64SMFR0_EL1'') then(ID_AA64SMFR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64SMFR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64SMFR0_EL1_Type v)) |) )\<close>


definition ID_AA64PFR2_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64PFR2_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64PFR2_EL1_ref = ( (|
  name = (''ID_AA64PFR2_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64PFR2_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64PFR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64PFR2_EL1'') then(ID_AA64PFR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64PFR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64PFR2_EL1_Type v)) |) )\<close>


definition ID_AA64PFR1_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64PFR1_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64PFR1_EL1_ref = ( (|
  name = (''ID_AA64PFR1_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64PFR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64PFR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64PFR1_EL1'') then(ID_AA64PFR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64PFR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64PFR1_EL1_Type v)) |) )\<close>


definition ID_AA64MMFR4_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64MMFR4_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64MMFR4_EL1_ref = ( (|
  name = (''ID_AA64MMFR4_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64MMFR4_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64MMFR4_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64MMFR4_EL1'') then(ID_AA64MMFR4_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64MMFR4_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64MMFR4_EL1_Type v)) |) )\<close>


definition ID_AA64MMFR3_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64MMFR3_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64MMFR3_EL1_ref = ( (|
  name = (''ID_AA64MMFR3_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64MMFR3_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64MMFR3_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64MMFR3_EL1'') then(ID_AA64MMFR3_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64MMFR3_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64MMFR3_EL1_Type v)) |) )\<close>


definition ID_AA64MMFR2_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64MMFR2_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64MMFR2_EL1_ref = ( (|
  name = (''ID_AA64MMFR2_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64MMFR2_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64MMFR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64MMFR2_EL1'') then(ID_AA64MMFR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64MMFR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64MMFR2_EL1_Type v)) |) )\<close>


definition ID_AA64MMFR0_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64MMFR0_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64MMFR0_EL1_ref = ( (|
  name = (''ID_AA64MMFR0_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64MMFR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64MMFR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64MMFR0_EL1'') then(ID_AA64MMFR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64MMFR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64MMFR0_EL1_Type v)) |) )\<close>


definition ID_AA64ISAR2_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64ISAR2_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64ISAR2_EL1_ref = ( (|
  name = (''ID_AA64ISAR2_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64ISAR2_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64ISAR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64ISAR2_EL1'') then(ID_AA64ISAR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64ISAR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64ISAR2_EL1_Type v)) |) )\<close>


definition ID_AA64ISAR0_EL1_ref  :: \<open>((regstate),(register_value),(ID_AA64ISAR0_EL1_Type))register_ref \<close>  where 
     \<open> ID_AA64ISAR0_EL1_ref = ( (|
  name = (''ID_AA64ISAR0_EL1''),
  read_from = ((\<lambda> s .  (| ID_AA64ISAR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_AA64ISAR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64ISAR0_EL1'') then(ID_AA64ISAR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_AA64ISAR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_AA64ISAR0_EL1_Type v)) |) )\<close>


definition ID_AA64AFR1_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ID_AA64AFR1_EL1_ref = ( (|
  name = (''ID_AA64AFR1_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ID_AA64AFR1_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64AFR1_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ID_AA64AFR0_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ID_AA64AFR0_EL1_ref = ( (|
  name = (''ID_AA64AFR0_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ID_AA64AFR0_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AA64AFR0_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ICV_NMIAR1_EL1_ref  :: \<open>((regstate),(register_value),(ICV_NMIAR1_EL1_Type))register_ref \<close>  where 
     \<open> ICV_NMIAR1_EL1_ref = ( (|
  name = (''ICV_NMIAR1_EL1''),
  read_from = ((\<lambda> s .  (| ICV_NMIAR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_NMIAR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_NMIAR1_EL1'') then(ICV_NMIAR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_NMIAR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_NMIAR1_EL1_Type v)) |) )\<close>


definition ICC_SRE_EL3_ref  :: \<open>((regstate),(register_value),(ICC_SRE_EL3_Type))register_ref \<close>  where 
     \<open> ICC_SRE_EL3_ref = ( (|
  name = (''ICC_SRE_EL3''),
  read_from = ((\<lambda> s .  (| ICC_SRE_EL3_Type_bits = ((bitvector_64_reg   s) (''ICC_SRE_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_SRE_EL3'') then(ICC_SRE_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_SRE_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_SRE_EL3_Type v)) |) )\<close>


definition ICC_NMIAR1_EL1_ref  :: \<open>((regstate),(register_value),(ICC_NMIAR1_EL1_Type))register_ref \<close>  where 
     \<open> ICC_NMIAR1_EL1_ref = ( (|
  name = (''ICC_NMIAR1_EL1''),
  read_from = ((\<lambda> s .  (| ICC_NMIAR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_NMIAR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_NMIAR1_EL1'') then(ICC_NMIAR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_NMIAR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_NMIAR1_EL1_Type v)) |) )\<close>


definition ICC_IGRPEN1_EL3_ref  :: \<open>((regstate),(register_value),(ICC_IGRPEN1_EL3_Type))register_ref \<close>  where 
     \<open> ICC_IGRPEN1_EL3_ref = ( (|
  name = (''ICC_IGRPEN1_EL3''),
  read_from = ((\<lambda> s .  (| ICC_IGRPEN1_EL3_Type_bits = ((bitvector_64_reg   s) (''ICC_IGRPEN1_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_IGRPEN1_EL3'') then(ICC_IGRPEN1_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IGRPEN1_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IGRPEN1_EL3_Type v)) |) )\<close>


definition ICC_CTLR_EL3_ref  :: \<open>((regstate),(register_value),(ICC_CTLR_EL3_Type))register_ref \<close>  where 
     \<open> ICC_CTLR_EL3_ref = ( (|
  name = (''ICC_CTLR_EL3''),
  read_from = ((\<lambda> s .  (| ICC_CTLR_EL3_Type_bits = ((bitvector_64_reg   s) (''ICC_CTLR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_CTLR_EL3'') then(ICC_CTLR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_CTLR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_CTLR_EL3_Type v)) |) )\<close>


definition HFGWTR_EL2_ref  :: \<open>((regstate),(register_value),(HFGWTR_EL2_Type))register_ref \<close>  where 
     \<open> HFGWTR_EL2_ref = ( (|
  name = (''HFGWTR_EL2''),
  read_from = ((\<lambda> s .  (| HFGWTR_EL2_Type_bits = ((bitvector_64_reg   s) (''HFGWTR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HFGWTR_EL2'') then(HFGWTR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HFGWTR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HFGWTR_EL2_Type v)) |) )\<close>


definition HFGWTR2_EL2_ref  :: \<open>((regstate),(register_value),(HFGWTR2_EL2_Type))register_ref \<close>  where 
     \<open> HFGWTR2_EL2_ref = ( (|
  name = (''HFGWTR2_EL2''),
  read_from = ((\<lambda> s .  (| HFGWTR2_EL2_Type_bits = ((bitvector_64_reg   s) (''HFGWTR2_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HFGWTR2_EL2'') then(HFGWTR2_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HFGWTR2_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HFGWTR2_EL2_Type v)) |) )\<close>


definition HFGRTR_EL2_ref  :: \<open>((regstate),(register_value),(HFGRTR_EL2_Type))register_ref \<close>  where 
     \<open> HFGRTR_EL2_ref = ( (|
  name = (''HFGRTR_EL2''),
  read_from = ((\<lambda> s .  (| HFGRTR_EL2_Type_bits = ((bitvector_64_reg   s) (''HFGRTR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HFGRTR_EL2'') then(HFGRTR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HFGRTR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HFGRTR_EL2_Type v)) |) )\<close>


definition HFGRTR2_EL2_ref  :: \<open>((regstate),(register_value),(HFGRTR2_EL2_Type))register_ref \<close>  where 
     \<open> HFGRTR2_EL2_ref = ( (|
  name = (''HFGRTR2_EL2''),
  read_from = ((\<lambda> s .  (| HFGRTR2_EL2_Type_bits = ((bitvector_64_reg   s) (''HFGRTR2_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HFGRTR2_EL2'') then(HFGRTR2_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HFGRTR2_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HFGRTR2_EL2_Type v)) |) )\<close>


definition HFGITR2_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> HFGITR2_EL2_ref = ( (|
  name = (''HFGITR2_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''HFGITR2_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HFGITR2_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition HDFGWTR_EL2_ref  :: \<open>((regstate),(register_value),(HDFGWTR_EL2_Type))register_ref \<close>  where 
     \<open> HDFGWTR_EL2_ref = ( (|
  name = (''HDFGWTR_EL2''),
  read_from = ((\<lambda> s .  (| HDFGWTR_EL2_Type_bits = ((bitvector_64_reg   s) (''HDFGWTR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HDFGWTR_EL2'') then(HDFGWTR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HDFGWTR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HDFGWTR_EL2_Type v)) |) )\<close>


definition HDFGWTR2_EL2_ref  :: \<open>((regstate),(register_value),(HDFGWTR2_EL2_Type))register_ref \<close>  where 
     \<open> HDFGWTR2_EL2_ref = ( (|
  name = (''HDFGWTR2_EL2''),
  read_from = ((\<lambda> s .  (| HDFGWTR2_EL2_Type_bits = ((bitvector_64_reg   s) (''HDFGWTR2_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HDFGWTR2_EL2'') then(HDFGWTR2_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HDFGWTR2_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HDFGWTR2_EL2_Type v)) |) )\<close>


definition HDFGRTR_EL2_ref  :: \<open>((regstate),(register_value),(HDFGRTR_EL2_Type))register_ref \<close>  where 
     \<open> HDFGRTR_EL2_ref = ( (|
  name = (''HDFGRTR_EL2''),
  read_from = ((\<lambda> s .  (| HDFGRTR_EL2_Type_bits = ((bitvector_64_reg   s) (''HDFGRTR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HDFGRTR_EL2'') then(HDFGRTR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HDFGRTR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HDFGRTR_EL2_Type v)) |) )\<close>


definition HDFGRTR2_EL2_ref  :: \<open>((regstate),(register_value),(HDFGRTR2_EL2_Type))register_ref \<close>  where 
     \<open> HDFGRTR2_EL2_ref = ( (|
  name = (''HDFGRTR2_EL2''),
  read_from = ((\<lambda> s .  (| HDFGRTR2_EL2_Type_bits = ((bitvector_64_reg   s) (''HDFGRTR2_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HDFGRTR2_EL2'') then(HDFGRTR2_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HDFGRTR2_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HDFGRTR2_EL2_Type v)) |) )\<close>


definition HAFGRTR_EL2_ref  :: \<open>((regstate),(register_value),(HAFGRTR_EL2_Type))register_ref \<close>  where 
     \<open> HAFGRTR_EL2_ref = ( (|
  name = (''HAFGRTR_EL2''),
  read_from = ((\<lambda> s .  (| HAFGRTR_EL2_Type_bits = ((bitvector_64_reg   s) (''HAFGRTR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HAFGRTR_EL2'') then(HAFGRTR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HAFGRTR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HAFGRTR_EL2_Type v)) |) )\<close>


definition GMID_EL1_ref  :: \<open>((regstate),(register_value),(GMID_EL1_Type))register_ref \<close>  where 
     \<open> GMID_EL1_ref = ( (|
  name = (''GMID_EL1''),
  read_from = ((\<lambda> s .  (| GMID_EL1_Type_bits = ((bitvector_64_reg   s) (''GMID_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GMID_EL1'') then(GMID_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GMID_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GMID_EL1_Type v)) |) )\<close>


definition DCZID_EL0_ref  :: \<open>((regstate),(register_value),(DCZID_EL0_Type))register_ref \<close>  where 
     \<open> DCZID_EL0_ref = ( (|
  name = (''DCZID_EL0''),
  read_from = ((\<lambda> s .  (| DCZID_EL0_Type_bits = ((bitvector_64_reg   s) (''DCZID_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DCZID_EL0'') then(DCZID_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DCZID_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DCZID_EL0_Type v)) |) )\<close>


definition DBGDTRTX_EL0_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> DBGDTRTX_EL0_ref = ( (|
  name = (''DBGDTRTX_EL0''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''DBGDTRTX_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DBGDTRTX_EL0'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition DBGDTRRX_EL0_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> DBGDTRRX_EL0_ref = ( (|
  name = (''DBGDTRRX_EL0''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''DBGDTRRX_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DBGDTRRX_EL0'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition DACR32_EL2_ref  :: \<open>((regstate),(register_value),(DACR32_EL2_Type))register_ref \<close>  where 
     \<open> DACR32_EL2_ref = ( (|
  name = (''DACR32_EL2''),
  read_from = ((\<lambda> s .  (| DACR32_EL2_Type_bits = ((bitvector_64_reg   s) (''DACR32_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DACR32_EL2'') then(DACR32_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DACR32_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DACR32_EL2_Type v)) |) )\<close>


definition CNTV_TVAL_EL0_ref  :: \<open>((regstate),(register_value),(CNTV_TVAL_EL0_Type))register_ref \<close>  where 
     \<open> CNTV_TVAL_EL0_ref = ( (|
  name = (''CNTV_TVAL_EL0''),
  read_from = ((\<lambda> s .  (| CNTV_TVAL_EL0_Type_bits = ((bitvector_64_reg   s) (''CNTV_TVAL_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTV_TVAL_EL0'') then(CNTV_TVAL_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTV_TVAL_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTV_TVAL_EL0_Type v)) |) )\<close>


definition CNTP_TVAL_EL0_ref  :: \<open>((regstate),(register_value),(CNTP_TVAL_EL0_Type))register_ref \<close>  where 
     \<open> CNTP_TVAL_EL0_ref = ( (|
  name = (''CNTP_TVAL_EL0''),
  read_from = ((\<lambda> s .  (| CNTP_TVAL_EL0_Type_bits = ((bitvector_64_reg   s) (''CNTP_TVAL_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTP_TVAL_EL0'') then(CNTP_TVAL_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTP_TVAL_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTP_TVAL_EL0_Type v)) |) )\<close>


definition CNTPS_TVAL_EL1_ref  :: \<open>((regstate),(register_value),(CNTPS_TVAL_EL1_Type))register_ref \<close>  where 
     \<open> CNTPS_TVAL_EL1_ref = ( (|
  name = (''CNTPS_TVAL_EL1''),
  read_from = ((\<lambda> s .  (| CNTPS_TVAL_EL1_Type_bits = ((bitvector_64_reg   s) (''CNTPS_TVAL_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTPS_TVAL_EL1'') then(CNTPS_TVAL_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTPS_TVAL_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTPS_TVAL_EL1_Type v)) |) )\<close>


definition CNTHV_TVAL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHV_TVAL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHV_TVAL_EL2_ref = ( (|
  name = (''CNTHV_TVAL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHV_TVAL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHV_TVAL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHV_TVAL_EL2'') then(CNTHV_TVAL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHV_TVAL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHV_TVAL_EL2_Type v)) |) )\<close>


definition CNTHVS_TVAL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHVS_TVAL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHVS_TVAL_EL2_ref = ( (|
  name = (''CNTHVS_TVAL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHVS_TVAL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHVS_TVAL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHVS_TVAL_EL2'') then(CNTHVS_TVAL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHVS_TVAL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHVS_TVAL_EL2_Type v)) |) )\<close>


definition CNTHP_TVAL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHP_TVAL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHP_TVAL_EL2_ref = ( (|
  name = (''CNTHP_TVAL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHP_TVAL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHP_TVAL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHP_TVAL_EL2'') then(CNTHP_TVAL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHP_TVAL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHP_TVAL_EL2_Type v)) |) )\<close>


definition CNTHPS_TVAL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHPS_TVAL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHPS_TVAL_EL2_ref = ( (|
  name = (''CNTHPS_TVAL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHPS_TVAL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHPS_TVAL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHPS_TVAL_EL2'') then(CNTHPS_TVAL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHPS_TVAL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHPS_TVAL_EL2_Type v)) |) )\<close>


definition CNTFRQ_EL0_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> CNTFRQ_EL0_ref = ( (|
  name = (''CNTFRQ_EL0''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''CNTFRQ_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTFRQ_EL0'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition BRBINFINJ_EL1_ref  :: \<open>((regstate),(register_value),(BRBINFINJ_EL1_Type))register_ref \<close>  where 
     \<open> BRBINFINJ_EL1_ref = ( (|
  name = (''BRBINFINJ_EL1''),
  read_from = ((\<lambda> s .  (| BRBINFINJ_EL1_Type_bits = ((bitvector_64_reg   s) (''BRBINFINJ_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''BRBINFINJ_EL1'') then(BRBINFINJ_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  BRBINFINJ_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_BRBINFINJ_EL1_Type v)) |) )\<close>


definition AMCG1IDR_EL0_ref  :: \<open>((regstate),(register_value),(AMCG1IDR_EL0_Type))register_ref \<close>  where 
     \<open> AMCG1IDR_EL0_ref = ( (|
  name = (''AMCG1IDR_EL0''),
  read_from = ((\<lambda> s .  (| AMCG1IDR_EL0_Type_bits = ((bitvector_64_reg   s) (''AMCG1IDR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMCG1IDR_EL0'') then(AMCG1IDR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCG1IDR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCG1IDR_EL0_Type v)) |) )\<close>


definition ACCDATA_EL1_ref  :: \<open>((regstate),(register_value),(ACCDATA_EL1_Type))register_ref \<close>  where 
     \<open> ACCDATA_EL1_ref = ( (|
  name = (''ACCDATA_EL1''),
  read_from = ((\<lambda> s .  (| ACCDATA_EL1_Type_bits = ((bitvector_64_reg   s) (''ACCDATA_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ACCDATA_EL1'') then(ACCDATA_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ACCDATA_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ACCDATA_EL1_Type v)) |) )\<close>


definition num_ctx_breakpoints_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> num_ctx_breakpoints_ref = ( (|
  name = (''__num_ctx_breakpoints''),
  read_from = ((\<lambda> s . (int_reg   s) (''__num_ctx_breakpoints''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__num_ctx_breakpoints'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition exclusive_granule_size_ref  :: \<open>((regstate),(register_value),((4)Word.word))register_ref \<close>  where 
     \<open> exclusive_granule_size_ref = ( (|
  name = (''__exclusive_granule_size''),
  read_from = ((\<lambda> s . (bitvector_4_reg   s) (''__exclusive_granule_size''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_4_reg :=
  ((\<lambda> reg .  if reg = (''__exclusive_granule_size'') then v else(bitvector_4_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_4_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_4 v)) |) )\<close>


definition TLBTR_ref  :: \<open>((regstate),(register_value),(TLBTR_Type))register_ref \<close>  where 
     \<open> TLBTR_ref = ( (|
  name = (''TLBTR''),
  read_from = ((\<lambda> s .  (| TLBTR_Type_bits = ((bitvector_32_reg   s) (''TLBTR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''TLBTR'') then(TLBTR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TLBTR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TLBTR_Type v)) |) )\<close>


definition PMCEID3_ref  :: \<open>((regstate),(register_value),(PMCEID3_Type))register_ref \<close>  where 
     \<open> PMCEID3_ref = ( (|
  name = (''_PMCEID3''),
  read_from = ((\<lambda> s .  (| PMCEID3_Type_bits = ((bitvector_32_reg   s) (''_PMCEID3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMCEID3'') then(PMCEID3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCEID3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCEID3_Type v)) |) )\<close>


definition PMCEID2_ref  :: \<open>((regstate),(register_value),(PMCEID2_Type))register_ref \<close>  where 
     \<open> PMCEID2_ref = ( (|
  name = (''_PMCEID2''),
  read_from = ((\<lambda> s .  (| PMCEID2_Type_bits = ((bitvector_32_reg   s) (''_PMCEID2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMCEID2'') then(PMCEID2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCEID2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCEID2_Type v)) |) )\<close>


definition PMCEID1_ref  :: \<open>((regstate),(register_value),(PMCEID1_Type))register_ref \<close>  where 
     \<open> PMCEID1_ref = ( (|
  name = (''_PMCEID1''),
  read_from = ((\<lambda> s .  (| PMCEID1_Type_bits = ((bitvector_32_reg   s) (''_PMCEID1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMCEID1'') then(PMCEID1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCEID1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCEID1_Type v)) |) )\<close>


definition PMCEID1_EL0_ref  :: \<open>((regstate),(register_value),(PMCEID1_EL0_Type))register_ref \<close>  where 
     \<open> PMCEID1_EL0_ref = ( (|
  name = (''PMCEID1_EL0''),
  read_from = ((\<lambda> s .  (| PMCEID1_EL0_Type_bits = ((bitvector_64_reg   s) (''PMCEID1_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMCEID1_EL0'') then(PMCEID1_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCEID1_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCEID1_EL0_Type v)) |) )\<close>


definition PMCEID0_ref  :: \<open>((regstate),(register_value),(PMCEID0_Type))register_ref \<close>  where 
     \<open> PMCEID0_ref = ( (|
  name = (''_PMCEID0''),
  read_from = ((\<lambda> s .  (| PMCEID0_Type_bits = ((bitvector_32_reg   s) (''_PMCEID0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMCEID0'') then(PMCEID0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCEID0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCEID0_Type v)) |) )\<close>


definition PMCEID0_EL0_ref  :: \<open>((regstate),(register_value),(PMCEID0_EL0_Type))register_ref \<close>  where 
     \<open> PMCEID0_EL0_ref = ( (|
  name = (''PMCEID0_EL0''),
  read_from = ((\<lambda> s .  (| PMCEID0_EL0_Type_bits = ((bitvector_64_reg   s) (''PMCEID0_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMCEID0_EL0'') then(PMCEID0_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCEID0_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCEID0_EL0_Type v)) |) )\<close>


definition NMRR_S_ref  :: \<open>((regstate),(register_value),(NMRR_Type))register_ref \<close>  where 
     \<open> NMRR_S_ref = ( (|
  name = (''NMRR_S''),
  read_from = ((\<lambda> s .  (| NMRR_Type_bits = ((bitvector_32_reg   s) (''NMRR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''NMRR_S'') then(NMRR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  NMRR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_NMRR_Type v)) |) )\<close>


definition NMRR_NS_ref  :: \<open>((regstate),(register_value),(NMRR_Type))register_ref \<close>  where 
     \<open> NMRR_NS_ref = ( (|
  name = (''_NMRR_NS''),
  read_from = ((\<lambda> s .  (| NMRR_Type_bits = ((bitvector_32_reg   s) (''_NMRR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_NMRR_NS'') then(NMRR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  NMRR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_NMRR_Type v)) |) )\<close>


definition MVFR1_ref  :: \<open>((regstate),(register_value),(MVFR1_Type))register_ref \<close>  where 
     \<open> MVFR1_ref = ( (|
  name = (''_MVFR1''),
  read_from = ((\<lambda> s .  (| MVFR1_Type_bits = ((bitvector_32_reg   s) (''_MVFR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_MVFR1'') then(MVFR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MVFR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MVFR1_Type v)) |) )\<close>


definition MVFR1_EL1_ref  :: \<open>((regstate),(register_value),(MVFR1_EL1_Type))register_ref \<close>  where 
     \<open> MVFR1_EL1_ref = ( (|
  name = (''MVFR1_EL1''),
  read_from = ((\<lambda> s .  (| MVFR1_EL1_Type_bits = ((bitvector_64_reg   s) (''MVFR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MVFR1_EL1'') then(MVFR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MVFR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MVFR1_EL1_Type v)) |) )\<close>


definition MVFR0_ref  :: \<open>((regstate),(register_value),(MVFR0_Type))register_ref \<close>  where 
     \<open> MVFR0_ref = ( (|
  name = (''_MVFR0''),
  read_from = ((\<lambda> s .  (| MVFR0_Type_bits = ((bitvector_32_reg   s) (''_MVFR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_MVFR0'') then(MVFR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MVFR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MVFR0_Type v)) |) )\<close>


definition MVFR0_EL1_ref  :: \<open>((regstate),(register_value),(MVFR0_EL1_Type))register_ref \<close>  where 
     \<open> MVFR0_EL1_ref = ( (|
  name = (''MVFR0_EL1''),
  read_from = ((\<lambda> s .  (| MVFR0_EL1_Type_bits = ((bitvector_64_reg   s) (''MVFR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MVFR0_EL1'') then(MVFR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MVFR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MVFR0_EL1_Type v)) |) )\<close>


definition MIDR_ref  :: \<open>((regstate),(register_value),(MIDR_Type))register_ref \<close>  where 
     \<open> MIDR_ref = ( (|
  name = (''_MIDR''),
  read_from = ((\<lambda> s .  (| MIDR_Type_bits = ((bitvector_32_reg   s) (''_MIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_MIDR'') then(MIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MIDR_Type v)) |) )\<close>


definition MIDR_EL1_ref  :: \<open>((regstate),(register_value),(MIDR_EL1_Type))register_ref \<close>  where 
     \<open> MIDR_EL1_ref = ( (|
  name = (''MIDR_EL1''),
  read_from = ((\<lambda> s .  (| MIDR_EL1_Type_bits = ((bitvector_64_reg   s) (''MIDR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MIDR_EL1'') then(MIDR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MIDR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MIDR_EL1_Type v)) |) )\<close>


definition ID_PFR1_ref  :: \<open>((regstate),(register_value),(ID_PFR1_Type))register_ref \<close>  where 
     \<open> ID_PFR1_ref = ( (|
  name = (''_ID_PFR1''),
  read_from = ((\<lambda> s .  (| ID_PFR1_Type_bits = ((bitvector_32_reg   s) (''_ID_PFR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_PFR1'') then(ID_PFR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_PFR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_PFR1_Type v)) |) )\<close>


definition ID_PFR1_EL1_ref  :: \<open>((regstate),(register_value),(ID_PFR1_EL1_Type))register_ref \<close>  where 
     \<open> ID_PFR1_EL1_ref = ( (|
  name = (''ID_PFR1_EL1''),
  read_from = ((\<lambda> s .  (| ID_PFR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_PFR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_PFR1_EL1'') then(ID_PFR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_PFR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_PFR1_EL1_Type v)) |) )\<close>


definition ID_PFR0_ref  :: \<open>((regstate),(register_value),(ID_PFR0_Type))register_ref \<close>  where 
     \<open> ID_PFR0_ref = ( (|
  name = (''_ID_PFR0''),
  read_from = ((\<lambda> s .  (| ID_PFR0_Type_bits = ((bitvector_32_reg   s) (''_ID_PFR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_PFR0'') then(ID_PFR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_PFR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_PFR0_Type v)) |) )\<close>


definition ID_PFR0_EL1_ref  :: \<open>((regstate),(register_value),(ID_PFR0_EL1_Type))register_ref \<close>  where 
     \<open> ID_PFR0_EL1_ref = ( (|
  name = (''ID_PFR0_EL1''),
  read_from = ((\<lambda> s .  (| ID_PFR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_PFR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_PFR0_EL1'') then(ID_PFR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_PFR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_PFR0_EL1_Type v)) |) )\<close>


definition ID_MMFR4_ref  :: \<open>((regstate),(register_value),(ID_MMFR4_Type))register_ref \<close>  where 
     \<open> ID_MMFR4_ref = ( (|
  name = (''_ID_MMFR4''),
  read_from = ((\<lambda> s .  (| ID_MMFR4_Type_bits = ((bitvector_32_reg   s) (''_ID_MMFR4'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_MMFR4'') then(ID_MMFR4_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR4_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR4_Type v)) |) )\<close>


definition ID_MMFR4_EL1_ref  :: \<open>((regstate),(register_value),(ID_MMFR4_EL1_Type))register_ref \<close>  where 
     \<open> ID_MMFR4_EL1_ref = ( (|
  name = (''ID_MMFR4_EL1''),
  read_from = ((\<lambda> s .  (| ID_MMFR4_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_MMFR4_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_MMFR4_EL1'') then(ID_MMFR4_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR4_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR4_EL1_Type v)) |) )\<close>


definition ID_MMFR3_ref  :: \<open>((regstate),(register_value),(ID_MMFR3_Type))register_ref \<close>  where 
     \<open> ID_MMFR3_ref = ( (|
  name = (''_ID_MMFR3''),
  read_from = ((\<lambda> s .  (| ID_MMFR3_Type_bits = ((bitvector_32_reg   s) (''_ID_MMFR3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_MMFR3'') then(ID_MMFR3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR3_Type v)) |) )\<close>


definition ID_MMFR3_EL1_ref  :: \<open>((regstate),(register_value),(ID_MMFR3_EL1_Type))register_ref \<close>  where 
     \<open> ID_MMFR3_EL1_ref = ( (|
  name = (''ID_MMFR3_EL1''),
  read_from = ((\<lambda> s .  (| ID_MMFR3_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_MMFR3_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_MMFR3_EL1'') then(ID_MMFR3_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR3_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR3_EL1_Type v)) |) )\<close>


definition ID_MMFR2_ref  :: \<open>((regstate),(register_value),(ID_MMFR2_Type))register_ref \<close>  where 
     \<open> ID_MMFR2_ref = ( (|
  name = (''_ID_MMFR2''),
  read_from = ((\<lambda> s .  (| ID_MMFR2_Type_bits = ((bitvector_32_reg   s) (''_ID_MMFR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_MMFR2'') then(ID_MMFR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR2_Type v)) |) )\<close>


definition ID_MMFR2_EL1_ref  :: \<open>((regstate),(register_value),(ID_MMFR2_EL1_Type))register_ref \<close>  where 
     \<open> ID_MMFR2_EL1_ref = ( (|
  name = (''ID_MMFR2_EL1''),
  read_from = ((\<lambda> s .  (| ID_MMFR2_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_MMFR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_MMFR2_EL1'') then(ID_MMFR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR2_EL1_Type v)) |) )\<close>


definition ID_MMFR1_ref  :: \<open>((regstate),(register_value),(ID_MMFR1_Type))register_ref \<close>  where 
     \<open> ID_MMFR1_ref = ( (|
  name = (''_ID_MMFR1''),
  read_from = ((\<lambda> s .  (| ID_MMFR1_Type_bits = ((bitvector_32_reg   s) (''_ID_MMFR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_MMFR1'') then(ID_MMFR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR1_Type v)) |) )\<close>


definition ID_MMFR1_EL1_ref  :: \<open>((regstate),(register_value),(ID_MMFR1_EL1_Type))register_ref \<close>  where 
     \<open> ID_MMFR1_EL1_ref = ( (|
  name = (''ID_MMFR1_EL1''),
  read_from = ((\<lambda> s .  (| ID_MMFR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_MMFR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_MMFR1_EL1'') then(ID_MMFR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR1_EL1_Type v)) |) )\<close>


definition ID_MMFR0_ref  :: \<open>((regstate),(register_value),(ID_MMFR0_Type))register_ref \<close>  where 
     \<open> ID_MMFR0_ref = ( (|
  name = (''_ID_MMFR0''),
  read_from = ((\<lambda> s .  (| ID_MMFR0_Type_bits = ((bitvector_32_reg   s) (''_ID_MMFR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_MMFR0'') then(ID_MMFR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR0_Type v)) |) )\<close>


definition ID_MMFR0_EL1_ref  :: \<open>((regstate),(register_value),(ID_MMFR0_EL1_Type))register_ref \<close>  where 
     \<open> ID_MMFR0_EL1_ref = ( (|
  name = (''ID_MMFR0_EL1''),
  read_from = ((\<lambda> s .  (| ID_MMFR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_MMFR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_MMFR0_EL1'') then(ID_MMFR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR0_EL1_Type v)) |) )\<close>


definition ID_ISAR6_ref  :: \<open>((regstate),(register_value),(ID_ISAR6_Type))register_ref \<close>  where 
     \<open> ID_ISAR6_ref = ( (|
  name = (''_ID_ISAR6''),
  read_from = ((\<lambda> s .  (| ID_ISAR6_Type_bits = ((bitvector_32_reg   s) (''_ID_ISAR6'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_ISAR6'') then(ID_ISAR6_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR6_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR6_Type v)) |) )\<close>


definition ID_ISAR6_EL1_ref  :: \<open>((regstate),(register_value),(ID_ISAR6_EL1_Type))register_ref \<close>  where 
     \<open> ID_ISAR6_EL1_ref = ( (|
  name = (''ID_ISAR6_EL1''),
  read_from = ((\<lambda> s .  (| ID_ISAR6_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_ISAR6_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_ISAR6_EL1'') then(ID_ISAR6_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR6_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR6_EL1_Type v)) |) )\<close>


definition ID_ISAR4_ref  :: \<open>((regstate),(register_value),(ID_ISAR4_Type))register_ref \<close>  where 
     \<open> ID_ISAR4_ref = ( (|
  name = (''_ID_ISAR4''),
  read_from = ((\<lambda> s .  (| ID_ISAR4_Type_bits = ((bitvector_32_reg   s) (''_ID_ISAR4'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_ISAR4'') then(ID_ISAR4_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR4_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR4_Type v)) |) )\<close>


definition ID_ISAR4_EL1_ref  :: \<open>((regstate),(register_value),(ID_ISAR4_EL1_Type))register_ref \<close>  where 
     \<open> ID_ISAR4_EL1_ref = ( (|
  name = (''ID_ISAR4_EL1''),
  read_from = ((\<lambda> s .  (| ID_ISAR4_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_ISAR4_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_ISAR4_EL1'') then(ID_ISAR4_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR4_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR4_EL1_Type v)) |) )\<close>


definition ID_ISAR3_ref  :: \<open>((regstate),(register_value),(ID_ISAR3_Type))register_ref \<close>  where 
     \<open> ID_ISAR3_ref = ( (|
  name = (''_ID_ISAR3''),
  read_from = ((\<lambda> s .  (| ID_ISAR3_Type_bits = ((bitvector_32_reg   s) (''_ID_ISAR3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_ISAR3'') then(ID_ISAR3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR3_Type v)) |) )\<close>


definition ID_ISAR3_EL1_ref  :: \<open>((regstate),(register_value),(ID_ISAR3_EL1_Type))register_ref \<close>  where 
     \<open> ID_ISAR3_EL1_ref = ( (|
  name = (''ID_ISAR3_EL1''),
  read_from = ((\<lambda> s .  (| ID_ISAR3_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_ISAR3_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_ISAR3_EL1'') then(ID_ISAR3_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR3_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR3_EL1_Type v)) |) )\<close>


definition ID_ISAR2_ref  :: \<open>((regstate),(register_value),(ID_ISAR2_Type))register_ref \<close>  where 
     \<open> ID_ISAR2_ref = ( (|
  name = (''_ID_ISAR2''),
  read_from = ((\<lambda> s .  (| ID_ISAR2_Type_bits = ((bitvector_32_reg   s) (''_ID_ISAR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_ISAR2'') then(ID_ISAR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR2_Type v)) |) )\<close>


definition ID_ISAR2_EL1_ref  :: \<open>((regstate),(register_value),(ID_ISAR2_EL1_Type))register_ref \<close>  where 
     \<open> ID_ISAR2_EL1_ref = ( (|
  name = (''ID_ISAR2_EL1''),
  read_from = ((\<lambda> s .  (| ID_ISAR2_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_ISAR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_ISAR2_EL1'') then(ID_ISAR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR2_EL1_Type v)) |) )\<close>


definition ID_ISAR1_ref  :: \<open>((regstate),(register_value),(ID_ISAR1_Type))register_ref \<close>  where 
     \<open> ID_ISAR1_ref = ( (|
  name = (''_ID_ISAR1''),
  read_from = ((\<lambda> s .  (| ID_ISAR1_Type_bits = ((bitvector_32_reg   s) (''_ID_ISAR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_ISAR1'') then(ID_ISAR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR1_Type v)) |) )\<close>


definition ID_ISAR1_EL1_ref  :: \<open>((regstate),(register_value),(ID_ISAR1_EL1_Type))register_ref \<close>  where 
     \<open> ID_ISAR1_EL1_ref = ( (|
  name = (''ID_ISAR1_EL1''),
  read_from = ((\<lambda> s .  (| ID_ISAR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_ISAR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_ISAR1_EL1'') then(ID_ISAR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR1_EL1_Type v)) |) )\<close>


definition ID_DFR0_ref  :: \<open>((regstate),(register_value),(ID_DFR0_Type))register_ref \<close>  where 
     \<open> ID_DFR0_ref = ( (|
  name = (''_ID_DFR0''),
  read_from = ((\<lambda> s .  (| ID_DFR0_Type_bits = ((bitvector_32_reg   s) (''_ID_DFR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_DFR0'') then(ID_DFR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_DFR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_DFR0_Type v)) |) )\<close>


definition ID_DFR0_EL1_ref  :: \<open>((regstate),(register_value),(ID_DFR0_EL1_Type))register_ref \<close>  where 
     \<open> ID_DFR0_EL1_ref = ( (|
  name = (''ID_DFR0_EL1''),
  read_from = ((\<lambda> s .  (| ID_DFR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_DFR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_DFR0_EL1'') then(ID_DFR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_DFR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_DFR0_EL1_Type v)) |) )\<close>


definition FPSID_ref  :: \<open>((regstate),(register_value),(FPSID_Type))register_ref \<close>  where 
     \<open> FPSID_ref = ( (|
  name = (''FPSID''),
  read_from = ((\<lambda> s .  (| FPSID_Type_bits = ((bitvector_32_reg   s) (''FPSID'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''FPSID'') then(FPSID_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  FPSID_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_FPSID_Type v)) |) )\<close>


definition DBGDEVID_ref  :: \<open>((regstate),(register_value),(DBGDEVID_Type))register_ref \<close>  where 
     \<open> DBGDEVID_ref = ( (|
  name = (''DBGDEVID''),
  read_from = ((\<lambda> s .  (| DBGDEVID_Type_bits = ((bitvector_32_reg   s) (''DBGDEVID'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''DBGDEVID'') then(DBGDEVID_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDEVID_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDEVID_Type v)) |) )\<close>


definition CLIDR_ref  :: \<open>((regstate),(register_value),(CLIDR_Type))register_ref \<close>  where 
     \<open> CLIDR_ref = ( (|
  name = (''_CLIDR''),
  read_from = ((\<lambda> s .  (| CLIDR_Type_bits = ((bitvector_32_reg   s) (''_CLIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CLIDR'') then(CLIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CLIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CLIDR_Type v)) |) )\<close>


definition VTCR_ref  :: \<open>((regstate),(register_value),(VTCR_Type))register_ref \<close>  where 
     \<open> VTCR_ref = ( (|
  name = (''_VTCR''),
  read_from = ((\<lambda> s .  (| VTCR_Type_bits = ((bitvector_32_reg   s) (''_VTCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_VTCR'') then(VTCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VTCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VTCR_Type v)) |) )\<close>


definition VPIDR_ref  :: \<open>((regstate),(register_value),(VPIDR_Type))register_ref \<close>  where 
     \<open> VPIDR_ref = ( (|
  name = (''_VPIDR''),
  read_from = ((\<lambda> s .  (| VPIDR_Type_bits = ((bitvector_32_reg   s) (''_VPIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_VPIDR'') then(VPIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VPIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VPIDR_Type v)) |) )\<close>


definition VPIDR_EL2_ref  :: \<open>((regstate),(register_value),(VPIDR_EL2_Type))register_ref \<close>  where 
     \<open> VPIDR_EL2_ref = ( (|
  name = (''VPIDR_EL2''),
  read_from = ((\<lambda> s .  (| VPIDR_EL2_Type_bits = ((bitvector_64_reg   s) (''VPIDR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VPIDR_EL2'') then(VPIDR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VPIDR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VPIDR_EL2_Type v)) |) )\<close>


definition VMPIDR_ref  :: \<open>((regstate),(register_value),(VMPIDR_Type))register_ref \<close>  where 
     \<open> VMPIDR_ref = ( (|
  name = (''_VMPIDR''),
  read_from = ((\<lambda> s .  (| VMPIDR_Type_bits = ((bitvector_32_reg   s) (''_VMPIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_VMPIDR'') then(VMPIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VMPIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VMPIDR_Type v)) |) )\<close>


definition VMPIDR_EL2_ref  :: \<open>((regstate),(register_value),(VMPIDR_EL2_Type))register_ref \<close>  where 
     \<open> VMPIDR_EL2_ref = ( (|
  name = (''VMPIDR_EL2''),
  read_from = ((\<lambda> s .  (| VMPIDR_EL2_Type_bits = ((bitvector_64_reg   s) (''VMPIDR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VMPIDR_EL2'') then(VMPIDR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VMPIDR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VMPIDR_EL2_Type v)) |) )\<close>


definition TTBCR2_S_ref  :: \<open>((regstate),(register_value),(TTBCR2_Type))register_ref \<close>  where 
     \<open> TTBCR2_S_ref = ( (|
  name = (''TTBCR2_S''),
  read_from = ((\<lambda> s .  (| TTBCR2_Type_bits = ((bitvector_32_reg   s) (''TTBCR2_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''TTBCR2_S'') then(TTBCR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBCR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBCR2_Type v)) |) )\<close>


definition TTBCR2_NS_ref  :: \<open>((regstate),(register_value),(TTBCR2_Type))register_ref \<close>  where 
     \<open> TTBCR2_NS_ref = ( (|
  name = (''_TTBCR2_NS''),
  read_from = ((\<lambda> s .  (| TTBCR2_Type_bits = ((bitvector_32_reg   s) (''_TTBCR2_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_TTBCR2_NS'') then(TTBCR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBCR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBCR2_Type v)) |) )\<close>


definition TRFCR_ref  :: \<open>((regstate),(register_value),(TRFCR_Type))register_ref \<close>  where 
     \<open> TRFCR_ref = ( (|
  name = (''_TRFCR''),
  read_from = ((\<lambda> s .  (| TRFCR_Type_bits = ((bitvector_32_reg   s) (''_TRFCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_TRFCR'') then(TRFCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TRFCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TRFCR_Type v)) |) )\<close>


definition TRFCR_EL1_ref  :: \<open>((regstate),(register_value),(TRFCR_EL1_Type))register_ref \<close>  where 
     \<open> TRFCR_EL1_ref = ( (|
  name = (''TRFCR_EL1''),
  read_from = ((\<lambda> s .  (| TRFCR_EL1_Type_bits = ((bitvector_64_reg   s) (''TRFCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TRFCR_EL1'') then(TRFCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TRFCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TRFCR_EL1_Type v)) |) )\<close>


definition RMR_ref  :: \<open>((regstate),(register_value),(RMR_Type))register_ref \<close>  where 
     \<open> RMR_ref = ( (|
  name = (''_RMR''),
  read_from = ((\<lambda> s .  (| RMR_Type_bits = ((bitvector_32_reg   s) (''_RMR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_RMR'') then(RMR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RMR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RMR_Type v)) |) )\<close>


definition RMR_EL3_ref  :: \<open>((regstate),(register_value),(RMR_EL3_Type))register_ref \<close>  where 
     \<open> RMR_EL3_ref = ( (|
  name = (''RMR_EL3''),
  read_from = ((\<lambda> s .  (| RMR_EL3_Type_bits = ((bitvector_64_reg   s) (''RMR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''RMR_EL3'') then(RMR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RMR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RMR_EL3_Type v)) |) )\<close>


definition RMR_EL1_ref  :: \<open>((regstate),(register_value),(RMR_EL1_Type))register_ref \<close>  where 
     \<open> RMR_EL1_ref = ( (|
  name = (''RMR_EL1''),
  read_from = ((\<lambda> s .  (| RMR_EL1_Type_bits = ((bitvector_64_reg   s) (''RMR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''RMR_EL1'') then(RMR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RMR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RMR_EL1_Type v)) |) )\<close>


definition PRRR_S_ref  :: \<open>((regstate),(register_value),(PRRR_Type))register_ref \<close>  where 
     \<open> PRRR_S_ref = ( (|
  name = (''PRRR_S''),
  read_from = ((\<lambda> s .  (| PRRR_Type_bits = ((bitvector_32_reg   s) (''PRRR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PRRR_S'') then(PRRR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PRRR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PRRR_Type v)) |) )\<close>


definition PRRR_NS_ref  :: \<open>((regstate),(register_value),(PRRR_Type))register_ref \<close>  where 
     \<open> PRRR_NS_ref = ( (|
  name = (''_PRRR_NS''),
  read_from = ((\<lambda> s .  (| PRRR_Type_bits = ((bitvector_32_reg   s) (''_PRRR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PRRR_NS'') then(PRRR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PRRR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PRRR_Type v)) |) )\<close>


definition PMVIDSR_ref  :: \<open>((regstate),(register_value),(PMVIDSR_Type))register_ref \<close>  where 
     \<open> PMVIDSR_ref = ( (|
  name = (''PMVIDSR''),
  read_from = ((\<lambda> s .  (| PMVIDSR_Type_bits = ((bitvector_32_reg   s) (''PMVIDSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMVIDSR'') then(PMVIDSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMVIDSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMVIDSR_Type v)) |) )\<close>


definition PMVCIDSR_ref  :: \<open>((regstate),(register_value),(PMVCIDSR_Type))register_ref \<close>  where 
     \<open> PMVCIDSR_ref = ( (|
  name = (''PMVCIDSR''),
  read_from = ((\<lambda> s .  (| PMVCIDSR_Type_bits = ((bitvector_64_reg   s) (''PMVCIDSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMVCIDSR'') then(PMVCIDSR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMVCIDSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMVCIDSR_Type v)) |) )\<close>


definition PMUSERENR_ref  :: \<open>((regstate),(register_value),(PMUSERENR_Type))register_ref \<close>  where 
     \<open> PMUSERENR_ref = ( (|
  name = (''_PMUSERENR''),
  read_from = ((\<lambda> s .  (| PMUSERENR_Type_bits = ((bitvector_32_reg   s) (''_PMUSERENR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMUSERENR'') then(PMUSERENR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMUSERENR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMUSERENR_Type v)) |) )\<close>


definition PMUSERENR_EL0_ref  :: \<open>((regstate),(register_value),(PMUSERENR_EL0_Type))register_ref \<close>  where 
     \<open> PMUSERENR_EL0_ref = ( (|
  name = (''PMUSERENR_EL0''),
  read_from = ((\<lambda> s .  (| PMUSERENR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMUSERENR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMUSERENR_EL0'') then(PMUSERENR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMUSERENR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMUSERENR_EL0_Type v)) |) )\<close>


definition PMSWINC_ref  :: \<open>((regstate),(register_value),(PMSWINC_Type))register_ref \<close>  where 
     \<open> PMSWINC_ref = ( (|
  name = (''_PMSWINC''),
  read_from = ((\<lambda> s .  (| PMSWINC_Type_bits = ((bitvector_32_reg   s) (''_PMSWINC'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMSWINC'') then(PMSWINC_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSWINC_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSWINC_Type v)) |) )\<close>


definition PMSWINC_EL0_ref  :: \<open>((regstate),(register_value),(PMSWINC_EL0_Type))register_ref \<close>  where 
     \<open> PMSWINC_EL0_ref = ( (|
  name = (''PMSWINC_EL0''),
  read_from = ((\<lambda> s .  (| PMSWINC_EL0_Type_bits = ((bitvector_64_reg   s) (''PMSWINC_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSWINC_EL0'') then(PMSWINC_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSWINC_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSWINC_EL0_Type v)) |) )\<close>


definition PMSELR_ref  :: \<open>((regstate),(register_value),(PMSELR_Type))register_ref \<close>  where 
     \<open> PMSELR_ref = ( (|
  name = (''_PMSELR''),
  read_from = ((\<lambda> s .  (| PMSELR_Type_bits = ((bitvector_32_reg   s) (''_PMSELR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMSELR'') then(PMSELR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSELR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSELR_Type v)) |) )\<close>


definition PMSELR_EL0_ref  :: \<open>((regstate),(register_value),(PMSELR_EL0_Type))register_ref \<close>  where 
     \<open> PMSELR_EL0_ref = ( (|
  name = (''PMSELR_EL0''),
  read_from = ((\<lambda> s .  (| PMSELR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMSELR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSELR_EL0'') then(PMSELR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSELR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSELR_EL0_Type v)) |) )\<close>


definition PMPIDR4_ref  :: \<open>((regstate),(register_value),(PMPIDR4_Type))register_ref \<close>  where 
     \<open> PMPIDR4_ref = ( (|
  name = (''PMPIDR4''),
  read_from = ((\<lambda> s .  (| PMPIDR4_Type_bits = ((bitvector_32_reg   s) (''PMPIDR4'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMPIDR4'') then(PMPIDR4_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMPIDR4_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMPIDR4_Type v)) |) )\<close>


definition PMPIDR3_ref  :: \<open>((regstate),(register_value),(PMPIDR3_Type))register_ref \<close>  where 
     \<open> PMPIDR3_ref = ( (|
  name = (''PMPIDR3''),
  read_from = ((\<lambda> s .  (| PMPIDR3_Type_bits = ((bitvector_32_reg   s) (''PMPIDR3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMPIDR3'') then(PMPIDR3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMPIDR3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMPIDR3_Type v)) |) )\<close>


definition PMPIDR2_ref  :: \<open>((regstate),(register_value),(PMPIDR2_Type))register_ref \<close>  where 
     \<open> PMPIDR2_ref = ( (|
  name = (''PMPIDR2''),
  read_from = ((\<lambda> s .  (| PMPIDR2_Type_bits = ((bitvector_32_reg   s) (''PMPIDR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMPIDR2'') then(PMPIDR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMPIDR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMPIDR2_Type v)) |) )\<close>


definition PMPIDR1_ref  :: \<open>((regstate),(register_value),(PMPIDR1_Type))register_ref \<close>  where 
     \<open> PMPIDR1_ref = ( (|
  name = (''PMPIDR1''),
  read_from = ((\<lambda> s .  (| PMPIDR1_Type_bits = ((bitvector_32_reg   s) (''PMPIDR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMPIDR1'') then(PMPIDR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMPIDR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMPIDR1_Type v)) |) )\<close>


definition PMPIDR0_ref  :: \<open>((regstate),(register_value),(PMPIDR0_Type))register_ref \<close>  where 
     \<open> PMPIDR0_ref = ( (|
  name = (''PMPIDR0''),
  read_from = ((\<lambda> s .  (| PMPIDR0_Type_bits = ((bitvector_32_reg   s) (''PMPIDR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMPIDR0'') then(PMPIDR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMPIDR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMPIDR0_Type v)) |) )\<close>


definition PMPCSR_ref  :: \<open>((regstate),(register_value),(PMPCSR_Type))register_ref \<close>  where 
     \<open> PMPCSR_ref = ( (|
  name = (''PMPCSR''),
  read_from = ((\<lambda> s .  (| PMPCSR_Type_bits = ((bitvector_64_reg   s) (''PMPCSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMPCSR'') then(PMPCSR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMPCSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMPCSR_Type v)) |) )\<close>


definition PMPCSCTL_ref  :: \<open>((regstate),(register_value),(PMPCSCTL_Type))register_ref \<close>  where 
     \<open> PMPCSCTL_ref = ( (|
  name = (''PMPCSCTL''),
  read_from = ((\<lambda> s .  (| PMPCSCTL_Type_bits = ((bitvector_64_reg   s) (''PMPCSCTL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMPCSCTL'') then(PMPCSCTL_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMPCSCTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMPCSCTL_Type v)) |) )\<close>


definition PMOVS_ref  :: \<open>((regstate),(register_value),(PMOVS_Type))register_ref \<close>  where 
     \<open> PMOVS_ref = ( (|
  name = (''_PMOVS''),
  read_from = ((\<lambda> s .  (| PMOVS_Type_bits = ((bitvector_64_reg   s) (''_PMOVS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_PMOVS'') then(PMOVS_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMOVS_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMOVS_Type v)) |) )\<close>


definition PMMIR_ref  :: \<open>((regstate),(register_value),(PMMIR_Type))register_ref \<close>  where 
     \<open> PMMIR_ref = ( (|
  name = (''PMMIR''),
  read_from = ((\<lambda> s .  (| PMMIR_Type_bits = ((bitvector_32_reg   s) (''PMMIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMMIR'') then(PMMIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMMIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMMIR_Type v)) |) )\<close>


definition PMLSR_ref  :: \<open>((regstate),(register_value),(PMLSR_Type))register_ref \<close>  where 
     \<open> PMLSR_ref = ( (|
  name = (''PMLSR''),
  read_from = ((\<lambda> s .  (| PMLSR_Type_bits = ((bitvector_32_reg   s) (''PMLSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMLSR'') then(PMLSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMLSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMLSR_Type v)) |) )\<close>


definition PMLAR_ref  :: \<open>((regstate),(register_value),(PMLAR_Type))register_ref \<close>  where 
     \<open> PMLAR_ref = ( (|
  name = (''PMLAR''),
  read_from = ((\<lambda> s .  (| PMLAR_Type_bits = ((bitvector_32_reg   s) (''PMLAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMLAR'') then(PMLAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMLAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMLAR_Type v)) |) )\<close>


definition PMITCTRL_ref  :: \<open>((regstate),(register_value),(PMITCTRL_Type))register_ref \<close>  where 
     \<open> PMITCTRL_ref = ( (|
  name = (''PMITCTRL''),
  read_from = ((\<lambda> s .  (| PMITCTRL_Type_bits = ((bitvector_32_reg   s) (''PMITCTRL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMITCTRL'') then(PMITCTRL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMITCTRL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMITCTRL_Type v)) |) )\<close>


definition PMINTEN_ref  :: \<open>((regstate),(register_value),(PMINTEN_Type))register_ref \<close>  where 
     \<open> PMINTEN_ref = ( (|
  name = (''_PMINTEN''),
  read_from = ((\<lambda> s .  (| PMINTEN_Type_bits = ((bitvector_64_reg   s) (''_PMINTEN'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_PMINTEN'') then(PMINTEN_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMINTEN_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMINTEN_Type v)) |) )\<close>


definition PMINTENSET_EL1_ref  :: \<open>((regstate),(register_value),(PMINTENSET_EL1_Type))register_ref \<close>  where 
     \<open> PMINTENSET_EL1_ref = ( (|
  name = (''PMINTENSET_EL1''),
  read_from = ((\<lambda> s .  (| PMINTENSET_EL1_Type_bits = ((bitvector_64_reg   s) (''PMINTENSET_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMINTENSET_EL1'') then(PMINTENSET_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMINTENSET_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMINTENSET_EL1_Type v)) |) )\<close>


definition PMIIDR_ref  :: \<open>((regstate),(register_value),(PMIIDR_Type))register_ref \<close>  where 
     \<open> PMIIDR_ref = ( (|
  name = (''PMIIDR''),
  read_from = ((\<lambda> s .  (| PMIIDR_Type_bits = ((bitvector_64_reg   s) (''PMIIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMIIDR'') then(PMIIDR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMIIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMIIDR_Type v)) |) )\<close>


definition PMDEVTYPE_ref  :: \<open>((regstate),(register_value),(PMDEVTYPE_Type))register_ref \<close>  where 
     \<open> PMDEVTYPE_ref = ( (|
  name = (''PMDEVTYPE''),
  read_from = ((\<lambda> s .  (| PMDEVTYPE_Type_bits = ((bitvector_32_reg   s) (''PMDEVTYPE'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMDEVTYPE'') then(PMDEVTYPE_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMDEVTYPE_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMDEVTYPE_Type v)) |) )\<close>


definition PMDEVID_ref  :: \<open>((regstate),(register_value),(PMDEVID_Type))register_ref \<close>  where 
     \<open> PMDEVID_ref = ( (|
  name = (''PMDEVID''),
  read_from = ((\<lambda> s .  (| PMDEVID_Type_bits = ((bitvector_32_reg   s) (''PMDEVID'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMDEVID'') then(PMDEVID_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMDEVID_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMDEVID_Type v)) |) )\<close>


definition PMCNTEN_ref  :: \<open>((regstate),(register_value),(PMCNTEN_Type))register_ref \<close>  where 
     \<open> PMCNTEN_ref = ( (|
  name = (''_PMCNTEN''),
  read_from = ((\<lambda> s .  (| PMCNTEN_Type_bits = ((bitvector_64_reg   s) (''_PMCNTEN'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_PMCNTEN'') then(PMCNTEN_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCNTEN_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCNTEN_Type v)) |) )\<close>


definition PMCIDR3_ref  :: \<open>((regstate),(register_value),(PMCIDR3_Type))register_ref \<close>  where 
     \<open> PMCIDR3_ref = ( (|
  name = (''PMCIDR3''),
  read_from = ((\<lambda> s .  (| PMCIDR3_Type_bits = ((bitvector_32_reg   s) (''PMCIDR3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMCIDR3'') then(PMCIDR3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCIDR3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCIDR3_Type v)) |) )\<close>


definition PMCIDR2_ref  :: \<open>((regstate),(register_value),(PMCIDR2_Type))register_ref \<close>  where 
     \<open> PMCIDR2_ref = ( (|
  name = (''PMCIDR2''),
  read_from = ((\<lambda> s .  (| PMCIDR2_Type_bits = ((bitvector_32_reg   s) (''PMCIDR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMCIDR2'') then(PMCIDR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCIDR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCIDR2_Type v)) |) )\<close>


definition PMCIDR1_ref  :: \<open>((regstate),(register_value),(PMCIDR1_Type))register_ref \<close>  where 
     \<open> PMCIDR1_ref = ( (|
  name = (''PMCIDR1''),
  read_from = ((\<lambda> s .  (| PMCIDR1_Type_bits = ((bitvector_32_reg   s) (''PMCIDR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMCIDR1'') then(PMCIDR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCIDR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCIDR1_Type v)) |) )\<close>


definition PMCIDR0_ref  :: \<open>((regstate),(register_value),(PMCIDR0_Type))register_ref \<close>  where 
     \<open> PMCIDR0_ref = ( (|
  name = (''PMCIDR0''),
  read_from = ((\<lambda> s .  (| PMCIDR0_Type_bits = ((bitvector_32_reg   s) (''PMCIDR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMCIDR0'') then(PMCIDR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCIDR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCIDR0_Type v)) |) )\<close>


definition PMCGCR0_ref  :: \<open>((regstate),(register_value),(PMCGCR0_Type))register_ref \<close>  where 
     \<open> PMCGCR0_ref = ( (|
  name = (''PMCGCR0''),
  read_from = ((\<lambda> s .  (| PMCGCR0_Type_bits = ((bitvector_32_reg   s) (''PMCGCR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMCGCR0'') then(PMCGCR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCGCR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCGCR0_Type v)) |) )\<close>


definition PMCFGR_ref  :: \<open>((regstate),(register_value),(PMCFGR_Type))register_ref \<close>  where 
     \<open> PMCFGR_ref = ( (|
  name = (''PMCFGR''),
  read_from = ((\<lambda> s .  (| PMCFGR_Type_bits = ((bitvector_64_reg   s) (''PMCFGR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMCFGR'') then(PMCFGR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCFGR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCFGR_Type v)) |) )\<close>


definition PMAUTHSTATUS_ref  :: \<open>((regstate),(register_value),(PMAUTHSTATUS_Type))register_ref \<close>  where 
     \<open> PMAUTHSTATUS_ref = ( (|
  name = (''PMAUTHSTATUS''),
  read_from = ((\<lambda> s .  (| PMAUTHSTATUS_Type_bits = ((bitvector_32_reg   s) (''PMAUTHSTATUS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''PMAUTHSTATUS'') then(PMAUTHSTATUS_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMAUTHSTATUS_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMAUTHSTATUS_Type v)) |) )\<close>


definition PAR_S_ref  :: \<open>((regstate),(register_value),(PAR_Type))register_ref \<close>  where 
     \<open> PAR_S_ref = ( (|
  name = (''PAR_S''),
  read_from = ((\<lambda> s .  (| PAR_Type_bits = ((bitvector_64_reg   s) (''PAR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PAR_S'') then(PAR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PAR_Type v)) |) )\<close>


definition PAR_NS_ref  :: \<open>((regstate),(register_value),(PAR_Type))register_ref \<close>  where 
     \<open> PAR_NS_ref = ( (|
  name = (''PAR_NS''),
  read_from = ((\<lambda> s .  (| PAR_Type_bits = ((bitvector_64_reg   s) (''PAR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PAR_NS'') then(PAR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PAR_Type v)) |) )\<close>


definition MVFR2_ref  :: \<open>((regstate),(register_value),(MVFR2_Type))register_ref \<close>  where 
     \<open> MVFR2_ref = ( (|
  name = (''_MVFR2''),
  read_from = ((\<lambda> s .  (| MVFR2_Type_bits = ((bitvector_32_reg   s) (''_MVFR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_MVFR2'') then(MVFR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MVFR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MVFR2_Type v)) |) )\<close>


definition MVFR2_EL1_ref  :: \<open>((regstate),(register_value),(MVFR2_EL1_Type))register_ref \<close>  where 
     \<open> MVFR2_EL1_ref = ( (|
  name = (''MVFR2_EL1''),
  read_from = ((\<lambda> s .  (| MVFR2_EL1_Type_bits = ((bitvector_64_reg   s) (''MVFR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MVFR2_EL1'') then(MVFR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MVFR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MVFR2_EL1_Type v)) |) )\<close>


definition MPIDR_ref  :: \<open>((regstate),(register_value),(MPIDR_Type))register_ref \<close>  where 
     \<open> MPIDR_ref = ( (|
  name = (''_MPIDR''),
  read_from = ((\<lambda> s .  (| MPIDR_Type_bits = ((bitvector_32_reg   s) (''_MPIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_MPIDR'') then(MPIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPIDR_Type v)) |) )\<close>


definition MPIDR_EL1_ref  :: \<open>((regstate),(register_value),(MPIDR_EL1_Type))register_ref \<close>  where 
     \<open> MPIDR_EL1_ref = ( (|
  name = (''MPIDR_EL1''),
  read_from = ((\<lambda> s .  (| MPIDR_EL1_Type_bits = ((bitvector_64_reg   s) (''MPIDR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPIDR_EL1'') then(MPIDR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPIDR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPIDR_EL1_Type v)) |) )\<close>


definition JOSCR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> JOSCR_ref = ( (|
  name = (''JOSCR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''JOSCR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''JOSCR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition JMCR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> JMCR_ref = ( (|
  name = (''JMCR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''JMCR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''JMCR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition JIDR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> JIDR_ref = ( (|
  name = (''JIDR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''JIDR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''JIDR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ISR_ref  :: \<open>((regstate),(register_value),(ISR_Type))register_ref \<close>  where 
     \<open> ISR_ref = ( (|
  name = (''_ISR''),
  read_from = ((\<lambda> s .  (| ISR_Type_bits = ((bitvector_32_reg   s) (''_ISR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ISR'') then(ISR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ISR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ISR_Type v)) |) )\<close>


definition ISR_EL1_ref  :: \<open>((regstate),(register_value),(ISR_EL1_Type))register_ref \<close>  where 
     \<open> ISR_EL1_ref = ( (|
  name = (''ISR_EL1''),
  read_from = ((\<lambda> s .  (| ISR_EL1_Type_bits = ((bitvector_64_reg   s) (''ISR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ISR_EL1'') then(ISR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ISR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ISR_EL1_Type v)) |) )\<close>


definition ID_PFR2_ref  :: \<open>((regstate),(register_value),(ID_PFR2_Type))register_ref \<close>  where 
     \<open> ID_PFR2_ref = ( (|
  name = (''_ID_PFR2''),
  read_from = ((\<lambda> s .  (| ID_PFR2_Type_bits = ((bitvector_32_reg   s) (''_ID_PFR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_PFR2'') then(ID_PFR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_PFR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_PFR2_Type v)) |) )\<close>


definition ID_PFR2_EL1_ref  :: \<open>((regstate),(register_value),(ID_PFR2_EL1_Type))register_ref \<close>  where 
     \<open> ID_PFR2_EL1_ref = ( (|
  name = (''ID_PFR2_EL1''),
  read_from = ((\<lambda> s .  (| ID_PFR2_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_PFR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_PFR2_EL1'') then(ID_PFR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_PFR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_PFR2_EL1_Type v)) |) )\<close>


definition ID_MMFR5_ref  :: \<open>((regstate),(register_value),(ID_MMFR5_Type))register_ref \<close>  where 
     \<open> ID_MMFR5_ref = ( (|
  name = (''_ID_MMFR5''),
  read_from = ((\<lambda> s .  (| ID_MMFR5_Type_bits = ((bitvector_32_reg   s) (''_ID_MMFR5'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_MMFR5'') then(ID_MMFR5_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR5_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR5_Type v)) |) )\<close>


definition ID_MMFR5_EL1_ref  :: \<open>((regstate),(register_value),(ID_MMFR5_EL1_Type))register_ref \<close>  where 
     \<open> ID_MMFR5_EL1_ref = ( (|
  name = (''ID_MMFR5_EL1''),
  read_from = ((\<lambda> s .  (| ID_MMFR5_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_MMFR5_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_MMFR5_EL1'') then(ID_MMFR5_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_MMFR5_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_MMFR5_EL1_Type v)) |) )\<close>


definition ID_ISAR5_ref  :: \<open>((regstate),(register_value),(ID_ISAR5_Type))register_ref \<close>  where 
     \<open> ID_ISAR5_ref = ( (|
  name = (''_ID_ISAR5''),
  read_from = ((\<lambda> s .  (| ID_ISAR5_Type_bits = ((bitvector_32_reg   s) (''_ID_ISAR5'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_ISAR5'') then(ID_ISAR5_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR5_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR5_Type v)) |) )\<close>


definition ID_ISAR5_EL1_ref  :: \<open>((regstate),(register_value),(ID_ISAR5_EL1_Type))register_ref \<close>  where 
     \<open> ID_ISAR5_EL1_ref = ( (|
  name = (''ID_ISAR5_EL1''),
  read_from = ((\<lambda> s .  (| ID_ISAR5_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_ISAR5_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_ISAR5_EL1'') then(ID_ISAR5_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR5_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR5_EL1_Type v)) |) )\<close>


definition ID_ISAR0_ref  :: \<open>((regstate),(register_value),(ID_ISAR0_Type))register_ref \<close>  where 
     \<open> ID_ISAR0_ref = ( (|
  name = (''_ID_ISAR0''),
  read_from = ((\<lambda> s .  (| ID_ISAR0_Type_bits = ((bitvector_32_reg   s) (''_ID_ISAR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_ISAR0'') then(ID_ISAR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR0_Type v)) |) )\<close>


definition ID_ISAR0_EL1_ref  :: \<open>((regstate),(register_value),(ID_ISAR0_EL1_Type))register_ref \<close>  where 
     \<open> ID_ISAR0_EL1_ref = ( (|
  name = (''ID_ISAR0_EL1''),
  read_from = ((\<lambda> s .  (| ID_ISAR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_ISAR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_ISAR0_EL1'') then(ID_ISAR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_ISAR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_ISAR0_EL1_Type v)) |) )\<close>


definition ID_DFR1_ref  :: \<open>((regstate),(register_value),(ID_DFR1_Type))register_ref \<close>  where 
     \<open> ID_DFR1_ref = ( (|
  name = (''_ID_DFR1''),
  read_from = ((\<lambda> s .  (| ID_DFR1_Type_bits = ((bitvector_32_reg   s) (''_ID_DFR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_DFR1'') then(ID_DFR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_DFR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_DFR1_Type v)) |) )\<close>


definition ID_DFR1_EL1_ref  :: \<open>((regstate),(register_value),(ID_DFR1_EL1_Type))register_ref \<close>  where 
     \<open> ID_DFR1_EL1_ref = ( (|
  name = (''ID_DFR1_EL1''),
  read_from = ((\<lambda> s .  (| ID_DFR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ID_DFR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_DFR1_EL1'') then(ID_DFR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ID_DFR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ID_DFR1_EL1_Type v)) |) )\<close>


definition ID_AFR0_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ID_AFR0_ref = ( (|
  name = (''_ID_AFR0''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ID_AFR0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ID_AFR0'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ID_AFR0_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ID_AFR0_EL1_ref = ( (|
  name = (''ID_AFR0_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ID_AFR0_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ID_AFR0_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ICV_RPR_ref  :: \<open>((regstate),(register_value),(ICV_RPR_Type))register_ref \<close>  where 
     \<open> ICV_RPR_ref = ( (|
  name = (''_ICV_RPR''),
  read_from = ((\<lambda> s .  (| ICV_RPR_Type_bits = ((bitvector_32_reg   s) (''_ICV_RPR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_RPR'') then(ICV_RPR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_RPR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_RPR_Type v)) |) )\<close>


definition ICV_RPR_EL1_ref  :: \<open>((regstate),(register_value),(ICV_RPR_EL1_Type))register_ref \<close>  where 
     \<open> ICV_RPR_EL1_ref = ( (|
  name = (''ICV_RPR_EL1''),
  read_from = ((\<lambda> s .  (| ICV_RPR_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_RPR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_RPR_EL1'') then(ICV_RPR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_RPR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_RPR_EL1_Type v)) |) )\<close>


definition ICV_PMR_ref  :: \<open>((regstate),(register_value),(ICV_PMR_Type))register_ref \<close>  where 
     \<open> ICV_PMR_ref = ( (|
  name = (''_ICV_PMR''),
  read_from = ((\<lambda> s .  (| ICV_PMR_Type_bits = ((bitvector_32_reg   s) (''_ICV_PMR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_PMR'') then(ICV_PMR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_PMR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_PMR_Type v)) |) )\<close>


definition ICV_PMR_EL1_ref  :: \<open>((regstate),(register_value),(ICV_PMR_EL1_Type))register_ref \<close>  where 
     \<open> ICV_PMR_EL1_ref = ( (|
  name = (''ICV_PMR_EL1''),
  read_from = ((\<lambda> s .  (| ICV_PMR_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_PMR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_PMR_EL1'') then(ICV_PMR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_PMR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_PMR_EL1_Type v)) |) )\<close>


definition ICV_IGRPEN1_ref  :: \<open>((regstate),(register_value),(ICV_IGRPEN1_Type))register_ref \<close>  where 
     \<open> ICV_IGRPEN1_ref = ( (|
  name = (''_ICV_IGRPEN1''),
  read_from = ((\<lambda> s .  (| ICV_IGRPEN1_Type_bits = ((bitvector_32_reg   s) (''_ICV_IGRPEN1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_IGRPEN1'') then(ICV_IGRPEN1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_IGRPEN1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_IGRPEN1_Type v)) |) )\<close>


definition ICV_IGRPEN1_EL1_ref  :: \<open>((regstate),(register_value),(ICV_IGRPEN1_EL1_Type))register_ref \<close>  where 
     \<open> ICV_IGRPEN1_EL1_ref = ( (|
  name = (''ICV_IGRPEN1_EL1''),
  read_from = ((\<lambda> s .  (| ICV_IGRPEN1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_IGRPEN1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_IGRPEN1_EL1'') then(ICV_IGRPEN1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_IGRPEN1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_IGRPEN1_EL1_Type v)) |) )\<close>


definition ICV_IGRPEN0_ref  :: \<open>((regstate),(register_value),(ICV_IGRPEN0_Type))register_ref \<close>  where 
     \<open> ICV_IGRPEN0_ref = ( (|
  name = (''_ICV_IGRPEN0''),
  read_from = ((\<lambda> s .  (| ICV_IGRPEN0_Type_bits = ((bitvector_32_reg   s) (''_ICV_IGRPEN0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_IGRPEN0'') then(ICV_IGRPEN0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_IGRPEN0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_IGRPEN0_Type v)) |) )\<close>


definition ICV_IGRPEN0_EL1_ref  :: \<open>((regstate),(register_value),(ICV_IGRPEN0_EL1_Type))register_ref \<close>  where 
     \<open> ICV_IGRPEN0_EL1_ref = ( (|
  name = (''ICV_IGRPEN0_EL1''),
  read_from = ((\<lambda> s .  (| ICV_IGRPEN0_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_IGRPEN0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_IGRPEN0_EL1'') then(ICV_IGRPEN0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_IGRPEN0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_IGRPEN0_EL1_Type v)) |) )\<close>


definition ICV_IAR1_ref  :: \<open>((regstate),(register_value),(ICV_IAR1_Type))register_ref \<close>  where 
     \<open> ICV_IAR1_ref = ( (|
  name = (''_ICV_IAR1''),
  read_from = ((\<lambda> s .  (| ICV_IAR1_Type_bits = ((bitvector_32_reg   s) (''_ICV_IAR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_IAR1'') then(ICV_IAR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_IAR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_IAR1_Type v)) |) )\<close>


definition ICV_IAR1_EL1_ref  :: \<open>((regstate),(register_value),(ICV_IAR1_EL1_Type))register_ref \<close>  where 
     \<open> ICV_IAR1_EL1_ref = ( (|
  name = (''ICV_IAR1_EL1''),
  read_from = ((\<lambda> s .  (| ICV_IAR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_IAR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_IAR1_EL1'') then(ICV_IAR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_IAR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_IAR1_EL1_Type v)) |) )\<close>


definition ICV_IAR0_ref  :: \<open>((regstate),(register_value),(ICV_IAR0_Type))register_ref \<close>  where 
     \<open> ICV_IAR0_ref = ( (|
  name = (''_ICV_IAR0''),
  read_from = ((\<lambda> s .  (| ICV_IAR0_Type_bits = ((bitvector_32_reg   s) (''_ICV_IAR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_IAR0'') then(ICV_IAR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_IAR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_IAR0_Type v)) |) )\<close>


definition ICV_IAR0_EL1_ref  :: \<open>((regstate),(register_value),(ICV_IAR0_EL1_Type))register_ref \<close>  where 
     \<open> ICV_IAR0_EL1_ref = ( (|
  name = (''ICV_IAR0_EL1''),
  read_from = ((\<lambda> s .  (| ICV_IAR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_IAR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_IAR0_EL1'') then(ICV_IAR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_IAR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_IAR0_EL1_Type v)) |) )\<close>


definition ICV_HPPIR1_ref  :: \<open>((regstate),(register_value),(ICV_HPPIR1_Type))register_ref \<close>  where 
     \<open> ICV_HPPIR1_ref = ( (|
  name = (''_ICV_HPPIR1''),
  read_from = ((\<lambda> s .  (| ICV_HPPIR1_Type_bits = ((bitvector_32_reg   s) (''_ICV_HPPIR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_HPPIR1'') then(ICV_HPPIR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_HPPIR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_HPPIR1_Type v)) |) )\<close>


definition ICV_HPPIR1_EL1_ref  :: \<open>((regstate),(register_value),(ICV_HPPIR1_EL1_Type))register_ref \<close>  where 
     \<open> ICV_HPPIR1_EL1_ref = ( (|
  name = (''ICV_HPPIR1_EL1''),
  read_from = ((\<lambda> s .  (| ICV_HPPIR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_HPPIR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_HPPIR1_EL1'') then(ICV_HPPIR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_HPPIR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_HPPIR1_EL1_Type v)) |) )\<close>


definition ICV_HPPIR0_ref  :: \<open>((regstate),(register_value),(ICV_HPPIR0_Type))register_ref \<close>  where 
     \<open> ICV_HPPIR0_ref = ( (|
  name = (''_ICV_HPPIR0''),
  read_from = ((\<lambda> s .  (| ICV_HPPIR0_Type_bits = ((bitvector_32_reg   s) (''_ICV_HPPIR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_HPPIR0'') then(ICV_HPPIR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_HPPIR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_HPPIR0_Type v)) |) )\<close>


definition ICV_HPPIR0_EL1_ref  :: \<open>((regstate),(register_value),(ICV_HPPIR0_EL1_Type))register_ref \<close>  where 
     \<open> ICV_HPPIR0_EL1_ref = ( (|
  name = (''ICV_HPPIR0_EL1''),
  read_from = ((\<lambda> s .  (| ICV_HPPIR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_HPPIR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_HPPIR0_EL1'') then(ICV_HPPIR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_HPPIR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_HPPIR0_EL1_Type v)) |) )\<close>


definition ICV_EOIR1_ref  :: \<open>((regstate),(register_value),(ICV_EOIR1_Type))register_ref \<close>  where 
     \<open> ICV_EOIR1_ref = ( (|
  name = (''_ICV_EOIR1''),
  read_from = ((\<lambda> s .  (| ICV_EOIR1_Type_bits = ((bitvector_32_reg   s) (''_ICV_EOIR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_EOIR1'') then(ICV_EOIR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_EOIR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_EOIR1_Type v)) |) )\<close>


definition ICV_EOIR1_EL1_ref  :: \<open>((regstate),(register_value),(ICV_EOIR1_EL1_Type))register_ref \<close>  where 
     \<open> ICV_EOIR1_EL1_ref = ( (|
  name = (''ICV_EOIR1_EL1''),
  read_from = ((\<lambda> s .  (| ICV_EOIR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_EOIR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_EOIR1_EL1'') then(ICV_EOIR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_EOIR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_EOIR1_EL1_Type v)) |) )\<close>


definition ICV_EOIR0_ref  :: \<open>((regstate),(register_value),(ICV_EOIR0_Type))register_ref \<close>  where 
     \<open> ICV_EOIR0_ref = ( (|
  name = (''_ICV_EOIR0''),
  read_from = ((\<lambda> s .  (| ICV_EOIR0_Type_bits = ((bitvector_32_reg   s) (''_ICV_EOIR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_EOIR0'') then(ICV_EOIR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_EOIR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_EOIR0_Type v)) |) )\<close>


definition ICV_EOIR0_EL1_ref  :: \<open>((regstate),(register_value),(ICV_EOIR0_EL1_Type))register_ref \<close>  where 
     \<open> ICV_EOIR0_EL1_ref = ( (|
  name = (''ICV_EOIR0_EL1''),
  read_from = ((\<lambda> s .  (| ICV_EOIR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_EOIR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_EOIR0_EL1'') then(ICV_EOIR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_EOIR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_EOIR0_EL1_Type v)) |) )\<close>


definition ICV_DIR_ref  :: \<open>((regstate),(register_value),(ICV_DIR_Type))register_ref \<close>  where 
     \<open> ICV_DIR_ref = ( (|
  name = (''_ICV_DIR''),
  read_from = ((\<lambda> s .  (| ICV_DIR_Type_bits = ((bitvector_32_reg   s) (''_ICV_DIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_DIR'') then(ICV_DIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_DIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_DIR_Type v)) |) )\<close>


definition ICV_DIR_EL1_ref  :: \<open>((regstate),(register_value),(ICV_DIR_EL1_Type))register_ref \<close>  where 
     \<open> ICV_DIR_EL1_ref = ( (|
  name = (''ICV_DIR_EL1''),
  read_from = ((\<lambda> s .  (| ICV_DIR_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_DIR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_DIR_EL1'') then(ICV_DIR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_DIR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_DIR_EL1_Type v)) |) )\<close>


definition ICV_CTLR_ref  :: \<open>((regstate),(register_value),(ICV_CTLR_Type))register_ref \<close>  where 
     \<open> ICV_CTLR_ref = ( (|
  name = (''_ICV_CTLR''),
  read_from = ((\<lambda> s .  (| ICV_CTLR_Type_bits = ((bitvector_32_reg   s) (''_ICV_CTLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_CTLR'') then(ICV_CTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_CTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_CTLR_Type v)) |) )\<close>


definition ICV_CTLR_EL1_ref  :: \<open>((regstate),(register_value),(ICV_CTLR_EL1_Type))register_ref \<close>  where 
     \<open> ICV_CTLR_EL1_ref = ( (|
  name = (''ICV_CTLR_EL1''),
  read_from = ((\<lambda> s .  (| ICV_CTLR_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_CTLR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_CTLR_EL1'') then(ICV_CTLR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_CTLR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_CTLR_EL1_Type v)) |) )\<close>


definition ICV_BPR1_ref  :: \<open>((regstate),(register_value),(ICV_BPR1_Type))register_ref \<close>  where 
     \<open> ICV_BPR1_ref = ( (|
  name = (''_ICV_BPR1''),
  read_from = ((\<lambda> s .  (| ICV_BPR1_Type_bits = ((bitvector_32_reg   s) (''_ICV_BPR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_BPR1'') then(ICV_BPR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_BPR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_BPR1_Type v)) |) )\<close>


definition ICV_BPR1_EL1_ref  :: \<open>((regstate),(register_value),(ICV_BPR1_EL1_Type))register_ref \<close>  where 
     \<open> ICV_BPR1_EL1_ref = ( (|
  name = (''ICV_BPR1_EL1''),
  read_from = ((\<lambda> s .  (| ICV_BPR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_BPR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_BPR1_EL1'') then(ICV_BPR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_BPR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_BPR1_EL1_Type v)) |) )\<close>


definition ICV_BPR0_ref  :: \<open>((regstate),(register_value),(ICV_BPR0_Type))register_ref \<close>  where 
     \<open> ICV_BPR0_ref = ( (|
  name = (''_ICV_BPR0''),
  read_from = ((\<lambda> s .  (| ICV_BPR0_Type_bits = ((bitvector_32_reg   s) (''_ICV_BPR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICV_BPR0'') then(ICV_BPR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_BPR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_BPR0_Type v)) |) )\<close>


definition ICV_BPR0_EL1_ref  :: \<open>((regstate),(register_value),(ICV_BPR0_EL1_Type))register_ref \<close>  where 
     \<open> ICV_BPR0_EL1_ref = ( (|
  name = (''ICV_BPR0_EL1''),
  read_from = ((\<lambda> s .  (| ICV_BPR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ICV_BPR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICV_BPR0_EL1'') then(ICV_BPR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICV_BPR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICV_BPR0_EL1_Type v)) |) )\<close>


definition ICH_VTR_ref  :: \<open>((regstate),(register_value),(ICH_VTR_Type))register_ref \<close>  where 
     \<open> ICH_VTR_ref = ( (|
  name = (''_ICH_VTR''),
  read_from = ((\<lambda> s .  (| ICH_VTR_Type_bits = ((bitvector_32_reg   s) (''_ICH_VTR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICH_VTR'') then(ICH_VTR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_VTR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_VTR_Type v)) |) )\<close>


definition ICH_VTR_EL2_ref  :: \<open>((regstate),(register_value),(ICH_VTR_EL2_Type))register_ref \<close>  where 
     \<open> ICH_VTR_EL2_ref = ( (|
  name = (''ICH_VTR_EL2''),
  read_from = ((\<lambda> s .  (| ICH_VTR_EL2_Type_bits = ((bitvector_64_reg   s) (''ICH_VTR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICH_VTR_EL2'') then(ICH_VTR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_VTR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_VTR_EL2_Type v)) |) )\<close>


definition ICH_VMCR_ref  :: \<open>((regstate),(register_value),(ICH_VMCR_Type))register_ref \<close>  where 
     \<open> ICH_VMCR_ref = ( (|
  name = (''_ICH_VMCR''),
  read_from = ((\<lambda> s .  (| ICH_VMCR_Type_bits = ((bitvector_32_reg   s) (''_ICH_VMCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICH_VMCR'') then(ICH_VMCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_VMCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_VMCR_Type v)) |) )\<close>


definition ICH_VMCR_EL2_ref  :: \<open>((regstate),(register_value),(ICH_VMCR_EL2_Type))register_ref \<close>  where 
     \<open> ICH_VMCR_EL2_ref = ( (|
  name = (''ICH_VMCR_EL2''),
  read_from = ((\<lambda> s .  (| ICH_VMCR_EL2_Type_bits = ((bitvector_64_reg   s) (''ICH_VMCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICH_VMCR_EL2'') then(ICH_VMCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_VMCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_VMCR_EL2_Type v)) |) )\<close>


definition ICH_MISR_ref  :: \<open>((regstate),(register_value),(ICH_MISR_Type))register_ref \<close>  where 
     \<open> ICH_MISR_ref = ( (|
  name = (''_ICH_MISR''),
  read_from = ((\<lambda> s .  (| ICH_MISR_Type_bits = ((bitvector_32_reg   s) (''_ICH_MISR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICH_MISR'') then(ICH_MISR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_MISR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_MISR_Type v)) |) )\<close>


definition ICH_MISR_EL2_ref  :: \<open>((regstate),(register_value),(ICH_MISR_EL2_Type))register_ref \<close>  where 
     \<open> ICH_MISR_EL2_ref = ( (|
  name = (''ICH_MISR_EL2''),
  read_from = ((\<lambda> s .  (| ICH_MISR_EL2_Type_bits = ((bitvector_64_reg   s) (''ICH_MISR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICH_MISR_EL2'') then(ICH_MISR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_MISR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_MISR_EL2_Type v)) |) )\<close>


definition ICH_HCR_ref  :: \<open>((regstate),(register_value),(ICH_HCR_Type))register_ref \<close>  where 
     \<open> ICH_HCR_ref = ( (|
  name = (''_ICH_HCR''),
  read_from = ((\<lambda> s .  (| ICH_HCR_Type_bits = ((bitvector_32_reg   s) (''_ICH_HCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICH_HCR'') then(ICH_HCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_HCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_HCR_Type v)) |) )\<close>


definition ICH_HCR_EL2_ref  :: \<open>((regstate),(register_value),(ICH_HCR_EL2_Type))register_ref \<close>  where 
     \<open> ICH_HCR_EL2_ref = ( (|
  name = (''ICH_HCR_EL2''),
  read_from = ((\<lambda> s .  (| ICH_HCR_EL2_Type_bits = ((bitvector_64_reg   s) (''ICH_HCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICH_HCR_EL2'') then(ICH_HCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_HCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_HCR_EL2_Type v)) |) )\<close>


definition ICH_ELRSR_ref  :: \<open>((regstate),(register_value),(ICH_ELRSR_Type))register_ref \<close>  where 
     \<open> ICH_ELRSR_ref = ( (|
  name = (''_ICH_ELRSR''),
  read_from = ((\<lambda> s .  (| ICH_ELRSR_Type_bits = ((bitvector_32_reg   s) (''_ICH_ELRSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICH_ELRSR'') then(ICH_ELRSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_ELRSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_ELRSR_Type v)) |) )\<close>


definition ICH_ELRSR_EL2_ref  :: \<open>((regstate),(register_value),(ICH_ELRSR_EL2_Type))register_ref \<close>  where 
     \<open> ICH_ELRSR_EL2_ref = ( (|
  name = (''ICH_ELRSR_EL2''),
  read_from = ((\<lambda> s .  (| ICH_ELRSR_EL2_Type_bits = ((bitvector_64_reg   s) (''ICH_ELRSR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICH_ELRSR_EL2'') then(ICH_ELRSR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_ELRSR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_ELRSR_EL2_Type v)) |) )\<close>


definition ICH_EISR_ref  :: \<open>((regstate),(register_value),(ICH_EISR_Type))register_ref \<close>  where 
     \<open> ICH_EISR_ref = ( (|
  name = (''_ICH_EISR''),
  read_from = ((\<lambda> s .  (| ICH_EISR_Type_bits = ((bitvector_32_reg   s) (''_ICH_EISR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICH_EISR'') then(ICH_EISR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_EISR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_EISR_Type v)) |) )\<close>


definition ICH_EISR_EL2_ref  :: \<open>((regstate),(register_value),(ICH_EISR_EL2_Type))register_ref \<close>  where 
     \<open> ICH_EISR_EL2_ref = ( (|
  name = (''ICH_EISR_EL2''),
  read_from = ((\<lambda> s .  (| ICH_EISR_EL2_Type_bits = ((bitvector_64_reg   s) (''ICH_EISR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICH_EISR_EL2'') then(ICH_EISR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICH_EISR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICH_EISR_EL2_Type v)) |) )\<close>


definition ICC_SRE_S_ref  :: \<open>((regstate),(register_value),(ICC_SRE_Type))register_ref \<close>  where 
     \<open> ICC_SRE_S_ref = ( (|
  name = (''_ICC_SRE_S''),
  read_from = ((\<lambda> s .  (| ICC_SRE_Type_bits = ((bitvector_32_reg   s) (''_ICC_SRE_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_SRE_S'') then(ICC_SRE_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_SRE_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_SRE_Type v)) |) )\<close>


definition ICC_SRE_EL1_S_ref  :: \<open>((regstate),(register_value),(ICC_SRE_EL1_Type))register_ref \<close>  where 
     \<open> ICC_SRE_EL1_S_ref = ( (|
  name = (''ICC_SRE_EL1_S''),
  read_from = ((\<lambda> s .  (| ICC_SRE_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_SRE_EL1_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_SRE_EL1_S'') then(ICC_SRE_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_SRE_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_SRE_EL1_Type v)) |) )\<close>


definition ICC_SRE_NS_ref  :: \<open>((regstate),(register_value),(ICC_SRE_Type))register_ref \<close>  where 
     \<open> ICC_SRE_NS_ref = ( (|
  name = (''_ICC_SRE_NS''),
  read_from = ((\<lambda> s .  (| ICC_SRE_Type_bits = ((bitvector_32_reg   s) (''_ICC_SRE_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_SRE_NS'') then(ICC_SRE_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_SRE_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_SRE_Type v)) |) )\<close>


definition ICC_SRE_EL1_NS_ref  :: \<open>((regstate),(register_value),(ICC_SRE_EL1_Type))register_ref \<close>  where 
     \<open> ICC_SRE_EL1_NS_ref = ( (|
  name = (''ICC_SRE_EL1_NS''),
  read_from = ((\<lambda> s .  (| ICC_SRE_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_SRE_EL1_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_SRE_EL1_NS'') then(ICC_SRE_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_SRE_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_SRE_EL1_Type v)) |) )\<close>


definition ICC_SGI1R_ref  :: \<open>((regstate),(register_value),(ICC_SGI1R_Type))register_ref \<close>  where 
     \<open> ICC_SGI1R_ref = ( (|
  name = (''_ICC_SGI1R''),
  read_from = ((\<lambda> s .  (| ICC_SGI1R_Type_bits = ((bitvector_64_reg   s) (''_ICC_SGI1R'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_SGI1R'') then(ICC_SGI1R_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_SGI1R_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_SGI1R_Type v)) |) )\<close>


definition ICC_SGI1R_EL1_ref  :: \<open>((regstate),(register_value),(ICC_SGI1R_EL1_Type))register_ref \<close>  where 
     \<open> ICC_SGI1R_EL1_ref = ( (|
  name = (''ICC_SGI1R_EL1''),
  read_from = ((\<lambda> s .  (| ICC_SGI1R_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_SGI1R_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_SGI1R_EL1'') then(ICC_SGI1R_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_SGI1R_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_SGI1R_EL1_Type v)) |) )\<close>


definition ICC_SGI0R_ref  :: \<open>((regstate),(register_value),(ICC_SGI0R_Type))register_ref \<close>  where 
     \<open> ICC_SGI0R_ref = ( (|
  name = (''_ICC_SGI0R''),
  read_from = ((\<lambda> s .  (| ICC_SGI0R_Type_bits = ((bitvector_64_reg   s) (''_ICC_SGI0R'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_SGI0R'') then(ICC_SGI0R_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_SGI0R_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_SGI0R_Type v)) |) )\<close>


definition ICC_SGI0R_EL1_ref  :: \<open>((regstate),(register_value),(ICC_SGI0R_EL1_Type))register_ref \<close>  where 
     \<open> ICC_SGI0R_EL1_ref = ( (|
  name = (''ICC_SGI0R_EL1''),
  read_from = ((\<lambda> s .  (| ICC_SGI0R_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_SGI0R_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_SGI0R_EL1'') then(ICC_SGI0R_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_SGI0R_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_SGI0R_EL1_Type v)) |) )\<close>


definition ICC_RPR_ref  :: \<open>((regstate),(register_value),(ICC_RPR_Type))register_ref \<close>  where 
     \<open> ICC_RPR_ref = ( (|
  name = (''_ICC_RPR''),
  read_from = ((\<lambda> s .  (| ICC_RPR_Type_bits = ((bitvector_32_reg   s) (''_ICC_RPR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_RPR'') then(ICC_RPR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_RPR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_RPR_Type v)) |) )\<close>


definition ICC_RPR_EL1_ref  :: \<open>((regstate),(register_value),(ICC_RPR_EL1_Type))register_ref \<close>  where 
     \<open> ICC_RPR_EL1_ref = ( (|
  name = (''ICC_RPR_EL1''),
  read_from = ((\<lambda> s .  (| ICC_RPR_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_RPR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_RPR_EL1'') then(ICC_RPR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_RPR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_RPR_EL1_Type v)) |) )\<close>


definition ICC_PMR_ref  :: \<open>((regstate),(register_value),(ICC_PMR_Type))register_ref \<close>  where 
     \<open> ICC_PMR_ref = ( (|
  name = (''_ICC_PMR''),
  read_from = ((\<lambda> s .  (| ICC_PMR_Type_bits = ((bitvector_32_reg   s) (''_ICC_PMR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_PMR'') then(ICC_PMR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_PMR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_PMR_Type v)) |) )\<close>


definition ICC_MSRE_ref  :: \<open>((regstate),(register_value),(ICC_MSRE_Type))register_ref \<close>  where 
     \<open> ICC_MSRE_ref = ( (|
  name = (''ICC_MSRE''),
  read_from = ((\<lambda> s .  (| ICC_MSRE_Type_bits = ((bitvector_32_reg   s) (''ICC_MSRE'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''ICC_MSRE'') then(ICC_MSRE_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_MSRE_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_MSRE_Type v)) |) )\<close>


definition ICC_MGRPEN1_ref  :: \<open>((regstate),(register_value),(ICC_MGRPEN1_Type))register_ref \<close>  where 
     \<open> ICC_MGRPEN1_ref = ( (|
  name = (''ICC_MGRPEN1''),
  read_from = ((\<lambda> s .  (| ICC_MGRPEN1_Type_bits = ((bitvector_32_reg   s) (''ICC_MGRPEN1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''ICC_MGRPEN1'') then(ICC_MGRPEN1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_MGRPEN1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_MGRPEN1_Type v)) |) )\<close>


definition ICC_MCTLR_ref  :: \<open>((regstate),(register_value),(ICC_MCTLR_Type))register_ref \<close>  where 
     \<open> ICC_MCTLR_ref = ( (|
  name = (''ICC_MCTLR''),
  read_from = ((\<lambda> s .  (| ICC_MCTLR_Type_bits = ((bitvector_32_reg   s) (''ICC_MCTLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''ICC_MCTLR'') then(ICC_MCTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_MCTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_MCTLR_Type v)) |) )\<close>


definition ICC_IGRPEN1_S_ref  :: \<open>((regstate),(register_value),(ICC_IGRPEN1_Type))register_ref \<close>  where 
     \<open> ICC_IGRPEN1_S_ref = ( (|
  name = (''_ICC_IGRPEN1_S''),
  read_from = ((\<lambda> s .  (| ICC_IGRPEN1_Type_bits = ((bitvector_32_reg   s) (''_ICC_IGRPEN1_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_IGRPEN1_S'') then(ICC_IGRPEN1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IGRPEN1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IGRPEN1_Type v)) |) )\<close>


definition ICC_IGRPEN1_EL1_S_ref  :: \<open>((regstate),(register_value),(ICC_IGRPEN1_EL1_Type))register_ref \<close>  where 
     \<open> ICC_IGRPEN1_EL1_S_ref = ( (|
  name = (''ICC_IGRPEN1_EL1_S''),
  read_from = ((\<lambda> s .  (| ICC_IGRPEN1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_IGRPEN1_EL1_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_IGRPEN1_EL1_S'') then(ICC_IGRPEN1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IGRPEN1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IGRPEN1_EL1_Type v)) |) )\<close>


definition ICC_IGRPEN1_NS_ref  :: \<open>((regstate),(register_value),(ICC_IGRPEN1_Type))register_ref \<close>  where 
     \<open> ICC_IGRPEN1_NS_ref = ( (|
  name = (''_ICC_IGRPEN1_NS''),
  read_from = ((\<lambda> s .  (| ICC_IGRPEN1_Type_bits = ((bitvector_32_reg   s) (''_ICC_IGRPEN1_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_IGRPEN1_NS'') then(ICC_IGRPEN1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IGRPEN1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IGRPEN1_Type v)) |) )\<close>


definition ICC_IGRPEN1_EL1_NS_ref  :: \<open>((regstate),(register_value),(ICC_IGRPEN1_EL1_Type))register_ref \<close>  where 
     \<open> ICC_IGRPEN1_EL1_NS_ref = ( (|
  name = (''ICC_IGRPEN1_EL1_NS''),
  read_from = ((\<lambda> s .  (| ICC_IGRPEN1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_IGRPEN1_EL1_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_IGRPEN1_EL1_NS'') then(ICC_IGRPEN1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IGRPEN1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IGRPEN1_EL1_Type v)) |) )\<close>


definition ICC_IGRPEN0_ref  :: \<open>((regstate),(register_value),(ICC_IGRPEN0_Type))register_ref \<close>  where 
     \<open> ICC_IGRPEN0_ref = ( (|
  name = (''_ICC_IGRPEN0''),
  read_from = ((\<lambda> s .  (| ICC_IGRPEN0_Type_bits = ((bitvector_32_reg   s) (''_ICC_IGRPEN0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_IGRPEN0'') then(ICC_IGRPEN0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IGRPEN0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IGRPEN0_Type v)) |) )\<close>


definition ICC_IGRPEN0_EL1_ref  :: \<open>((regstate),(register_value),(ICC_IGRPEN0_EL1_Type))register_ref \<close>  where 
     \<open> ICC_IGRPEN0_EL1_ref = ( (|
  name = (''ICC_IGRPEN0_EL1''),
  read_from = ((\<lambda> s .  (| ICC_IGRPEN0_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_IGRPEN0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_IGRPEN0_EL1'') then(ICC_IGRPEN0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IGRPEN0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IGRPEN0_EL1_Type v)) |) )\<close>


definition ICC_IAR1_ref  :: \<open>((regstate),(register_value),(ICC_IAR1_Type))register_ref \<close>  where 
     \<open> ICC_IAR1_ref = ( (|
  name = (''_ICC_IAR1''),
  read_from = ((\<lambda> s .  (| ICC_IAR1_Type_bits = ((bitvector_32_reg   s) (''_ICC_IAR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_IAR1'') then(ICC_IAR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IAR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IAR1_Type v)) |) )\<close>


definition ICC_IAR1_EL1_ref  :: \<open>((regstate),(register_value),(ICC_IAR1_EL1_Type))register_ref \<close>  where 
     \<open> ICC_IAR1_EL1_ref = ( (|
  name = (''ICC_IAR1_EL1''),
  read_from = ((\<lambda> s .  (| ICC_IAR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_IAR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_IAR1_EL1'') then(ICC_IAR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IAR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IAR1_EL1_Type v)) |) )\<close>


definition ICC_IAR0_ref  :: \<open>((regstate),(register_value),(ICC_IAR0_Type))register_ref \<close>  where 
     \<open> ICC_IAR0_ref = ( (|
  name = (''_ICC_IAR0''),
  read_from = ((\<lambda> s .  (| ICC_IAR0_Type_bits = ((bitvector_32_reg   s) (''_ICC_IAR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_IAR0'') then(ICC_IAR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IAR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IAR0_Type v)) |) )\<close>


definition ICC_IAR0_EL1_ref  :: \<open>((regstate),(register_value),(ICC_IAR0_EL1_Type))register_ref \<close>  where 
     \<open> ICC_IAR0_EL1_ref = ( (|
  name = (''ICC_IAR0_EL1''),
  read_from = ((\<lambda> s .  (| ICC_IAR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_IAR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_IAR0_EL1'') then(ICC_IAR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_IAR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_IAR0_EL1_Type v)) |) )\<close>


definition ICC_HSRE_ref  :: \<open>((regstate),(register_value),(ICC_HSRE_Type))register_ref \<close>  where 
     \<open> ICC_HSRE_ref = ( (|
  name = (''_ICC_HSRE''),
  read_from = ((\<lambda> s .  (| ICC_HSRE_Type_bits = ((bitvector_32_reg   s) (''_ICC_HSRE'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_HSRE'') then(ICC_HSRE_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_HSRE_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_HSRE_Type v)) |) )\<close>


definition ICC_SRE_EL2_ref  :: \<open>((regstate),(register_value),(ICC_SRE_EL2_Type))register_ref \<close>  where 
     \<open> ICC_SRE_EL2_ref = ( (|
  name = (''ICC_SRE_EL2''),
  read_from = ((\<lambda> s .  (| ICC_SRE_EL2_Type_bits = ((bitvector_64_reg   s) (''ICC_SRE_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_SRE_EL2'') then(ICC_SRE_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_SRE_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_SRE_EL2_Type v)) |) )\<close>


definition ICC_HPPIR1_ref  :: \<open>((regstate),(register_value),(ICC_HPPIR1_Type))register_ref \<close>  where 
     \<open> ICC_HPPIR1_ref = ( (|
  name = (''_ICC_HPPIR1''),
  read_from = ((\<lambda> s .  (| ICC_HPPIR1_Type_bits = ((bitvector_32_reg   s) (''_ICC_HPPIR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_HPPIR1'') then(ICC_HPPIR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_HPPIR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_HPPIR1_Type v)) |) )\<close>


definition ICC_HPPIR1_EL1_ref  :: \<open>((regstate),(register_value),(ICC_HPPIR1_EL1_Type))register_ref \<close>  where 
     \<open> ICC_HPPIR1_EL1_ref = ( (|
  name = (''ICC_HPPIR1_EL1''),
  read_from = ((\<lambda> s .  (| ICC_HPPIR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_HPPIR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_HPPIR1_EL1'') then(ICC_HPPIR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_HPPIR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_HPPIR1_EL1_Type v)) |) )\<close>


definition ICC_HPPIR0_ref  :: \<open>((regstate),(register_value),(ICC_HPPIR0_Type))register_ref \<close>  where 
     \<open> ICC_HPPIR0_ref = ( (|
  name = (''_ICC_HPPIR0''),
  read_from = ((\<lambda> s .  (| ICC_HPPIR0_Type_bits = ((bitvector_32_reg   s) (''_ICC_HPPIR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_HPPIR0'') then(ICC_HPPIR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_HPPIR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_HPPIR0_Type v)) |) )\<close>


definition ICC_HPPIR0_EL1_ref  :: \<open>((regstate),(register_value),(ICC_HPPIR0_EL1_Type))register_ref \<close>  where 
     \<open> ICC_HPPIR0_EL1_ref = ( (|
  name = (''ICC_HPPIR0_EL1''),
  read_from = ((\<lambda> s .  (| ICC_HPPIR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_HPPIR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_HPPIR0_EL1'') then(ICC_HPPIR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_HPPIR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_HPPIR0_EL1_Type v)) |) )\<close>


definition ICC_EOIR1_ref  :: \<open>((regstate),(register_value),(ICC_EOIR1_Type))register_ref \<close>  where 
     \<open> ICC_EOIR1_ref = ( (|
  name = (''_ICC_EOIR1''),
  read_from = ((\<lambda> s .  (| ICC_EOIR1_Type_bits = ((bitvector_32_reg   s) (''_ICC_EOIR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_EOIR1'') then(ICC_EOIR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_EOIR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_EOIR1_Type v)) |) )\<close>


definition ICC_EOIR1_EL1_ref  :: \<open>((regstate),(register_value),(ICC_EOIR1_EL1_Type))register_ref \<close>  where 
     \<open> ICC_EOIR1_EL1_ref = ( (|
  name = (''ICC_EOIR1_EL1''),
  read_from = ((\<lambda> s .  (| ICC_EOIR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_EOIR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_EOIR1_EL1'') then(ICC_EOIR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_EOIR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_EOIR1_EL1_Type v)) |) )\<close>


definition ICC_EOIR0_ref  :: \<open>((regstate),(register_value),(ICC_EOIR0_Type))register_ref \<close>  where 
     \<open> ICC_EOIR0_ref = ( (|
  name = (''_ICC_EOIR0''),
  read_from = ((\<lambda> s .  (| ICC_EOIR0_Type_bits = ((bitvector_32_reg   s) (''_ICC_EOIR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_EOIR0'') then(ICC_EOIR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_EOIR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_EOIR0_Type v)) |) )\<close>


definition ICC_EOIR0_EL1_ref  :: \<open>((regstate),(register_value),(ICC_EOIR0_EL1_Type))register_ref \<close>  where 
     \<open> ICC_EOIR0_EL1_ref = ( (|
  name = (''ICC_EOIR0_EL1''),
  read_from = ((\<lambda> s .  (| ICC_EOIR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_EOIR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_EOIR0_EL1'') then(ICC_EOIR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_EOIR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_EOIR0_EL1_Type v)) |) )\<close>


definition ICC_DIR_ref  :: \<open>((regstate),(register_value),(ICC_DIR_Type))register_ref \<close>  where 
     \<open> ICC_DIR_ref = ( (|
  name = (''_ICC_DIR''),
  read_from = ((\<lambda> s .  (| ICC_DIR_Type_bits = ((bitvector_32_reg   s) (''_ICC_DIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_DIR'') then(ICC_DIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_DIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_DIR_Type v)) |) )\<close>


definition ICC_DIR_EL1_ref  :: \<open>((regstate),(register_value),(ICC_DIR_EL1_Type))register_ref \<close>  where 
     \<open> ICC_DIR_EL1_ref = ( (|
  name = (''ICC_DIR_EL1''),
  read_from = ((\<lambda> s .  (| ICC_DIR_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_DIR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_DIR_EL1'') then(ICC_DIR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_DIR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_DIR_EL1_Type v)) |) )\<close>


definition ICC_CTLR_S_ref  :: \<open>((regstate),(register_value),(ICC_CTLR_Type))register_ref \<close>  where 
     \<open> ICC_CTLR_S_ref = ( (|
  name = (''_ICC_CTLR_S''),
  read_from = ((\<lambda> s .  (| ICC_CTLR_Type_bits = ((bitvector_32_reg   s) (''_ICC_CTLR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_CTLR_S'') then(ICC_CTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_CTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_CTLR_Type v)) |) )\<close>


definition ICC_CTLR_EL1_S_ref  :: \<open>((regstate),(register_value),(ICC_CTLR_EL1_Type))register_ref \<close>  where 
     \<open> ICC_CTLR_EL1_S_ref = ( (|
  name = (''ICC_CTLR_EL1_S''),
  read_from = ((\<lambda> s .  (| ICC_CTLR_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_CTLR_EL1_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_CTLR_EL1_S'') then(ICC_CTLR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_CTLR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_CTLR_EL1_Type v)) |) )\<close>


definition ICC_CTLR_NS_ref  :: \<open>((regstate),(register_value),(ICC_CTLR_Type))register_ref \<close>  where 
     \<open> ICC_CTLR_NS_ref = ( (|
  name = (''_ICC_CTLR_NS''),
  read_from = ((\<lambda> s .  (| ICC_CTLR_Type_bits = ((bitvector_32_reg   s) (''_ICC_CTLR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_CTLR_NS'') then(ICC_CTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_CTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_CTLR_Type v)) |) )\<close>


definition ICC_CTLR_EL1_NS_ref  :: \<open>((regstate),(register_value),(ICC_CTLR_EL1_Type))register_ref \<close>  where 
     \<open> ICC_CTLR_EL1_NS_ref = ( (|
  name = (''ICC_CTLR_EL1_NS''),
  read_from = ((\<lambda> s .  (| ICC_CTLR_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_CTLR_EL1_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_CTLR_EL1_NS'') then(ICC_CTLR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_CTLR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_CTLR_EL1_Type v)) |) )\<close>


definition ICC_BPR1_S_ref  :: \<open>((regstate),(register_value),(ICC_BPR1_Type))register_ref \<close>  where 
     \<open> ICC_BPR1_S_ref = ( (|
  name = (''_ICC_BPR1_S''),
  read_from = ((\<lambda> s .  (| ICC_BPR1_Type_bits = ((bitvector_32_reg   s) (''_ICC_BPR1_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_BPR1_S'') then(ICC_BPR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_BPR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_BPR1_Type v)) |) )\<close>


definition ICC_BPR1_EL1_S_ref  :: \<open>((regstate),(register_value),(ICC_BPR1_EL1_Type))register_ref \<close>  where 
     \<open> ICC_BPR1_EL1_S_ref = ( (|
  name = (''ICC_BPR1_EL1_S''),
  read_from = ((\<lambda> s .  (| ICC_BPR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_BPR1_EL1_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_BPR1_EL1_S'') then(ICC_BPR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_BPR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_BPR1_EL1_Type v)) |) )\<close>


definition ICC_BPR1_NS_ref  :: \<open>((regstate),(register_value),(ICC_BPR1_Type))register_ref \<close>  where 
     \<open> ICC_BPR1_NS_ref = ( (|
  name = (''_ICC_BPR1_NS''),
  read_from = ((\<lambda> s .  (| ICC_BPR1_Type_bits = ((bitvector_32_reg   s) (''_ICC_BPR1_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_BPR1_NS'') then(ICC_BPR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_BPR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_BPR1_Type v)) |) )\<close>


definition ICC_BPR1_EL1_NS_ref  :: \<open>((regstate),(register_value),(ICC_BPR1_EL1_Type))register_ref \<close>  where 
     \<open> ICC_BPR1_EL1_NS_ref = ( (|
  name = (''ICC_BPR1_EL1_NS''),
  read_from = ((\<lambda> s .  (| ICC_BPR1_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_BPR1_EL1_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_BPR1_EL1_NS'') then(ICC_BPR1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_BPR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_BPR1_EL1_Type v)) |) )\<close>


definition ICC_BPR0_ref  :: \<open>((regstate),(register_value),(ICC_BPR0_Type))register_ref \<close>  where 
     \<open> ICC_BPR0_ref = ( (|
  name = (''_ICC_BPR0''),
  read_from = ((\<lambda> s .  (| ICC_BPR0_Type_bits = ((bitvector_32_reg   s) (''_ICC_BPR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_BPR0'') then(ICC_BPR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_BPR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_BPR0_Type v)) |) )\<close>


definition ICC_BPR0_EL1_ref  :: \<open>((regstate),(register_value),(ICC_BPR0_EL1_Type))register_ref \<close>  where 
     \<open> ICC_BPR0_EL1_ref = ( (|
  name = (''ICC_BPR0_EL1''),
  read_from = ((\<lambda> s .  (| ICC_BPR0_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_BPR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_BPR0_EL1'') then(ICC_BPR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_BPR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_BPR0_EL1_Type v)) |) )\<close>


definition ICC_ASGI1R_ref  :: \<open>((regstate),(register_value),(ICC_ASGI1R_Type))register_ref \<close>  where 
     \<open> ICC_ASGI1R_ref = ( (|
  name = (''_ICC_ASGI1R''),
  read_from = ((\<lambda> s .  (| ICC_ASGI1R_Type_bits = ((bitvector_64_reg   s) (''_ICC_ASGI1R'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_ICC_ASGI1R'') then(ICC_ASGI1R_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_ASGI1R_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_ASGI1R_Type v)) |) )\<close>


definition ICC_ASGI1R_EL1_ref  :: \<open>((regstate),(register_value),(ICC_ASGI1R_EL1_Type))register_ref \<close>  where 
     \<open> ICC_ASGI1R_EL1_ref = ( (|
  name = (''ICC_ASGI1R_EL1''),
  read_from = ((\<lambda> s .  (| ICC_ASGI1R_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_ASGI1R_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_ASGI1R_EL1'') then(ICC_ASGI1R_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_ASGI1R_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_ASGI1R_EL1_Type v)) |) )\<close>


definition HTRFCR_ref  :: \<open>((regstate),(register_value),(HTRFCR_Type))register_ref \<close>  where 
     \<open> HTRFCR_ref = ( (|
  name = (''_HTRFCR''),
  read_from = ((\<lambda> s .  (| HTRFCR_Type_bits = ((bitvector_32_reg   s) (''_HTRFCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HTRFCR'') then(HTRFCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HTRFCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HTRFCR_Type v)) |) )\<close>


definition TRFCR_EL2_ref  :: \<open>((regstate),(register_value),(TRFCR_EL2_Type))register_ref \<close>  where 
     \<open> TRFCR_EL2_ref = ( (|
  name = (''TRFCR_EL2''),
  read_from = ((\<lambda> s .  (| TRFCR_EL2_Type_bits = ((bitvector_64_reg   s) (''TRFCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TRFCR_EL2'') then(TRFCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TRFCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TRFCR_EL2_Type v)) |) )\<close>


definition HTCR_ref  :: \<open>((regstate),(register_value),(HTCR_Type))register_ref \<close>  where 
     \<open> HTCR_ref = ( (|
  name = (''_HTCR''),
  read_from = ((\<lambda> s .  (| HTCR_Type_bits = ((bitvector_32_reg   s) (''_HTCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HTCR'') then(HTCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HTCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HTCR_Type v)) |) )\<close>


definition HSTR_ref  :: \<open>((regstate),(register_value),(HSTR_Type))register_ref \<close>  where 
     \<open> HSTR_ref = ( (|
  name = (''_HSTR''),
  read_from = ((\<lambda> s .  (| HSTR_Type_bits = ((bitvector_32_reg   s) (''_HSTR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HSTR'') then(HSTR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HSTR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HSTR_Type v)) |) )\<close>


definition HSTR_EL2_ref  :: \<open>((regstate),(register_value),(HSTR_EL2_Type))register_ref \<close>  where 
     \<open> HSTR_EL2_ref = ( (|
  name = (''HSTR_EL2''),
  read_from = ((\<lambda> s .  (| HSTR_EL2_Type_bits = ((bitvector_64_reg   s) (''HSTR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HSTR_EL2'') then(HSTR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HSTR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HSTR_EL2_Type v)) |) )\<close>


definition HRMR_ref  :: \<open>((regstate),(register_value),(HRMR_Type))register_ref \<close>  where 
     \<open> HRMR_ref = ( (|
  name = (''_HRMR''),
  read_from = ((\<lambda> s .  (| HRMR_Type_bits = ((bitvector_32_reg   s) (''_HRMR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HRMR'') then(HRMR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HRMR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HRMR_Type v)) |) )\<close>


definition RMR_EL2_ref  :: \<open>((regstate),(register_value),(RMR_EL2_Type))register_ref \<close>  where 
     \<open> RMR_EL2_ref = ( (|
  name = (''RMR_EL2''),
  read_from = ((\<lambda> s .  (| RMR_EL2_Type_bits = ((bitvector_64_reg   s) (''RMR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''RMR_EL2'') then(RMR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RMR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RMR_EL2_Type v)) |) )\<close>


definition GITS_TYPER_ref  :: \<open>((regstate),(register_value),(GITS_TYPER_Type))register_ref \<close>  where 
     \<open> GITS_TYPER_ref = ( (|
  name = (''GITS_TYPER''),
  read_from = ((\<lambda> s .  (| GITS_TYPER_Type_bits = ((bitvector_64_reg   s) (''GITS_TYPER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GITS_TYPER'') then(GITS_TYPER_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_TYPER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_TYPER_Type v)) |) )\<close>


definition GITS_STATUSR_ref  :: \<open>((regstate),(register_value),(GITS_STATUSR_Type))register_ref \<close>  where 
     \<open> GITS_STATUSR_ref = ( (|
  name = (''GITS_STATUSR''),
  read_from = ((\<lambda> s .  (| GITS_STATUSR_Type_bits = ((bitvector_32_reg   s) (''GITS_STATUSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GITS_STATUSR'') then(GITS_STATUSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_STATUSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_STATUSR_Type v)) |) )\<close>


definition GITS_SGIR_ref  :: \<open>((regstate),(register_value),(GITS_SGIR_Type))register_ref \<close>  where 
     \<open> GITS_SGIR_ref = ( (|
  name = (''GITS_SGIR''),
  read_from = ((\<lambda> s .  (| GITS_SGIR_Type_bits = ((bitvector_64_reg   s) (''GITS_SGIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GITS_SGIR'') then(GITS_SGIR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_SGIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_SGIR_Type v)) |) )\<close>


definition GITS_PARTIDR_ref  :: \<open>((regstate),(register_value),(GITS_PARTIDR_Type))register_ref \<close>  where 
     \<open> GITS_PARTIDR_ref = ( (|
  name = (''GITS_PARTIDR''),
  read_from = ((\<lambda> s .  (| GITS_PARTIDR_Type_bits = ((bitvector_32_reg   s) (''GITS_PARTIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GITS_PARTIDR'') then(GITS_PARTIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_PARTIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_PARTIDR_Type v)) |) )\<close>


definition GITS_MPIDR_ref  :: \<open>((regstate),(register_value),(GITS_MPIDR_Type))register_ref \<close>  where 
     \<open> GITS_MPIDR_ref = ( (|
  name = (''GITS_MPIDR''),
  read_from = ((\<lambda> s .  (| GITS_MPIDR_Type_bits = ((bitvector_32_reg   s) (''GITS_MPIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GITS_MPIDR'') then(GITS_MPIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_MPIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_MPIDR_Type v)) |) )\<close>


definition GITS_MPAMIDR_ref  :: \<open>((regstate),(register_value),(GITS_MPAMIDR_Type))register_ref \<close>  where 
     \<open> GITS_MPAMIDR_ref = ( (|
  name = (''GITS_MPAMIDR''),
  read_from = ((\<lambda> s .  (| GITS_MPAMIDR_Type_bits = ((bitvector_32_reg   s) (''GITS_MPAMIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GITS_MPAMIDR'') then(GITS_MPAMIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_MPAMIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_MPAMIDR_Type v)) |) )\<close>


definition GITS_IIDR_ref  :: \<open>((regstate),(register_value),(GITS_IIDR_Type))register_ref \<close>  where 
     \<open> GITS_IIDR_ref = ( (|
  name = (''GITS_IIDR''),
  read_from = ((\<lambda> s .  (| GITS_IIDR_Type_bits = ((bitvector_32_reg   s) (''GITS_IIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GITS_IIDR'') then(GITS_IIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_IIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_IIDR_Type v)) |) )\<close>


definition GITS_CWRITER_ref  :: \<open>((regstate),(register_value),(GITS_CWRITER_Type))register_ref \<close>  where 
     \<open> GITS_CWRITER_ref = ( (|
  name = (''GITS_CWRITER''),
  read_from = ((\<lambda> s .  (| GITS_CWRITER_Type_bits = ((bitvector_64_reg   s) (''GITS_CWRITER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GITS_CWRITER'') then(GITS_CWRITER_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_CWRITER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_CWRITER_Type v)) |) )\<close>


definition GITS_CTLR_ref  :: \<open>((regstate),(register_value),(GITS_CTLR_Type))register_ref \<close>  where 
     \<open> GITS_CTLR_ref = ( (|
  name = (''GITS_CTLR''),
  read_from = ((\<lambda> s .  (| GITS_CTLR_Type_bits = ((bitvector_32_reg   s) (''GITS_CTLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GITS_CTLR'') then(GITS_CTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_CTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_CTLR_Type v)) |) )\<close>


definition GITS_CREADR_ref  :: \<open>((regstate),(register_value),(GITS_CREADR_Type))register_ref \<close>  where 
     \<open> GITS_CREADR_ref = ( (|
  name = (''GITS_CREADR''),
  read_from = ((\<lambda> s .  (| GITS_CREADR_Type_bits = ((bitvector_64_reg   s) (''GITS_CREADR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GITS_CREADR'') then(GITS_CREADR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_CREADR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_CREADR_Type v)) |) )\<close>


definition GITS_CBASER_ref  :: \<open>((regstate),(register_value),(GITS_CBASER_Type))register_ref \<close>  where 
     \<open> GITS_CBASER_ref = ( (|
  name = (''GITS_CBASER''),
  read_from = ((\<lambda> s .  (| GITS_CBASER_Type_bits = ((bitvector_64_reg   s) (''GITS_CBASER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GITS_CBASER'') then(GITS_CBASER_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GITS_CBASER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GITS_CBASER_Type v)) |) )\<close>


definition GICV_STATUSR_ref  :: \<open>((regstate),(register_value),(GICV_STATUSR_Type))register_ref \<close>  where 
     \<open> GICV_STATUSR_ref = ( (|
  name = (''GICV_STATUSR''),
  read_from = ((\<lambda> s .  (| GICV_STATUSR_Type_bits = ((bitvector_32_reg   s) (''GICV_STATUSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_STATUSR'') then(GICV_STATUSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_STATUSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_STATUSR_Type v)) |) )\<close>


definition GICV_RPR_ref  :: \<open>((regstate),(register_value),(GICV_RPR_Type))register_ref \<close>  where 
     \<open> GICV_RPR_ref = ( (|
  name = (''GICV_RPR''),
  read_from = ((\<lambda> s .  (| GICV_RPR_Type_bits = ((bitvector_32_reg   s) (''GICV_RPR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_RPR'') then(GICV_RPR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_RPR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_RPR_Type v)) |) )\<close>


definition GICV_PMR_ref  :: \<open>((regstate),(register_value),(GICV_PMR_Type))register_ref \<close>  where 
     \<open> GICV_PMR_ref = ( (|
  name = (''GICV_PMR''),
  read_from = ((\<lambda> s .  (| GICV_PMR_Type_bits = ((bitvector_32_reg   s) (''GICV_PMR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_PMR'') then(GICV_PMR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_PMR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_PMR_Type v)) |) )\<close>


definition GICV_IAR_ref  :: \<open>((regstate),(register_value),(GICV_IAR_Type))register_ref \<close>  where 
     \<open> GICV_IAR_ref = ( (|
  name = (''GICV_IAR''),
  read_from = ((\<lambda> s .  (| GICV_IAR_Type_bits = ((bitvector_32_reg   s) (''GICV_IAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_IAR'') then(GICV_IAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_IAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_IAR_Type v)) |) )\<close>


definition GICV_HPPIR_ref  :: \<open>((regstate),(register_value),(GICV_HPPIR_Type))register_ref \<close>  where 
     \<open> GICV_HPPIR_ref = ( (|
  name = (''GICV_HPPIR''),
  read_from = ((\<lambda> s .  (| GICV_HPPIR_Type_bits = ((bitvector_32_reg   s) (''GICV_HPPIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_HPPIR'') then(GICV_HPPIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_HPPIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_HPPIR_Type v)) |) )\<close>


definition GICV_EOIR_ref  :: \<open>((regstate),(register_value),(GICV_EOIR_Type))register_ref \<close>  where 
     \<open> GICV_EOIR_ref = ( (|
  name = (''GICV_EOIR''),
  read_from = ((\<lambda> s .  (| GICV_EOIR_Type_bits = ((bitvector_32_reg   s) (''GICV_EOIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_EOIR'') then(GICV_EOIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_EOIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_EOIR_Type v)) |) )\<close>


definition GICV_DIR_ref  :: \<open>((regstate),(register_value),(GICV_DIR_Type))register_ref \<close>  where 
     \<open> GICV_DIR_ref = ( (|
  name = (''GICV_DIR''),
  read_from = ((\<lambda> s .  (| GICV_DIR_Type_bits = ((bitvector_32_reg   s) (''GICV_DIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_DIR'') then(GICV_DIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_DIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_DIR_Type v)) |) )\<close>


definition GICV_CTLR_ref  :: \<open>((regstate),(register_value),(GICV_CTLR_Type))register_ref \<close>  where 
     \<open> GICV_CTLR_ref = ( (|
  name = (''GICV_CTLR''),
  read_from = ((\<lambda> s .  (| GICV_CTLR_Type_bits = ((bitvector_32_reg   s) (''GICV_CTLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_CTLR'') then(GICV_CTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_CTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_CTLR_Type v)) |) )\<close>


definition GICV_BPR_ref  :: \<open>((regstate),(register_value),(GICV_BPR_Type))register_ref \<close>  where 
     \<open> GICV_BPR_ref = ( (|
  name = (''GICV_BPR''),
  read_from = ((\<lambda> s .  (| GICV_BPR_Type_bits = ((bitvector_32_reg   s) (''GICV_BPR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_BPR'') then(GICV_BPR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_BPR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_BPR_Type v)) |) )\<close>


definition GICV_AIAR_ref  :: \<open>((regstate),(register_value),(GICV_AIAR_Type))register_ref \<close>  where 
     \<open> GICV_AIAR_ref = ( (|
  name = (''GICV_AIAR''),
  read_from = ((\<lambda> s .  (| GICV_AIAR_Type_bits = ((bitvector_32_reg   s) (''GICV_AIAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_AIAR'') then(GICV_AIAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_AIAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_AIAR_Type v)) |) )\<close>


definition GICV_AHPPIR_ref  :: \<open>((regstate),(register_value),(GICV_AHPPIR_Type))register_ref \<close>  where 
     \<open> GICV_AHPPIR_ref = ( (|
  name = (''GICV_AHPPIR''),
  read_from = ((\<lambda> s .  (| GICV_AHPPIR_Type_bits = ((bitvector_32_reg   s) (''GICV_AHPPIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_AHPPIR'') then(GICV_AHPPIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_AHPPIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_AHPPIR_Type v)) |) )\<close>


definition GICV_AEOIR_ref  :: \<open>((regstate),(register_value),(GICV_AEOIR_Type))register_ref \<close>  where 
     \<open> GICV_AEOIR_ref = ( (|
  name = (''GICV_AEOIR''),
  read_from = ((\<lambda> s .  (| GICV_AEOIR_Type_bits = ((bitvector_32_reg   s) (''GICV_AEOIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_AEOIR'') then(GICV_AEOIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_AEOIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_AEOIR_Type v)) |) )\<close>


definition GICV_ABPR_ref  :: \<open>((regstate),(register_value),(GICV_ABPR_Type))register_ref \<close>  where 
     \<open> GICV_ABPR_ref = ( (|
  name = (''GICV_ABPR''),
  read_from = ((\<lambda> s .  (| GICV_ABPR_Type_bits = ((bitvector_32_reg   s) (''GICV_ABPR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICV_ABPR'') then(GICV_ABPR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICV_ABPR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICV_ABPR_Type v)) |) )\<close>


definition GICR_WAKER_ref  :: \<open>((regstate),(register_value),(GICR_WAKER_Type))register_ref \<close>  where 
     \<open> GICR_WAKER_ref = ( (|
  name = (''GICR_WAKER''),
  read_from = ((\<lambda> s .  (| GICR_WAKER_Type_bits = ((bitvector_32_reg   s) (''GICR_WAKER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_WAKER'') then(GICR_WAKER_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_WAKER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_WAKER_Type v)) |) )\<close>


definition GICR_VSGIR_ref  :: \<open>((regstate),(register_value),(GICR_VSGIR_Type))register_ref \<close>  where 
     \<open> GICR_VSGIR_ref = ( (|
  name = (''GICR_VSGIR''),
  read_from = ((\<lambda> s .  (| GICR_VSGIR_Type_bits = ((bitvector_32_reg   s) (''GICR_VSGIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_VSGIR'') then(GICR_VSGIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_VSGIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_VSGIR_Type v)) |) )\<close>


definition GICR_VSGIPENDR_ref  :: \<open>((regstate),(register_value),(GICR_VSGIPENDR_Type))register_ref \<close>  where 
     \<open> GICR_VSGIPENDR_ref = ( (|
  name = (''GICR_VSGIPENDR''),
  read_from = ((\<lambda> s .  (| GICR_VSGIPENDR_Type_bits = ((bitvector_32_reg   s) (''GICR_VSGIPENDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_VSGIPENDR'') then(GICR_VSGIPENDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_VSGIPENDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_VSGIPENDR_Type v)) |) )\<close>


definition GICR_VPROPBASER_ref  :: \<open>((regstate),(register_value),(GICR_VPROPBASER_Type))register_ref \<close>  where 
     \<open> GICR_VPROPBASER_ref = ( (|
  name = (''GICR_VPROPBASER''),
  read_from = ((\<lambda> s .  (| GICR_VPROPBASER_Type_bits = ((bitvector_64_reg   s) (''GICR_VPROPBASER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GICR_VPROPBASER'') then(GICR_VPROPBASER_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_VPROPBASER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_VPROPBASER_Type v)) |) )\<close>


definition GICR_VPENDBASER_ref  :: \<open>((regstate),(register_value),(GICR_VPENDBASER_Type))register_ref \<close>  where 
     \<open> GICR_VPENDBASER_ref = ( (|
  name = (''GICR_VPENDBASER''),
  read_from = ((\<lambda> s .  (| GICR_VPENDBASER_Type_bits = ((bitvector_64_reg   s) (''GICR_VPENDBASER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GICR_VPENDBASER'') then(GICR_VPENDBASER_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_VPENDBASER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_VPENDBASER_Type v)) |) )\<close>


definition GICR_SYNCR_ref  :: \<open>((regstate),(register_value),(GICR_SYNCR_Type))register_ref \<close>  where 
     \<open> GICR_SYNCR_ref = ( (|
  name = (''GICR_SYNCR''),
  read_from = ((\<lambda> s .  (| GICR_SYNCR_Type_bits = ((bitvector_32_reg   s) (''GICR_SYNCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_SYNCR'') then(GICR_SYNCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_SYNCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_SYNCR_Type v)) |) )\<close>


definition GICR_STATUSR_ref  :: \<open>((regstate),(register_value),(GICR_STATUSR_Type))register_ref \<close>  where 
     \<open> GICR_STATUSR_ref = ( (|
  name = (''GICR_STATUSR''),
  read_from = ((\<lambda> s .  (| GICR_STATUSR_Type_bits = ((bitvector_32_reg   s) (''GICR_STATUSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_STATUSR'') then(GICR_STATUSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_STATUSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_STATUSR_Type v)) |) )\<close>


definition GICR_SETLPIR_ref  :: \<open>((regstate),(register_value),(GICR_SETLPIR_Type))register_ref \<close>  where 
     \<open> GICR_SETLPIR_ref = ( (|
  name = (''GICR_SETLPIR''),
  read_from = ((\<lambda> s .  (| GICR_SETLPIR_Type_bits = ((bitvector_64_reg   s) (''GICR_SETLPIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GICR_SETLPIR'') then(GICR_SETLPIR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_SETLPIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_SETLPIR_Type v)) |) )\<close>


definition GICR_PROPBASER_ref  :: \<open>((regstate),(register_value),(GICR_PROPBASER_Type))register_ref \<close>  where 
     \<open> GICR_PROPBASER_ref = ( (|
  name = (''GICR_PROPBASER''),
  read_from = ((\<lambda> s .  (| GICR_PROPBASER_Type_bits = ((bitvector_64_reg   s) (''GICR_PROPBASER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GICR_PROPBASER'') then(GICR_PROPBASER_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_PROPBASER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_PROPBASER_Type v)) |) )\<close>


definition GICR_PENDBASER_ref  :: \<open>((regstate),(register_value),(GICR_PENDBASER_Type))register_ref \<close>  where 
     \<open> GICR_PENDBASER_ref = ( (|
  name = (''GICR_PENDBASER''),
  read_from = ((\<lambda> s .  (| GICR_PENDBASER_Type_bits = ((bitvector_64_reg   s) (''GICR_PENDBASER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GICR_PENDBASER'') then(GICR_PENDBASER_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_PENDBASER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_PENDBASER_Type v)) |) )\<close>


definition GICR_PARTIDR_ref  :: \<open>((regstate),(register_value),(GICR_PARTIDR_Type))register_ref \<close>  where 
     \<open> GICR_PARTIDR_ref = ( (|
  name = (''GICR_PARTIDR''),
  read_from = ((\<lambda> s .  (| GICR_PARTIDR_Type_bits = ((bitvector_32_reg   s) (''GICR_PARTIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_PARTIDR'') then(GICR_PARTIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_PARTIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_PARTIDR_Type v)) |) )\<close>


definition GICR_MPAMIDR_ref  :: \<open>((regstate),(register_value),(GICR_MPAMIDR_Type))register_ref \<close>  where 
     \<open> GICR_MPAMIDR_ref = ( (|
  name = (''GICR_MPAMIDR''),
  read_from = ((\<lambda> s .  (| GICR_MPAMIDR_Type_bits = ((bitvector_32_reg   s) (''GICR_MPAMIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_MPAMIDR'') then(GICR_MPAMIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_MPAMIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_MPAMIDR_Type v)) |) )\<close>


definition GICR_ISENABLER0_ref  :: \<open>((regstate),(register_value),(GICR_ISENABLER0_Type))register_ref \<close>  where 
     \<open> GICR_ISENABLER0_ref = ( (|
  name = (''GICR_ISENABLER0''),
  read_from = ((\<lambda> s .  (| GICR_ISENABLER0_Type_bits = ((bitvector_32_reg   s) (''GICR_ISENABLER0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_ISENABLER0'') then(GICR_ISENABLER0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_ISENABLER0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_ISENABLER0_Type v)) |) )\<close>


definition GICR_INVLPIR_ref  :: \<open>((regstate),(register_value),(GICR_INVLPIR_Type))register_ref \<close>  where 
     \<open> GICR_INVLPIR_ref = ( (|
  name = (''GICR_INVLPIR''),
  read_from = ((\<lambda> s .  (| GICR_INVLPIR_Type_bits = ((bitvector_64_reg   s) (''GICR_INVLPIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GICR_INVLPIR'') then(GICR_INVLPIR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_INVLPIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_INVLPIR_Type v)) |) )\<close>


definition GICR_INVALLR_ref  :: \<open>((regstate),(register_value),(GICR_INVALLR_Type))register_ref \<close>  where 
     \<open> GICR_INVALLR_ref = ( (|
  name = (''GICR_INVALLR''),
  read_from = ((\<lambda> s .  (| GICR_INVALLR_Type_bits = ((bitvector_64_reg   s) (''GICR_INVALLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GICR_INVALLR'') then(GICR_INVALLR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_INVALLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_INVALLR_Type v)) |) )\<close>


definition GICR_INMIR0_ref  :: \<open>((regstate),(register_value),(GICR_INMIR0_Type))register_ref \<close>  where 
     \<open> GICR_INMIR0_ref = ( (|
  name = (''GICR_INMIR0''),
  read_from = ((\<lambda> s .  (| GICR_INMIR0_Type_bits = ((bitvector_32_reg   s) (''GICR_INMIR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_INMIR0'') then(GICR_INMIR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_INMIR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_INMIR0_Type v)) |) )\<close>


definition GICR_IIDR_ref  :: \<open>((regstate),(register_value),(GICR_IIDR_Type))register_ref \<close>  where 
     \<open> GICR_IIDR_ref = ( (|
  name = (''GICR_IIDR''),
  read_from = ((\<lambda> s .  (| GICR_IIDR_Type_bits = ((bitvector_32_reg   s) (''GICR_IIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_IIDR'') then(GICR_IIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_IIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_IIDR_Type v)) |) )\<close>


definition GICR_CTLR_ref  :: \<open>((regstate),(register_value),(GICR_CTLR_Type))register_ref \<close>  where 
     \<open> GICR_CTLR_ref = ( (|
  name = (''GICR_CTLR''),
  read_from = ((\<lambda> s .  (| GICR_CTLR_Type_bits = ((bitvector_32_reg   s) (''GICR_CTLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICR_CTLR'') then(GICR_CTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_CTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_CTLR_Type v)) |) )\<close>


definition GICR_CLRLPIR_ref  :: \<open>((regstate),(register_value),(GICR_CLRLPIR_Type))register_ref \<close>  where 
     \<open> GICR_CLRLPIR_ref = ( (|
  name = (''GICR_CLRLPIR''),
  read_from = ((\<lambda> s .  (| GICR_CLRLPIR_Type_bits = ((bitvector_64_reg   s) (''GICR_CLRLPIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GICR_CLRLPIR'') then(GICR_CLRLPIR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICR_CLRLPIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICR_CLRLPIR_Type v)) |) )\<close>


definition GICM_TYPER_ref  :: \<open>((regstate),(register_value),(GICM_TYPER_Type))register_ref \<close>  where 
     \<open> GICM_TYPER_ref = ( (|
  name = (''GICM_TYPER''),
  read_from = ((\<lambda> s .  (| GICM_TYPER_Type_bits = ((bitvector_32_reg   s) (''GICM_TYPER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICM_TYPER'') then(GICM_TYPER_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICM_TYPER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICM_TYPER_Type v)) |) )\<close>


definition GICM_SETSPI_SR_ref  :: \<open>((regstate),(register_value),(GICM_SETSPI_SR_Type))register_ref \<close>  where 
     \<open> GICM_SETSPI_SR_ref = ( (|
  name = (''GICM_SETSPI_SR''),
  read_from = ((\<lambda> s .  (| GICM_SETSPI_SR_Type_bits = ((bitvector_32_reg   s) (''GICM_SETSPI_SR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICM_SETSPI_SR'') then(GICM_SETSPI_SR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICM_SETSPI_SR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICM_SETSPI_SR_Type v)) |) )\<close>


definition GICM_SETSPI_NSR_ref  :: \<open>((regstate),(register_value),(GICM_SETSPI_NSR_Type))register_ref \<close>  where 
     \<open> GICM_SETSPI_NSR_ref = ( (|
  name = (''GICM_SETSPI_NSR''),
  read_from = ((\<lambda> s .  (| GICM_SETSPI_NSR_Type_bits = ((bitvector_32_reg   s) (''GICM_SETSPI_NSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICM_SETSPI_NSR'') then(GICM_SETSPI_NSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICM_SETSPI_NSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICM_SETSPI_NSR_Type v)) |) )\<close>


definition GICM_IIDR_ref  :: \<open>((regstate),(register_value),(GICM_IIDR_Type))register_ref \<close>  where 
     \<open> GICM_IIDR_ref = ( (|
  name = (''GICM_IIDR''),
  read_from = ((\<lambda> s .  (| GICM_IIDR_Type_bits = ((bitvector_32_reg   s) (''GICM_IIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICM_IIDR'') then(GICM_IIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICM_IIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICM_IIDR_Type v)) |) )\<close>


definition GICM_CLRSPI_SR_ref  :: \<open>((regstate),(register_value),(GICM_CLRSPI_SR_Type))register_ref \<close>  where 
     \<open> GICM_CLRSPI_SR_ref = ( (|
  name = (''GICM_CLRSPI_SR''),
  read_from = ((\<lambda> s .  (| GICM_CLRSPI_SR_Type_bits = ((bitvector_32_reg   s) (''GICM_CLRSPI_SR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICM_CLRSPI_SR'') then(GICM_CLRSPI_SR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICM_CLRSPI_SR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICM_CLRSPI_SR_Type v)) |) )\<close>


definition GICM_CLRSPI_NSR_ref  :: \<open>((regstate),(register_value),(GICM_CLRSPI_NSR_Type))register_ref \<close>  where 
     \<open> GICM_CLRSPI_NSR_ref = ( (|
  name = (''GICM_CLRSPI_NSR''),
  read_from = ((\<lambda> s .  (| GICM_CLRSPI_NSR_Type_bits = ((bitvector_32_reg   s) (''GICM_CLRSPI_NSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICM_CLRSPI_NSR'') then(GICM_CLRSPI_NSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICM_CLRSPI_NSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICM_CLRSPI_NSR_Type v)) |) )\<close>


definition GICH_VTR_ref  :: \<open>((regstate),(register_value),(GICH_VTR_Type))register_ref \<close>  where 
     \<open> GICH_VTR_ref = ( (|
  name = (''GICH_VTR''),
  read_from = ((\<lambda> s .  (| GICH_VTR_Type_bits = ((bitvector_32_reg   s) (''GICH_VTR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICH_VTR'') then(GICH_VTR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICH_VTR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICH_VTR_Type v)) |) )\<close>


definition GICH_VMCR_ref  :: \<open>((regstate),(register_value),(GICH_VMCR_Type))register_ref \<close>  where 
     \<open> GICH_VMCR_ref = ( (|
  name = (''GICH_VMCR''),
  read_from = ((\<lambda> s .  (| GICH_VMCR_Type_bits = ((bitvector_32_reg   s) (''GICH_VMCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICH_VMCR'') then(GICH_VMCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICH_VMCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICH_VMCR_Type v)) |) )\<close>


definition GICH_MISR_ref  :: \<open>((regstate),(register_value),(GICH_MISR_Type))register_ref \<close>  where 
     \<open> GICH_MISR_ref = ( (|
  name = (''GICH_MISR''),
  read_from = ((\<lambda> s .  (| GICH_MISR_Type_bits = ((bitvector_32_reg   s) (''GICH_MISR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICH_MISR'') then(GICH_MISR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICH_MISR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICH_MISR_Type v)) |) )\<close>


definition GICH_HCR_ref  :: \<open>((regstate),(register_value),(GICH_HCR_Type))register_ref \<close>  where 
     \<open> GICH_HCR_ref = ( (|
  name = (''GICH_HCR''),
  read_from = ((\<lambda> s .  (| GICH_HCR_Type_bits = ((bitvector_32_reg   s) (''GICH_HCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICH_HCR'') then(GICH_HCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICH_HCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICH_HCR_Type v)) |) )\<close>


definition GICH_ELRSR_ref  :: \<open>((regstate),(register_value),(GICH_ELRSR_Type))register_ref \<close>  where 
     \<open> GICH_ELRSR_ref = ( (|
  name = (''GICH_ELRSR''),
  read_from = ((\<lambda> s .  (| GICH_ELRSR_Type_bits = ((bitvector_32_reg   s) (''GICH_ELRSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICH_ELRSR'') then(GICH_ELRSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICH_ELRSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICH_ELRSR_Type v)) |) )\<close>


definition GICH_EISR_ref  :: \<open>((regstate),(register_value),(GICH_EISR_Type))register_ref \<close>  where 
     \<open> GICH_EISR_ref = ( (|
  name = (''GICH_EISR''),
  read_from = ((\<lambda> s .  (| GICH_EISR_Type_bits = ((bitvector_32_reg   s) (''GICH_EISR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICH_EISR'') then(GICH_EISR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICH_EISR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICH_EISR_Type v)) |) )\<close>


definition GICD_TYPER2_ref  :: \<open>((regstate),(register_value),(GICD_TYPER2_Type))register_ref \<close>  where 
     \<open> GICD_TYPER2_ref = ( (|
  name = (''GICD_TYPER2''),
  read_from = ((\<lambda> s .  (| GICD_TYPER2_Type_bits = ((bitvector_32_reg   s) (''GICD_TYPER2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICD_TYPER2'') then(GICD_TYPER2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICD_TYPER2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICD_TYPER2_Type v)) |) )\<close>


definition GICD_STATUSR_ref  :: \<open>((regstate),(register_value),(GICD_STATUSR_Type))register_ref \<close>  where 
     \<open> GICD_STATUSR_ref = ( (|
  name = (''GICD_STATUSR''),
  read_from = ((\<lambda> s .  (| GICD_STATUSR_Type_bits = ((bitvector_32_reg   s) (''GICD_STATUSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICD_STATUSR'') then(GICD_STATUSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICD_STATUSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICD_STATUSR_Type v)) |) )\<close>


definition GICD_SGIR_ref  :: \<open>((regstate),(register_value),(GICD_SGIR_Type))register_ref \<close>  where 
     \<open> GICD_SGIR_ref = ( (|
  name = (''GICD_SGIR''),
  read_from = ((\<lambda> s .  (| GICD_SGIR_Type_bits = ((bitvector_32_reg   s) (''GICD_SGIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICD_SGIR'') then(GICD_SGIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICD_SGIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICD_SGIR_Type v)) |) )\<close>


definition GICD_SETSPI_SR_ref  :: \<open>((regstate),(register_value),(GICD_SETSPI_SR_Type))register_ref \<close>  where 
     \<open> GICD_SETSPI_SR_ref = ( (|
  name = (''GICD_SETSPI_SR''),
  read_from = ((\<lambda> s .  (| GICD_SETSPI_SR_Type_bits = ((bitvector_32_reg   s) (''GICD_SETSPI_SR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICD_SETSPI_SR'') then(GICD_SETSPI_SR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICD_SETSPI_SR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICD_SETSPI_SR_Type v)) |) )\<close>


definition GICD_SETSPI_NSR_ref  :: \<open>((regstate),(register_value),(GICD_SETSPI_NSR_Type))register_ref \<close>  where 
     \<open> GICD_SETSPI_NSR_ref = ( (|
  name = (''GICD_SETSPI_NSR''),
  read_from = ((\<lambda> s .  (| GICD_SETSPI_NSR_Type_bits = ((bitvector_32_reg   s) (''GICD_SETSPI_NSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICD_SETSPI_NSR'') then(GICD_SETSPI_NSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICD_SETSPI_NSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICD_SETSPI_NSR_Type v)) |) )\<close>


definition GICD_IIDR_ref  :: \<open>((regstate),(register_value),(GICD_IIDR_Type))register_ref \<close>  where 
     \<open> GICD_IIDR_ref = ( (|
  name = (''GICD_IIDR''),
  read_from = ((\<lambda> s .  (| GICD_IIDR_Type_bits = ((bitvector_32_reg   s) (''GICD_IIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICD_IIDR'') then(GICD_IIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICD_IIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICD_IIDR_Type v)) |) )\<close>


definition GICD_CTLR_ref  :: \<open>((regstate),(register_value),(GICD_CTLR_Type))register_ref \<close>  where 
     \<open> GICD_CTLR_ref = ( (|
  name = (''GICD_CTLR''),
  read_from = ((\<lambda> s .  (| GICD_CTLR_Type_bits = ((bitvector_32_reg   s) (''GICD_CTLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICD_CTLR'') then(GICD_CTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICD_CTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICD_CTLR_Type v)) |) )\<close>


definition GICD_CLRSPI_SR_ref  :: \<open>((regstate),(register_value),(GICD_CLRSPI_SR_Type))register_ref \<close>  where 
     \<open> GICD_CLRSPI_SR_ref = ( (|
  name = (''GICD_CLRSPI_SR''),
  read_from = ((\<lambda> s .  (| GICD_CLRSPI_SR_Type_bits = ((bitvector_32_reg   s) (''GICD_CLRSPI_SR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICD_CLRSPI_SR'') then(GICD_CLRSPI_SR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICD_CLRSPI_SR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICD_CLRSPI_SR_Type v)) |) )\<close>


definition GICD_CLRSPI_NSR_ref  :: \<open>((regstate),(register_value),(GICD_CLRSPI_NSR_Type))register_ref \<close>  where 
     \<open> GICD_CLRSPI_NSR_ref = ( (|
  name = (''GICD_CLRSPI_NSR''),
  read_from = ((\<lambda> s .  (| GICD_CLRSPI_NSR_Type_bits = ((bitvector_32_reg   s) (''GICD_CLRSPI_NSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICD_CLRSPI_NSR'') then(GICD_CLRSPI_NSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICD_CLRSPI_NSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICD_CLRSPI_NSR_Type v)) |) )\<close>


definition GICC_STATUSR_ref  :: \<open>((regstate),(register_value),(GICC_STATUSR_Type))register_ref \<close>  where 
     \<open> GICC_STATUSR_ref = ( (|
  name = (''GICC_STATUSR''),
  read_from = ((\<lambda> s .  (| GICC_STATUSR_Type_bits = ((bitvector_32_reg   s) (''GICC_STATUSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_STATUSR'') then(GICC_STATUSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_STATUSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_STATUSR_Type v)) |) )\<close>


definition GICC_RPR_ref  :: \<open>((regstate),(register_value),(GICC_RPR_Type))register_ref \<close>  where 
     \<open> GICC_RPR_ref = ( (|
  name = (''GICC_RPR''),
  read_from = ((\<lambda> s .  (| GICC_RPR_Type_bits = ((bitvector_32_reg   s) (''GICC_RPR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_RPR'') then(GICC_RPR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_RPR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_RPR_Type v)) |) )\<close>


definition GICC_PMR_ref  :: \<open>((regstate),(register_value),(GICC_PMR_Type))register_ref \<close>  where 
     \<open> GICC_PMR_ref = ( (|
  name = (''GICC_PMR''),
  read_from = ((\<lambda> s .  (| GICC_PMR_Type_bits = ((bitvector_32_reg   s) (''GICC_PMR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_PMR'') then(GICC_PMR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_PMR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_PMR_Type v)) |) )\<close>


definition GICC_IAR_ref  :: \<open>((regstate),(register_value),(GICC_IAR_Type))register_ref \<close>  where 
     \<open> GICC_IAR_ref = ( (|
  name = (''GICC_IAR''),
  read_from = ((\<lambda> s .  (| GICC_IAR_Type_bits = ((bitvector_32_reg   s) (''GICC_IAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_IAR'') then(GICC_IAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_IAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_IAR_Type v)) |) )\<close>


definition GICC_HPPIR_ref  :: \<open>((regstate),(register_value),(GICC_HPPIR_Type))register_ref \<close>  where 
     \<open> GICC_HPPIR_ref = ( (|
  name = (''GICC_HPPIR''),
  read_from = ((\<lambda> s .  (| GICC_HPPIR_Type_bits = ((bitvector_32_reg   s) (''GICC_HPPIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_HPPIR'') then(GICC_HPPIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_HPPIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_HPPIR_Type v)) |) )\<close>


definition GICC_EOIR_ref  :: \<open>((regstate),(register_value),(GICC_EOIR_Type))register_ref \<close>  where 
     \<open> GICC_EOIR_ref = ( (|
  name = (''GICC_EOIR''),
  read_from = ((\<lambda> s .  (| GICC_EOIR_Type_bits = ((bitvector_32_reg   s) (''GICC_EOIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_EOIR'') then(GICC_EOIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_EOIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_EOIR_Type v)) |) )\<close>


definition GICC_DIR_ref  :: \<open>((regstate),(register_value),(GICC_DIR_Type))register_ref \<close>  where 
     \<open> GICC_DIR_ref = ( (|
  name = (''GICC_DIR''),
  read_from = ((\<lambda> s .  (| GICC_DIR_Type_bits = ((bitvector_32_reg   s) (''GICC_DIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_DIR'') then(GICC_DIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_DIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_DIR_Type v)) |) )\<close>


definition GICC_BPR_ref  :: \<open>((regstate),(register_value),(GICC_BPR_Type))register_ref \<close>  where 
     \<open> GICC_BPR_ref = ( (|
  name = (''GICC_BPR''),
  read_from = ((\<lambda> s .  (| GICC_BPR_Type_bits = ((bitvector_32_reg   s) (''GICC_BPR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_BPR'') then(GICC_BPR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_BPR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_BPR_Type v)) |) )\<close>


definition GICC_AIAR_ref  :: \<open>((regstate),(register_value),(GICC_AIAR_Type))register_ref \<close>  where 
     \<open> GICC_AIAR_ref = ( (|
  name = (''GICC_AIAR''),
  read_from = ((\<lambda> s .  (| GICC_AIAR_Type_bits = ((bitvector_32_reg   s) (''GICC_AIAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_AIAR'') then(GICC_AIAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_AIAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_AIAR_Type v)) |) )\<close>


definition GICC_AHPPIR_ref  :: \<open>((regstate),(register_value),(GICC_AHPPIR_Type))register_ref \<close>  where 
     \<open> GICC_AHPPIR_ref = ( (|
  name = (''GICC_AHPPIR''),
  read_from = ((\<lambda> s .  (| GICC_AHPPIR_Type_bits = ((bitvector_32_reg   s) (''GICC_AHPPIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_AHPPIR'') then(GICC_AHPPIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_AHPPIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_AHPPIR_Type v)) |) )\<close>


definition GICC_AEOIR_ref  :: \<open>((regstate),(register_value),(GICC_AEOIR_Type))register_ref \<close>  where 
     \<open> GICC_AEOIR_ref = ( (|
  name = (''GICC_AEOIR''),
  read_from = ((\<lambda> s .  (| GICC_AEOIR_Type_bits = ((bitvector_32_reg   s) (''GICC_AEOIR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_AEOIR'') then(GICC_AEOIR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_AEOIR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_AEOIR_Type v)) |) )\<close>


definition GICC_ABPR_ref  :: \<open>((regstate),(register_value),(GICC_ABPR_Type))register_ref \<close>  where 
     \<open> GICC_ABPR_ref = ( (|
  name = (''GICC_ABPR''),
  read_from = ((\<lambda> s .  (| GICC_ABPR_Type_bits = ((bitvector_32_reg   s) (''GICC_ABPR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_ABPR'') then(GICC_ABPR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_ABPR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_ABPR_Type v)) |) )\<close>


definition FCSEIDR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> FCSEIDR_ref = ( (|
  name = (''FCSEIDR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''FCSEIDR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''FCSEIDR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ERRSELR_ref  :: \<open>((regstate),(register_value),(ERRSELR_Type))register_ref \<close>  where 
     \<open> ERRSELR_ref = ( (|
  name = (''_ERRSELR''),
  read_from = ((\<lambda> s .  (| ERRSELR_Type_bits = ((bitvector_32_reg   s) (''_ERRSELR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERRSELR'') then(ERRSELR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ERRSELR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ERRSELR_Type v)) |) )\<close>


definition ERRSELR_EL1_ref  :: \<open>((regstate),(register_value),(ERRSELR_EL1_Type))register_ref \<close>  where 
     \<open> ERRSELR_EL1_ref = ( (|
  name = (''ERRSELR_EL1''),
  read_from = ((\<lambda> s .  (| ERRSELR_EL1_Type_bits = ((bitvector_64_reg   s) (''ERRSELR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERRSELR_EL1'') then(ERRSELR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ERRSELR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ERRSELR_EL1_Type v)) |) )\<close>


definition ERRIDR_ref  :: \<open>((regstate),(register_value),(ERRIDR_Type))register_ref \<close>  where 
     \<open> ERRIDR_ref = ( (|
  name = (''_ERRIDR''),
  read_from = ((\<lambda> s .  (| ERRIDR_Type_bits = ((bitvector_32_reg   s) (''_ERRIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ERRIDR'') then(ERRIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ERRIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ERRIDR_Type v)) |) )\<close>


definition ERRIDR_EL1_ref  :: \<open>((regstate),(register_value),(ERRIDR_EL1_Type))register_ref \<close>  where 
     \<open> ERRIDR_EL1_ref = ( (|
  name = (''ERRIDR_EL1''),
  read_from = ((\<lambda> s .  (| ERRIDR_EL1_Type_bits = ((bitvector_64_reg   s) (''ERRIDR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ERRIDR_EL1'') then(ERRIDR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ERRIDR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ERRIDR_EL1_Type v)) |) )\<close>


definition EDVIDSR_ref  :: \<open>((regstate),(register_value),(EDVIDSR_Type))register_ref \<close>  where 
     \<open> EDVIDSR_ref = ( (|
  name = (''EDVIDSR''),
  read_from = ((\<lambda> s .  (| EDVIDSR_Type_bits = ((bitvector_32_reg   s) (''EDVIDSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDVIDSR'') then(EDVIDSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDVIDSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDVIDSR_Type v)) |) )\<close>


definition EDRCR_ref  :: \<open>((regstate),(register_value),(EDRCR_Type))register_ref \<close>  where 
     \<open> EDRCR_ref = ( (|
  name = (''EDRCR''),
  read_from = ((\<lambda> s .  (| EDRCR_Type_bits = ((bitvector_32_reg   s) (''EDRCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDRCR'') then(EDRCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDRCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDRCR_Type v)) |) )\<close>


definition EDPRSR_ref  :: \<open>((regstate),(register_value),(EDPRSR_Type))register_ref \<close>  where 
     \<open> EDPRSR_ref = ( (|
  name = (''EDPRSR''),
  read_from = ((\<lambda> s .  (| EDPRSR_Type_bits = ((bitvector_32_reg   s) (''EDPRSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDPRSR'') then(EDPRSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDPRSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDPRSR_Type v)) |) )\<close>


definition EDPRCR_ref  :: \<open>((regstate),(register_value),(EDPRCR_Type))register_ref \<close>  where 
     \<open> EDPRCR_ref = ( (|
  name = (''EDPRCR''),
  read_from = ((\<lambda> s .  (| EDPRCR_Type_bits = ((bitvector_32_reg   s) (''EDPRCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDPRCR'') then(EDPRCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDPRCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDPRCR_Type v)) |) )\<close>


definition EDPIDR4_ref  :: \<open>((regstate),(register_value),(EDPIDR4_Type))register_ref \<close>  where 
     \<open> EDPIDR4_ref = ( (|
  name = (''EDPIDR4''),
  read_from = ((\<lambda> s .  (| EDPIDR4_Type_bits = ((bitvector_32_reg   s) (''EDPIDR4'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDPIDR4'') then(EDPIDR4_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDPIDR4_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDPIDR4_Type v)) |) )\<close>


definition EDPIDR3_ref  :: \<open>((regstate),(register_value),(EDPIDR3_Type))register_ref \<close>  where 
     \<open> EDPIDR3_ref = ( (|
  name = (''EDPIDR3''),
  read_from = ((\<lambda> s .  (| EDPIDR3_Type_bits = ((bitvector_32_reg   s) (''EDPIDR3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDPIDR3'') then(EDPIDR3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDPIDR3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDPIDR3_Type v)) |) )\<close>


definition EDPIDR2_ref  :: \<open>((regstate),(register_value),(EDPIDR2_Type))register_ref \<close>  where 
     \<open> EDPIDR2_ref = ( (|
  name = (''EDPIDR2''),
  read_from = ((\<lambda> s .  (| EDPIDR2_Type_bits = ((bitvector_32_reg   s) (''EDPIDR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDPIDR2'') then(EDPIDR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDPIDR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDPIDR2_Type v)) |) )\<close>


definition EDPIDR1_ref  :: \<open>((regstate),(register_value),(EDPIDR1_Type))register_ref \<close>  where 
     \<open> EDPIDR1_ref = ( (|
  name = (''EDPIDR1''),
  read_from = ((\<lambda> s .  (| EDPIDR1_Type_bits = ((bitvector_32_reg   s) (''EDPIDR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDPIDR1'') then(EDPIDR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDPIDR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDPIDR1_Type v)) |) )\<close>


definition EDPIDR0_ref  :: \<open>((regstate),(register_value),(EDPIDR0_Type))register_ref \<close>  where 
     \<open> EDPIDR0_ref = ( (|
  name = (''EDPIDR0''),
  read_from = ((\<lambda> s .  (| EDPIDR0_Type_bits = ((bitvector_32_reg   s) (''EDPIDR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDPIDR0'') then(EDPIDR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDPIDR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDPIDR0_Type v)) |) )\<close>


definition EDPFR_ref  :: \<open>((regstate),(register_value),(EDPFR_Type))register_ref \<close>  where 
     \<open> EDPFR_ref = ( (|
  name = (''EDPFR''),
  read_from = ((\<lambda> s .  (| EDPFR_Type_bits = ((bitvector_64_reg   s) (''EDPFR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''EDPFR'') then(EDPFR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDPFR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDPFR_Type v)) |) )\<close>


definition EDPCSR_ref  :: \<open>((regstate),(register_value),(EDPCSR_Type))register_ref \<close>  where 
     \<open> EDPCSR_ref = ( (|
  name = (''EDPCSR''),
  read_from = ((\<lambda> s .  (| EDPCSR_Type_bits = ((bitvector_64_reg   s) (''EDPCSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''EDPCSR'') then(EDPCSR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDPCSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDPCSR_Type v)) |) )\<close>


definition EDLSR_ref  :: \<open>((regstate),(register_value),(EDLSR_Type))register_ref \<close>  where 
     \<open> EDLSR_ref = ( (|
  name = (''EDLSR''),
  read_from = ((\<lambda> s .  (| EDLSR_Type_bits = ((bitvector_32_reg   s) (''EDLSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDLSR'') then(EDLSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDLSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDLSR_Type v)) |) )\<close>


definition EDLAR_ref  :: \<open>((regstate),(register_value),(EDLAR_Type))register_ref \<close>  where 
     \<open> EDLAR_ref = ( (|
  name = (''EDLAR''),
  read_from = ((\<lambda> s .  (| EDLAR_Type_bits = ((bitvector_32_reg   s) (''EDLAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDLAR'') then(EDLAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDLAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDLAR_Type v)) |) )\<close>


definition EDITCTRL_ref  :: \<open>((regstate),(register_value),(EDITCTRL_Type))register_ref \<close>  where 
     \<open> EDITCTRL_ref = ( (|
  name = (''EDITCTRL''),
  read_from = ((\<lambda> s .  (| EDITCTRL_Type_bits = ((bitvector_32_reg   s) (''EDITCTRL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDITCTRL'') then(EDITCTRL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDITCTRL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDITCTRL_Type v)) |) )\<close>


definition EDHSR_ref  :: \<open>((regstate),(register_value),(EDHSR_Type))register_ref \<close>  where 
     \<open> EDHSR_ref = ( (|
  name = (''EDHSR''),
  read_from = ((\<lambda> s .  (| EDHSR_Type_bits = ((bitvector_64_reg   s) (''EDHSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''EDHSR'') then(EDHSR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDHSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDHSR_Type v)) |) )\<close>


definition EDDFR1_ref  :: \<open>((regstate),(register_value),(EDDFR1_Type))register_ref \<close>  where 
     \<open> EDDFR1_ref = ( (|
  name = (''EDDFR1''),
  read_from = ((\<lambda> s .  (| EDDFR1_Type_bits = ((bitvector_64_reg   s) (''EDDFR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''EDDFR1'') then(EDDFR1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDDFR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDDFR1_Type v)) |) )\<close>


definition EDDFR_ref  :: \<open>((regstate),(register_value),(EDDFR_Type))register_ref \<close>  where 
     \<open> EDDFR_ref = ( (|
  name = (''EDDFR''),
  read_from = ((\<lambda> s .  (| EDDFR_Type_bits = ((bitvector_64_reg   s) (''EDDFR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''EDDFR'') then(EDDFR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDDFR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDDFR_Type v)) |) )\<close>


definition EDDEVTYPE_ref  :: \<open>((regstate),(register_value),(EDDEVTYPE_Type))register_ref \<close>  where 
     \<open> EDDEVTYPE_ref = ( (|
  name = (''EDDEVTYPE''),
  read_from = ((\<lambda> s .  (| EDDEVTYPE_Type_bits = ((bitvector_32_reg   s) (''EDDEVTYPE'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDDEVTYPE'') then(EDDEVTYPE_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDDEVTYPE_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDDEVTYPE_Type v)) |) )\<close>


definition EDDEVID2_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> EDDEVID2_ref = ( (|
  name = (''EDDEVID2''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''EDDEVID2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDDEVID2'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition EDDEVID1_ref  :: \<open>((regstate),(register_value),(EDDEVID1_Type))register_ref \<close>  where 
     \<open> EDDEVID1_ref = ( (|
  name = (''EDDEVID1''),
  read_from = ((\<lambda> s .  (| EDDEVID1_Type_bits = ((bitvector_32_reg   s) (''EDDEVID1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDDEVID1'') then(EDDEVID1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDDEVID1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDDEVID1_Type v)) |) )\<close>


definition EDDEVID_ref  :: \<open>((regstate),(register_value),(EDDEVID_Type))register_ref \<close>  where 
     \<open> EDDEVID_ref = ( (|
  name = (''EDDEVID''),
  read_from = ((\<lambda> s .  (| EDDEVID_Type_bits = ((bitvector_32_reg   s) (''EDDEVID'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDDEVID'') then(EDDEVID_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDDEVID_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDDEVID_Type v)) |) )\<close>


definition EDCIDR3_ref  :: \<open>((regstate),(register_value),(EDCIDR3_Type))register_ref \<close>  where 
     \<open> EDCIDR3_ref = ( (|
  name = (''EDCIDR3''),
  read_from = ((\<lambda> s .  (| EDCIDR3_Type_bits = ((bitvector_32_reg   s) (''EDCIDR3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDCIDR3'') then(EDCIDR3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDCIDR3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDCIDR3_Type v)) |) )\<close>


definition EDCIDR2_ref  :: \<open>((regstate),(register_value),(EDCIDR2_Type))register_ref \<close>  where 
     \<open> EDCIDR2_ref = ( (|
  name = (''EDCIDR2''),
  read_from = ((\<lambda> s .  (| EDCIDR2_Type_bits = ((bitvector_32_reg   s) (''EDCIDR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDCIDR2'') then(EDCIDR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDCIDR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDCIDR2_Type v)) |) )\<close>


definition EDCIDR1_ref  :: \<open>((regstate),(register_value),(EDCIDR1_Type))register_ref \<close>  where 
     \<open> EDCIDR1_ref = ( (|
  name = (''EDCIDR1''),
  read_from = ((\<lambda> s .  (| EDCIDR1_Type_bits = ((bitvector_32_reg   s) (''EDCIDR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDCIDR1'') then(EDCIDR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDCIDR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDCIDR1_Type v)) |) )\<close>


definition EDCIDR0_ref  :: \<open>((regstate),(register_value),(EDCIDR0_Type))register_ref \<close>  where 
     \<open> EDCIDR0_ref = ( (|
  name = (''EDCIDR0''),
  read_from = ((\<lambda> s .  (| EDCIDR0_Type_bits = ((bitvector_32_reg   s) (''EDCIDR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDCIDR0'') then(EDCIDR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDCIDR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDCIDR0_Type v)) |) )\<close>


definition EDAA32PFR_ref  :: \<open>((regstate),(register_value),(EDAA32PFR_Type))register_ref \<close>  where 
     \<open> EDAA32PFR_ref = ( (|
  name = (''EDAA32PFR''),
  read_from = ((\<lambda> s .  (| EDAA32PFR_Type_bits = ((bitvector_64_reg   s) (''EDAA32PFR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''EDAA32PFR'') then(EDAA32PFR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDAA32PFR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDAA32PFR_Type v)) |) )\<close>


definition DBGWFAR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> DBGWFAR_ref = ( (|
  name = (''DBGWFAR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''DBGWFAR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''DBGWFAR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition DBGVCR_ref  :: \<open>((regstate),(register_value),(DBGVCR_Type))register_ref \<close>  where 
     \<open> DBGVCR_ref = ( (|
  name = (''_DBGVCR''),
  read_from = ((\<lambda> s .  (| DBGVCR_Type_bits = ((bitvector_32_reg   s) (''_DBGVCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGVCR'') then(DBGVCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGVCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGVCR_Type v)) |) )\<close>


definition DBGVCR32_EL2_ref  :: \<open>((regstate),(register_value),(DBGVCR32_EL2_Type))register_ref \<close>  where 
     \<open> DBGVCR32_EL2_ref = ( (|
  name = (''DBGVCR32_EL2''),
  read_from = ((\<lambda> s .  (| DBGVCR32_EL2_Type_bits = ((bitvector_64_reg   s) (''DBGVCR32_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DBGVCR32_EL2'') then(DBGVCR32_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGVCR32_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGVCR32_EL2_Type v)) |) )\<close>


definition DBGDSAR_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> DBGDSAR_ref = ( (|
  name = (''DBGDSAR''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''DBGDSAR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DBGDSAR'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition DBGDRAR_ref  :: \<open>((regstate),(register_value),(DBGDRAR_Type))register_ref \<close>  where 
     \<open> DBGDRAR_ref = ( (|
  name = (''_DBGDRAR''),
  read_from = ((\<lambda> s .  (| DBGDRAR_Type_bits = ((bitvector_64_reg   s) (''_DBGDRAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_DBGDRAR'') then(DBGDRAR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDRAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDRAR_Type v)) |) )\<close>


definition MDRAR_EL1_ref  :: \<open>((regstate),(register_value),(MDRAR_EL1_Type))register_ref \<close>  where 
     \<open> MDRAR_EL1_ref = ( (|
  name = (''MDRAR_EL1''),
  read_from = ((\<lambda> s .  (| MDRAR_EL1_Type_bits = ((bitvector_64_reg   s) (''MDRAR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MDRAR_EL1'') then(MDRAR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MDRAR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MDRAR_EL1_Type v)) |) )\<close>


definition DBGDIDR_ref  :: \<open>((regstate),(register_value),(DBGDIDR_Type))register_ref \<close>  where 
     \<open> DBGDIDR_ref = ( (|
  name = (''DBGDIDR''),
  read_from = ((\<lambda> s .  (| DBGDIDR_Type_bits = ((bitvector_32_reg   s) (''DBGDIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''DBGDIDR'') then(DBGDIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDIDR_Type v)) |) )\<close>


definition DBGDEVID2_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> DBGDEVID2_ref = ( (|
  name = (''DBGDEVID2''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''DBGDEVID2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''DBGDEVID2'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition DBGDEVID1_ref  :: \<open>((regstate),(register_value),(DBGDEVID1_Type))register_ref \<close>  where 
     \<open> DBGDEVID1_ref = ( (|
  name = (''DBGDEVID1''),
  read_from = ((\<lambda> s .  (| DBGDEVID1_Type_bits = ((bitvector_32_reg   s) (''DBGDEVID1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''DBGDEVID1'') then(DBGDEVID1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDEVID1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDEVID1_Type v)) |) )\<close>


definition DBGDCCINT_ref  :: \<open>((regstate),(register_value),(DBGDCCINT_Type))register_ref \<close>  where 
     \<open> DBGDCCINT_ref = ( (|
  name = (''_DBGDCCINT''),
  read_from = ((\<lambda> s .  (| DBGDCCINT_Type_bits = ((bitvector_32_reg   s) (''_DBGDCCINT'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGDCCINT'') then(DBGDCCINT_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDCCINT_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDCCINT_Type v)) |) )\<close>


definition MDCCINT_EL1_ref  :: \<open>((regstate),(register_value),(MDCCINT_EL1_Type))register_ref \<close>  where 
     \<open> MDCCINT_EL1_ref = ( (|
  name = (''MDCCINT_EL1''),
  read_from = ((\<lambda> s .  (| MDCCINT_EL1_Type_bits = ((bitvector_64_reg   s) (''MDCCINT_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MDCCINT_EL1'') then(MDCCINT_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MDCCINT_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MDCCINT_EL1_Type v)) |) )\<close>


definition DBGCLAIMSET_ref  :: \<open>((regstate),(register_value),(DBGCLAIMSET_Type))register_ref \<close>  where 
     \<open> DBGCLAIMSET_ref = ( (|
  name = (''_DBGCLAIMSET''),
  read_from = ((\<lambda> s .  (| DBGCLAIMSET_Type_bits = ((bitvector_32_reg   s) (''_DBGCLAIMSET'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGCLAIMSET'') then(DBGCLAIMSET_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGCLAIMSET_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGCLAIMSET_Type v)) |) )\<close>


definition DBGCLAIMSET_EL1_ref  :: \<open>((regstate),(register_value),(DBGCLAIMSET_EL1_Type))register_ref \<close>  where 
     \<open> DBGCLAIMSET_EL1_ref = ( (|
  name = (''DBGCLAIMSET_EL1''),
  read_from = ((\<lambda> s .  (| DBGCLAIMSET_EL1_Type_bits = ((bitvector_64_reg   s) (''DBGCLAIMSET_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DBGCLAIMSET_EL1'') then(DBGCLAIMSET_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGCLAIMSET_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGCLAIMSET_EL1_Type v)) |) )\<close>


definition DBGCLAIMCLR_ref  :: \<open>((regstate),(register_value),(DBGCLAIMCLR_Type))register_ref \<close>  where 
     \<open> DBGCLAIMCLR_ref = ( (|
  name = (''_DBGCLAIMCLR''),
  read_from = ((\<lambda> s .  (| DBGCLAIMCLR_Type_bits = ((bitvector_32_reg   s) (''_DBGCLAIMCLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGCLAIMCLR'') then(DBGCLAIMCLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGCLAIMCLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGCLAIMCLR_Type v)) |) )\<close>


definition DBGCLAIMCLR_EL1_ref  :: \<open>((regstate),(register_value),(DBGCLAIMCLR_EL1_Type))register_ref \<close>  where 
     \<open> DBGCLAIMCLR_EL1_ref = ( (|
  name = (''DBGCLAIMCLR_EL1''),
  read_from = ((\<lambda> s .  (| DBGCLAIMCLR_EL1_Type_bits = ((bitvector_64_reg   s) (''DBGCLAIMCLR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DBGCLAIMCLR_EL1'') then(DBGCLAIMCLR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGCLAIMCLR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGCLAIMCLR_EL1_Type v)) |) )\<close>


definition DBGAUTHSTATUS_ref  :: \<open>((regstate),(register_value),(DBGAUTHSTATUS_Type))register_ref \<close>  where 
     \<open> DBGAUTHSTATUS_ref = ( (|
  name = (''_DBGAUTHSTATUS''),
  read_from = ((\<lambda> s .  (| DBGAUTHSTATUS_Type_bits = ((bitvector_32_reg   s) (''_DBGAUTHSTATUS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGAUTHSTATUS'') then(DBGAUTHSTATUS_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGAUTHSTATUS_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGAUTHSTATUS_Type v)) |) )\<close>


definition DBGAUTHSTATUS_EL1_ref  :: \<open>((regstate),(register_value),(DBGAUTHSTATUS_EL1_Type))register_ref \<close>  where 
     \<open> DBGAUTHSTATUS_EL1_ref = ( (|
  name = (''DBGAUTHSTATUS_EL1''),
  read_from = ((\<lambda> s .  (| DBGAUTHSTATUS_EL1_Type_bits = ((bitvector_64_reg   s) (''DBGAUTHSTATUS_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DBGAUTHSTATUS_EL1'') then(DBGAUTHSTATUS_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGAUTHSTATUS_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGAUTHSTATUS_EL1_Type v)) |) )\<close>


definition CTR_ref  :: \<open>((regstate),(register_value),(CTR_Type))register_ref \<close>  where 
     \<open> CTR_ref = ( (|
  name = (''_CTR''),
  read_from = ((\<lambda> s .  (| CTR_Type_bits = ((bitvector_32_reg   s) (''_CTR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CTR'') then(CTR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTR_Type v)) |) )\<close>


definition CTIPIDR4_ref  :: \<open>((regstate),(register_value),(CTIPIDR4_Type))register_ref \<close>  where 
     \<open> CTIPIDR4_ref = ( (|
  name = (''CTIPIDR4''),
  read_from = ((\<lambda> s .  (| CTIPIDR4_Type_bits = ((bitvector_32_reg   s) (''CTIPIDR4'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIPIDR4'') then(CTIPIDR4_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIPIDR4_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIPIDR4_Type v)) |) )\<close>


definition CTIPIDR3_ref  :: \<open>((regstate),(register_value),(CTIPIDR3_Type))register_ref \<close>  where 
     \<open> CTIPIDR3_ref = ( (|
  name = (''CTIPIDR3''),
  read_from = ((\<lambda> s .  (| CTIPIDR3_Type_bits = ((bitvector_32_reg   s) (''CTIPIDR3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIPIDR3'') then(CTIPIDR3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIPIDR3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIPIDR3_Type v)) |) )\<close>


definition CTIPIDR2_ref  :: \<open>((regstate),(register_value),(CTIPIDR2_Type))register_ref \<close>  where 
     \<open> CTIPIDR2_ref = ( (|
  name = (''CTIPIDR2''),
  read_from = ((\<lambda> s .  (| CTIPIDR2_Type_bits = ((bitvector_32_reg   s) (''CTIPIDR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIPIDR2'') then(CTIPIDR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIPIDR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIPIDR2_Type v)) |) )\<close>


definition CTIPIDR1_ref  :: \<open>((regstate),(register_value),(CTIPIDR1_Type))register_ref \<close>  where 
     \<open> CTIPIDR1_ref = ( (|
  name = (''CTIPIDR1''),
  read_from = ((\<lambda> s .  (| CTIPIDR1_Type_bits = ((bitvector_32_reg   s) (''CTIPIDR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIPIDR1'') then(CTIPIDR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIPIDR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIPIDR1_Type v)) |) )\<close>


definition CTIPIDR0_ref  :: \<open>((regstate),(register_value),(CTIPIDR0_Type))register_ref \<close>  where 
     \<open> CTIPIDR0_ref = ( (|
  name = (''CTIPIDR0''),
  read_from = ((\<lambda> s .  (| CTIPIDR0_Type_bits = ((bitvector_32_reg   s) (''CTIPIDR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIPIDR0'') then(CTIPIDR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIPIDR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIPIDR0_Type v)) |) )\<close>


definition CTILSR_ref  :: \<open>((regstate),(register_value),(CTILSR_Type))register_ref \<close>  where 
     \<open> CTILSR_ref = ( (|
  name = (''CTILSR''),
  read_from = ((\<lambda> s .  (| CTILSR_Type_bits = ((bitvector_32_reg   s) (''CTILSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTILSR'') then(CTILSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTILSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTILSR_Type v)) |) )\<close>


definition CTILAR_ref  :: \<open>((regstate),(register_value),(CTILAR_Type))register_ref \<close>  where 
     \<open> CTILAR_ref = ( (|
  name = (''CTILAR''),
  read_from = ((\<lambda> s .  (| CTILAR_Type_bits = ((bitvector_32_reg   s) (''CTILAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTILAR'') then(CTILAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTILAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTILAR_Type v)) |) )\<close>


definition CTIITCTRL_ref  :: \<open>((regstate),(register_value),(CTIITCTRL_Type))register_ref \<close>  where 
     \<open> CTIITCTRL_ref = ( (|
  name = (''CTIITCTRL''),
  read_from = ((\<lambda> s .  (| CTIITCTRL_Type_bits = ((bitvector_32_reg   s) (''CTIITCTRL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIITCTRL'') then(CTIITCTRL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIITCTRL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIITCTRL_Type v)) |) )\<close>


definition CTIDEVTYPE_ref  :: \<open>((regstate),(register_value),(CTIDEVTYPE_Type))register_ref \<close>  where 
     \<open> CTIDEVTYPE_ref = ( (|
  name = (''CTIDEVTYPE''),
  read_from = ((\<lambda> s .  (| CTIDEVTYPE_Type_bits = ((bitvector_32_reg   s) (''CTIDEVTYPE'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIDEVTYPE'') then(CTIDEVTYPE_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIDEVTYPE_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIDEVTYPE_Type v)) |) )\<close>


definition CTIDEVID2_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> CTIDEVID2_ref = ( (|
  name = (''CTIDEVID2''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''CTIDEVID2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIDEVID2'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition CTIDEVID1_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> CTIDEVID1_ref = ( (|
  name = (''CTIDEVID1''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''CTIDEVID1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIDEVID1'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition CTIDEVID_ref  :: \<open>((regstate),(register_value),(CTIDEVID_Type))register_ref \<close>  where 
     \<open> CTIDEVID_ref = ( (|
  name = (''CTIDEVID''),
  read_from = ((\<lambda> s .  (| CTIDEVID_Type_bits = ((bitvector_32_reg   s) (''CTIDEVID'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIDEVID'') then(CTIDEVID_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIDEVID_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIDEVID_Type v)) |) )\<close>


definition CTIDEVCTL_ref  :: \<open>((regstate),(register_value),(CTIDEVCTL_Type))register_ref \<close>  where 
     \<open> CTIDEVCTL_ref = ( (|
  name = (''CTIDEVCTL''),
  read_from = ((\<lambda> s .  (| CTIDEVCTL_Type_bits = ((bitvector_32_reg   s) (''CTIDEVCTL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIDEVCTL'') then(CTIDEVCTL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIDEVCTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIDEVCTL_Type v)) |) )\<close>


definition CTICONTROL_ref  :: \<open>((regstate),(register_value),(CTICONTROL_Type))register_ref \<close>  where 
     \<open> CTICONTROL_ref = ( (|
  name = (''CTICONTROL''),
  read_from = ((\<lambda> s .  (| CTICONTROL_Type_bits = ((bitvector_32_reg   s) (''CTICONTROL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTICONTROL'') then(CTICONTROL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTICONTROL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTICONTROL_Type v)) |) )\<close>


definition CTICIDR3_ref  :: \<open>((regstate),(register_value),(CTICIDR3_Type))register_ref \<close>  where 
     \<open> CTICIDR3_ref = ( (|
  name = (''CTICIDR3''),
  read_from = ((\<lambda> s .  (| CTICIDR3_Type_bits = ((bitvector_32_reg   s) (''CTICIDR3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTICIDR3'') then(CTICIDR3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTICIDR3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTICIDR3_Type v)) |) )\<close>


definition CTICIDR2_ref  :: \<open>((regstate),(register_value),(CTICIDR2_Type))register_ref \<close>  where 
     \<open> CTICIDR2_ref = ( (|
  name = (''CTICIDR2''),
  read_from = ((\<lambda> s .  (| CTICIDR2_Type_bits = ((bitvector_32_reg   s) (''CTICIDR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTICIDR2'') then(CTICIDR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTICIDR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTICIDR2_Type v)) |) )\<close>


definition CTICIDR1_ref  :: \<open>((regstate),(register_value),(CTICIDR1_Type))register_ref \<close>  where 
     \<open> CTICIDR1_ref = ( (|
  name = (''CTICIDR1''),
  read_from = ((\<lambda> s .  (| CTICIDR1_Type_bits = ((bitvector_32_reg   s) (''CTICIDR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTICIDR1'') then(CTICIDR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTICIDR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTICIDR1_Type v)) |) )\<close>


definition CTICIDR0_ref  :: \<open>((regstate),(register_value),(CTICIDR0_Type))register_ref \<close>  where 
     \<open> CTICIDR0_ref = ( (|
  name = (''CTICIDR0''),
  read_from = ((\<lambda> s .  (| CTICIDR0_Type_bits = ((bitvector_32_reg   s) (''CTICIDR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTICIDR0'') then(CTICIDR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTICIDR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTICIDR0_Type v)) |) )\<close>


definition CTIAUTHSTATUS_ref  :: \<open>((regstate),(register_value),(CTIAUTHSTATUS_Type))register_ref \<close>  where 
     \<open> CTIAUTHSTATUS_ref = ( (|
  name = (''CTIAUTHSTATUS''),
  read_from = ((\<lambda> s .  (| CTIAUTHSTATUS_Type_bits = ((bitvector_32_reg   s) (''CTIAUTHSTATUS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CTIAUTHSTATUS'') then(CTIAUTHSTATUS_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTIAUTHSTATUS_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTIAUTHSTATUS_Type v)) |) )\<close>


definition CSSELR_S_ref  :: \<open>((regstate),(register_value),(CSSELR_Type))register_ref \<close>  where 
     \<open> CSSELR_S_ref = ( (|
  name = (''CSSELR_S''),
  read_from = ((\<lambda> s .  (| CSSELR_Type_bits = ((bitvector_32_reg   s) (''CSSELR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CSSELR_S'') then(CSSELR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CSSELR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CSSELR_Type v)) |) )\<close>


definition CSSELR_NS_ref  :: \<open>((regstate),(register_value),(CSSELR_Type))register_ref \<close>  where 
     \<open> CSSELR_NS_ref = ( (|
  name = (''_CSSELR_NS''),
  read_from = ((\<lambda> s .  (| CSSELR_Type_bits = ((bitvector_32_reg   s) (''_CSSELR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CSSELR_NS'') then(CSSELR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CSSELR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CSSELR_Type v)) |) )\<close>


definition CSSELR_EL1_ref  :: \<open>((regstate),(register_value),(CSSELR_EL1_Type))register_ref \<close>  where 
     \<open> CSSELR_EL1_ref = ( (|
  name = (''CSSELR_EL1''),
  read_from = ((\<lambda> s .  (| CSSELR_EL1_Type_bits = ((bitvector_64_reg   s) (''CSSELR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CSSELR_EL1'') then(CSSELR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CSSELR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CSSELR_EL1_Type v)) |) )\<close>


definition CNTV_CTL_ref  :: \<open>((regstate),(register_value),(CNTV_CTL_Type))register_ref \<close>  where 
     \<open> CNTV_CTL_ref = ( (|
  name = (''_CNTV_CTL''),
  read_from = ((\<lambda> s .  (| CNTV_CTL_Type_bits = ((bitvector_32_reg   s) (''_CNTV_CTL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CNTV_CTL'') then(CNTV_CTL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTV_CTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTV_CTL_Type v)) |) )\<close>


definition CNTSR_ref  :: \<open>((regstate),(register_value),(CNTSR_Type))register_ref \<close>  where 
     \<open> CNTSR_ref = ( (|
  name = (''CNTSR''),
  read_from = ((\<lambda> s .  (| CNTSR_Type_bits = ((bitvector_32_reg   s) (''CNTSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CNTSR'') then(CNTSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTSR_Type v)) |) )\<close>


definition CNTNSAR_ref  :: \<open>((regstate),(register_value),(CNTNSAR_Type))register_ref \<close>  where 
     \<open> CNTNSAR_ref = ( (|
  name = (''CNTNSAR''),
  read_from = ((\<lambda> s .  (| CNTNSAR_Type_bits = ((bitvector_32_reg   s) (''CNTNSAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CNTNSAR'') then(CNTNSAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTNSAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTNSAR_Type v)) |) )\<close>


definition CNTID_ref  :: \<open>((regstate),(register_value),(CNTID_Type))register_ref \<close>  where 
     \<open> CNTID_ref = ( (|
  name = (''CNTID''),
  read_from = ((\<lambda> s .  (| CNTID_Type_bits = ((bitvector_32_reg   s) (''CNTID'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CNTID'') then(CNTID_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTID_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTID_Type v)) |) )\<close>


definition CNTHV_CTL_ref  :: \<open>((regstate),(register_value),(CNTHV_CTL_Type))register_ref \<close>  where 
     \<open> CNTHV_CTL_ref = ( (|
  name = (''_CNTHV_CTL''),
  read_from = ((\<lambda> s .  (| CNTHV_CTL_Type_bits = ((bitvector_32_reg   s) (''_CNTHV_CTL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CNTHV_CTL'') then(CNTHV_CTL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHV_CTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHV_CTL_Type v)) |) )\<close>


definition CNTHVS_CTL_ref  :: \<open>((regstate),(register_value),(CNTHVS_CTL_Type))register_ref \<close>  where 
     \<open> CNTHVS_CTL_ref = ( (|
  name = (''_CNTHVS_CTL''),
  read_from = ((\<lambda> s .  (| CNTHVS_CTL_Type_bits = ((bitvector_32_reg   s) (''_CNTHVS_CTL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CNTHVS_CTL'') then(CNTHVS_CTL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHVS_CTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHVS_CTL_Type v)) |) )\<close>


definition CNTHPS_CTL_ref  :: \<open>((regstate),(register_value),(CNTHPS_CTL_Type))register_ref \<close>  where 
     \<open> CNTHPS_CTL_ref = ( (|
  name = (''_CNTHPS_CTL''),
  read_from = ((\<lambda> s .  (| CNTHPS_CTL_Type_bits = ((bitvector_32_reg   s) (''_CNTHPS_CTL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CNTHPS_CTL'') then(CNTHPS_CTL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHPS_CTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHPS_CTL_Type v)) |) )\<close>


definition CNTHCTL_ref  :: \<open>((regstate),(register_value),(CNTHCTL_Type))register_ref \<close>  where 
     \<open> CNTHCTL_ref = ( (|
  name = (''_CNTHCTL''),
  read_from = ((\<lambda> s .  (| CNTHCTL_Type_bits = ((bitvector_32_reg   s) (''_CNTHCTL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CNTHCTL'') then(CNTHCTL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHCTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHCTL_Type v)) |) )\<close>


definition CNTEL0ACR_ref  :: \<open>((regstate),(register_value),(CNTEL0ACR_Type))register_ref \<close>  where 
     \<open> CNTEL0ACR_ref = ( (|
  name = (''CNTEL0ACR''),
  read_from = ((\<lambda> s .  (| CNTEL0ACR_Type_bits = ((bitvector_32_reg   s) (''CNTEL0ACR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CNTEL0ACR'') then(CNTEL0ACR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTEL0ACR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTEL0ACR_Type v)) |) )\<close>


definition CCSIDR_ref  :: \<open>((regstate),(register_value),(CCSIDR_Type))register_ref \<close>  where 
     \<open> CCSIDR_ref = ( (|
  name = (''_CCSIDR''),
  read_from = ((\<lambda> s .  (| CCSIDR_Type_bits = ((bitvector_32_reg   s) (''_CCSIDR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CCSIDR'') then(CCSIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CCSIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CCSIDR_Type v)) |) )\<close>


definition CCSIDR_EL1_ref  :: \<open>((regstate),(register_value),(CCSIDR_EL1_Type))register_ref \<close>  where 
     \<open> CCSIDR_EL1_ref = ( (|
  name = (''CCSIDR_EL1''),
  read_from = ((\<lambda> s .  (| CCSIDR_EL1_Type_bits = ((bitvector_64_reg   s) (''CCSIDR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CCSIDR_EL1'') then(CCSIDR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CCSIDR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CCSIDR_EL1_Type v)) |) )\<close>


definition CCSIDR2_ref  :: \<open>((regstate),(register_value),(CCSIDR2_Type))register_ref \<close>  where 
     \<open> CCSIDR2_ref = ( (|
  name = (''_CCSIDR2''),
  read_from = ((\<lambda> s .  (| CCSIDR2_Type_bits = ((bitvector_32_reg   s) (''_CCSIDR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CCSIDR2'') then(CCSIDR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CCSIDR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CCSIDR2_Type v)) |) )\<close>


definition CCSIDR2_EL1_ref  :: \<open>((regstate),(register_value),(CCSIDR2_EL1_Type))register_ref \<close>  where 
     \<open> CCSIDR2_EL1_ref = ( (|
  name = (''CCSIDR2_EL1''),
  read_from = ((\<lambda> s .  (| CCSIDR2_EL1_Type_bits = ((bitvector_64_reg   s) (''CCSIDR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CCSIDR2_EL1'') then(CCSIDR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CCSIDR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CCSIDR2_EL1_Type v)) |) )\<close>


definition AMUSERENR_ref  :: \<open>((regstate),(register_value),(AMUSERENR_Type))register_ref \<close>  where 
     \<open> AMUSERENR_ref = ( (|
  name = (''_AMUSERENR''),
  read_from = ((\<lambda> s .  (| AMUSERENR_Type_bits = ((bitvector_32_reg   s) (''_AMUSERENR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AMUSERENR'') then(AMUSERENR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMUSERENR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMUSERENR_Type v)) |) )\<close>


definition AMUSERENR_EL0_ref  :: \<open>((regstate),(register_value),(AMUSERENR_EL0_Type))register_ref \<close>  where 
     \<open> AMUSERENR_EL0_ref = ( (|
  name = (''AMUSERENR_EL0''),
  read_from = ((\<lambda> s .  (| AMUSERENR_EL0_Type_bits = ((bitvector_64_reg   s) (''AMUSERENR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMUSERENR_EL0'') then(AMUSERENR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMUSERENR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMUSERENR_EL0_Type v)) |) )\<close>


definition AMPIDR4_ref  :: \<open>((regstate),(register_value),(AMPIDR4_Type))register_ref \<close>  where 
     \<open> AMPIDR4_ref = ( (|
  name = (''AMPIDR4''),
  read_from = ((\<lambda> s .  (| AMPIDR4_Type_bits = ((bitvector_32_reg   s) (''AMPIDR4'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMPIDR4'') then(AMPIDR4_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMPIDR4_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMPIDR4_Type v)) |) )\<close>


definition AMPIDR3_ref  :: \<open>((regstate),(register_value),(AMPIDR3_Type))register_ref \<close>  where 
     \<open> AMPIDR3_ref = ( (|
  name = (''AMPIDR3''),
  read_from = ((\<lambda> s .  (| AMPIDR3_Type_bits = ((bitvector_32_reg   s) (''AMPIDR3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMPIDR3'') then(AMPIDR3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMPIDR3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMPIDR3_Type v)) |) )\<close>


definition AMPIDR2_ref  :: \<open>((regstate),(register_value),(AMPIDR2_Type))register_ref \<close>  where 
     \<open> AMPIDR2_ref = ( (|
  name = (''AMPIDR2''),
  read_from = ((\<lambda> s .  (| AMPIDR2_Type_bits = ((bitvector_32_reg   s) (''AMPIDR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMPIDR2'') then(AMPIDR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMPIDR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMPIDR2_Type v)) |) )\<close>


definition AMPIDR1_ref  :: \<open>((regstate),(register_value),(AMPIDR1_Type))register_ref \<close>  where 
     \<open> AMPIDR1_ref = ( (|
  name = (''AMPIDR1''),
  read_from = ((\<lambda> s .  (| AMPIDR1_Type_bits = ((bitvector_32_reg   s) (''AMPIDR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMPIDR1'') then(AMPIDR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMPIDR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMPIDR1_Type v)) |) )\<close>


definition AMPIDR0_ref  :: \<open>((regstate),(register_value),(AMPIDR0_Type))register_ref \<close>  where 
     \<open> AMPIDR0_ref = ( (|
  name = (''AMPIDR0''),
  read_from = ((\<lambda> s .  (| AMPIDR0_Type_bits = ((bitvector_32_reg   s) (''AMPIDR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMPIDR0'') then(AMPIDR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMPIDR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMPIDR0_Type v)) |) )\<close>


definition AMDEVTYPE_ref  :: \<open>((regstate),(register_value),(AMDEVTYPE_Type))register_ref \<close>  where 
     \<open> AMDEVTYPE_ref = ( (|
  name = (''AMDEVTYPE''),
  read_from = ((\<lambda> s .  (| AMDEVTYPE_Type_bits = ((bitvector_32_reg   s) (''AMDEVTYPE'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMDEVTYPE'') then(AMDEVTYPE_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMDEVTYPE_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMDEVTYPE_Type v)) |) )\<close>


definition AMCR_ref  :: \<open>((regstate),(register_value),(AMCR_Type))register_ref \<close>  where 
     \<open> AMCR_ref = ( (|
  name = (''_AMCR''),
  read_from = ((\<lambda> s .  (| AMCR_Type_bits = ((bitvector_32_reg   s) (''_AMCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AMCR'') then(AMCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCR_Type v)) |) )\<close>


definition AMCR_EL0_ref  :: \<open>((regstate),(register_value),(AMCR_EL0_Type))register_ref \<close>  where 
     \<open> AMCR_EL0_ref = ( (|
  name = (''AMCR_EL0''),
  read_from = ((\<lambda> s .  (| AMCR_EL0_Type_bits = ((bitvector_64_reg   s) (''AMCR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMCR_EL0'') then(AMCR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCR_EL0_Type v)) |) )\<close>


definition AMCNTENSET1_ref  :: \<open>((regstate),(register_value),(AMCNTENSET1_Type))register_ref \<close>  where 
     \<open> AMCNTENSET1_ref = ( (|
  name = (''_AMCNTENSET1''),
  read_from = ((\<lambda> s .  (| AMCNTENSET1_Type_bits = ((bitvector_32_reg   s) (''_AMCNTENSET1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AMCNTENSET1'') then(AMCNTENSET1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCNTENSET1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCNTENSET1_Type v)) |) )\<close>


definition AMCNTENSET1_EL0_ref  :: \<open>((regstate),(register_value),(AMCNTENSET1_EL0_Type))register_ref \<close>  where 
     \<open> AMCNTENSET1_EL0_ref = ( (|
  name = (''AMCNTENSET1_EL0''),
  read_from = ((\<lambda> s .  (| AMCNTENSET1_EL0_Type_bits = ((bitvector_64_reg   s) (''AMCNTENSET1_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMCNTENSET1_EL0'') then(AMCNTENSET1_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCNTENSET1_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCNTENSET1_EL0_Type v)) |) )\<close>


definition AMCNTENSET0_ref  :: \<open>((regstate),(register_value),(AMCNTENSET0_Type))register_ref \<close>  where 
     \<open> AMCNTENSET0_ref = ( (|
  name = (''_AMCNTENSET0''),
  read_from = ((\<lambda> s .  (| AMCNTENSET0_Type_bits = ((bitvector_32_reg   s) (''_AMCNTENSET0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AMCNTENSET0'') then(AMCNTENSET0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCNTENSET0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCNTENSET0_Type v)) |) )\<close>


definition AMCNTENSET0_EL0_ref  :: \<open>((regstate),(register_value),(AMCNTENSET0_EL0_Type))register_ref \<close>  where 
     \<open> AMCNTENSET0_EL0_ref = ( (|
  name = (''AMCNTENSET0_EL0''),
  read_from = ((\<lambda> s .  (| AMCNTENSET0_EL0_Type_bits = ((bitvector_64_reg   s) (''AMCNTENSET0_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMCNTENSET0_EL0'') then(AMCNTENSET0_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCNTENSET0_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCNTENSET0_EL0_Type v)) |) )\<close>


definition AMCNTENCLR1_ref  :: \<open>((regstate),(register_value),(AMCNTENCLR1_Type))register_ref \<close>  where 
     \<open> AMCNTENCLR1_ref = ( (|
  name = (''_AMCNTENCLR1''),
  read_from = ((\<lambda> s .  (| AMCNTENCLR1_Type_bits = ((bitvector_32_reg   s) (''_AMCNTENCLR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AMCNTENCLR1'') then(AMCNTENCLR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCNTENCLR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCNTENCLR1_Type v)) |) )\<close>


definition AMCNTENCLR1_EL0_ref  :: \<open>((regstate),(register_value),(AMCNTENCLR1_EL0_Type))register_ref \<close>  where 
     \<open> AMCNTENCLR1_EL0_ref = ( (|
  name = (''AMCNTENCLR1_EL0''),
  read_from = ((\<lambda> s .  (| AMCNTENCLR1_EL0_Type_bits = ((bitvector_64_reg   s) (''AMCNTENCLR1_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMCNTENCLR1_EL0'') then(AMCNTENCLR1_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCNTENCLR1_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCNTENCLR1_EL0_Type v)) |) )\<close>


definition AMCNTENCLR0_ref  :: \<open>((regstate),(register_value),(AMCNTENCLR0_Type))register_ref \<close>  where 
     \<open> AMCNTENCLR0_ref = ( (|
  name = (''_AMCNTENCLR0''),
  read_from = ((\<lambda> s .  (| AMCNTENCLR0_Type_bits = ((bitvector_32_reg   s) (''_AMCNTENCLR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AMCNTENCLR0'') then(AMCNTENCLR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCNTENCLR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCNTENCLR0_Type v)) |) )\<close>


definition AMCNTENCLR0_EL0_ref  :: \<open>((regstate),(register_value),(AMCNTENCLR0_EL0_Type))register_ref \<close>  where 
     \<open> AMCNTENCLR0_EL0_ref = ( (|
  name = (''AMCNTENCLR0_EL0''),
  read_from = ((\<lambda> s .  (| AMCNTENCLR0_EL0_Type_bits = ((bitvector_64_reg   s) (''AMCNTENCLR0_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMCNTENCLR0_EL0'') then(AMCNTENCLR0_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCNTENCLR0_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCNTENCLR0_EL0_Type v)) |) )\<close>


definition AMCIDR3_ref  :: \<open>((regstate),(register_value),(AMCIDR3_Type))register_ref \<close>  where 
     \<open> AMCIDR3_ref = ( (|
  name = (''AMCIDR3''),
  read_from = ((\<lambda> s .  (| AMCIDR3_Type_bits = ((bitvector_32_reg   s) (''AMCIDR3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMCIDR3'') then(AMCIDR3_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCIDR3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCIDR3_Type v)) |) )\<close>


definition AMCIDR2_ref  :: \<open>((regstate),(register_value),(AMCIDR2_Type))register_ref \<close>  where 
     \<open> AMCIDR2_ref = ( (|
  name = (''AMCIDR2''),
  read_from = ((\<lambda> s .  (| AMCIDR2_Type_bits = ((bitvector_32_reg   s) (''AMCIDR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMCIDR2'') then(AMCIDR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCIDR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCIDR2_Type v)) |) )\<close>


definition AMCIDR1_ref  :: \<open>((regstate),(register_value),(AMCIDR1_Type))register_ref \<close>  where 
     \<open> AMCIDR1_ref = ( (|
  name = (''AMCIDR1''),
  read_from = ((\<lambda> s .  (| AMCIDR1_Type_bits = ((bitvector_32_reg   s) (''AMCIDR1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMCIDR1'') then(AMCIDR1_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCIDR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCIDR1_Type v)) |) )\<close>


definition AMCIDR0_ref  :: \<open>((regstate),(register_value),(AMCIDR0_Type))register_ref \<close>  where 
     \<open> AMCIDR0_ref = ( (|
  name = (''AMCIDR0''),
  read_from = ((\<lambda> s .  (| AMCIDR0_Type_bits = ((bitvector_32_reg   s) (''AMCIDR0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''AMCIDR0'') then(AMCIDR0_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCIDR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCIDR0_Type v)) |) )\<close>


definition AMCGCR_ref  :: \<open>((regstate),(register_value),(AMCGCR_Type))register_ref \<close>  where 
     \<open> AMCGCR_ref = ( (|
  name = (''_AMCGCR''),
  read_from = ((\<lambda> s .  (| AMCGCR_Type_bits = ((bitvector_32_reg   s) (''_AMCGCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AMCGCR'') then(AMCGCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCGCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCGCR_Type v)) |) )\<close>


definition AMCGCR_EL0_ref  :: \<open>((regstate),(register_value),(AMCGCR_EL0_Type))register_ref \<close>  where 
     \<open> AMCGCR_EL0_ref = ( (|
  name = (''AMCGCR_EL0''),
  read_from = ((\<lambda> s .  (| AMCGCR_EL0_Type_bits = ((bitvector_64_reg   s) (''AMCGCR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMCGCR_EL0'') then(AMCGCR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCGCR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCGCR_EL0_Type v)) |) )\<close>


definition AMCFGR_ref  :: \<open>((regstate),(register_value),(AMCFGR_Type))register_ref \<close>  where 
     \<open> AMCFGR_ref = ( (|
  name = (''_AMCFGR''),
  read_from = ((\<lambda> s .  (| AMCFGR_Type_bits = ((bitvector_32_reg   s) (''_AMCFGR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_AMCFGR'') then(AMCFGR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCFGR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCFGR_Type v)) |) )\<close>


definition AMCFGR_EL0_ref  :: \<open>((regstate),(register_value),(AMCFGR_EL0_Type))register_ref \<close>  where 
     \<open> AMCFGR_EL0_ref = ( (|
  name = (''AMCFGR_EL0''),
  read_from = ((\<lambda> s .  (| AMCFGR_EL0_Type_bits = ((bitvector_64_reg   s) (''AMCFGR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''AMCFGR_EL0'') then(AMCFGR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  AMCFGR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_AMCFGR_EL0_Type v)) |) )\<close>


definition RVBAR_EL3_ref  :: \<open>((regstate),(register_value),(RVBAR_EL3_Type))register_ref \<close>  where 
     \<open> RVBAR_EL3_ref = ( (|
  name = (''RVBAR_EL3''),
  read_from = ((\<lambda> s .  (| RVBAR_EL3_Type_bits = ((bitvector_64_reg   s) (''RVBAR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''RVBAR_EL3'') then(RVBAR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RVBAR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RVBAR_EL3_Type v)) |) )\<close>


definition RVBAR_EL2_ref  :: \<open>((regstate),(register_value),(RVBAR_EL2_Type))register_ref \<close>  where 
     \<open> RVBAR_EL2_ref = ( (|
  name = (''RVBAR_EL2''),
  read_from = ((\<lambda> s .  (| RVBAR_EL2_Type_bits = ((bitvector_64_reg   s) (''RVBAR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''RVBAR_EL2'') then(RVBAR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RVBAR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RVBAR_EL2_Type v)) |) )\<close>


definition RVBAR_EL1_ref  :: \<open>((regstate),(register_value),(RVBAR_EL1_Type))register_ref \<close>  where 
     \<open> RVBAR_EL1_ref = ( (|
  name = (''RVBAR_EL1''),
  read_from = ((\<lambda> s .  (| RVBAR_EL1_Type_bits = ((bitvector_64_reg   s) (''RVBAR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''RVBAR_EL1'') then(RVBAR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RVBAR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RVBAR_EL1_Type v)) |) )\<close>


definition VDISR_ref  :: \<open>((regstate),(register_value),(VDISR_Type))register_ref \<close>  where 
     \<open> VDISR_ref = ( (|
  name = (''_VDISR''),
  read_from = ((\<lambda> s .  (| VDISR_Type_bits = ((bitvector_32_reg   s) (''_VDISR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_VDISR'') then(VDISR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VDISR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VDISR_Type v)) |) )\<close>


definition VDISR_EL2_ref  :: \<open>((regstate),(register_value),(VDISR_EL2_Type))register_ref \<close>  where 
     \<open> VDISR_EL2_ref = ( (|
  name = (''VDISR_EL2''),
  read_from = ((\<lambda> s .  (| VDISR_EL2_Type_bits = ((bitvector_64_reg   s) (''VDISR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VDISR_EL2'') then(VDISR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VDISR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VDISR_EL2_Type v)) |) )\<close>


definition VDFSR_ref  :: \<open>((regstate),(register_value),(VDFSR_Type))register_ref \<close>  where 
     \<open> VDFSR_ref = ( (|
  name = (''_VDFSR''),
  read_from = ((\<lambda> s .  (| VDFSR_Type_bits = ((bitvector_32_reg   s) (''_VDFSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_VDFSR'') then(VDFSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VDFSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VDFSR_Type v)) |) )\<close>


definition VSESR_EL2_ref  :: \<open>((regstate),(register_value),(VSESR_EL2_Type))register_ref \<close>  where 
     \<open> VSESR_EL2_ref = ( (|
  name = (''VSESR_EL2''),
  read_from = ((\<lambda> s .  (| VSESR_EL2_Type_bits = ((bitvector_64_reg   s) (''VSESR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VSESR_EL2'') then(VSESR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VSESR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VSESR_EL2_Type v)) |) )\<close>


definition DISR_ref  :: \<open>((regstate),(register_value),(DISR_Type))register_ref \<close>  where 
     \<open> DISR_ref = ( (|
  name = (''_DISR''),
  read_from = ((\<lambda> s .  (| DISR_Type_bits = ((bitvector_32_reg   s) (''_DISR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DISR'') then(DISR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DISR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DISR_Type v)) |) )\<close>


definition DISR_EL1_ref  :: \<open>((regstate),(register_value),(DISR_EL1_Type))register_ref \<close>  where 
     \<open> DISR_EL1_ref = ( (|
  name = (''DISR_EL1''),
  read_from = ((\<lambda> s .  (| DISR_EL1_Type_bits = ((bitvector_64_reg   s) (''DISR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DISR_EL1'') then(DISR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DISR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DISR_EL1_Type v)) |) )\<close>


definition HFGITR_EL2_ref  :: \<open>((regstate),(register_value),(HFGITR_EL2_Type))register_ref \<close>  where 
     \<open> HFGITR_EL2_ref = ( (|
  name = (''HFGITR_EL2''),
  read_from = ((\<lambda> s .  (| HFGITR_EL2_Type_bits = ((bitvector_64_reg   s) (''HFGITR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HFGITR_EL2'') then(HFGITR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HFGITR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HFGITR_EL2_Type v)) |) )\<close>


definition VNCR_EL2_ref  :: \<open>((regstate),(register_value),(VNCR_EL2_Type))register_ref \<close>  where 
     \<open> VNCR_EL2_ref = ( (|
  name = (''VNCR_EL2''),
  read_from = ((\<lambda> s .  (| VNCR_EL2_Type_bits = ((bitvector_64_reg   s) (''VNCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VNCR_EL2'') then(VNCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VNCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VNCR_EL2_Type v)) |) )\<close>


definition RCWSMASK_EL1_ref  :: \<open>((regstate),(register_value),(RCWSMASK_EL1_Type))register_ref \<close>  where 
     \<open> RCWSMASK_EL1_ref = ( (|
  name = (''RCWSMASK_EL1''),
  read_from = ((\<lambda> s .  (| RCWSMASK_EL1_Type_bits = ((bitvector_128_reg   s) (''RCWSMASK_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_128_reg :=
  ((\<lambda> reg .  if reg = (''RCWSMASK_EL1'') then(RCWSMASK_EL1_Type_bits   v) else(bitvector_128_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RCWSMASK_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RCWSMASK_EL1_Type v)) |) )\<close>


definition RCWMASK_EL1_ref  :: \<open>((regstate),(register_value),(RCWMASK_EL1_Type))register_ref \<close>  where 
     \<open> RCWMASK_EL1_ref = ( (|
  name = (''RCWMASK_EL1''),
  read_from = ((\<lambda> s .  (| RCWMASK_EL1_Type_bits = ((bitvector_128_reg   s) (''RCWMASK_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_128_reg :=
  ((\<lambda> reg .  if reg = (''RCWMASK_EL1'') then(RCWMASK_EL1_Type_bits   v) else(bitvector_128_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RCWMASK_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RCWMASK_EL1_Type v)) |) )\<close>


definition SPESampleCounterValid_ref  :: \<open>((regstate),(register_value),((bool)list))register_ref \<close>  where 
     \<open> SPESampleCounterValid_ref = ( (|
  name = (''SPESampleCounterValid''),
  read_from = ((\<lambda> s . (vector_32_bool_reg   s) (''SPESampleCounterValid''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleCounterValid'') then v else(vector_32_bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bool_of_register_value v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  register_value_of_bool v)) v)) |) )\<close>


definition SPESampleCounterPending_ref  :: \<open>((regstate),(register_value),((bool)list))register_ref \<close>  where 
     \<open> SPESampleCounterPending_ref = ( (|
  name = (''SPESampleCounterPending''),
  read_from = ((\<lambda> s . (vector_32_bool_reg   s) (''SPESampleCounterPending''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleCounterPending'') then v else(vector_32_bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bool_of_register_value v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  register_value_of_bool v)) v)) |) )\<close>


definition VMECID_A_EL2_ref  :: \<open>((regstate),(register_value),(VMECID_A_EL2_Type))register_ref \<close>  where 
     \<open> VMECID_A_EL2_ref = ( (|
  name = (''VMECID_A_EL2''),
  read_from = ((\<lambda> s .  (| VMECID_A_EL2_Type_bits = ((bitvector_64_reg   s) (''VMECID_A_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VMECID_A_EL2'') then(VMECID_A_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VMECID_A_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VMECID_A_EL2_Type v)) |) )\<close>


definition S2POR_EL1_ref  :: \<open>((regstate),(register_value),(S2POR_EL1_Type))register_ref \<close>  where 
     \<open> S2POR_EL1_ref = ( (|
  name = (''S2POR_EL1''),
  read_from = ((\<lambda> s .  (| S2POR_EL1_Type_bits = ((bitvector_64_reg   s) (''S2POR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''S2POR_EL1'') then(S2POR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  S2POR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_S2POR_EL1_Type v)) |) )\<close>


definition VSTTBR_EL2_ref  :: \<open>((regstate),(register_value),(VSTTBR_EL2_Type))register_ref \<close>  where 
     \<open> VSTTBR_EL2_ref = ( (|
  name = (''VSTTBR_EL2''),
  read_from = ((\<lambda> s .  (| VSTTBR_EL2_Type_bits = ((bitvector_64_reg   s) (''VSTTBR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VSTTBR_EL2'') then(VSTTBR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VSTTBR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VSTTBR_EL2_Type v)) |) )\<close>


definition VSTCR_EL2_ref  :: \<open>((regstate),(register_value),(VSTCR_EL2_Type))register_ref \<close>  where 
     \<open> VSTCR_EL2_ref = ( (|
  name = (''VSTCR_EL2''),
  read_from = ((\<lambda> s .  (| VSTCR_EL2_Type_bits = ((bitvector_64_reg   s) (''VSTCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VSTCR_EL2'') then(VSTCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VSTCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VSTCR_EL2_Type v)) |) )\<close>


definition S2PIR_EL2_ref  :: \<open>((regstate),(register_value),(S2PIR_EL2_Type))register_ref \<close>  where 
     \<open> S2PIR_EL2_ref = ( (|
  name = (''S2PIR_EL2''),
  read_from = ((\<lambda> s .  (| S2PIR_EL2_Type_bits = ((bitvector_64_reg   s) (''S2PIR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''S2PIR_EL2'') then(S2PIR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  S2PIR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_S2PIR_EL2_Type v)) |) )\<close>


definition MECID_RL_A_EL3_ref  :: \<open>((regstate),(register_value),(MECID_RL_A_EL3_Type))register_ref \<close>  where 
     \<open> MECID_RL_A_EL3_ref = ( (|
  name = (''MECID_RL_A_EL3''),
  read_from = ((\<lambda> s .  (| MECID_RL_A_EL3_Type_bits = ((bitvector_64_reg   s) (''MECID_RL_A_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MECID_RL_A_EL3'') then(MECID_RL_A_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MECID_RL_A_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MECID_RL_A_EL3_Type v)) |) )\<close>


definition MECID_P1_EL2_ref  :: \<open>((regstate),(register_value),(MECID_P1_EL2_Type))register_ref \<close>  where 
     \<open> MECID_P1_EL2_ref = ( (|
  name = (''MECID_P1_EL2''),
  read_from = ((\<lambda> s .  (| MECID_P1_EL2_Type_bits = ((bitvector_64_reg   s) (''MECID_P1_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MECID_P1_EL2'') then(MECID_P1_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MECID_P1_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MECID_P1_EL2_Type v)) |) )\<close>


definition MECID_A1_EL2_ref  :: \<open>((regstate),(register_value),(MECID_A1_EL2_Type))register_ref \<close>  where 
     \<open> MECID_A1_EL2_ref = ( (|
  name = (''MECID_A1_EL2''),
  read_from = ((\<lambda> s .  (| MECID_A1_EL2_Type_bits = ((bitvector_64_reg   s) (''MECID_A1_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MECID_A1_EL2'') then(MECID_A1_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MECID_A1_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MECID_A1_EL2_Type v)) |) )\<close>


definition MECID_A0_EL2_ref  :: \<open>((regstate),(register_value),(MECID_A0_EL2_Type))register_ref \<close>  where 
     \<open> MECID_A0_EL2_ref = ( (|
  name = (''MECID_A0_EL2''),
  read_from = ((\<lambda> s .  (| MECID_A0_EL2_Type_bits = ((bitvector_64_reg   s) (''MECID_A0_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MECID_A0_EL2'') then(MECID_A0_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MECID_A0_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MECID_A0_EL2_Type v)) |) )\<close>


definition VMECID_P_EL2_ref  :: \<open>((regstate),(register_value),(VMECID_P_EL2_Type))register_ref \<close>  where 
     \<open> VMECID_P_EL2_ref = ( (|
  name = (''VMECID_P_EL2''),
  read_from = ((\<lambda> s .  (| VMECID_P_EL2_Type_bits = ((bitvector_64_reg   s) (''VMECID_P_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VMECID_P_EL2'') then(VMECID_P_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VMECID_P_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VMECID_P_EL2_Type v)) |) )\<close>


definition MECID_P0_EL2_ref  :: \<open>((regstate),(register_value),(MECID_P0_EL2_Type))register_ref \<close>  where 
     \<open> MECID_P0_EL2_ref = ( (|
  name = (''MECID_P0_EL2''),
  read_from = ((\<lambda> s .  (| MECID_P0_EL2_Type_bits = ((bitvector_64_reg   s) (''MECID_P0_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MECID_P0_EL2'') then(MECID_P0_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MECID_P0_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MECID_P0_EL2_Type v)) |) )\<close>


definition POR_EL0_ref  :: \<open>((regstate),(register_value),(POR_EL0_Type))register_ref \<close>  where 
     \<open> POR_EL0_ref = ( (|
  name = (''POR_EL0''),
  read_from = ((\<lambda> s .  (| POR_EL0_Type_bits = ((bitvector_64_reg   s) (''POR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''POR_EL0'') then(POR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  POR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_POR_EL0_Type v)) |) )\<close>


definition POR_EL3_ref  :: \<open>((regstate),(register_value),(POR_EL3_Type))register_ref \<close>  where 
     \<open> POR_EL3_ref = ( (|
  name = (''POR_EL3''),
  read_from = ((\<lambda> s .  (| POR_EL3_Type_bits = ((bitvector_64_reg   s) (''POR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''POR_EL3'') then(POR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  POR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_POR_EL3_Type v)) |) )\<close>


definition POR_EL2_ref  :: \<open>((regstate),(register_value),(POR_EL2_Type))register_ref \<close>  where 
     \<open> POR_EL2_ref = ( (|
  name = (''POR_EL2''),
  read_from = ((\<lambda> s .  (| POR_EL2_Type_bits = ((bitvector_64_reg   s) (''POR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''POR_EL2'') then(POR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  POR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_POR_EL2_Type v)) |) )\<close>


definition POR_EL1_ref  :: \<open>((regstate),(register_value),(POR_EL1_Type))register_ref \<close>  where 
     \<open> POR_EL1_ref = ( (|
  name = (''POR_EL1''),
  read_from = ((\<lambda> s .  (| POR_EL1_Type_bits = ((bitvector_64_reg   s) (''POR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''POR_EL1'') then(POR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  POR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_POR_EL1_Type v)) |) )\<close>


definition EDWAR_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> EDWAR_ref = ( (|
  name = (''EDWAR''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''EDWAR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''EDWAR'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition DBGWVR_EL1_ref  :: \<open>((regstate),(register_value),((DBGWVR_EL1_Type)list))register_ref \<close>  where 
     \<open> DBGWVR_EL1_ref = ( (|
  name = (''DBGWVR_EL1''),
  read_from = ((\<lambda> s . (vector_64_DBGWVR_EL1_Type_reg   s) (''DBGWVR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_64_DBGWVR_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''DBGWVR_EL1'') then v else(vector_64_DBGWVR_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  DBGWVR_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_DBGWVR_EL1_Type v)) v)) |) )\<close>


definition DBGWCR_EL1_ref  :: \<open>((regstate),(register_value),((DBGWCR_EL1_Type)list))register_ref \<close>  where 
     \<open> DBGWCR_EL1_ref = ( (|
  name = (''DBGWCR_EL1''),
  read_from = ((\<lambda> s . (vector_64_DBGWCR_EL1_Type_reg   s) (''DBGWCR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_64_DBGWCR_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''DBGWCR_EL1'') then v else(vector_64_DBGWCR_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  DBGWCR_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_DBGWCR_EL1_Type v)) v)) |) )\<close>


definition VTTBR_EL2_ref  :: \<open>((regstate),(register_value),(VTTBR_EL2_Type))register_ref \<close>  where 
     \<open> VTTBR_EL2_ref = ( (|
  name = (''_VTTBR_EL2''),
  read_from = ((\<lambda> s .  (| VTTBR_EL2_Type_bits = ((bitvector_128_reg   s) (''_VTTBR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_128_reg :=
  ((\<lambda> reg .  if reg = (''_VTTBR_EL2'') then(VTTBR_EL2_Type_bits   v) else(bitvector_128_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VTTBR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VTTBR_EL2_Type v)) |) )\<close>


definition VTTBR_ref  :: \<open>((regstate),(register_value),(VTTBR_Type))register_ref \<close>  where 
     \<open> VTTBR_ref = ( (|
  name = (''VTTBR''),
  read_from = ((\<lambda> s .  (| VTTBR_Type_bits = ((bitvector_64_reg   s) (''VTTBR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VTTBR'') then(VTTBR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VTTBR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VTTBR_Type v)) |) )\<close>


definition VTCR_EL2_ref  :: \<open>((regstate),(register_value),(VTCR_EL2_Type))register_ref \<close>  where 
     \<open> VTCR_EL2_ref = ( (|
  name = (''VTCR_EL2''),
  read_from = ((\<lambda> s .  (| VTCR_EL2_Type_bits = ((bitvector_64_reg   s) (''VTCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VTCR_EL2'') then(VTCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  VTCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_VTCR_EL2_Type v)) |) )\<close>


definition EDSCR2_ref  :: \<open>((regstate),(register_value),(EDSCR2_Type))register_ref \<close>  where 
     \<open> EDSCR2_ref = ( (|
  name = (''_EDSCR2''),
  read_from = ((\<lambda> s .  (| EDSCR2_Type_bits = ((bitvector_32_reg   s) (''_EDSCR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_EDSCR2'') then(EDSCR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDSCR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDSCR2_Type v)) |) )\<close>


definition DBGBVR_EL1_ref  :: \<open>((regstate),(register_value),((DBGBVR_EL1_Type)list))register_ref \<close>  where 
     \<open> DBGBVR_EL1_ref = ( (|
  name = (''DBGBVR_EL1''),
  read_from = ((\<lambda> s . (vector_64_DBGBVR_EL1_Type_reg   s) (''DBGBVR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_64_DBGBVR_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''DBGBVR_EL1'') then v else(vector_64_DBGBVR_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  DBGBVR_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_DBGBVR_EL1_Type v)) v)) |) )\<close>


definition DBGBCR_EL1_ref  :: \<open>((regstate),(register_value),((DBGBCR_EL1_Type)list))register_ref \<close>  where 
     \<open> DBGBCR_EL1_ref = ( (|
  name = (''DBGBCR_EL1''),
  read_from = ((\<lambda> s . (vector_64_DBGBCR_EL1_Type_reg   s) (''DBGBCR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| vector_64_DBGBCR_EL1_Type_reg :=
  ((\<lambda> reg .  if reg = (''DBGBCR_EL1'') then v else(vector_64_DBGBCR_EL1_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  DBGBCR_EL1_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_DBGBCR_EL1_Type v)) v)) |) )\<close>


definition CONTEXTIDR_EL2_ref  :: \<open>((regstate),(register_value),(CONTEXTIDR_EL2_Type))register_ref \<close>  where 
     \<open> CONTEXTIDR_EL2_ref = ( (|
  name = (''CONTEXTIDR_EL2''),
  read_from = ((\<lambda> s .  (| CONTEXTIDR_EL2_Type_bits = ((bitvector_64_reg   s) (''CONTEXTIDR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CONTEXTIDR_EL2'') then(CONTEXTIDR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CONTEXTIDR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CONTEXTIDR_EL2_Type v)) |) )\<close>


definition TFSR_EL3_ref  :: \<open>((regstate),(register_value),(TFSR_EL3_Type))register_ref \<close>  where 
     \<open> TFSR_EL3_ref = ( (|
  name = (''TFSR_EL3''),
  read_from = ((\<lambda> s .  (| TFSR_EL3_Type_bits = ((bitvector_64_reg   s) (''TFSR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TFSR_EL3'') then(TFSR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TFSR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TFSR_EL3_Type v)) |) )\<close>


definition TFSR_EL2_ref  :: \<open>((regstate),(register_value),(TFSR_EL2_Type))register_ref \<close>  where 
     \<open> TFSR_EL2_ref = ( (|
  name = (''TFSR_EL2''),
  read_from = ((\<lambda> s .  (| TFSR_EL2_Type_bits = ((bitvector_64_reg   s) (''TFSR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TFSR_EL2'') then(TFSR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TFSR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TFSR_EL2_Type v)) |) )\<close>


definition TFSR_EL1_ref  :: \<open>((regstate),(register_value),(TFSR_EL1_Type))register_ref \<close>  where 
     \<open> TFSR_EL1_ref = ( (|
  name = (''TFSR_EL1''),
  read_from = ((\<lambda> s .  (| TFSR_EL1_Type_bits = ((bitvector_64_reg   s) (''TFSR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TFSR_EL1'') then(TFSR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TFSR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TFSR_EL1_Type v)) |) )\<close>


definition TFSRE0_EL1_ref  :: \<open>((regstate),(register_value),(TFSRE0_EL1_Type))register_ref \<close>  where 
     \<open> TFSRE0_EL1_ref = ( (|
  name = (''TFSRE0_EL1''),
  read_from = ((\<lambda> s .  (| TFSRE0_EL1_Type_bits = ((bitvector_64_reg   s) (''TFSRE0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TFSRE0_EL1'') then(TFSRE0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TFSRE0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TFSRE0_EL1_Type v)) |) )\<close>


definition RGSR_EL1_ref  :: \<open>((regstate),(register_value),(RGSR_EL1_Type))register_ref \<close>  where 
     \<open> RGSR_EL1_ref = ( (|
  name = (''RGSR_EL1''),
  read_from = ((\<lambda> s .  (| RGSR_EL1_Type_bits = ((bitvector_64_reg   s) (''RGSR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''RGSR_EL1'') then(RGSR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  RGSR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_RGSR_EL1_Type v)) |) )\<close>


definition GCR_EL1_ref  :: \<open>((regstate),(register_value),(GCR_EL1_Type))register_ref \<close>  where 
     \<open> GCR_EL1_ref = ( (|
  name = (''GCR_EL1''),
  read_from = ((\<lambda> s .  (| GCR_EL1_Type_bits = ((bitvector_64_reg   s) (''GCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GCR_EL1'') then(GCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GCR_EL1_Type v)) |) )\<close>


definition CNTKCTL_ref  :: \<open>((regstate),(register_value),(CNTKCTL_Type))register_ref \<close>  where 
     \<open> CNTKCTL_ref = ( (|
  name = (''_CNTKCTL''),
  read_from = ((\<lambda> s .  (| CNTKCTL_Type_bits = ((bitvector_32_reg   s) (''_CNTKCTL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CNTKCTL'') then(CNTKCTL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTKCTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTKCTL_Type v)) |) )\<close>


definition APGAKeyLo_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> APGAKeyLo_EL1_ref = ( (|
  name = (''APGAKeyLo_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''APGAKeyLo_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''APGAKeyLo_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition APGAKeyHi_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> APGAKeyHi_EL1_ref = ( (|
  name = (''APGAKeyHi_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''APGAKeyHi_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''APGAKeyHi_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition APDBKeyLo_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> APDBKeyLo_EL1_ref = ( (|
  name = (''APDBKeyLo_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''APDBKeyLo_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''APDBKeyLo_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition APDBKeyHi_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> APDBKeyHi_EL1_ref = ( (|
  name = (''APDBKeyHi_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''APDBKeyHi_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''APDBKeyHi_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition APDAKeyLo_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> APDAKeyLo_EL1_ref = ( (|
  name = (''APDAKeyLo_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''APDAKeyLo_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''APDAKeyLo_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition APDAKeyHi_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> APDAKeyHi_EL1_ref = ( (|
  name = (''APDAKeyHi_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''APDAKeyHi_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''APDAKeyHi_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition APIBKeyLo_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> APIBKeyLo_EL1_ref = ( (|
  name = (''APIBKeyLo_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''APIBKeyLo_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''APIBKeyLo_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition APIBKeyHi_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> APIBKeyHi_EL1_ref = ( (|
  name = (''APIBKeyHi_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''APIBKeyHi_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''APIBKeyHi_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition APIAKeyLo_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> APIAKeyLo_EL1_ref = ( (|
  name = (''APIAKeyLo_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''APIAKeyLo_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''APIAKeyLo_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition APIAKeyHi_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> APIAKeyHi_EL1_ref = ( (|
  name = (''APIAKeyHi_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''APIAKeyHi_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''APIAKeyHi_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition TTBR0_EL3_ref  :: \<open>((regstate),(register_value),(TTBR0_EL3_Type))register_ref \<close>  where 
     \<open> TTBR0_EL3_ref = ( (|
  name = (''TTBR0_EL3''),
  read_from = ((\<lambda> s .  (| TTBR0_EL3_Type_bits = ((bitvector_64_reg   s) (''TTBR0_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TTBR0_EL3'') then(TTBR0_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBR0_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBR0_EL3_Type v)) |) )\<close>


definition SCTLR2_EL3_ref  :: \<open>((regstate),(register_value),(SCTLR2_EL3_Type))register_ref \<close>  where 
     \<open> SCTLR2_EL3_ref = ( (|
  name = (''SCTLR2_EL3''),
  read_from = ((\<lambda> s .  (| SCTLR2_EL3_Type_bits = ((bitvector_64_reg   s) (''SCTLR2_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCTLR2_EL3'') then(SCTLR2_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SCTLR2_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SCTLR2_EL3_Type v)) |) )\<close>


definition PIR_EL3_ref  :: \<open>((regstate),(register_value),(PIR_EL3_Type))register_ref \<close>  where 
     \<open> PIR_EL3_ref = ( (|
  name = (''PIR_EL3''),
  read_from = ((\<lambda> s .  (| PIR_EL3_Type_bits = ((bitvector_64_reg   s) (''PIR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PIR_EL3'') then(PIR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PIR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PIR_EL3_Type v)) |) )\<close>


definition MAIR_EL3_ref  :: \<open>((regstate),(register_value),(MAIR_EL3_Type))register_ref \<close>  where 
     \<open> MAIR_EL3_ref = ( (|
  name = (''MAIR_EL3''),
  read_from = ((\<lambda> s .  (| MAIR_EL3_Type_bits = ((bitvector_64_reg   s) (''MAIR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MAIR_EL3'') then(MAIR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MAIR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MAIR_EL3_Type v)) |) )\<close>


definition MAIR2_EL3_ref  :: \<open>((regstate),(register_value),(MAIR2_EL3_Type))register_ref \<close>  where 
     \<open> MAIR2_EL3_ref = ( (|
  name = (''MAIR2_EL3''),
  read_from = ((\<lambda> s .  (| MAIR2_EL3_Type_bits = ((bitvector_64_reg   s) (''MAIR2_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MAIR2_EL3'') then(MAIR2_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MAIR2_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MAIR2_EL3_Type v)) |) )\<close>


definition PIRE0_EL2_ref  :: \<open>((regstate),(register_value),(PIRE0_EL2_Type))register_ref \<close>  where 
     \<open> PIRE0_EL2_ref = ( (|
  name = (''PIRE0_EL2''),
  read_from = ((\<lambda> s .  (| PIRE0_EL2_Type_bits = ((bitvector_64_reg   s) (''PIRE0_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PIRE0_EL2'') then(PIRE0_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PIRE0_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PIRE0_EL2_Type v)) |) )\<close>


definition TCR2_EL2_ref  :: \<open>((regstate),(register_value),(TCR2_EL2_Type))register_ref \<close>  where 
     \<open> TCR2_EL2_ref = ( (|
  name = (''TCR2_EL2''),
  read_from = ((\<lambda> s .  (| TCR2_EL2_Type_bits = ((bitvector_64_reg   s) (''TCR2_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TCR2_EL2'') then(TCR2_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TCR2_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TCR2_EL2_Type v)) |) )\<close>


definition PIR_EL2_ref  :: \<open>((regstate),(register_value),(PIR_EL2_Type))register_ref \<close>  where 
     \<open> PIR_EL2_ref = ( (|
  name = (''PIR_EL2''),
  read_from = ((\<lambda> s .  (| PIR_EL2_Type_bits = ((bitvector_64_reg   s) (''PIR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PIR_EL2'') then(PIR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PIR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PIR_EL2_Type v)) |) )\<close>


definition MAIR_EL2_ref  :: \<open>((regstate),(register_value),(MAIR_EL2_Type))register_ref \<close>  where 
     \<open> MAIR_EL2_ref = ( (|
  name = (''MAIR_EL2''),
  read_from = ((\<lambda> s .  (| MAIR_EL2_Type_bits = ((bitvector_64_reg   s) (''MAIR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MAIR_EL2'') then(MAIR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MAIR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MAIR_EL2_Type v)) |) )\<close>


definition MAIR2_EL2_ref  :: \<open>((regstate),(register_value),(MAIR2_EL2_Type))register_ref \<close>  where 
     \<open> MAIR2_EL2_ref = ( (|
  name = (''MAIR2_EL2''),
  read_from = ((\<lambda> s .  (| MAIR2_EL2_Type_bits = ((bitvector_64_reg   s) (''MAIR2_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MAIR2_EL2'') then(MAIR2_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MAIR2_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MAIR2_EL2_Type v)) |) )\<close>


definition TCR2_EL1_ref  :: \<open>((regstate),(register_value),(TCR2_EL1_Type))register_ref \<close>  where 
     \<open> TCR2_EL1_ref = ( (|
  name = (''TCR2_EL1''),
  read_from = ((\<lambda> s .  (| TCR2_EL1_Type_bits = ((bitvector_64_reg   s) (''TCR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TCR2_EL1'') then(TCR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TCR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TCR2_EL1_Type v)) |) )\<close>


definition PIR_EL1_ref  :: \<open>((regstate),(register_value),(PIR_EL1_Type))register_ref \<close>  where 
     \<open> PIR_EL1_ref = ( (|
  name = (''PIR_EL1''),
  read_from = ((\<lambda> s .  (| PIR_EL1_Type_bits = ((bitvector_64_reg   s) (''PIR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PIR_EL1'') then(PIR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PIR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PIR_EL1_Type v)) |) )\<close>


definition PIRE0_EL1_ref  :: \<open>((regstate),(register_value),(PIRE0_EL1_Type))register_ref \<close>  where 
     \<open> PIRE0_EL1_ref = ( (|
  name = (''PIRE0_EL1''),
  read_from = ((\<lambda> s .  (| PIRE0_EL1_Type_bits = ((bitvector_64_reg   s) (''PIRE0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PIRE0_EL1'') then(PIRE0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PIRE0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PIRE0_EL1_Type v)) |) )\<close>


definition MAIR_EL1_ref  :: \<open>((regstate),(register_value),(MAIR_EL1_Type))register_ref \<close>  where 
     \<open> MAIR_EL1_ref = ( (|
  name = (''MAIR_EL1''),
  read_from = ((\<lambda> s .  (| MAIR_EL1_Type_bits = ((bitvector_64_reg   s) (''MAIR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MAIR_EL1'') then(MAIR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MAIR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MAIR_EL1_Type v)) |) )\<close>


definition MAIR2_EL1_ref  :: \<open>((regstate),(register_value),(MAIR2_EL1_Type))register_ref \<close>  where 
     \<open> MAIR2_EL1_ref = ( (|
  name = (''MAIR2_EL1''),
  read_from = ((\<lambda> s .  (| MAIR2_EL1_Type_bits = ((bitvector_64_reg   s) (''MAIR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MAIR2_EL1'') then(MAIR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MAIR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MAIR2_EL1_Type v)) |) )\<close>


definition GICC_CTLR_ref  :: \<open>((regstate),(register_value),(GICC_CTLR_Type))register_ref \<close>  where 
     \<open> GICC_CTLR_ref = ( (|
  name = (''GICC_CTLR''),
  read_from = ((\<lambda> s .  (| GICC_CTLR_Type_bits = ((bitvector_32_reg   s) (''GICC_CTLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''GICC_CTLR'') then(GICC_CTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GICC_CTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GICC_CTLR_Type v)) |) )\<close>


definition tlb_enabled_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> tlb_enabled_ref = ( (|
  name = (''__tlb_enabled''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__tlb_enabled''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__tlb_enabled'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition GPTBR_EL3_ref  :: \<open>((regstate),(register_value),(GPTBR_EL3_Type))register_ref \<close>  where 
     \<open> GPTBR_EL3_ref = ( (|
  name = (''GPTBR_EL3''),
  read_from = ((\<lambda> s .  (| GPTBR_EL3_Type_bits = ((bitvector_64_reg   s) (''GPTBR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GPTBR_EL3'') then(GPTBR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GPTBR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GPTBR_EL3_Type v)) |) )\<close>


definition GPCCR_EL3_ref  :: \<open>((regstate),(register_value),(GPCCR_EL3_Type))register_ref \<close>  where 
     \<open> GPCCR_EL3_ref = ( (|
  name = (''GPCCR_EL3''),
  read_from = ((\<lambda> s .  (| GPCCR_EL3_Type_bits = ((bitvector_64_reg   s) (''GPCCR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GPCCR_EL3'') then(GPCCR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GPCCR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GPCCR_EL3_Type v)) |) )\<close>


definition CNTKCTL_EL1_ref  :: \<open>((regstate),(register_value),(CNTKCTL_EL1_Type))register_ref \<close>  where 
     \<open> CNTKCTL_EL1_ref = ( (|
  name = (''CNTKCTL_EL1''),
  read_from = ((\<lambda> s .  (| CNTKCTL_EL1_Type_bits = ((bitvector_64_reg   s) (''CNTKCTL_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTKCTL_EL1'') then(CNTKCTL_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTKCTL_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTKCTL_EL1_Type v)) |) )\<close>


definition CNTSCR_ref  :: \<open>((regstate),(register_value),(CNTSCR_Type))register_ref \<close>  where 
     \<open> CNTSCR_ref = ( (|
  name = (''CNTSCR''),
  read_from = ((\<lambda> s .  (| CNTSCR_Type_bits = ((bitvector_32_reg   s) (''CNTSCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CNTSCR'') then(CNTSCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTSCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTSCR_Type v)) |) )\<close>


definition CNTCR_ref  :: \<open>((regstate),(register_value),(CNTCR_Type))register_ref \<close>  where 
     \<open> CNTCR_ref = ( (|
  name = (''CNTCR''),
  read_from = ((\<lambda> s .  (| CNTCR_Type_bits = ((bitvector_32_reg   s) (''CNTCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CNTCR'') then(CNTCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTCR_Type v)) |) )\<close>


definition CNTPS_CVAL_EL1_ref  :: \<open>((regstate),(register_value),(CNTPS_CVAL_EL1_Type))register_ref \<close>  where 
     \<open> CNTPS_CVAL_EL1_ref = ( (|
  name = (''CNTPS_CVAL_EL1''),
  read_from = ((\<lambda> s .  (| CNTPS_CVAL_EL1_Type_bits = ((bitvector_64_reg   s) (''CNTPS_CVAL_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTPS_CVAL_EL1'') then(CNTPS_CVAL_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTPS_CVAL_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTPS_CVAL_EL1_Type v)) |) )\<close>


definition CNTPS_CTL_EL1_ref  :: \<open>((regstate),(register_value),(CNTPS_CTL_EL1_Type))register_ref \<close>  where 
     \<open> CNTPS_CTL_EL1_ref = ( (|
  name = (''CNTPS_CTL_EL1''),
  read_from = ((\<lambda> s .  (| CNTPS_CTL_EL1_Type_bits = ((bitvector_64_reg   s) (''CNTPS_CTL_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTPS_CTL_EL1'') then(CNTPS_CTL_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTPS_CTL_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTPS_CTL_EL1_Type v)) |) )\<close>


definition CNTHV_CVAL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHV_CVAL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHV_CVAL_EL2_ref = ( (|
  name = (''CNTHV_CVAL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHV_CVAL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHV_CVAL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHV_CVAL_EL2'') then(CNTHV_CVAL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHV_CVAL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHV_CVAL_EL2_Type v)) |) )\<close>


definition CNTHV_CTL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHV_CTL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHV_CTL_EL2_ref = ( (|
  name = (''CNTHV_CTL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHV_CTL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHV_CTL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHV_CTL_EL2'') then(CNTHV_CTL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHV_CTL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHV_CTL_EL2_Type v)) |) )\<close>


definition CNTHVS_CVAL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHVS_CVAL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHVS_CVAL_EL2_ref = ( (|
  name = (''CNTHVS_CVAL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHVS_CVAL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHVS_CVAL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHVS_CVAL_EL2'') then(CNTHVS_CVAL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHVS_CVAL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHVS_CVAL_EL2_Type v)) |) )\<close>


definition CNTHVS_CTL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHVS_CTL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHVS_CTL_EL2_ref = ( (|
  name = (''CNTHVS_CTL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHVS_CTL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHVS_CTL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHVS_CTL_EL2'') then(CNTHVS_CTL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHVS_CTL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHVS_CTL_EL2_Type v)) |) )\<close>


definition CNTHPS_CVAL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHPS_CVAL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHPS_CVAL_EL2_ref = ( (|
  name = (''CNTHPS_CVAL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHPS_CVAL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHPS_CVAL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHPS_CVAL_EL2'') then(CNTHPS_CVAL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHPS_CVAL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHPS_CVAL_EL2_Type v)) |) )\<close>


definition CNTHPS_CTL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHPS_CTL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHPS_CTL_EL2_ref = ( (|
  name = (''CNTHPS_CTL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHPS_CTL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHPS_CTL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHPS_CTL_EL2'') then(CNTHPS_CTL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHPS_CTL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHPS_CTL_EL2_Type v)) |) )\<close>


definition CNTV_CVAL_EL0_ref  :: \<open>((regstate),(register_value),(CNTV_CVAL_EL0_Type))register_ref \<close>  where 
     \<open> CNTV_CVAL_EL0_ref = ( (|
  name = (''CNTV_CVAL_EL0''),
  read_from = ((\<lambda> s .  (| CNTV_CVAL_EL0_Type_bits = ((bitvector_64_reg   s) (''CNTV_CVAL_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTV_CVAL_EL0'') then(CNTV_CVAL_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTV_CVAL_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTV_CVAL_EL0_Type v)) |) )\<close>


definition CNTV_CTL_EL0_ref  :: \<open>((regstate),(register_value),(CNTV_CTL_EL0_Type))register_ref \<close>  where 
     \<open> CNTV_CTL_EL0_ref = ( (|
  name = (''CNTV_CTL_EL0''),
  read_from = ((\<lambda> s .  (| CNTV_CTL_EL0_Type_bits = ((bitvector_64_reg   s) (''CNTV_CTL_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTV_CTL_EL0'') then(CNTV_CTL_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTV_CTL_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTV_CTL_EL0_Type v)) |) )\<close>


definition CNTP_CVAL_S_ref  :: \<open>((regstate),(register_value),(CNTP_CVAL_Type))register_ref \<close>  where 
     \<open> CNTP_CVAL_S_ref = ( (|
  name = (''CNTP_CVAL_S''),
  read_from = ((\<lambda> s .  (| CNTP_CVAL_Type_bits = ((bitvector_64_reg   s) (''CNTP_CVAL_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTP_CVAL_S'') then(CNTP_CVAL_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTP_CVAL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTP_CVAL_Type v)) |) )\<close>


definition CNTP_CVAL_NS_ref  :: \<open>((regstate),(register_value),(CNTP_CVAL_Type))register_ref \<close>  where 
     \<open> CNTP_CVAL_NS_ref = ( (|
  name = (''_CNTP_CVAL_NS''),
  read_from = ((\<lambda> s .  (| CNTP_CVAL_Type_bits = ((bitvector_64_reg   s) (''_CNTP_CVAL_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_CNTP_CVAL_NS'') then(CNTP_CVAL_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTP_CVAL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTP_CVAL_Type v)) |) )\<close>


definition CNTP_CVAL_EL0_ref  :: \<open>((regstate),(register_value),(CNTP_CVAL_EL0_Type))register_ref \<close>  where 
     \<open> CNTP_CVAL_EL0_ref = ( (|
  name = (''CNTP_CVAL_EL0''),
  read_from = ((\<lambda> s .  (| CNTP_CVAL_EL0_Type_bits = ((bitvector_64_reg   s) (''CNTP_CVAL_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTP_CVAL_EL0'') then(CNTP_CVAL_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTP_CVAL_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTP_CVAL_EL0_Type v)) |) )\<close>


definition CNTP_CTL_S_ref  :: \<open>((regstate),(register_value),(CNTP_CTL_Type))register_ref \<close>  where 
     \<open> CNTP_CTL_S_ref = ( (|
  name = (''CNTP_CTL_S''),
  read_from = ((\<lambda> s .  (| CNTP_CTL_Type_bits = ((bitvector_32_reg   s) (''CNTP_CTL_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CNTP_CTL_S'') then(CNTP_CTL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTP_CTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTP_CTL_Type v)) |) )\<close>


definition CNTP_CTL_NS_ref  :: \<open>((regstate),(register_value),(CNTP_CTL_Type))register_ref \<close>  where 
     \<open> CNTP_CTL_NS_ref = ( (|
  name = (''_CNTP_CTL_NS''),
  read_from = ((\<lambda> s .  (| CNTP_CTL_Type_bits = ((bitvector_32_reg   s) (''_CNTP_CTL_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CNTP_CTL_NS'') then(CNTP_CTL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTP_CTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTP_CTL_Type v)) |) )\<close>


definition CNTP_CTL_EL0_ref  :: \<open>((regstate),(register_value),(CNTP_CTL_EL0_Type))register_ref \<close>  where 
     \<open> CNTP_CTL_EL0_ref = ( (|
  name = (''CNTP_CTL_EL0''),
  read_from = ((\<lambda> s .  (| CNTP_CTL_EL0_Type_bits = ((bitvector_64_reg   s) (''CNTP_CTL_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTP_CTL_EL0'') then(CNTP_CTL_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTP_CTL_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTP_CTL_EL0_Type v)) |) )\<close>


definition CNTHP_CVAL_ref  :: \<open>((regstate),(register_value),(CNTHP_CVAL_Type))register_ref \<close>  where 
     \<open> CNTHP_CVAL_ref = ( (|
  name = (''_CNTHP_CVAL''),
  read_from = ((\<lambda> s .  (| CNTHP_CVAL_Type_bits = ((bitvector_64_reg   s) (''_CNTHP_CVAL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_CNTHP_CVAL'') then(CNTHP_CVAL_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHP_CVAL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHP_CVAL_Type v)) |) )\<close>


definition CNTHP_CVAL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHP_CVAL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHP_CVAL_EL2_ref = ( (|
  name = (''CNTHP_CVAL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHP_CVAL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHP_CVAL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHP_CVAL_EL2'') then(CNTHP_CVAL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHP_CVAL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHP_CVAL_EL2_Type v)) |) )\<close>


definition CNTHP_CTL_ref  :: \<open>((regstate),(register_value),(CNTHP_CTL_Type))register_ref \<close>  where 
     \<open> CNTHP_CTL_ref = ( (|
  name = (''_CNTHP_CTL''),
  read_from = ((\<lambda> s .  (| CNTHP_CTL_Type_bits = ((bitvector_32_reg   s) (''_CNTHP_CTL'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CNTHP_CTL'') then(CNTHP_CTL_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHP_CTL_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHP_CTL_Type v)) |) )\<close>


definition CNTHP_CTL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHP_CTL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHP_CTL_EL2_ref = ( (|
  name = (''CNTHP_CTL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHP_CTL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHP_CTL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHP_CTL_EL2'') then(CNTHP_CTL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHP_CTL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHP_CTL_EL2_Type v)) |) )\<close>


definition FPEXC_ref  :: \<open>((regstate),(register_value),(FPEXC_Type))register_ref \<close>  where 
     \<open> FPEXC_ref = ( (|
  name = (''_FPEXC''),
  read_from = ((\<lambda> s .  (| FPEXC_Type_bits = ((bitvector_32_reg   s) (''_FPEXC'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_FPEXC'') then(FPEXC_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  FPEXC_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_FPEXC_Type v)) |) )\<close>


definition FPEXC32_EL2_ref  :: \<open>((regstate),(register_value),(FPEXC32_EL2_Type))register_ref \<close>  where 
     \<open> FPEXC32_EL2_ref = ( (|
  name = (''FPEXC32_EL2''),
  read_from = ((\<lambda> s .  (| FPEXC32_EL2_Type_bits = ((bitvector_64_reg   s) (''FPEXC32_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''FPEXC32_EL2'') then(FPEXC32_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  FPEXC32_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_FPEXC32_EL2_Type v)) |) )\<close>


definition SCTLR2_EL2_ref  :: \<open>((regstate),(register_value),(SCTLR2_EL2_Type))register_ref \<close>  where 
     \<open> SCTLR2_EL2_ref = ( (|
  name = (''SCTLR2_EL2''),
  read_from = ((\<lambda> s .  (| SCTLR2_EL2_Type_bits = ((bitvector_64_reg   s) (''SCTLR2_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCTLR2_EL2'') then(SCTLR2_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SCTLR2_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SCTLR2_EL2_Type v)) |) )\<close>


definition SCTLR2_EL1_ref  :: \<open>((regstate),(register_value),(SCTLR2_EL1_Type))register_ref \<close>  where 
     \<open> SCTLR2_EL1_ref = ( (|
  name = (''SCTLR2_EL1''),
  read_from = ((\<lambda> s .  (| SCTLR2_EL1_Type_bits = ((bitvector_64_reg   s) (''SCTLR2_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCTLR2_EL1'') then(SCTLR2_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SCTLR2_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SCTLR2_EL1_Type v)) |) )\<close>


definition IFAR_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> IFAR_S_ref = ( (|
  name = (''_IFAR_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_IFAR_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_IFAR_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition IFAR_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> IFAR_NS_ref = ( (|
  name = (''_IFAR_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_IFAR_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_IFAR_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition HCR2_ref  :: \<open>((regstate),(register_value),(HCR2_Type))register_ref \<close>  where 
     \<open> HCR2_ref = ( (|
  name = (''_HCR2''),
  read_from = ((\<lambda> s .  (| HCR2_Type_bits = ((bitvector_32_reg   s) (''_HCR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HCR2'') then(HCR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HCR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HCR2_Type v)) |) )\<close>


definition DBGDSCRext_ref  :: \<open>((regstate),(register_value),(DBGDSCRext_Type))register_ref \<close>  where 
     \<open> DBGDSCRext_ref = ( (|
  name = (''_DBGDSCRext''),
  read_from = ((\<lambda> s .  (| DBGDSCRext_Type_bits = ((bitvector_32_reg   s) (''_DBGDSCRext'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGDSCRext'') then(DBGDSCRext_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDSCRext_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDSCRext_Type v)) |) )\<close>


definition DBGDSCRint_ref  :: \<open>((regstate),(register_value),(DBGDSCRint_Type))register_ref \<close>  where 
     \<open> DBGDSCRint_ref = ( (|
  name = (''_DBGDSCRint''),
  read_from = ((\<lambda> s .  (| DBGDSCRint_Type_bits = ((bitvector_32_reg   s) (''_DBGDSCRint'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGDSCRint'') then(DBGDSCRint_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGDSCRint_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGDSCRint_Type v)) |) )\<close>


definition IFSR_S_ref  :: \<open>((regstate),(register_value),(IFSR_Type))register_ref \<close>  where 
     \<open> IFSR_S_ref = ( (|
  name = (''IFSR_S''),
  read_from = ((\<lambda> s .  (| IFSR_Type_bits = ((bitvector_32_reg   s) (''IFSR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''IFSR_S'') then(IFSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  IFSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_IFSR_Type v)) |) )\<close>


definition IFSR_NS_ref  :: \<open>((regstate),(register_value),(IFSR_Type))register_ref \<close>  where 
     \<open> IFSR_NS_ref = ( (|
  name = (''_IFSR_NS''),
  read_from = ((\<lambda> s .  (| IFSR_Type_bits = ((bitvector_32_reg   s) (''_IFSR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_IFSR_NS'') then(IFSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  IFSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_IFSR_Type v)) |) )\<close>


definition IFSR32_EL2_ref  :: \<open>((regstate),(register_value),(IFSR32_EL2_Type))register_ref \<close>  where 
     \<open> IFSR32_EL2_ref = ( (|
  name = (''IFSR32_EL2''),
  read_from = ((\<lambda> s .  (| IFSR32_EL2_Type_bits = ((bitvector_64_reg   s) (''IFSR32_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''IFSR32_EL2'') then(IFSR32_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  IFSR32_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_IFSR32_EL2_Type v)) |) )\<close>


definition DFSR_S_ref  :: \<open>((regstate),(register_value),(DFSR_Type))register_ref \<close>  where 
     \<open> DFSR_S_ref = ( (|
  name = (''DFSR_S''),
  read_from = ((\<lambda> s .  (| DFSR_Type_bits = ((bitvector_32_reg   s) (''DFSR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''DFSR_S'') then(DFSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DFSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DFSR_Type v)) |) )\<close>


definition DFSR_NS_ref  :: \<open>((regstate),(register_value),(DFSR_Type))register_ref \<close>  where 
     \<open> DFSR_NS_ref = ( (|
  name = (''_DFSR_NS''),
  read_from = ((\<lambda> s .  (| DFSR_Type_bits = ((bitvector_32_reg   s) (''_DFSR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DFSR_NS'') then(DFSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DFSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DFSR_Type v)) |) )\<close>


definition DFAR_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> DFAR_S_ref = ( (|
  name = (''_DFAR_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_DFAR_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DFAR_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition DFAR_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> DFAR_NS_ref = ( (|
  name = (''_DFAR_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_DFAR_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DFAR_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition MVBAR_ref  :: \<open>((regstate),(register_value),(MVBAR_Type))register_ref \<close>  where 
     \<open> MVBAR_ref = ( (|
  name = (''MVBAR''),
  read_from = ((\<lambda> s .  (| MVBAR_Type_bits = ((bitvector_32_reg   s) (''MVBAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''MVBAR'') then(MVBAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MVBAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MVBAR_Type v)) |) )\<close>


definition HVBAR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HVBAR_ref = ( (|
  name = (''_HVBAR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HVBAR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HVBAR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ELR_hyp_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ELR_hyp_ref = ( (|
  name = (''_ELR_hyp''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_ELR_hyp''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ELR_hyp'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition HSR_ref  :: \<open>((regstate),(register_value),(HSR_Type))register_ref \<close>  where 
     \<open> HSR_ref = ( (|
  name = (''_HSR''),
  read_from = ((\<lambda> s .  (| HSR_Type_bits = ((bitvector_32_reg   s) (''_HSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HSR'') then(HSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HSR_Type v)) |) )\<close>


definition HPFAR_ref  :: \<open>((regstate),(register_value),(HPFAR_Type))register_ref \<close>  where 
     \<open> HPFAR_ref = ( (|
  name = (''_HPFAR''),
  read_from = ((\<lambda> s .  (| HPFAR_Type_bits = ((bitvector_32_reg   s) (''_HPFAR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HPFAR'') then(HPFAR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HPFAR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HPFAR_Type v)) |) )\<close>


definition HIFAR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HIFAR_ref = ( (|
  name = (''_HIFAR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HIFAR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HIFAR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition HDFAR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> HDFAR_ref = ( (|
  name = (''_HDFAR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_HDFAR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HDFAR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition TTBR1_EL2_ref  :: \<open>((regstate),(register_value),(TTBR1_EL2_Type))register_ref \<close>  where 
     \<open> TTBR1_EL2_ref = ( (|
  name = (''TTBR1_EL2''),
  read_from = ((\<lambda> s .  (| TTBR1_EL2_Type_bits = ((bitvector_128_reg   s) (''TTBR1_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_128_reg :=
  ((\<lambda> reg .  if reg = (''TTBR1_EL2'') then(TTBR1_EL2_Type_bits   v) else(bitvector_128_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBR1_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBR1_EL2_Type v)) |) )\<close>


definition TTBR1_EL1_ref  :: \<open>((regstate),(register_value),(TTBR1_EL1_Type))register_ref \<close>  where 
     \<open> TTBR1_EL1_ref = ( (|
  name = (''_TTBR1_EL1''),
  read_from = ((\<lambda> s .  (| TTBR1_EL1_Type_bits = ((bitvector_128_reg   s) (''_TTBR1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_128_reg :=
  ((\<lambda> reg .  if reg = (''_TTBR1_EL1'') then(TTBR1_EL1_Type_bits   v) else(bitvector_128_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBR1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBR1_EL1_Type v)) |) )\<close>


definition TTBR1_S_ref  :: \<open>((regstate),(register_value),(TTBR1_Type))register_ref \<close>  where 
     \<open> TTBR1_S_ref = ( (|
  name = (''TTBR1_S''),
  read_from = ((\<lambda> s .  (| TTBR1_Type_bits = ((bitvector_64_reg   s) (''TTBR1_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TTBR1_S'') then(TTBR1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBR1_Type v)) |) )\<close>


definition TTBR1_NS_ref  :: \<open>((regstate),(register_value),(TTBR1_Type))register_ref \<close>  where 
     \<open> TTBR1_NS_ref = ( (|
  name = (''TTBR1_NS''),
  read_from = ((\<lambda> s .  (| TTBR1_Type_bits = ((bitvector_64_reg   s) (''TTBR1_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TTBR1_NS'') then(TTBR1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBR1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBR1_Type v)) |) )\<close>


definition TTBR0_EL2_ref  :: \<open>((regstate),(register_value),(TTBR0_EL2_Type))register_ref \<close>  where 
     \<open> TTBR0_EL2_ref = ( (|
  name = (''_TTBR0_EL2''),
  read_from = ((\<lambda> s .  (| TTBR0_EL2_Type_bits = ((bitvector_128_reg   s) (''_TTBR0_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_128_reg :=
  ((\<lambda> reg .  if reg = (''_TTBR0_EL2'') then(TTBR0_EL2_Type_bits   v) else(bitvector_128_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBR0_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBR0_EL2_Type v)) |) )\<close>


definition HTTBR_ref  :: \<open>((regstate),(register_value),(HTTBR_Type))register_ref \<close>  where 
     \<open> HTTBR_ref = ( (|
  name = (''HTTBR''),
  read_from = ((\<lambda> s .  (| HTTBR_Type_bits = ((bitvector_64_reg   s) (''HTTBR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HTTBR'') then(HTTBR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HTTBR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HTTBR_Type v)) |) )\<close>


definition TTBR0_EL1_ref  :: \<open>((regstate),(register_value),(TTBR0_EL1_Type))register_ref \<close>  where 
     \<open> TTBR0_EL1_ref = ( (|
  name = (''_TTBR0_EL1''),
  read_from = ((\<lambda> s .  (| TTBR0_EL1_Type_bits = ((bitvector_128_reg   s) (''_TTBR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_128_reg :=
  ((\<lambda> reg .  if reg = (''_TTBR0_EL1'') then(TTBR0_EL1_Type_bits   v) else(bitvector_128_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBR0_EL1_Type v)) |) )\<close>


definition TTBR0_S_ref  :: \<open>((regstate),(register_value),(TTBR0_Type))register_ref \<close>  where 
     \<open> TTBR0_S_ref = ( (|
  name = (''TTBR0_S''),
  read_from = ((\<lambda> s .  (| TTBR0_Type_bits = ((bitvector_64_reg   s) (''TTBR0_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TTBR0_S'') then(TTBR0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBR0_Type v)) |) )\<close>


definition TTBR0_NS_ref  :: \<open>((regstate),(register_value),(TTBR0_Type))register_ref \<close>  where 
     \<open> TTBR0_NS_ref = ( (|
  name = (''TTBR0_NS''),
  read_from = ((\<lambda> s .  (| TTBR0_Type_bits = ((bitvector_64_reg   s) (''TTBR0_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TTBR0_NS'') then(TTBR0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBR0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBR0_Type v)) |) )\<close>


definition CONTEXTIDR_S_ref  :: \<open>((regstate),(register_value),(CONTEXTIDR_Type))register_ref \<close>  where 
     \<open> CONTEXTIDR_S_ref = ( (|
  name = (''CONTEXTIDR_S''),
  read_from = ((\<lambda> s .  (| CONTEXTIDR_Type_bits = ((bitvector_32_reg   s) (''CONTEXTIDR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''CONTEXTIDR_S'') then(CONTEXTIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CONTEXTIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CONTEXTIDR_Type v)) |) )\<close>


definition CONTEXTIDR_NS_ref  :: \<open>((regstate),(register_value),(CONTEXTIDR_Type))register_ref \<close>  where 
     \<open> CONTEXTIDR_NS_ref = ( (|
  name = (''_CONTEXTIDR_NS''),
  read_from = ((\<lambda> s .  (| CONTEXTIDR_Type_bits = ((bitvector_32_reg   s) (''_CONTEXTIDR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CONTEXTIDR_NS'') then(CONTEXTIDR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CONTEXTIDR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CONTEXTIDR_Type v)) |) )\<close>


definition TTBCR_S_ref  :: \<open>((regstate),(register_value),(TTBCR_Type))register_ref \<close>  where 
     \<open> TTBCR_S_ref = ( (|
  name = (''TTBCR_S''),
  read_from = ((\<lambda> s .  (| TTBCR_Type_bits = ((bitvector_32_reg   s) (''TTBCR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''TTBCR_S'') then(TTBCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBCR_Type v)) |) )\<close>


definition TTBCR_NS_ref  :: \<open>((regstate),(register_value),(TTBCR_Type))register_ref \<close>  where 
     \<open> TTBCR_NS_ref = ( (|
  name = (''_TTBCR_NS''),
  read_from = ((\<lambda> s .  (| TTBCR_Type_bits = ((bitvector_32_reg   s) (''_TTBCR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_TTBCR_NS'') then(TTBCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TTBCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TTBCR_Type v)) |) )\<close>


definition CONTEXTIDR_EL1_ref  :: \<open>((regstate),(register_value),(CONTEXTIDR_EL1_Type))register_ref \<close>  where 
     \<open> CONTEXTIDR_EL1_ref = ( (|
  name = (''CONTEXTIDR_EL1''),
  read_from = ((\<lambda> s .  (| CONTEXTIDR_EL1_Type_bits = ((bitvector_64_reg   s) (''CONTEXTIDR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CONTEXTIDR_EL1'') then(CONTEXTIDR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CONTEXTIDR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CONTEXTIDR_EL1_Type v)) |) )\<close>


definition CLIDR_EL1_ref  :: \<open>((regstate),(register_value),(CLIDR_EL1_Type))register_ref \<close>  where 
     \<open> CLIDR_EL1_ref = ( (|
  name = (''CLIDR_EL1''),
  read_from = ((\<lambda> s .  (| CLIDR_EL1_Type_bits = ((bitvector_64_reg   s) (''CLIDR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CLIDR_EL1'') then(CLIDR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CLIDR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CLIDR_EL1_Type v)) |) )\<close>


definition MPAMSM_EL1_ref  :: \<open>((regstate),(register_value),(MPAMSM_EL1_Type))register_ref \<close>  where 
     \<open> MPAMSM_EL1_ref = ( (|
  name = (''MPAMSM_EL1''),
  read_from = ((\<lambda> s .  (| MPAMSM_EL1_Type_bits = ((bitvector_64_reg   s) (''MPAMSM_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMSM_EL1'') then(MPAMSM_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMSM_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMSM_EL1_Type v)) |) )\<close>


definition MPAM0_EL1_ref  :: \<open>((regstate),(register_value),(MPAM0_EL1_Type))register_ref \<close>  where 
     \<open> MPAM0_EL1_ref = ( (|
  name = (''MPAM0_EL1''),
  read_from = ((\<lambda> s .  (| MPAM0_EL1_Type_bits = ((bitvector_64_reg   s) (''MPAM0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAM0_EL1'') then(MPAM0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAM0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAM0_EL1_Type v)) |) )\<close>


definition MPAMVPM7_EL2_ref  :: \<open>((regstate),(register_value),(MPAMVPM7_EL2_Type))register_ref \<close>  where 
     \<open> MPAMVPM7_EL2_ref = ( (|
  name = (''MPAMVPM7_EL2''),
  read_from = ((\<lambda> s .  (| MPAMVPM7_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAMVPM7_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMVPM7_EL2'') then(MPAMVPM7_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMVPM7_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMVPM7_EL2_Type v)) |) )\<close>


definition MPAMVPM6_EL2_ref  :: \<open>((regstate),(register_value),(MPAMVPM6_EL2_Type))register_ref \<close>  where 
     \<open> MPAMVPM6_EL2_ref = ( (|
  name = (''MPAMVPM6_EL2''),
  read_from = ((\<lambda> s .  (| MPAMVPM6_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAMVPM6_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMVPM6_EL2'') then(MPAMVPM6_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMVPM6_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMVPM6_EL2_Type v)) |) )\<close>


definition MPAMVPM5_EL2_ref  :: \<open>((regstate),(register_value),(MPAMVPM5_EL2_Type))register_ref \<close>  where 
     \<open> MPAMVPM5_EL2_ref = ( (|
  name = (''MPAMVPM5_EL2''),
  read_from = ((\<lambda> s .  (| MPAMVPM5_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAMVPM5_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMVPM5_EL2'') then(MPAMVPM5_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMVPM5_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMVPM5_EL2_Type v)) |) )\<close>


definition MPAMVPM4_EL2_ref  :: \<open>((regstate),(register_value),(MPAMVPM4_EL2_Type))register_ref \<close>  where 
     \<open> MPAMVPM4_EL2_ref = ( (|
  name = (''MPAMVPM4_EL2''),
  read_from = ((\<lambda> s .  (| MPAMVPM4_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAMVPM4_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMVPM4_EL2'') then(MPAMVPM4_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMVPM4_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMVPM4_EL2_Type v)) |) )\<close>


definition MPAMVPM3_EL2_ref  :: \<open>((regstate),(register_value),(MPAMVPM3_EL2_Type))register_ref \<close>  where 
     \<open> MPAMVPM3_EL2_ref = ( (|
  name = (''MPAMVPM3_EL2''),
  read_from = ((\<lambda> s .  (| MPAMVPM3_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAMVPM3_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMVPM3_EL2'') then(MPAMVPM3_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMVPM3_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMVPM3_EL2_Type v)) |) )\<close>


definition MPAMVPM2_EL2_ref  :: \<open>((regstate),(register_value),(MPAMVPM2_EL2_Type))register_ref \<close>  where 
     \<open> MPAMVPM2_EL2_ref = ( (|
  name = (''MPAMVPM2_EL2''),
  read_from = ((\<lambda> s .  (| MPAMVPM2_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAMVPM2_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMVPM2_EL2'') then(MPAMVPM2_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMVPM2_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMVPM2_EL2_Type v)) |) )\<close>


definition MPAMVPM1_EL2_ref  :: \<open>((regstate),(register_value),(MPAMVPM1_EL2_Type))register_ref \<close>  where 
     \<open> MPAMVPM1_EL2_ref = ( (|
  name = (''MPAMVPM1_EL2''),
  read_from = ((\<lambda> s .  (| MPAMVPM1_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAMVPM1_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMVPM1_EL2'') then(MPAMVPM1_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMVPM1_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMVPM1_EL2_Type v)) |) )\<close>


definition MPAMVPMV_EL2_ref  :: \<open>((regstate),(register_value),(MPAMVPMV_EL2_Type))register_ref \<close>  where 
     \<open> MPAMVPMV_EL2_ref = ( (|
  name = (''MPAMVPMV_EL2''),
  read_from = ((\<lambda> s .  (| MPAMVPMV_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAMVPMV_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMVPMV_EL2'') then(MPAMVPMV_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMVPMV_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMVPMV_EL2_Type v)) |) )\<close>


definition MPAMVPM0_EL2_ref  :: \<open>((regstate),(register_value),(MPAMVPM0_EL2_Type))register_ref \<close>  where 
     \<open> MPAMVPM0_EL2_ref = ( (|
  name = (''MPAMVPM0_EL2''),
  read_from = ((\<lambda> s .  (| MPAMVPM0_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAMVPM0_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMVPM0_EL2'') then(MPAMVPM0_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMVPM0_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMVPM0_EL2_Type v)) |) )\<close>


definition MPAMHCR_EL2_ref  :: \<open>((regstate),(register_value),(MPAMHCR_EL2_Type))register_ref \<close>  where 
     \<open> MPAMHCR_EL2_ref = ( (|
  name = (''MPAMHCR_EL2''),
  read_from = ((\<lambda> s .  (| MPAMHCR_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAMHCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMHCR_EL2'') then(MPAMHCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMHCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMHCR_EL2_Type v)) |) )\<close>


definition MPAMIDR_EL1_ref  :: \<open>((regstate),(register_value),(MPAMIDR_EL1_Type))register_ref \<close>  where 
     \<open> MPAMIDR_EL1_ref = ( (|
  name = (''MPAMIDR_EL1''),
  read_from = ((\<lambda> s .  (| MPAMIDR_EL1_Type_bits = ((bitvector_64_reg   s) (''MPAMIDR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAMIDR_EL1'') then(MPAMIDR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAMIDR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAMIDR_EL1_Type v)) |) )\<close>


definition MPAM1_EL1_ref  :: \<open>((regstate),(register_value),(MPAM1_EL1_Type))register_ref \<close>  where 
     \<open> MPAM1_EL1_ref = ( (|
  name = (''_MPAM1_EL1''),
  read_from = ((\<lambda> s .  (| MPAM1_EL1_Type_bits = ((bitvector_64_reg   s) (''_MPAM1_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_MPAM1_EL1'') then(MPAM1_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAM1_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAM1_EL1_Type v)) |) )\<close>


definition MPAM3_EL3_ref  :: \<open>((regstate),(register_value),(MPAM3_EL3_Type))register_ref \<close>  where 
     \<open> MPAM3_EL3_ref = ( (|
  name = (''_MPAM3_EL3''),
  read_from = ((\<lambda> s .  (| MPAM3_EL3_Type_bits = ((bitvector_64_reg   s) (''_MPAM3_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_MPAM3_EL3'') then(MPAM3_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAM3_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAM3_EL3_Type v)) |) )\<close>


definition MPAM2_EL2_ref  :: \<open>((regstate),(register_value),(MPAM2_EL2_Type))register_ref \<close>  where 
     \<open> MPAM2_EL2_ref = ( (|
  name = (''MPAM2_EL2''),
  read_from = ((\<lambda> s .  (| MPAM2_EL2_Type_bits = ((bitvector_64_reg   s) (''MPAM2_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MPAM2_EL2'') then(MPAM2_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MPAM2_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MPAM2_EL2_Type v)) |) )\<close>


definition HCRX_EL2_ref  :: \<open>((regstate),(register_value),(HCRX_EL2_Type))register_ref \<close>  where 
     \<open> HCRX_EL2_ref = ( (|
  name = (''HCRX_EL2''),
  read_from = ((\<lambda> s .  (| HCRX_EL2_Type_bits = ((bitvector_64_reg   s) (''HCRX_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HCRX_EL2'') then(HCRX_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HCRX_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HCRX_EL2_Type v)) |) )\<close>


definition GCSCRE0_EL1_ref  :: \<open>((regstate),(register_value),(GCSCRE0_EL1_Type))register_ref \<close>  where 
     \<open> GCSCRE0_EL1_ref = ( (|
  name = (''GCSCRE0_EL1''),
  read_from = ((\<lambda> s .  (| GCSCRE0_EL1_Type_bits = ((bitvector_64_reg   s) (''GCSCRE0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GCSCRE0_EL1'') then(GCSCRE0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GCSCRE0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GCSCRE0_EL1_Type v)) |) )\<close>


definition VBAR_S_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> VBAR_S_ref = ( (|
  name = (''VBAR_S''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''VBAR_S''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''VBAR_S'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition VBAR_NS_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> VBAR_NS_ref = ( (|
  name = (''_VBAR_NS''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_VBAR_NS''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_VBAR_NS'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition VBAR_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> VBAR_EL3_ref = ( (|
  name = (''VBAR_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''VBAR_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VBAR_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition VBAR_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> VBAR_EL2_ref = ( (|
  name = (''VBAR_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''VBAR_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VBAR_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition VBAR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> VBAR_EL1_ref = ( (|
  name = (''VBAR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''VBAR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''VBAR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition EDESR_ref  :: \<open>((regstate),(register_value),(EDESR_Type))register_ref \<close>  where 
     \<open> EDESR_ref = ( (|
  name = (''EDESR''),
  read_from = ((\<lambda> s .  (| EDESR_Type_bits = ((bitvector_32_reg   s) (''EDESR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDESR'') then(EDESR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDESR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDESR_Type v)) |) )\<close>


definition EDECCR_ref  :: \<open>((regstate),(register_value),(EDECCR_Type))register_ref \<close>  where 
     \<open> EDECCR_ref = ( (|
  name = (''_EDECCR''),
  read_from = ((\<lambda> s .  (| EDECCR_Type_bits = ((bitvector_32_reg   s) (''_EDECCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_EDECCR'') then(EDECCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDECCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDECCR_Type v)) |) )\<close>


definition OSECCR_EL1_ref  :: \<open>((regstate),(register_value),(OSECCR_EL1_Type))register_ref \<close>  where 
     \<open> OSECCR_EL1_ref = ( (|
  name = (''OSECCR_EL1''),
  read_from = ((\<lambda> s .  (| OSECCR_EL1_Type_bits = ((bitvector_64_reg   s) (''OSECCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''OSECCR_EL1'') then(OSECCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  OSECCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_OSECCR_EL1_Type v)) |) )\<close>


definition SPSR_und_ref  :: \<open>((regstate),(register_value),(SPSR_und_Type))register_ref \<close>  where 
     \<open> SPSR_und_ref = ( (|
  name = (''SPSR_und''),
  read_from = ((\<lambda> s .  (| SPSR_und_Type_bits = ((bitvector_64_reg   s) (''SPSR_und'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPSR_und'') then(SPSR_und_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPSR_und_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPSR_und_Type v)) |) )\<close>


definition SPSR_svc_ref  :: \<open>((regstate),(register_value),(SPSR_svc_Type))register_ref \<close>  where 
     \<open> SPSR_svc_ref = ( (|
  name = (''_SPSR_svc''),
  read_from = ((\<lambda> s .  (| SPSR_svc_Type_bits = ((bitvector_32_reg   s) (''_SPSR_svc'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_SPSR_svc'') then(SPSR_svc_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPSR_svc_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPSR_svc_Type v)) |) )\<close>


definition SPSR_mon_ref  :: \<open>((regstate),(register_value),(SPSR_mon_Type))register_ref \<close>  where 
     \<open> SPSR_mon_ref = ( (|
  name = (''SPSR_mon''),
  read_from = ((\<lambda> s .  (| SPSR_mon_Type_bits = ((bitvector_32_reg   s) (''SPSR_mon'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''SPSR_mon'') then(SPSR_mon_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPSR_mon_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPSR_mon_Type v)) |) )\<close>


definition SPSR_irq_ref  :: \<open>((regstate),(register_value),(SPSR_irq_Type))register_ref \<close>  where 
     \<open> SPSR_irq_ref = ( (|
  name = (''SPSR_irq''),
  read_from = ((\<lambda> s .  (| SPSR_irq_Type_bits = ((bitvector_64_reg   s) (''SPSR_irq'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPSR_irq'') then(SPSR_irq_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPSR_irq_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPSR_irq_Type v)) |) )\<close>


definition SPSR_hyp_ref  :: \<open>((regstate),(register_value),(SPSR_hyp_Type))register_ref \<close>  where 
     \<open> SPSR_hyp_ref = ( (|
  name = (''_SPSR_hyp''),
  read_from = ((\<lambda> s .  (| SPSR_hyp_Type_bits = ((bitvector_32_reg   s) (''_SPSR_hyp'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_SPSR_hyp'') then(SPSR_hyp_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPSR_hyp_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPSR_hyp_Type v)) |) )\<close>


definition SPSR_fiq_ref  :: \<open>((regstate),(register_value),(SPSR_fiq_Type))register_ref \<close>  where 
     \<open> SPSR_fiq_ref = ( (|
  name = (''SPSR_fiq''),
  read_from = ((\<lambda> s .  (| SPSR_fiq_Type_bits = ((bitvector_64_reg   s) (''SPSR_fiq'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPSR_fiq'') then(SPSR_fiq_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPSR_fiq_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPSR_fiq_Type v)) |) )\<close>


definition SPSR_abt_ref  :: \<open>((regstate),(register_value),(SPSR_abt_Type))register_ref \<close>  where 
     \<open> SPSR_abt_ref = ( (|
  name = (''SPSR_abt''),
  read_from = ((\<lambda> s .  (| SPSR_abt_Type_bits = ((bitvector_64_reg   s) (''SPSR_abt'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPSR_abt'') then(SPSR_abt_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPSR_abt_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPSR_abt_Type v)) |) )\<close>


definition SPSR_EL3_ref  :: \<open>((regstate),(register_value),(SPSR_EL3_Type))register_ref \<close>  where 
     \<open> SPSR_EL3_ref = ( (|
  name = (''SPSR_EL3''),
  read_from = ((\<lambda> s .  (| SPSR_EL3_Type_bits = ((bitvector_64_reg   s) (''SPSR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPSR_EL3'') then(SPSR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPSR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPSR_EL3_Type v)) |) )\<close>


definition SPSR_EL2_ref  :: \<open>((regstate),(register_value),(SPSR_EL2_Type))register_ref \<close>  where 
     \<open> SPSR_EL2_ref = ( (|
  name = (''SPSR_EL2''),
  read_from = ((\<lambda> s .  (| SPSR_EL2_Type_bits = ((bitvector_64_reg   s) (''SPSR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPSR_EL2'') then(SPSR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPSR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPSR_EL2_Type v)) |) )\<close>


definition SPSR_EL1_ref  :: \<open>((regstate),(register_value),(SPSR_EL1_Type))register_ref \<close>  where 
     \<open> SPSR_EL1_ref = ( (|
  name = (''SPSR_EL1''),
  read_from = ((\<lambda> s .  (| SPSR_EL1_Type_bits = ((bitvector_64_reg   s) (''SPSR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPSR_EL1'') then(SPSR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SPSR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SPSR_EL1_Type v)) |) )\<close>


definition ELR_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ELR_EL3_ref = ( (|
  name = (''ELR_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ELR_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ELR_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ELR_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ELR_EL2_ref = ( (|
  name = (''ELR_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ELR_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ELR_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ELR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> ELR_EL1_ref = ( (|
  name = (''ELR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''ELR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ELR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition PFAR_EL2_ref  :: \<open>((regstate),(register_value),(PFAR_EL2_Type))register_ref \<close>  where 
     \<open> PFAR_EL2_ref = ( (|
  name = (''PFAR_EL2''),
  read_from = ((\<lambda> s .  (| PFAR_EL2_Type_bits = ((bitvector_64_reg   s) (''PFAR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PFAR_EL2'') then(PFAR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PFAR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PFAR_EL2_Type v)) |) )\<close>


definition PFAR_EL1_ref  :: \<open>((regstate),(register_value),(PFAR_EL1_Type))register_ref \<close>  where 
     \<open> PFAR_EL1_ref = ( (|
  name = (''PFAR_EL1''),
  read_from = ((\<lambda> s .  (| PFAR_EL1_Type_bits = ((bitvector_64_reg   s) (''PFAR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PFAR_EL1'') then(PFAR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PFAR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PFAR_EL1_Type v)) |) )\<close>


definition MFAR_EL3_ref  :: \<open>((regstate),(register_value),(MFAR_EL3_Type))register_ref \<close>  where 
     \<open> MFAR_EL3_ref = ( (|
  name = (''MFAR_EL3''),
  read_from = ((\<lambda> s .  (| MFAR_EL3_Type_bits = ((bitvector_64_reg   s) (''MFAR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MFAR_EL3'') then(MFAR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MFAR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MFAR_EL3_Type v)) |) )\<close>


definition HPFAR_EL2_ref  :: \<open>((regstate),(register_value),(HPFAR_EL2_Type))register_ref \<close>  where 
     \<open> HPFAR_EL2_ref = ( (|
  name = (''HPFAR_EL2''),
  read_from = ((\<lambda> s .  (| HPFAR_EL2_Type_bits = ((bitvector_64_reg   s) (''HPFAR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HPFAR_EL2'') then(HPFAR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HPFAR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HPFAR_EL2_Type v)) |) )\<close>


definition FAR_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> FAR_EL3_ref = ( (|
  name = (''FAR_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''FAR_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''FAR_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition FAR_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> FAR_EL2_ref = ( (|
  name = (''FAR_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''FAR_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''FAR_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition FAR_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> FAR_EL1_ref = ( (|
  name = (''FAR_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''FAR_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''FAR_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition ESR_EL3_ref  :: \<open>((regstate),(register_value),(ESR_EL3_Type))register_ref \<close>  where 
     \<open> ESR_EL3_ref = ( (|
  name = (''ESR_EL3''),
  read_from = ((\<lambda> s .  (| ESR_EL3_Type_bits = ((bitvector_64_reg   s) (''ESR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ESR_EL3'') then(ESR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ESR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ESR_EL3_Type v)) |) )\<close>


definition ESR_EL2_ref  :: \<open>((regstate),(register_value),(ESR_EL2_Type))register_ref \<close>  where 
     \<open> ESR_EL2_ref = ( (|
  name = (''ESR_EL2''),
  read_from = ((\<lambda> s .  (| ESR_EL2_Type_bits = ((bitvector_64_reg   s) (''ESR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ESR_EL2'') then(ESR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ESR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ESR_EL2_Type v)) |) )\<close>


definition ESR_EL1_ref  :: \<open>((regstate),(register_value),(ESR_EL1_Type))register_ref \<close>  where 
     \<open> ESR_EL1_ref = ( (|
  name = (''ESR_EL1''),
  read_from = ((\<lambda> s .  (| ESR_EL1_Type_bits = ((bitvector_64_reg   s) (''ESR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ESR_EL1'') then(ESR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ESR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ESR_EL1_Type v)) |) )\<close>


definition SCTLR_S_ref  :: \<open>((regstate),(register_value),(SCTLR_Type))register_ref \<close>  where 
     \<open> SCTLR_S_ref = ( (|
  name = (''SCTLR_S''),
  read_from = ((\<lambda> s .  (| SCTLR_Type_bits = ((bitvector_32_reg   s) (''SCTLR_S'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''SCTLR_S'') then(SCTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SCTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SCTLR_Type v)) |) )\<close>


definition SCTLR_NS_ref  :: \<open>((regstate),(register_value),(SCTLR_Type))register_ref \<close>  where 
     \<open> SCTLR_NS_ref = ( (|
  name = (''_SCTLR_NS''),
  read_from = ((\<lambda> s .  (| SCTLR_Type_bits = ((bitvector_32_reg   s) (''_SCTLR_NS'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_SCTLR_NS'') then(SCTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SCTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SCTLR_Type v)) |) )\<close>


definition SCTLR_EL3_ref  :: \<open>((regstate),(register_value),(SCTLR_EL3_Type))register_ref \<close>  where 
     \<open> SCTLR_EL3_ref = ( (|
  name = (''SCTLR_EL3''),
  read_from = ((\<lambda> s .  (| SCTLR_EL3_Type_bits = ((bitvector_64_reg   s) (''SCTLR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCTLR_EL3'') then(SCTLR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SCTLR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SCTLR_EL3_Type v)) |) )\<close>


definition SCTLR_EL1_ref  :: \<open>((regstate),(register_value),(SCTLR_EL1_Type))register_ref \<close>  where 
     \<open> SCTLR_EL1_ref = ( (|
  name = (''SCTLR_EL1''),
  read_from = ((\<lambda> s .  (| SCTLR_EL1_Type_bits = ((bitvector_64_reg   s) (''SCTLR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCTLR_EL1'') then(SCTLR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SCTLR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SCTLR_EL1_Type v)) |) )\<close>


definition HSCTLR_ref  :: \<open>((regstate),(register_value),(HSCTLR_Type))register_ref \<close>  where 
     \<open> HSCTLR_ref = ( (|
  name = (''_HSCTLR''),
  read_from = ((\<lambda> s .  (| HSCTLR_Type_bits = ((bitvector_32_reg   s) (''_HSCTLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HSCTLR'') then(HSCTLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HSCTLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HSCTLR_Type v)) |) )\<close>


definition SCTLR_EL2_ref  :: \<open>((regstate),(register_value),(SCTLR_EL2_Type))register_ref \<close>  where 
     \<open> SCTLR_EL2_ref = ( (|
  name = (''SCTLR_EL2''),
  read_from = ((\<lambda> s .  (| SCTLR_EL2_Type_bits = ((bitvector_64_reg   s) (''SCTLR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCTLR_EL2'') then(SCTLR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SCTLR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SCTLR_EL2_Type v)) |) )\<close>


definition HCR_ref  :: \<open>((regstate),(register_value),(HCR_Type))register_ref \<close>  where 
     \<open> HCR_ref = ( (|
  name = (''_HCR''),
  read_from = ((\<lambda> s .  (| HCR_Type_bits = ((bitvector_32_reg   s) (''_HCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HCR'') then(HCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HCR_Type v)) |) )\<close>


definition DBGOSLSR_ref  :: \<open>((regstate),(register_value),(DBGOSLSR_Type))register_ref \<close>  where 
     \<open> DBGOSLSR_ref = ( (|
  name = (''_DBGOSLSR''),
  read_from = ((\<lambda> s .  (| DBGOSLSR_Type_bits = ((bitvector_32_reg   s) (''_DBGOSLSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGOSLSR'') then(DBGOSLSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGOSLSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGOSLSR_Type v)) |) )\<close>


definition OSLSR_EL1_ref  :: \<open>((regstate),(register_value),(OSLSR_EL1_Type))register_ref \<close>  where 
     \<open> OSLSR_EL1_ref = ( (|
  name = (''OSLSR_EL1''),
  read_from = ((\<lambda> s .  (| OSLSR_EL1_Type_bits = ((bitvector_64_reg   s) (''OSLSR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''OSLSR_EL1'') then(OSLSR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  OSLSR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_OSLSR_EL1_Type v)) |) )\<close>


definition MDSCR_EL1_ref  :: \<open>((regstate),(register_value),(MDSCR_EL1_Type))register_ref \<close>  where 
     \<open> MDSCR_EL1_ref = ( (|
  name = (''MDSCR_EL1''),
  read_from = ((\<lambda> s .  (| MDSCR_EL1_Type_bits = ((bitvector_64_reg   s) (''MDSCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MDSCR_EL1'') then(MDSCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MDSCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MDSCR_EL1_Type v)) |) )\<close>


definition GCSCR_EL3_ref  :: \<open>((regstate),(register_value),(GCSCR_EL3_Type))register_ref \<close>  where 
     \<open> GCSCR_EL3_ref = ( (|
  name = (''GCSCR_EL3''),
  read_from = ((\<lambda> s .  (| GCSCR_EL3_Type_bits = ((bitvector_64_reg   s) (''GCSCR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GCSCR_EL3'') then(GCSCR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GCSCR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GCSCR_EL3_Type v)) |) )\<close>


definition GCSCR_EL2_ref  :: \<open>((regstate),(register_value),(GCSCR_EL2_Type))register_ref \<close>  where 
     \<open> GCSCR_EL2_ref = ( (|
  name = (''GCSCR_EL2''),
  read_from = ((\<lambda> s .  (| GCSCR_EL2_Type_bits = ((bitvector_64_reg   s) (''GCSCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GCSCR_EL2'') then(GCSCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GCSCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GCSCR_EL2_Type v)) |) )\<close>


definition GCSCR_EL1_ref  :: \<open>((regstate),(register_value),(GCSCR_EL1_Type))register_ref \<close>  where 
     \<open> GCSCR_EL1_ref = ( (|
  name = (''GCSCR_EL1''),
  read_from = ((\<lambda> s .  (| GCSCR_EL1_Type_bits = ((bitvector_64_reg   s) (''GCSCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GCSCR_EL1'') then(GCSCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GCSCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GCSCR_EL1_Type v)) |) )\<close>


definition GIC_Pending_ref  :: \<open>((regstate),(register_value),((InterruptID)option))register_ref \<close>  where 
     \<open> GIC_Pending_ref = ( (|
  name = (''__GIC_Pending''),
  read_from = ((\<lambda> s . (option_InterruptID_reg   s) (''__GIC_Pending''))),
  write_to = ((\<lambda> v s .  (( s (| option_InterruptID_reg :=
  ((\<lambda> reg .  if reg = (''__GIC_Pending'') then v else(option_InterruptID_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  option_of_regval ((\<lambda> v .  InterruptID_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_option ((\<lambda> v .  regval_of_InterruptID v)) v)) |) )\<close>


definition GIC_Active_ref  :: \<open>((regstate),(register_value),((InterruptID)option))register_ref \<close>  where 
     \<open> GIC_Active_ref = ( (|
  name = (''__GIC_Active''),
  read_from = ((\<lambda> s . (option_InterruptID_reg   s) (''__GIC_Active''))),
  write_to = ((\<lambda> v s .  (( s (| option_InterruptID_reg :=
  ((\<lambda> reg .  if reg = (''__GIC_Active'') then v else(option_InterruptID_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  option_of_regval ((\<lambda> v .  InterruptID_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_option ((\<lambda> v .  regval_of_InterruptID v)) v)) |) )\<close>


definition DBGPRCR_ref  :: \<open>((regstate),(register_value),(DBGPRCR_Type))register_ref \<close>  where 
     \<open> DBGPRCR_ref = ( (|
  name = (''_DBGPRCR''),
  read_from = ((\<lambda> s .  (| DBGPRCR_Type_bits = ((bitvector_32_reg   s) (''_DBGPRCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGPRCR'') then(DBGPRCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGPRCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGPRCR_Type v)) |) )\<close>


definition DBGPRCR_EL1_ref  :: \<open>((regstate),(register_value),(DBGPRCR_EL1_Type))register_ref \<close>  where 
     \<open> DBGPRCR_EL1_ref = ( (|
  name = (''DBGPRCR_EL1''),
  read_from = ((\<lambda> s .  (| DBGPRCR_EL1_Type_bits = ((bitvector_64_reg   s) (''DBGPRCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DBGPRCR_EL1'') then(DBGPRCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGPRCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGPRCR_EL1_Type v)) |) )\<close>


definition DBGOSDLR_ref  :: \<open>((regstate),(register_value),(DBGOSDLR_Type))register_ref \<close>  where 
     \<open> DBGOSDLR_ref = ( (|
  name = (''_DBGOSDLR''),
  read_from = ((\<lambda> s .  (| DBGOSDLR_Type_bits = ((bitvector_32_reg   s) (''_DBGOSDLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DBGOSDLR'') then(DBGOSDLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DBGOSDLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DBGOSDLR_Type v)) |) )\<close>


definition OSDLR_EL1_ref  :: \<open>((regstate),(register_value),(OSDLR_EL1_Type))register_ref \<close>  where 
     \<open> OSDLR_EL1_ref = ( (|
  name = (''OSDLR_EL1''),
  read_from = ((\<lambda> s .  (| OSDLR_EL1_Type_bits = ((bitvector_64_reg   s) (''OSDLR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''OSDLR_EL1'') then(OSDLR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  OSDLR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_OSDLR_EL1_Type v)) |) )\<close>


definition SP_EL3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SP_EL3_ref = ( (|
  name = (''SP_EL3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SP_EL3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SP_EL3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition SP_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SP_EL2_ref = ( (|
  name = (''SP_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SP_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SP_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition SP_EL1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SP_EL1_ref = ( (|
  name = (''SP_EL1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SP_EL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SP_EL1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition SP_EL0_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SP_EL0_ref = ( (|
  name = (''SP_EL0''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SP_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SP_EL0'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition NSACR_ref  :: \<open>((regstate),(register_value),(NSACR_Type))register_ref \<close>  where 
     \<open> NSACR_ref = ( (|
  name = (''NSACR''),
  read_from = ((\<lambda> s .  (| NSACR_Type_bits = ((bitvector_32_reg   s) (''NSACR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''NSACR'') then(NSACR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  NSACR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_NSACR_Type v)) |) )\<close>


definition HCPTR_ref  :: \<open>((regstate),(register_value),(HCPTR_Type))register_ref \<close>  where 
     \<open> HCPTR_ref = ( (|
  name = (''_HCPTR''),
  read_from = ((\<lambda> s .  (| HCPTR_Type_bits = ((bitvector_32_reg   s) (''_HCPTR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HCPTR'') then(HCPTR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HCPTR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HCPTR_Type v)) |) )\<close>


definition CPACR_ref  :: \<open>((regstate),(register_value),(CPACR_Type))register_ref \<close>  where 
     \<open> CPACR_ref = ( (|
  name = (''_CPACR''),
  read_from = ((\<lambda> s .  (| CPACR_Type_bits = ((bitvector_32_reg   s) (''_CPACR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_CPACR'') then(CPACR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CPACR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CPACR_Type v)) |) )\<close>


definition CPTR_EL3_ref  :: \<open>((regstate),(register_value),(CPTR_EL3_Type))register_ref \<close>  where 
     \<open> CPTR_EL3_ref = ( (|
  name = (''CPTR_EL3''),
  read_from = ((\<lambda> s .  (| CPTR_EL3_Type_bits = ((bitvector_64_reg   s) (''CPTR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CPTR_EL3'') then(CPTR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CPTR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CPTR_EL3_Type v)) |) )\<close>


definition CPTR_EL2_ref  :: \<open>((regstate),(register_value),(CPTR_EL2_Type))register_ref \<close>  where 
     \<open> CPTR_EL2_ref = ( (|
  name = (''CPTR_EL2''),
  read_from = ((\<lambda> s .  (| CPTR_EL2_Type_bits = ((bitvector_64_reg   s) (''CPTR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CPTR_EL2'') then(CPTR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CPTR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CPTR_EL2_Type v)) |) )\<close>


definition CPACR_EL1_ref  :: \<open>((regstate),(register_value),(CPACR_EL1_Type))register_ref \<close>  where 
     \<open> CPACR_EL1_ref = ( (|
  name = (''CPACR_EL1''),
  read_from = ((\<lambda> s .  (| CPACR_EL1_Type_bits = ((bitvector_64_reg   s) (''CPACR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CPACR_EL1'') then(CPACR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CPACR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CPACR_EL1_Type v)) |) )\<close>


definition GCSPR_EL3_ref  :: \<open>((regstate),(register_value),(GCSPR_EL3_Type))register_ref \<close>  where 
     \<open> GCSPR_EL3_ref = ( (|
  name = (''GCSPR_EL3''),
  read_from = ((\<lambda> s .  (| GCSPR_EL3_Type_bits = ((bitvector_64_reg   s) (''GCSPR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GCSPR_EL3'') then(GCSPR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GCSPR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GCSPR_EL3_Type v)) |) )\<close>


definition GCSPR_EL2_ref  :: \<open>((regstate),(register_value),(GCSPR_EL2_Type))register_ref \<close>  where 
     \<open> GCSPR_EL2_ref = ( (|
  name = (''GCSPR_EL2''),
  read_from = ((\<lambda> s .  (| GCSPR_EL2_Type_bits = ((bitvector_64_reg   s) (''GCSPR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GCSPR_EL2'') then(GCSPR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GCSPR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GCSPR_EL2_Type v)) |) )\<close>


definition GCSPR_EL1_ref  :: \<open>((regstate),(register_value),(GCSPR_EL1_Type))register_ref \<close>  where 
     \<open> GCSPR_EL1_ref = ( (|
  name = (''GCSPR_EL1''),
  read_from = ((\<lambda> s .  (| GCSPR_EL1_Type_bits = ((bitvector_64_reg   s) (''GCSPR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GCSPR_EL1'') then(GCSPR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GCSPR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GCSPR_EL1_Type v)) |) )\<close>


definition GCSPR_EL0_ref  :: \<open>((regstate),(register_value),(GCSPR_EL0_Type))register_ref \<close>  where 
     \<open> GCSPR_EL0_ref = ( (|
  name = (''GCSPR_EL0''),
  read_from = ((\<lambda> s .  (| GCSPR_EL0_Type_bits = ((bitvector_64_reg   s) (''GCSPR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''GCSPR_EL0'') then(GCSPR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  GCSPR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_GCSPR_EL0_Type v)) |) )\<close>


definition SMCR_EL3_ref  :: \<open>((regstate),(register_value),(SMCR_EL3_Type))register_ref \<close>  where 
     \<open> SMCR_EL3_ref = ( (|
  name = (''SMCR_EL3''),
  read_from = ((\<lambda> s .  (| SMCR_EL3_Type_bits = ((bitvector_64_reg   s) (''SMCR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SMCR_EL3'') then(SMCR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SMCR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SMCR_EL3_Type v)) |) )\<close>


definition SMCR_EL2_ref  :: \<open>((regstate),(register_value),(SMCR_EL2_Type))register_ref \<close>  where 
     \<open> SMCR_EL2_ref = ( (|
  name = (''SMCR_EL2''),
  read_from = ((\<lambda> s .  (| SMCR_EL2_Type_bits = ((bitvector_64_reg   s) (''SMCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SMCR_EL2'') then(SMCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SMCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SMCR_EL2_Type v)) |) )\<close>


definition SMCR_EL1_ref  :: \<open>((regstate),(register_value),(SMCR_EL1_Type))register_ref \<close>  where 
     \<open> SMCR_EL1_ref = ( (|
  name = (''SMCR_EL1''),
  read_from = ((\<lambda> s .  (| SMCR_EL1_Type_bits = ((bitvector_64_reg   s) (''SMCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SMCR_EL1'') then(SMCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SMCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SMCR_EL1_Type v)) |) )\<close>


definition ZCR_EL3_ref  :: \<open>((regstate),(register_value),(ZCR_EL3_Type))register_ref \<close>  where 
     \<open> ZCR_EL3_ref = ( (|
  name = (''ZCR_EL3''),
  read_from = ((\<lambda> s .  (| ZCR_EL3_Type_bits = ((bitvector_64_reg   s) (''ZCR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ZCR_EL3'') then(ZCR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ZCR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ZCR_EL3_Type v)) |) )\<close>


definition ZCR_EL2_ref  :: \<open>((regstate),(register_value),(ZCR_EL2_Type))register_ref \<close>  where 
     \<open> ZCR_EL2_ref = ( (|
  name = (''ZCR_EL2''),
  read_from = ((\<lambda> s .  (| ZCR_EL2_Type_bits = ((bitvector_64_reg   s) (''ZCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ZCR_EL2'') then(ZCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ZCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ZCR_EL2_Type v)) |) )\<close>


definition ZCR_EL1_ref  :: \<open>((regstate),(register_value),(ZCR_EL1_Type))register_ref \<close>  where 
     \<open> ZCR_EL1_ref = ( (|
  name = (''ZCR_EL1''),
  read_from = ((\<lambda> s .  (| ZCR_EL1_Type_bits = ((bitvector_64_reg   s) (''ZCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ZCR_EL1'') then(ZCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ZCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ZCR_EL1_Type v)) |) )\<close>


definition PMBSR_EL1_ref  :: \<open>((regstate),(register_value),(PMBSR_EL1_Type))register_ref \<close>  where 
     \<open> PMBSR_EL1_ref = ( (|
  name = (''PMBSR_EL1''),
  read_from = ((\<lambda> s .  (| PMBSR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMBSR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMBSR_EL1'') then(PMBSR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMBSR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMBSR_EL1_Type v)) |) )\<close>


definition PMBLIMITR_EL1_ref  :: \<open>((regstate),(register_value),(PMBLIMITR_EL1_Type))register_ref \<close>  where 
     \<open> PMBLIMITR_EL1_ref = ( (|
  name = (''PMBLIMITR_EL1''),
  read_from = ((\<lambda> s .  (| PMBLIMITR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMBLIMITR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMBLIMITR_EL1'') then(PMBLIMITR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMBLIMITR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMBLIMITR_EL1_Type v)) |) )\<close>


definition PMSCR_EL2_ref  :: \<open>((regstate),(register_value),(PMSCR_EL2_Type))register_ref \<close>  where 
     \<open> PMSCR_EL2_ref = ( (|
  name = (''PMSCR_EL2''),
  read_from = ((\<lambda> s .  (| PMSCR_EL2_Type_bits = ((bitvector_64_reg   s) (''PMSCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSCR_EL2'') then(PMSCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSCR_EL2_Type v)) |) )\<close>


definition PMSCR_EL1_ref  :: \<open>((regstate),(register_value),(PMSCR_EL1_Type))register_ref \<close>  where 
     \<open> PMSCR_EL1_ref = ( (|
  name = (''PMSCR_EL1''),
  read_from = ((\<lambda> s .  (| PMSCR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMSCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSCR_EL1'') then(PMSCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSCR_EL1_Type v)) |) )\<close>


definition SPESampleAddressValid_ref  :: \<open>((regstate),(register_value),((bool)list))register_ref \<close>  where 
     \<open> SPESampleAddressValid_ref = ( (|
  name = (''SPESampleAddressValid''),
  read_from = ((\<lambda> s . (vector_32_bool_reg   s) (''SPESampleAddressValid''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleAddressValid'') then v else(vector_32_bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bool_of_register_value v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  register_value_of_bool v)) v)) |) )\<close>


definition SPESampleAddress_ref  :: \<open>((regstate),(register_value),(((64)Word.word)list))register_ref \<close>  where 
     \<open> SPESampleAddress_ref = ( (|
  name = (''SPESampleAddress''),
  read_from = ((\<lambda> s . (vector_32_bitvector_64_reg   s) (''SPESampleAddress''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleAddress'') then v else(vector_32_bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_64_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_64 v)) v)) |) )\<close>


definition PMSIDR_EL1_ref  :: \<open>((regstate),(register_value),(PMSIDR_EL1_Type))register_ref \<close>  where 
     \<open> PMSIDR_EL1_ref = ( (|
  name = (''PMSIDR_EL1''),
  read_from = ((\<lambda> s .  (| PMSIDR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMSIDR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMSIDR_EL1'') then(PMSIDR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMSIDR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMSIDR_EL1_Type v)) |) )\<close>


definition Records_TGT_ref  :: \<open>((regstate),(register_value),((BRBTGTType)list))register_ref \<close>  where 
     \<open> Records_TGT_ref = ( (|
  name = (''Records_TGT''),
  read_from = ((\<lambda> s . (vector_64_BRBTGTType_reg   s) (''Records_TGT''))),
  write_to = ((\<lambda> v s .  (( s (| vector_64_BRBTGTType_reg :=
  ((\<lambda> reg .  if reg = (''Records_TGT'') then v else(vector_64_BRBTGTType_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  BRBTGTType_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_BRBTGTType v)) v)) |) )\<close>


definition Records_SRC_ref  :: \<open>((regstate),(register_value),((BRBSRCType)list))register_ref \<close>  where 
     \<open> Records_SRC_ref = ( (|
  name = (''Records_SRC''),
  read_from = ((\<lambda> s . (vector_64_BRBSRCType_reg   s) (''Records_SRC''))),
  write_to = ((\<lambda> v s .  (( s (| vector_64_BRBSRCType_reg :=
  ((\<lambda> reg .  if reg = (''Records_SRC'') then v else(vector_64_BRBSRCType_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  BRBSRCType_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_BRBSRCType v)) v)) |) )\<close>


definition Records_INF_ref  :: \<open>((regstate),(register_value),((BRBINFType)list))register_ref \<close>  where 
     \<open> Records_INF_ref = ( (|
  name = (''Records_INF''),
  read_from = ((\<lambda> s . (vector_64_BRBINFType_reg   s) (''Records_INF''))),
  write_to = ((\<lambda> v s .  (( s (| vector_64_BRBINFType_reg :=
  ((\<lambda> reg .  if reg = (''Records_INF'') then v else(vector_64_BRBINFType_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  BRBINFType_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_BRBINFType v)) v)) |) )\<close>


definition BRBIDR0_EL1_ref  :: \<open>((regstate),(register_value),(BRBIDR0_EL1_Type))register_ref \<close>  where 
     \<open> BRBIDR0_EL1_ref = ( (|
  name = (''BRBIDR0_EL1''),
  read_from = ((\<lambda> s .  (| BRBIDR0_EL1_Type_bits = ((bitvector_64_reg   s) (''BRBIDR0_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''BRBIDR0_EL1'') then(BRBIDR0_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  BRBIDR0_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_BRBIDR0_EL1_Type v)) |) )\<close>


definition TCR_EL3_ref  :: \<open>((regstate),(register_value),(TCR_EL3_Type))register_ref \<close>  where 
     \<open> TCR_EL3_ref = ( (|
  name = (''TCR_EL3''),
  read_from = ((\<lambda> s .  (| TCR_EL3_Type_bits = ((bitvector_64_reg   s) (''TCR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TCR_EL3'') then(TCR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TCR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TCR_EL3_Type v)) |) )\<close>


definition TCR_EL2_ref  :: \<open>((regstate),(register_value),(TCR_EL2_Type))register_ref \<close>  where 
     \<open> TCR_EL2_ref = ( (|
  name = (''TCR_EL2''),
  read_from = ((\<lambda> s .  (| TCR_EL2_Type_bits = ((bitvector_64_reg   s) (''TCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TCR_EL2'') then(TCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TCR_EL2_Type v)) |) )\<close>


definition TCR_EL1_ref  :: \<open>((regstate),(register_value),(TCR_EL1_Type))register_ref \<close>  where 
     \<open> TCR_EL1_ref = ( (|
  name = (''TCR_EL1''),
  read_from = ((\<lambda> s .  (| TCR_EL1_Type_bits = ((bitvector_64_reg   s) (''TCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''TCR_EL1'') then(TCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TCR_EL1_Type v)) |) )\<close>


definition DSPSR2_ref  :: \<open>((regstate),(register_value),(DSPSR2_Type))register_ref \<close>  where 
     \<open> DSPSR2_ref = ( (|
  name = (''_DSPSR2''),
  read_from = ((\<lambda> s .  (| DSPSR2_Type_bits = ((bitvector_32_reg   s) (''_DSPSR2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DSPSR2'') then(DSPSR2_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DSPSR2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DSPSR2_Type v)) |) )\<close>


definition DSPSR_ref  :: \<open>((regstate),(register_value),(DSPSR_Type))register_ref \<close>  where 
     \<open> DSPSR_ref = ( (|
  name = (''_DSPSR''),
  read_from = ((\<lambda> s .  (| DSPSR_Type_bits = ((bitvector_32_reg   s) (''_DSPSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DSPSR'') then(DSPSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DSPSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DSPSR_Type v)) |) )\<close>


definition DSPSR_EL0_ref  :: \<open>((regstate),(register_value),(DSPSR_EL0_Type))register_ref \<close>  where 
     \<open> DSPSR_EL0_ref = ( (|
  name = (''DSPSR_EL0''),
  read_from = ((\<lambda> s .  (| DSPSR_EL0_Type_bits = ((bitvector_64_reg   s) (''DSPSR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DSPSR_EL0'') then(DSPSR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DSPSR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DSPSR_EL0_Type v)) |) )\<close>


definition DLR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> DLR_ref = ( (|
  name = (''_DLR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''_DLR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DLR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition DLR_EL0_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> DLR_EL0_ref = ( (|
  name = (''DLR_EL0''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''DLR_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''DLR_EL0'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition EDECR_ref  :: \<open>((regstate),(register_value),(EDECR_Type))register_ref \<close>  where 
     \<open> EDECR_ref = ( (|
  name = (''EDECR''),
  read_from = ((\<lambda> s .  (| EDECR_Type_bits = ((bitvector_32_reg   s) (''EDECR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''EDECR'') then(EDECR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDECR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDECR_Type v)) |) )\<close>


definition mpam_vpmr_max_ref  :: \<open>((regstate),(register_value),((3)Word.word))register_ref \<close>  where 
     \<open> mpam_vpmr_max_ref = ( (|
  name = (''__mpam_vpmr_max''),
  read_from = ((\<lambda> s . (bitvector_3_reg   s) (''__mpam_vpmr_max''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_3_reg :=
  ((\<lambda> reg .  if reg = (''__mpam_vpmr_max'') then v else(bitvector_3_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_3_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_3 v)) |) )\<close>


definition mpam_pmg_max_ref  :: \<open>((regstate),(register_value),((8)Word.word))register_ref \<close>  where 
     \<open> mpam_pmg_max_ref = ( (|
  name = (''__mpam_pmg_max''),
  read_from = ((\<lambda> s . (bitvector_8_reg   s) (''__mpam_pmg_max''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_8_reg :=
  ((\<lambda> reg .  if reg = (''__mpam_pmg_max'') then v else(bitvector_8_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_8_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_8 v)) |) )\<close>


definition mpam_partid_max_ref  :: \<open>((regstate),(register_value),((16)Word.word))register_ref \<close>  where 
     \<open> mpam_partid_max_ref = ( (|
  name = (''__mpam_partid_max''),
  read_from = ((\<lambda> s . (bitvector_16_reg   s) (''__mpam_partid_max''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_16_reg :=
  ((\<lambda> reg .  if reg = (''__mpam_partid_max'') then v else(bitvector_16_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_16_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_16 v)) |) )\<close>


definition mpam_has_hcr_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> mpam_has_hcr_ref = ( (|
  name = (''__mpam_has_hcr''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__mpam_has_hcr''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__mpam_has_hcr'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition impdef_TG1_ref  :: \<open>((regstate),(register_value),((2)Word.word))register_ref \<close>  where 
     \<open> impdef_TG1_ref = ( (|
  name = (''__impdef_TG1''),
  read_from = ((\<lambda> s . (bitvector_2_reg   s) (''__impdef_TG1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_2_reg :=
  ((\<lambda> reg .  if reg = (''__impdef_TG1'') then v else(bitvector_2_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_2_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_2 v)) |) )\<close>


definition impdef_TG0_ref  :: \<open>((regstate),(register_value),((2)Word.word))register_ref \<close>  where 
     \<open> impdef_TG0_ref = ( (|
  name = (''__impdef_TG0''),
  read_from = ((\<lambda> s . (bitvector_2_reg   s) (''__impdef_TG0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_2_reg :=
  ((\<lambda> reg .  if reg = (''__impdef_TG0'') then v else(bitvector_2_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_2_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_2 v)) |) )\<close>


definition CFG_RVBAR_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> CFG_RVBAR_ref = ( (|
  name = (''CFG_RVBAR''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''CFG_RVBAR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CFG_RVBAR'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition CNTHCTL_EL2_ref  :: \<open>((regstate),(register_value),(CNTHCTL_EL2_Type))register_ref \<close>  where 
     \<open> CNTHCTL_EL2_ref = ( (|
  name = (''CNTHCTL_EL2''),
  read_from = ((\<lambda> s .  (| CNTHCTL_EL2_Type_bits = ((bitvector_64_reg   s) (''CNTHCTL_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTHCTL_EL2'') then(CNTHCTL_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CNTHCTL_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CNTHCTL_EL2_Type v)) |) )\<close>


definition CNTVOFF_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> CNTVOFF_EL2_ref = ( (|
  name = (''CNTVOFF_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''CNTVOFF_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTVOFF_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition CNTPOFF_EL2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> CNTPOFF_EL2_ref = ( (|
  name = (''CNTPOFF_EL2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''CNTPOFF_EL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CNTPOFF_EL2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition BRBTS_EL1_ref  :: \<open>((regstate),(register_value),(BRBTS_EL1_Type))register_ref \<close>  where 
     \<open> BRBTS_EL1_ref = ( (|
  name = (''BRBTS_EL1''),
  read_from = ((\<lambda> s .  (| BRBTS_EL1_Type_bits = ((bitvector_64_reg   s) (''BRBTS_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''BRBTS_EL1'') then(BRBTS_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  BRBTS_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_BRBTS_EL1_Type v)) |) )\<close>


definition BRBFCR_EL1_ref  :: \<open>((regstate),(register_value),(BRBFCR_EL1_Type))register_ref \<close>  where 
     \<open> BRBFCR_EL1_ref = ( (|
  name = (''BRBFCR_EL1''),
  read_from = ((\<lambda> s .  (| BRBFCR_EL1_Type_bits = ((bitvector_64_reg   s) (''BRBFCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''BRBFCR_EL1'') then(BRBFCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  BRBFCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_BRBFCR_EL1_Type v)) |) )\<close>


definition BRBCR_EL2_ref  :: \<open>((regstate),(register_value),(BRBCR_EL2_Type))register_ref \<close>  where 
     \<open> BRBCR_EL2_ref = ( (|
  name = (''BRBCR_EL2''),
  read_from = ((\<lambda> s .  (| BRBCR_EL2_Type_bits = ((bitvector_64_reg   s) (''BRBCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''BRBCR_EL2'') then(BRBCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  BRBCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_BRBCR_EL2_Type v)) |) )\<close>


definition BRBCR_EL1_ref  :: \<open>((regstate),(register_value),(BRBCR_EL1_Type))register_ref \<close>  where 
     \<open> BRBCR_EL1_ref = ( (|
  name = (''BRBCR_EL1''),
  read_from = ((\<lambda> s .  (| BRBCR_EL1_Type_bits = ((bitvector_64_reg   s) (''BRBCR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''BRBCR_EL1'') then(BRBCR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  BRBCR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_BRBCR_EL1_Type v)) |) )\<close>


definition PMOVSSET_EL0_ref  :: \<open>((regstate),(register_value),(PMOVSSET_EL0_Type))register_ref \<close>  where 
     \<open> PMOVSSET_EL0_ref = ( (|
  name = (''PMOVSSET_EL0''),
  read_from = ((\<lambda> s .  (| PMOVSSET_EL0_Type_bits = ((bitvector_64_reg   s) (''PMOVSSET_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMOVSSET_EL0'') then(PMOVSSET_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMOVSSET_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMOVSSET_EL0_Type v)) |) )\<close>


definition PMICNTR_EL0_ref  :: \<open>((regstate),(register_value),(PMICNTR_EL0_Type))register_ref \<close>  where 
     \<open> PMICNTR_EL0_ref = ( (|
  name = (''PMICNTR_EL0''),
  read_from = ((\<lambda> s .  (| PMICNTR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMICNTR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMICNTR_EL0'') then(PMICNTR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMICNTR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMICNTR_EL0_Type v)) |) )\<close>


definition SDER_ref  :: \<open>((regstate),(register_value),(SDER_Type))register_ref \<close>  where 
     \<open> SDER_ref = ( (|
  name = (''_SDER''),
  read_from = ((\<lambda> s .  (| SDER_Type_bits = ((bitvector_32_reg   s) (''_SDER'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_SDER'') then(SDER_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SDER_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SDER_Type v)) |) )\<close>


definition SDER32_EL3_ref  :: \<open>((regstate),(register_value),(SDER32_EL3_Type))register_ref \<close>  where 
     \<open> SDER32_EL3_ref = ( (|
  name = (''_SDER32_EL3''),
  read_from = ((\<lambda> s .  (| SDER32_EL3_Type_bits = ((bitvector_64_reg   s) (''_SDER32_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_SDER32_EL3'') then(SDER32_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SDER32_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SDER32_EL3_Type v)) |) )\<close>


definition SDER32_EL2_ref  :: \<open>((regstate),(register_value),(SDER32_EL2_Type))register_ref \<close>  where 
     \<open> SDER32_EL2_ref = ( (|
  name = (''SDER32_EL2''),
  read_from = ((\<lambda> s .  (| SDER32_EL2_Type_bits = ((bitvector_64_reg   s) (''SDER32_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SDER32_EL2'') then(SDER32_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SDER32_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SDER32_EL2_Type v)) |) )\<close>


definition SDCR_ref  :: \<open>((regstate),(register_value),(SDCR_Type))register_ref \<close>  where 
     \<open> SDCR_ref = ( (|
  name = (''SDCR''),
  read_from = ((\<lambda> s .  (| SDCR_Type_bits = ((bitvector_32_reg   s) (''SDCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''SDCR'') then(SDCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SDCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SDCR_Type v)) |) )\<close>


definition PMICFILTR_EL0_ref  :: \<open>((regstate),(register_value),(PMICFILTR_EL0_Type))register_ref \<close>  where 
     \<open> PMICFILTR_EL0_ref = ( (|
  name = (''PMICFILTR_EL0''),
  read_from = ((\<lambda> s .  (| PMICFILTR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMICFILTR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMICFILTR_EL0'') then(PMICFILTR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMICFILTR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMICFILTR_EL0_Type v)) |) )\<close>


definition PMEVTYPER_ref  :: \<open>((regstate),(register_value),((PMEVTYPER_Type)list))register_ref \<close>  where 
     \<open> PMEVTYPER_ref = ( (|
  name = (''_PMEVTYPER''),
  read_from = ((\<lambda> s . (vector_31_PMEVTYPER_Type_reg   s) (''_PMEVTYPER''))),
  write_to = ((\<lambda> v s .  (( s (| vector_31_PMEVTYPER_Type_reg :=
  ((\<lambda> reg .  if reg = (''_PMEVTYPER'') then v else(vector_31_PMEVTYPER_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  PMEVTYPER_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_PMEVTYPER_Type v)) v)) |) )\<close>


definition PMEVTYPER_EL0_ref  :: \<open>((regstate),(register_value),((PMEVTYPER_EL0_Type)list))register_ref \<close>  where 
     \<open> PMEVTYPER_EL0_ref = ( (|
  name = (''PMEVTYPER_EL0''),
  read_from = ((\<lambda> s . (vector_32_PMEVTYPER_EL0_Type_reg   s) (''PMEVTYPER_EL0''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_PMEVTYPER_EL0_Type_reg :=
  ((\<lambda> reg .  if reg = (''PMEVTYPER_EL0'') then v else(vector_32_PMEVTYPER_EL0_Type_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  PMEVTYPER_EL0_Type_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_PMEVTYPER_EL0_Type v)) v)) |) )\<close>


definition PMCNTENSET_ref  :: \<open>((regstate),(register_value),(PMCNTENSET_Type))register_ref \<close>  where 
     \<open> PMCNTENSET_ref = ( (|
  name = (''_PMCNTENSET''),
  read_from = ((\<lambda> s .  (| PMCNTENSET_Type_bits = ((bitvector_32_reg   s) (''_PMCNTENSET'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMCNTENSET'') then(PMCNTENSET_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCNTENSET_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCNTENSET_Type v)) |) )\<close>


definition PMCNTENSET_EL0_ref  :: \<open>((regstate),(register_value),(PMCNTENSET_EL0_Type))register_ref \<close>  where 
     \<open> PMCNTENSET_EL0_ref = ( (|
  name = (''PMCNTENSET_EL0''),
  read_from = ((\<lambda> s .  (| PMCNTENSET_EL0_Type_bits = ((bitvector_64_reg   s) (''PMCNTENSET_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMCNTENSET_EL0'') then(PMCNTENSET_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCNTENSET_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCNTENSET_EL0_Type v)) |) )\<close>


definition PMCCFILTR_ref  :: \<open>((regstate),(register_value),(PMCCFILTR_Type))register_ref \<close>  where 
     \<open> PMCCFILTR_ref = ( (|
  name = (''_PMCCFILTR''),
  read_from = ((\<lambda> s .  (| PMCCFILTR_Type_bits = ((bitvector_32_reg   s) (''_PMCCFILTR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMCCFILTR'') then(PMCCFILTR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCCFILTR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCCFILTR_Type v)) |) )\<close>


definition PMCCFILTR_EL0_ref  :: \<open>((regstate),(register_value),(PMCCFILTR_EL0_Type))register_ref \<close>  where 
     \<open> PMCCFILTR_EL0_ref = ( (|
  name = (''PMCCFILTR_EL0''),
  read_from = ((\<lambda> s .  (| PMCCFILTR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMCCFILTR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMCCFILTR_EL0'') then(PMCCFILTR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCCFILTR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCCFILTR_EL0_Type v)) |) )\<close>


definition MDCR_EL3_ref  :: \<open>((regstate),(register_value),(MDCR_EL3_Type))register_ref \<close>  where 
     \<open> MDCR_EL3_ref = ( (|
  name = (''MDCR_EL3''),
  read_from = ((\<lambda> s .  (| MDCR_EL3_Type_bits = ((bitvector_64_reg   s) (''MDCR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MDCR_EL3'') then(MDCR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MDCR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MDCR_EL3_Type v)) |) )\<close>


definition PMOVSR_ref  :: \<open>((regstate),(register_value),(PMOVSR_Type))register_ref \<close>  where 
     \<open> PMOVSR_ref = ( (|
  name = (''_PMOVSR''),
  read_from = ((\<lambda> s .  (| PMOVSR_Type_bits = ((bitvector_32_reg   s) (''_PMOVSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMOVSR'') then(PMOVSR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMOVSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMOVSR_Type v)) |) )\<close>


definition PMOVSCLR_EL0_ref  :: \<open>((regstate),(register_value),(PMOVSCLR_EL0_Type))register_ref \<close>  where 
     \<open> PMOVSCLR_EL0_ref = ( (|
  name = (''PMOVSCLR_EL0''),
  read_from = ((\<lambda> s .  (| PMOVSCLR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMOVSCLR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMOVSCLR_EL0'') then(PMOVSCLR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMOVSCLR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMOVSCLR_EL0_Type v)) |) )\<close>


definition PMINTENCLR_ref  :: \<open>((regstate),(register_value),(PMINTENCLR_Type))register_ref \<close>  where 
     \<open> PMINTENCLR_ref = ( (|
  name = (''_PMINTENCLR''),
  read_from = ((\<lambda> s .  (| PMINTENCLR_Type_bits = ((bitvector_32_reg   s) (''_PMINTENCLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMINTENCLR'') then(PMINTENCLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMINTENCLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMINTENCLR_Type v)) |) )\<close>


definition PMINTENCLR_EL1_ref  :: \<open>((regstate),(register_value),(PMINTENCLR_EL1_Type))register_ref \<close>  where 
     \<open> PMINTENCLR_EL1_ref = ( (|
  name = (''PMINTENCLR_EL1''),
  read_from = ((\<lambda> s .  (| PMINTENCLR_EL1_Type_bits = ((bitvector_64_reg   s) (''PMINTENCLR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMINTENCLR_EL1'') then(PMINTENCLR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMINTENCLR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMINTENCLR_EL1_Type v)) |) )\<close>


definition PMCR_ref  :: \<open>((regstate),(register_value),(PMCR_Type))register_ref \<close>  where 
     \<open> PMCR_ref = ( (|
  name = (''_PMCR''),
  read_from = ((\<lambda> s .  (| PMCR_Type_bits = ((bitvector_32_reg   s) (''_PMCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMCR'') then(PMCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCR_Type v)) |) )\<close>


definition PMCR_EL0_ref  :: \<open>((regstate),(register_value),(PMCR_EL0_Type))register_ref \<close>  where 
     \<open> PMCR_EL0_ref = ( (|
  name = (''PMCR_EL0''),
  read_from = ((\<lambda> s .  (| PMCR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMCR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMCR_EL0'') then(PMCR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCR_EL0_Type v)) |) )\<close>


definition PMCNTENCLR_ref  :: \<open>((regstate),(register_value),(PMCNTENCLR_Type))register_ref \<close>  where 
     \<open> PMCNTENCLR_ref = ( (|
  name = (''_PMCNTENCLR''),
  read_from = ((\<lambda> s .  (| PMCNTENCLR_Type_bits = ((bitvector_32_reg   s) (''_PMCNTENCLR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_PMCNTENCLR'') then(PMCNTENCLR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCNTENCLR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCNTENCLR_Type v)) |) )\<close>


definition PMCNTENCLR_EL0_ref  :: \<open>((regstate),(register_value),(PMCNTENCLR_EL0_Type))register_ref \<close>  where 
     \<open> PMCNTENCLR_EL0_ref = ( (|
  name = (''PMCNTENCLR_EL0''),
  read_from = ((\<lambda> s .  (| PMCNTENCLR_EL0_Type_bits = ((bitvector_64_reg   s) (''PMCNTENCLR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''PMCNTENCLR_EL0'') then(PMCNTENCLR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  PMCNTENCLR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_PMCNTENCLR_EL0_Type v)) |) )\<close>


definition EDSCR_ref  :: \<open>((regstate),(register_value),(EDSCR_Type))register_ref \<close>  where 
     \<open> EDSCR_ref = ( (|
  name = (''_EDSCR''),
  read_from = ((\<lambda> s .  (| EDSCR_Type_bits = ((bitvector_32_reg   s) (''_EDSCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_EDSCR'') then(EDSCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  EDSCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_EDSCR_Type v)) |) )\<close>


definition MDCCSR_EL0_ref  :: \<open>((regstate),(register_value),(MDCCSR_EL0_Type))register_ref \<close>  where 
     \<open> MDCCSR_EL0_ref = ( (|
  name = (''MDCCSR_EL0''),
  read_from = ((\<lambda> s .  (| MDCCSR_EL0_Type_bits = ((bitvector_64_reg   s) (''MDCCSR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MDCCSR_EL0'') then(MDCCSR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MDCCSR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MDCCSR_EL0_Type v)) |) )\<close>


definition HDCR_ref  :: \<open>((regstate),(register_value),(HDCR_Type))register_ref \<close>  where 
     \<open> HDCR_ref = ( (|
  name = (''_HDCR''),
  read_from = ((\<lambda> s .  (| HDCR_Type_bits = ((bitvector_32_reg   s) (''_HDCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_HDCR'') then(HDCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HDCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HDCR_Type v)) |) )\<close>


definition MDCR_EL2_ref  :: \<open>((regstate),(register_value),(MDCR_EL2_Type))register_ref \<close>  where 
     \<open> MDCR_EL2_ref = ( (|
  name = (''MDCR_EL2''),
  read_from = ((\<lambda> s .  (| MDCR_EL2_Type_bits = ((bitvector_64_reg   s) (''MDCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''MDCR_EL2'') then(MDCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  MDCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_MDCR_EL2_Type v)) |) )\<close>


definition supported_pa_size_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> supported_pa_size_ref = ( (|
  name = (''__supported_pa_size''),
  read_from = ((\<lambda> s . (int_reg   s) (''__supported_pa_size''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__supported_pa_size'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition max_implemented_sveveclen_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> max_implemented_sveveclen_ref = ( (|
  name = (''__max_implemented_sveveclen''),
  read_from = ((\<lambda> s . (int_reg   s) (''__max_implemented_sveveclen''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__max_implemented_sveveclen'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition max_implemented_smeveclen_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> max_implemented_smeveclen_ref = ( (|
  name = (''__max_implemented_smeveclen''),
  read_from = ((\<lambda> s . (int_reg   s) (''__max_implemented_smeveclen''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__max_implemented_smeveclen'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition has_sve_extended_bf16_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> has_sve_extended_bf16_ref = ( (|
  name = (''__has_sve_extended_bf16''),
  read_from = ((\<lambda> s . (int_reg   s) (''__has_sve_extended_bf16''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__has_sve_extended_bf16'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition block_bbm_implemented_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> block_bbm_implemented_ref = ( (|
  name = (''__block_bbm_implemented''),
  read_from = ((\<lambda> s . (int_reg   s) (''__block_bbm_implemented''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__block_bbm_implemented'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition CTR_EL0_ref  :: \<open>((regstate),(register_value),(CTR_EL0_Type))register_ref \<close>  where 
     \<open> CTR_EL0_ref = ( (|
  name = (''CTR_EL0''),
  read_from = ((\<lambda> s .  (| CTR_EL0_Type_bits = ((bitvector_64_reg   s) (''CTR_EL0'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''CTR_EL0'') then(CTR_EL0_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  CTR_EL0_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_CTR_EL0_Type v)) |) )\<close>


definition ERRnFR_ref  :: \<open>((regstate),(register_value),((ERRnFR_ElemType)list))register_ref \<close>  where 
     \<open> ERRnFR_ref = ( (|
  name = (''ERRnFR''),
  read_from = ((\<lambda> s . (vector_4_ERRnFR_ElemType_reg   s) (''ERRnFR''))),
  write_to = ((\<lambda> v s .  (( s (| vector_4_ERRnFR_ElemType_reg :=
  ((\<lambda> reg .  if reg = (''ERRnFR'') then v else(vector_4_ERRnFR_ElemType_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  ERRnFR_ElemType_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_ERRnFR_ElemType v)) v)) |) )\<close>


definition RVBAR_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> RVBAR_ref = ( (|
  name = (''RVBAR''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''RVBAR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''RVBAR'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition FPSCR_ref  :: \<open>((regstate),(register_value),(FPSCR_Type))register_ref \<close>  where 
     \<open> FPSCR_ref = ( (|
  name = (''_FPSCR''),
  read_from = ((\<lambda> s .  (| FPSCR_Type_bits = ((bitvector_32_reg   s) (''_FPSCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_FPSCR'') then(FPSCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  FPSCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_FPSCR_Type v)) |) )\<close>


definition sme_only_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> sme_only_ref = ( (|
  name = (''__sme_only''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__sme_only''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__sme_only'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition setg_mops_option_a_supported_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> setg_mops_option_a_supported_ref = ( (|
  name = (''__setg_mops_option_a_supported''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__setg_mops_option_a_supported''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__setg_mops_option_a_supported'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition set_mops_option_a_supported_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> set_mops_option_a_supported_ref = ( (|
  name = (''__set_mops_option_a_supported''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__set_mops_option_a_supported''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__set_mops_option_a_supported'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition mte_implemented_ref  :: \<open>((regstate),(register_value),((4)Word.word))register_ref \<close>  where 
     \<open> mte_implemented_ref = ( (|
  name = (''__mte_implemented''),
  read_from = ((\<lambda> s . (bitvector_4_reg   s) (''__mte_implemented''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_4_reg :=
  ((\<lambda> reg .  if reg = (''__mte_implemented'') then v else(bitvector_4_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_4_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_4 v)) |) )\<close>


definition mpam_major_ref  :: \<open>((regstate),(register_value),((4)Word.word))register_ref \<close>  where 
     \<open> mpam_major_ref = ( (|
  name = (''__mpam_major''),
  read_from = ((\<lambda> s . (bitvector_4_reg   s) (''__mpam_major''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_4_reg :=
  ((\<lambda> reg .  if reg = (''__mpam_major'') then v else(bitvector_4_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_4_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_4 v)) |) )\<close>


definition mpam_frac_ref  :: \<open>((regstate),(register_value),((4)Word.word))register_ref \<close>  where 
     \<open> mpam_frac_ref = ( (|
  name = (''__mpam_frac''),
  read_from = ((\<lambda> s . (bitvector_4_reg   s) (''__mpam_frac''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_4_reg :=
  ((\<lambda> reg .  if reg = (''__mpam_frac'') then v else(bitvector_4_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_4_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_4 v)) |) )\<close>


definition isb_is_branch_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> isb_is_branch_ref = ( (|
  name = (''__isb_is_branch''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__isb_is_branch''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__isb_is_branch'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition has_sme_priority_control_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> has_sme_priority_control_ref = ( (|
  name = (''__has_sme_priority_control''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__has_sme_priority_control''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__has_sme_priority_control'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition feat_rpres_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> feat_rpres_ref = ( (|
  name = (''__feat_rpres''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__feat_rpres''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__feat_rpres'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition empam_tidr_implemented_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> empam_tidr_implemented_ref = ( (|
  name = (''__empam_tidr_implemented''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__empam_tidr_implemented''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__empam_tidr_implemented'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition empam_sdeflt_implemented_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> empam_sdeflt_implemented_ref = ( (|
  name = (''__empam_sdeflt_implemented''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__empam_sdeflt_implemented''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__empam_sdeflt_implemented'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition empam_force_ns_implemented_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> empam_force_ns_implemented_ref = ( (|
  name = (''__empam_force_ns_implemented''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__empam_force_ns_implemented''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__empam_force_ns_implemented'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition empam_force_ns_RAO_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> empam_force_ns_RAO_ref = ( (|
  name = (''__empam_force_ns_RAO''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__empam_force_ns_RAO''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__empam_force_ns_RAO'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition cpyf_mops_option_a_supported_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> cpyf_mops_option_a_supported_ref = ( (|
  name = (''__cpyf_mops_option_a_supported''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__cpyf_mops_option_a_supported''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__cpyf_mops_option_a_supported'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition cpy_mops_option_a_supported_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> cpy_mops_option_a_supported_ref = ( (|
  name = (''__cpy_mops_option_a_supported''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__cpy_mops_option_a_supported''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__cpy_mops_option_a_supported'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition apply_effective_shareability_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> apply_effective_shareability_ref = ( (|
  name = (''__apply_effective_shareability''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__apply_effective_shareability''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__apply_effective_shareability'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SCR_ref  :: \<open>((regstate),(register_value),(SCR_Type))register_ref \<close>  where 
     \<open> SCR_ref = ( (|
  name = (''SCR''),
  read_from = ((\<lambda> s .  (| SCR_Type_bits = ((bitvector_32_reg   s) (''SCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''SCR'') then(SCR_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SCR_Type v)) |) )\<close>


definition SCR_EL3_ref  :: \<open>((regstate),(register_value),(SCR_EL3_Type))register_ref \<close>  where 
     \<open> SCR_EL3_ref = ( (|
  name = (''SCR_EL3''),
  read_from = ((\<lambda> s .  (| SCR_EL3_Type_bits = ((bitvector_64_reg   s) (''SCR_EL3'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SCR_EL3'') then(SCR_EL3_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  SCR_EL3_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_SCR_EL3_Type v)) |) )\<close>


definition HCR_EL2_ref  :: \<open>((regstate),(register_value),(HCR_EL2_Type))register_ref \<close>  where 
     \<open> HCR_EL2_ref = ( (|
  name = (''HCR_EL2''),
  read_from = ((\<lambda> s .  (| HCR_EL2_Type_bits = ((bitvector_64_reg   s) (''HCR_EL2'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''HCR_EL2'') then(HCR_EL2_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  HCR_EL2_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_HCR_EL2_Type v)) |) )\<close>


definition Dclone_ref  :: \<open>((regstate),(register_value),(((64)Word.word)list))register_ref \<close>  where 
     \<open> Dclone_ref = ( (|
  name = (''_Dclone''),
  read_from = ((\<lambda> s . (vector_32_bitvector_64_reg   s) (''_Dclone''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_Dclone'') then v else(vector_32_bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_64_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_64 v)) v)) |) )\<close>


definition LR_mon_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> LR_mon_ref = ( (|
  name = (''LR_mon''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''LR_mon''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''LR_mon'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition SP_mon_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> SP_mon_ref = ( (|
  name = (''SP_mon''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''SP_mon''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''SP_mon'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition sp_rel_access_pc_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> sp_rel_access_pc_ref = ( (|
  name = (''sp_rel_access_pc''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''sp_rel_access_pc''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''sp_rel_access_pc'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition DCACHE_CCSIDR_RESET_ref  :: \<open>((regstate),(register_value),(((64)Word.word)list))register_ref \<close>  where 
     \<open> DCACHE_CCSIDR_RESET_ref = ( (|
  name = (''__DCACHE_CCSIDR_RESET''),
  read_from = ((\<lambda> s . (vector_7_bitvector_64_reg   s) (''__DCACHE_CCSIDR_RESET''))),
  write_to = ((\<lambda> v s .  (( s (| vector_7_bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''__DCACHE_CCSIDR_RESET'') then v else(vector_7_bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_64_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_64 v)) v)) |) )\<close>


definition ICACHE_CCSIDR_RESET_ref  :: \<open>((regstate),(register_value),(((64)Word.word)list))register_ref \<close>  where 
     \<open> ICACHE_CCSIDR_RESET_ref = ( (|
  name = (''__ICACHE_CCSIDR_RESET''),
  read_from = ((\<lambda> s . (vector_7_bitvector_64_reg   s) (''__ICACHE_CCSIDR_RESET''))),
  write_to = ((\<lambda> v s .  (( s (| vector_7_bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''__ICACHE_CCSIDR_RESET'') then v else(vector_7_bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_64_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_64 v)) v)) |) )\<close>


definition highest_el_aarch32_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> highest_el_aarch32_ref = ( (|
  name = (''__highest_el_aarch32''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__highest_el_aarch32''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__highest_el_aarch32'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition ExclusiveMonitorSet_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> ExclusiveMonitorSet_ref = ( (|
  name = (''__ExclusiveMonitorSet''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__ExclusiveMonitorSet''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__ExclusiveMonitorSet'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition BranchTaken_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> BranchTaken_ref = ( (|
  name = (''__BranchTaken''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__BranchTaken''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__BranchTaken'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition Branchtypetaken_ref  :: \<open>((regstate),(register_value),(BranchType))register_ref \<close>  where 
     \<open> Branchtypetaken_ref = ( (|
  name = (''Branchtypetaken''),
  read_from = ((\<lambda> s . (BranchType_reg   s) (''Branchtypetaken''))),
  write_to = ((\<lambda> v s .  (( s (| BranchType_reg :=
  ((\<lambda> reg .  if reg = (''Branchtypetaken'') then v else(BranchType_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  BranchType_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_BranchType v)) |) )\<close>


definition currentCond_ref  :: \<open>((regstate),(register_value),((4)Word.word))register_ref \<close>  where 
     \<open> currentCond_ref = ( (|
  name = (''__currentCond''),
  read_from = ((\<lambda> s . (bitvector_4_reg   s) (''__currentCond''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_4_reg :=
  ((\<lambda> reg .  if reg = (''__currentCond'') then v else(bitvector_4_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_4_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_4 v)) |) )\<close>


definition ThisInstrEnc_ref  :: \<open>((regstate),(register_value),(InstrEnc))register_ref \<close>  where 
     \<open> ThisInstrEnc_ref = ( (|
  name = (''__ThisInstrEnc''),
  read_from = ((\<lambda> s . (InstrEnc_reg   s) (''__ThisInstrEnc''))),
  write_to = ((\<lambda> v s .  (( s (| InstrEnc_reg :=
  ((\<lambda> reg .  if reg = (''__ThisInstrEnc'') then v else(InstrEnc_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  InstrEnc_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of___InstrEnc v)) |) )\<close>


definition ThisInstr_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> ThisInstr_ref = ( (|
  name = (''__ThisInstr''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''__ThisInstr''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''__ThisInstr'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition ETEBase_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> ETEBase_ref = ( (|
  name = (''__ETEBase''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__ETEBase''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__ETEBase'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition VLPI_base_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> VLPI_base_ref = ( (|
  name = (''__VLPI_base''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__VLPI_base''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__VLPI_base'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition SGI_base_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> SGI_base_ref = ( (|
  name = (''__SGI_base''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__SGI_base''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__SGI_base'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition RD_base_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> RD_base_ref = ( (|
  name = (''__RD_base''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__RD_base''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__RD_base'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition CNTCTLBase_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> CNTCTLBase_ref = ( (|
  name = (''__CNTCTLBase''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__CNTCTLBase''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__CNTCTLBase'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition CNTEL0BaseN_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> CNTEL0BaseN_ref = ( (|
  name = (''__CNTEL0BaseN''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__CNTEL0BaseN''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__CNTEL0BaseN'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition CNTBaseN_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> CNTBaseN_ref = ( (|
  name = (''__CNTBaseN''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__CNTBaseN''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__CNTBaseN'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition CNTReadBase_ref  :: \<open>((regstate),(register_value),((56)Word.word))register_ref \<close>  where 
     \<open> CNTReadBase_ref = ( (|
  name = (''__CNTReadBase''),
  read_from = ((\<lambda> s . (bitvector_56_reg   s) (''__CNTReadBase''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_56_reg :=
  ((\<lambda> reg .  if reg = (''__CNTReadBase'') then v else(bitvector_56_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_56_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_56 v)) |) )\<close>


definition InstructionStep_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> InstructionStep_ref = ( (|
  name = (''__InstructionStep''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__InstructionStep''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__InstructionStep'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition RTPIDEN_ref  :: \<open>((regstate),(register_value),(Signal))register_ref \<close>  where 
     \<open> RTPIDEN_ref = ( (|
  name = (''RTPIDEN''),
  read_from = ((\<lambda> s . (Signal_reg   s) (''RTPIDEN''))),
  write_to = ((\<lambda> v s .  (( s (| Signal_reg :=
  ((\<lambda> reg .  if reg = (''RTPIDEN'') then v else(Signal_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  Signal_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_Signal v)) |) )\<close>


definition RLPIDEN_ref  :: \<open>((regstate),(register_value),(Signal))register_ref \<close>  where 
     \<open> RLPIDEN_ref = ( (|
  name = (''RLPIDEN''),
  read_from = ((\<lambda> s . (Signal_reg   s) (''RLPIDEN''))),
  write_to = ((\<lambda> v s .  (( s (| Signal_reg :=
  ((\<lambda> reg .  if reg = (''RLPIDEN'') then v else(Signal_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  Signal_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_Signal v)) |) )\<close>


definition SPNIDEN_ref  :: \<open>((regstate),(register_value),(Signal))register_ref \<close>  where 
     \<open> SPNIDEN_ref = ( (|
  name = (''SPNIDEN''),
  read_from = ((\<lambda> s . (Signal_reg   s) (''SPNIDEN''))),
  write_to = ((\<lambda> v s .  (( s (| Signal_reg :=
  ((\<lambda> reg .  if reg = (''SPNIDEN'') then v else(Signal_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  Signal_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_Signal v)) |) )\<close>


definition SPIDEN_ref  :: \<open>((regstate),(register_value),(Signal))register_ref \<close>  where 
     \<open> SPIDEN_ref = ( (|
  name = (''SPIDEN''),
  read_from = ((\<lambda> s . (Signal_reg   s) (''SPIDEN''))),
  write_to = ((\<lambda> v s .  (( s (| Signal_reg :=
  ((\<lambda> reg .  if reg = (''SPIDEN'') then v else(Signal_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  Signal_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_Signal v)) |) )\<close>


definition NIDEN_ref  :: \<open>((regstate),(register_value),(Signal))register_ref \<close>  where 
     \<open> NIDEN_ref = ( (|
  name = (''NIDEN''),
  read_from = ((\<lambda> s . (Signal_reg   s) (''NIDEN''))),
  write_to = ((\<lambda> v s .  (( s (| Signal_reg :=
  ((\<lambda> reg .  if reg = (''NIDEN'') then v else(Signal_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  Signal_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_Signal v)) |) )\<close>


definition DBGEN_ref  :: \<open>((regstate),(register_value),(Signal))register_ref \<close>  where 
     \<open> DBGEN_ref = ( (|
  name = (''DBGEN''),
  read_from = ((\<lambda> s . (Signal_reg   s) (''DBGEN''))),
  write_to = ((\<lambda> v s .  (( s (| Signal_reg :=
  ((\<lambda> reg .  if reg = (''DBGEN'') then v else(Signal_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  Signal_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_Signal v)) |) )\<close>


definition last_branch_valid_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> last_branch_valid_ref = ( (|
  name = (''__last_branch_valid''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__last_branch_valid''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__last_branch_valid'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition last_cycle_count_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> last_cycle_count_ref = ( (|
  name = (''__last_cycle_count''),
  read_from = ((\<lambda> s . (int_reg   s) (''__last_cycle_count''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__last_cycle_count'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition SPERecordSize_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> SPERecordSize_ref = ( (|
  name = (''SPERecordSize''),
  read_from = ((\<lambda> s . (int_reg   s) (''SPERecordSize''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''SPERecordSize'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition SPE_LFSR_initialized_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> SPE_LFSR_initialized_ref = ( (|
  name = (''__SPE_LFSR_initialized''),
  read_from = ((\<lambda> s . (bool_reg   s) (''__SPE_LFSR_initialized''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''__SPE_LFSR_initialized'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SPE_LFSR_ref  :: \<open>((regstate),(register_value),((24)Word.word))register_ref \<close>  where 
     \<open> SPE_LFSR_ref = ( (|
  name = (''__SPE_LFSR''),
  read_from = ((\<lambda> s . (bitvector_24_reg   s) (''__SPE_LFSR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_24_reg :=
  ((\<lambda> reg .  if reg = (''__SPE_LFSR'') then v else(bitvector_24_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_24_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_24 v)) |) )\<close>


definition SPESampleEvents_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SPESampleEvents_ref = ( (|
  name = (''SPESampleEvents''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SPESampleEvents''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleEvents'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition SPESampleTimestampValid_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> SPESampleTimestampValid_ref = ( (|
  name = (''SPESampleTimestampValid''),
  read_from = ((\<lambda> s . (bool_reg   s) (''SPESampleTimestampValid''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleTimestampValid'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SPESampleTimestamp_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SPESampleTimestamp_ref = ( (|
  name = (''SPESampleTimestamp''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SPESampleTimestamp''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleTimestamp'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition SPESampleSubclassValid_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> SPESampleSubclassValid_ref = ( (|
  name = (''SPESampleSubclassValid''),
  read_from = ((\<lambda> s . (bool_reg   s) (''SPESampleSubclassValid''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleSubclassValid'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SPESampleSubclass_ref  :: \<open>((regstate),(register_value),((8)Word.word))register_ref \<close>  where 
     \<open> SPESampleSubclass_ref = ( (|
  name = (''SPESampleSubclass''),
  read_from = ((\<lambda> s . (bitvector_8_reg   s) (''SPESampleSubclass''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_8_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleSubclass'') then v else(bitvector_8_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_8_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_8 v)) |) )\<close>


definition SPESampleClass_ref  :: \<open>((regstate),(register_value),((2)Word.word))register_ref \<close>  where 
     \<open> SPESampleClass_ref = ( (|
  name = (''SPESampleClass''),
  read_from = ((\<lambda> s . (bitvector_2_reg   s) (''SPESampleClass''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_2_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleClass'') then v else(bitvector_2_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_2_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_2 v)) |) )\<close>


definition SPESampleOpType_ref  :: \<open>((regstate),(register_value),(OpType))register_ref \<close>  where 
     \<open> SPESampleOpType_ref = ( (|
  name = (''SPESampleOpType''),
  read_from = ((\<lambda> s . (OpType_reg   s) (''SPESampleOpType''))),
  write_to = ((\<lambda> v s .  (( s (| OpType_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleOpType'') then v else(OpType_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  OpType_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_OpType v)) |) )\<close>


definition SPESampleDataSourceValid_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> SPESampleDataSourceValid_ref = ( (|
  name = (''SPESampleDataSourceValid''),
  read_from = ((\<lambda> s . (bool_reg   s) (''SPESampleDataSourceValid''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleDataSourceValid'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SPESampleDataSource_ref  :: \<open>((regstate),(register_value),((16)Word.word))register_ref \<close>  where 
     \<open> SPESampleDataSource_ref = ( (|
  name = (''SPESampleDataSource''),
  read_from = ((\<lambda> s . (bitvector_16_reg   s) (''SPESampleDataSource''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_16_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleDataSource'') then v else(bitvector_16_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_16_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_16 v)) |) )\<close>


definition SPESamplePreviousBranchAddressValid_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> SPESamplePreviousBranchAddressValid_ref = ( (|
  name = (''SPESamplePreviousBranchAddressValid''),
  read_from = ((\<lambda> s . (bool_reg   s) (''SPESamplePreviousBranchAddressValid''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESamplePreviousBranchAddressValid'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SPESamplePreviousBranchAddress_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> SPESamplePreviousBranchAddress_ref = ( (|
  name = (''SPESamplePreviousBranchAddress''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''SPESamplePreviousBranchAddress''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''SPESamplePreviousBranchAddress'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition SPESampleInstIsNV2_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> SPESampleInstIsNV2_ref = ( (|
  name = (''SPESampleInstIsNV2''),
  read_from = ((\<lambda> s . (bool_reg   s) (''SPESampleInstIsNV2''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleInstIsNV2'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SPESampleContextEL2Valid_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> SPESampleContextEL2Valid_ref = ( (|
  name = (''SPESampleContextEL2Valid''),
  read_from = ((\<lambda> s . (bool_reg   s) (''SPESampleContextEL2Valid''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleContextEL2Valid'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SPESampleContextEL2_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> SPESampleContextEL2_ref = ( (|
  name = (''SPESampleContextEL2''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''SPESampleContextEL2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleContextEL2'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition SPESampleContextEL1Valid_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> SPESampleContextEL1Valid_ref = ( (|
  name = (''SPESampleContextEL1Valid''),
  read_from = ((\<lambda> s . (bool_reg   s) (''SPESampleContextEL1Valid''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleContextEL1Valid'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SPESampleContextEL1_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> SPESampleContextEL1_ref = ( (|
  name = (''SPESampleContextEL1''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''SPESampleContextEL1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleContextEL1'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition SPESampleInFlight_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> SPESampleInFlight_ref = ( (|
  name = (''SPESampleInFlight''),
  read_from = ((\<lambda> s . (bool_reg   s) (''SPESampleInFlight''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''SPESampleInFlight'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition TSTATE_ref  :: \<open>((regstate),(register_value),(TMState))register_ref \<close>  where 
     \<open> TSTATE_ref = ( (|
  name = (''TSTATE''),
  read_from = ((\<lambda> s . (TMState_reg   s) (''TSTATE''))),
  write_to = ((\<lambda> v s .  (( s (| TMState_reg :=
  ((\<lambda> reg .  if reg = (''TSTATE'') then v else(TMState_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  TMState_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_TMState v)) |) )\<close>


definition ICC_PMR_EL1_ref  :: \<open>((regstate),(register_value),(ICC_PMR_EL1_Type))register_ref \<close>  where 
     \<open> ICC_PMR_EL1_ref = ( (|
  name = (''ICC_PMR_EL1''),
  read_from = ((\<lambda> s .  (| ICC_PMR_EL1_Type_bits = ((bitvector_64_reg   s) (''ICC_PMR_EL1'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''ICC_PMR_EL1'') then(ICC_PMR_EL1_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ICC_PMR_EL1_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ICC_PMR_EL1_Type v)) |) )\<close>


definition FPSR_ref  :: \<open>((regstate),(register_value),(FPSR_Type))register_ref \<close>  where 
     \<open> FPSR_ref = ( (|
  name = (''FPSR''),
  read_from = ((\<lambda> s .  (| FPSR_Type_bits = ((bitvector_64_reg   s) (''FPSR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''FPSR'') then(FPSR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  FPSR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_FPSR_Type v)) |) )\<close>


definition FPCR_ref  :: \<open>((regstate),(register_value),(FPCR_Type))register_ref \<close>  where 
     \<open> FPCR_ref = ( (|
  name = (''FPCR''),
  read_from = ((\<lambda> s .  (| FPCR_Type_bits = ((bitvector_64_reg   s) (''FPCR'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''FPCR'') then(FPCR_Type_bits   v) else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  FPCR_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_FPCR_Type v)) |) )\<close>


definition ZT0_ref  :: \<open>((regstate),(register_value),((512)Word.word))register_ref \<close>  where 
     \<open> ZT0_ref = ( (|
  name = (''_ZT0''),
  read_from = ((\<lambda> s . (bitvector_512_reg   s) (''_ZT0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_512_reg :=
  ((\<lambda> reg .  if reg = (''_ZT0'') then v else(bitvector_512_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_512_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_512 v)) |) )\<close>


definition ZA_ref  :: \<open>((regstate),(register_value),(((2048)Word.word)list))register_ref \<close>  where 
     \<open> ZA_ref = ( (|
  name = (''_ZA''),
  read_from = ((\<lambda> s . (vector_256_bitvector_2048_reg   s) (''_ZA''))),
  write_to = ((\<lambda> v s .  (( s (| vector_256_bitvector_2048_reg :=
  ((\<lambda> reg .  if reg = (''_ZA'') then v else(vector_256_bitvector_2048_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_2048_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_2048 v)) v)) |) )\<close>


definition FFR_ref  :: \<open>((regstate),(register_value),((256)Word.word))register_ref \<close>  where 
     \<open> FFR_ref = ( (|
  name = (''_FFR''),
  read_from = ((\<lambda> s . (bitvector_256_reg   s) (''_FFR''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_256_reg :=
  ((\<lambda> reg .  if reg = (''_FFR'') then v else(bitvector_256_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_256_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_256 v)) |) )\<close>


definition P_ref  :: \<open>((regstate),(register_value),(((256)Word.word)list))register_ref \<close>  where 
     \<open> P_ref = ( (|
  name = (''_P''),
  read_from = ((\<lambda> s . (vector_16_bitvector_256_reg   s) (''_P''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_bitvector_256_reg :=
  ((\<lambda> reg .  if reg = (''_P'') then v else(vector_16_bitvector_256_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_256_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_256 v)) v)) |) )\<close>


definition Z_ref  :: \<open>((regstate),(register_value),(((2048)Word.word)list))register_ref \<close>  where 
     \<open> Z_ref = ( (|
  name = (''_Z''),
  read_from = ((\<lambda> s . (vector_32_bitvector_2048_reg   s) (''_Z''))),
  write_to = ((\<lambda> v s .  (( s (| vector_32_bitvector_2048_reg :=
  ((\<lambda> reg .  if reg = (''_Z'') then v else(vector_32_bitvector_2048_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_2048_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_2048 v)) v)) |) )\<close>


definition BTypeCompatible_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> BTypeCompatible_ref = ( (|
  name = (''BTypeCompatible''),
  read_from = ((\<lambda> s . (bool_reg   s) (''BTypeCompatible''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''BTypeCompatible'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition BTypeNext_ref  :: \<open>((regstate),(register_value),((2)Word.word))register_ref \<close>  where 
     \<open> BTypeNext_ref = ( (|
  name = (''BTypeNext''),
  read_from = ((\<lambda> s . (bitvector_2_reg   s) (''BTypeNext''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_2_reg :=
  ((\<lambda> reg .  if reg = (''BTypeNext'') then v else(bitvector_2_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_2_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_2 v)) |) )\<close>


definition InGuardedPage_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> InGuardedPage_ref = ( (|
  name = (''InGuardedPage''),
  read_from = ((\<lambda> s . (bool_reg   s) (''InGuardedPage''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''InGuardedPage'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition RC_ref  :: \<open>((regstate),(register_value),(((64)Word.word)list))register_ref \<close>  where 
     \<open> RC_ref = ( (|
  name = (''RC''),
  read_from = ((\<lambda> s . (vector_5_bitvector_64_reg   s) (''RC''))),
  write_to = ((\<lambda> v s .  (( s (| vector_5_bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''RC'') then v else(vector_5_bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bitvector_64_of_regval v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  regval_of_bitvector_64 v)) v)) |) )\<close>


definition PhysicalCount_ref  :: \<open>((regstate),(register_value),((88)Word.word))register_ref \<close>  where 
     \<open> PhysicalCount_ref = ( (|
  name = (''PhysicalCount''),
  read_from = ((\<lambda> s . (bitvector_88_reg   s) (''PhysicalCount''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_88_reg :=
  ((\<lambda> reg .  if reg = (''PhysicalCount'') then v else(bitvector_88_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_88_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_88 v)) |) )\<close>


definition PC_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> PC_ref = ( (|
  name = (''_PC''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''_PC''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''_PC'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R30_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R30_ref = ( (|
  name = (''R30''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R30''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R30'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R29_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R29_ref = ( (|
  name = (''R29''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R29''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R29'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R28_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R28_ref = ( (|
  name = (''R28''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R28''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R28'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R27_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R27_ref = ( (|
  name = (''R27''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R27''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R27'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R26_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R26_ref = ( (|
  name = (''R26''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R26''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R26'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R25_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R25_ref = ( (|
  name = (''R25''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R25''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R25'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R24_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R24_ref = ( (|
  name = (''R24''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R24''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R24'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R23_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R23_ref = ( (|
  name = (''R23''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R23''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R23'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R22_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R22_ref = ( (|
  name = (''R22''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R22''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R22'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R21_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R21_ref = ( (|
  name = (''R21''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R21''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R21'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R20_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R20_ref = ( (|
  name = (''R20''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R20''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R20'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R19_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R19_ref = ( (|
  name = (''R19''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R19''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R19'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R18_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R18_ref = ( (|
  name = (''R18''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R18''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R18'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R17_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R17_ref = ( (|
  name = (''R17''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R17''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R17'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R16_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R16_ref = ( (|
  name = (''R16''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R16''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R16'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R15_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R15_ref = ( (|
  name = (''R15''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R15''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R15'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R14_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R14_ref = ( (|
  name = (''R14''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R14''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R14'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R13_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R13_ref = ( (|
  name = (''R13''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R13''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R13'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R12_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R12_ref = ( (|
  name = (''R12''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R12''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R12'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R11_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R11_ref = ( (|
  name = (''R11''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R11''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R11'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R10_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R10_ref = ( (|
  name = (''R10''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R10''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R10'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R9_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R9_ref = ( (|
  name = (''R9''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R9''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R9'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R8_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R8_ref = ( (|
  name = (''R8''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R8''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R8'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R7_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R7_ref = ( (|
  name = (''R7''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R7''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R7'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R6_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R6_ref = ( (|
  name = (''R6''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R6''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R6'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R5_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R5_ref = ( (|
  name = (''R5''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R5''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R5'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R4_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R4_ref = ( (|
  name = (''R4''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R4''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R4'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R3_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R3_ref = ( (|
  name = (''R3''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R3''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R3'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R2_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R2_ref = ( (|
  name = (''R2''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R2''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R2'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R1_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R1_ref = ( (|
  name = (''R1''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R1''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R1'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition R0_ref  :: \<open>((regstate),(register_value),((64)Word.word))register_ref \<close>  where 
     \<open> R0_ref = ( (|
  name = (''R0''),
  read_from = ((\<lambda> s . (bitvector_64_reg   s) (''R0''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_64_reg :=
  ((\<lambda> reg .  if reg = (''R0'') then v else(bitvector_64_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_64_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_64 v)) |) )\<close>


definition EventRegister_ref  :: \<open>((regstate),(register_value),((1)Word.word))register_ref \<close>  where 
     \<open> EventRegister_ref = ( (|
  name = (''EventRegister''),
  read_from = ((\<lambda> s . (bitvector_1_reg   s) (''EventRegister''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_1_reg :=
  ((\<lambda> reg .  if reg = (''EventRegister'') then v else(bitvector_1_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_1_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_1 v)) |) )\<close>


definition ShouldAdvanceSS_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> ShouldAdvanceSS_ref = ( (|
  name = (''ShouldAdvanceSS''),
  read_from = ((\<lambda> s . (bool_reg   s) (''ShouldAdvanceSS''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''ShouldAdvanceSS'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition ShouldAdvanceIT_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> ShouldAdvanceIT_ref = ( (|
  name = (''ShouldAdvanceIT''),
  read_from = ((\<lambda> s . (bool_reg   s) (''ShouldAdvanceIT''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''ShouldAdvanceIT'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition PSTATE_ref  :: \<open>((regstate),(register_value),(ProcState))register_ref \<close>  where 
     \<open> PSTATE_ref = ( (|
  name = (''PSTATE''),
  read_from = ((\<lambda> s . (ProcState_reg   s) (''PSTATE''))),
  write_to = ((\<lambda> v s .  (( s (| ProcState_reg :=
  ((\<lambda> reg .  if reg = (''PSTATE'') then v else(ProcState_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  ProcState_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_ProcState v)) |) )\<close>


definition clock_divider_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> clock_divider_ref = ( (|
  name = (''__clock_divider''),
  read_from = ((\<lambda> s . (int_reg   s) (''__clock_divider''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__clock_divider'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition PMULastThresholdValue_ref  :: \<open>((regstate),(register_value),((bool)list))register_ref \<close>  where 
     \<open> PMULastThresholdValue_ref = ( (|
  name = (''PMULastThresholdValue''),
  read_from = ((\<lambda> s . (vector_31_bool_reg   s) (''PMULastThresholdValue''))),
  write_to = ((\<lambda> v s .  (( s (| vector_31_bool_reg :=
  ((\<lambda> reg .  if reg = (''PMULastThresholdValue'') then v else(vector_31_bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bool_of_register_value v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  register_value_of_bool v)) v)) |) )\<close>


definition PMUEventAccumulator_ref  :: \<open>((regstate),(register_value),((ii)list))register_ref \<close>  where 
     \<open> PMUEventAccumulator_ref = ( (|
  name = (''PMUEventAccumulator''),
  read_from = ((\<lambda> s . (vector_31_int_reg   s) (''PMUEventAccumulator''))),
  write_to = ((\<lambda> v s .  (( s (| vector_31_int_reg :=
  ((\<lambda> reg .  if reg = (''PMUEventAccumulator'') then v else(vector_31_int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  int_of_register_value v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  register_value_of_int v)) v)) |) )\<close>


definition DormantCtlReg_ref  :: \<open>((regstate),(register_value),(DormantCtl_Type))register_ref \<close>  where 
     \<open> DormantCtlReg_ref = ( (|
  name = (''_DormantCtlReg''),
  read_from = ((\<lambda> s .  (| DormantCtl_Type_bits = ((bitvector_32_reg   s) (''_DormantCtlReg'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_DormantCtlReg'') then(DormantCtl_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  DormantCtl_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_DormantCtl_Type v)) |) )\<close>


definition ConfigReg_ref  :: \<open>((regstate),(register_value),(Configuration_Type))register_ref \<close>  where 
     \<open> ConfigReg_ref = ( (|
  name = (''_ConfigReg''),
  read_from = ((\<lambda> s .  (| Configuration_Type_bits = ((bitvector_32_reg   s) (''_ConfigReg'')) |))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''_ConfigReg'') then(Configuration_Type_bits   v) else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  Configuration_Type_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_Configuration_Type v)) |) )\<close>


definition IsWFEsleep_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> IsWFEsleep_ref = ( (|
  name = (''IsWFEsleep''),
  read_from = ((\<lambda> s . (bool_reg   s) (''IsWFEsleep''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''IsWFEsleep'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition IsWFIsleep_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> IsWFIsleep_ref = ( (|
  name = (''IsWFIsleep''),
  read_from = ((\<lambda> s . (bool_reg   s) (''IsWFIsleep''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''IsWFIsleep'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition CP15SDISABLE2_ref  :: \<open>((regstate),(register_value),(Signal))register_ref \<close>  where 
     \<open> CP15SDISABLE2_ref = ( (|
  name = (''CP15SDISABLE2''),
  read_from = ((\<lambda> s . (Signal_reg   s) (''CP15SDISABLE2''))),
  write_to = ((\<lambda> v s .  (( s (| Signal_reg :=
  ((\<lambda> reg .  if reg = (''CP15SDISABLE2'') then v else(Signal_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  Signal_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_Signal v)) |) )\<close>


definition CP15SDISABLE_ref  :: \<open>((regstate),(register_value),(Signal))register_ref \<close>  where 
     \<open> CP15SDISABLE_ref = ( (|
  name = (''CP15SDISABLE''),
  read_from = ((\<lambda> s . (Signal_reg   s) (''CP15SDISABLE''))),
  write_to = ((\<lambda> v s .  (( s (| Signal_reg :=
  ((\<lambda> reg .  if reg = (''CP15SDISABLE'') then v else(Signal_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  Signal_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_Signal v)) |) )\<close>


definition cycle_count_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> cycle_count_ref = ( (|
  name = (''__cycle_count''),
  read_from = ((\<lambda> s . (int_reg   s) (''__cycle_count''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''__cycle_count'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition trcclaim_tags_ref  :: \<open>((regstate),(register_value),((32)Word.word))register_ref \<close>  where 
     \<open> trcclaim_tags_ref = ( (|
  name = (''__trcclaim_tags''),
  read_from = ((\<lambda> s . (bitvector_32_reg   s) (''__trcclaim_tags''))),
  write_to = ((\<lambda> v s .  (( s (| bitvector_32_reg :=
  ((\<lambda> reg .  if reg = (''__trcclaim_tags'') then v else(bitvector_32_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bitvector_32_of_regval v)),
  regval_of = ((\<lambda> v .  regval_of_bitvector_32 v)) |) )\<close>


definition NUM_WATCHPOINTS_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> NUM_WATCHPOINTS_ref = ( (|
  name = (''NUM_WATCHPOINTS''),
  read_from = ((\<lambda> s . (int_reg   s) (''NUM_WATCHPOINTS''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''NUM_WATCHPOINTS'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition NUM_BREAKPOINTS_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> NUM_BREAKPOINTS_ref = ( (|
  name = (''NUM_BREAKPOINTS''),
  read_from = ((\<lambda> s . (int_reg   s) (''NUM_BREAKPOINTS''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''NUM_BREAKPOINTS'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition NUM_GIC_LIST_REGS_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> NUM_GIC_LIST_REGS_ref = ( (|
  name = (''NUM_GIC_LIST_REGS''),
  read_from = ((\<lambda> s . (int_reg   s) (''NUM_GIC_LIST_REGS''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''NUM_GIC_LIST_REGS'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition NUM_GIC_PRIORITY_BITS_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> NUM_GIC_PRIORITY_BITS_ref = ( (|
  name = (''NUM_GIC_PRIORITY_BITS''),
  read_from = ((\<lambda> s . (int_reg   s) (''NUM_GIC_PRIORITY_BITS''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''NUM_GIC_PRIORITY_BITS'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition NUM_GIC_PREEMPTION_BITS_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> NUM_GIC_PREEMPTION_BITS_ref = ( (|
  name = (''NUM_GIC_PREEMPTION_BITS''),
  read_from = ((\<lambda> s . (int_reg   s) (''NUM_GIC_PREEMPTION_BITS''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''NUM_GIC_PREEMPTION_BITS'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition NUM_BRBE_RECORDS_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> NUM_BRBE_RECORDS_ref = ( (|
  name = (''NUM_BRBE_RECORDS''),
  read_from = ((\<lambda> s . (int_reg   s) (''NUM_BRBE_RECORDS''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''NUM_BRBE_RECORDS'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition NUM_PMU_COUNTERS_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> NUM_PMU_COUNTERS_ref = ( (|
  name = (''NUM_PMU_COUNTERS''),
  read_from = ((\<lambda> s . (int_reg   s) (''NUM_PMU_COUNTERS''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''NUM_PMU_COUNTERS'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition NUM_AMU_CG1_MONITORS_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> NUM_AMU_CG1_MONITORS_ref = ( (|
  name = (''NUM_AMU_CG1_MONITORS''),
  read_from = ((\<lambda> s . (int_reg   s) (''NUM_AMU_CG1_MONITORS''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''NUM_AMU_CG1_MONITORS'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition NUM_AMU_CG0_MONITORS_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> NUM_AMU_CG0_MONITORS_ref = ( (|
  name = (''NUM_AMU_CG0_MONITORS''),
  read_from = ((\<lambda> s . (int_reg   s) (''NUM_AMU_CG0_MONITORS''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''NUM_AMU_CG0_MONITORS'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition NUM_AMU_COUNTER_GROUPS_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> NUM_AMU_COUNTER_GROUPS_ref = ( (|
  name = (''NUM_AMU_COUNTER_GROUPS''),
  read_from = ((\<lambda> s . (int_reg   s) (''NUM_AMU_COUNTER_GROUPS''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg :=
  ((\<lambda> reg .  if reg = (''NUM_AMU_COUNTER_GROUPS'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


definition VariantImplemented_ref  :: \<open>((regstate),(register_value),((bool)list))register_ref \<close>  where 
     \<open> VariantImplemented_ref = ( (|
  name = (''VariantImplemented''),
  read_from = ((\<lambda> s . (vector_16_bool_reg   s) (''VariantImplemented''))),
  write_to = ((\<lambda> v s .  (( s (| vector_16_bool_reg :=
  ((\<lambda> reg .  if reg = (''VariantImplemented'') then v else(vector_16_bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bool_of_register_value v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  register_value_of_bool v)) v)) |) )\<close>


definition FeatureImpl_ref  :: \<open>((regstate),(register_value),((bool)list))register_ref \<close>  where 
     \<open> FeatureImpl_ref = ( (|
  name = (''FeatureImpl''),
  read_from = ((\<lambda> s . (vector_259_bool_reg   s) (''FeatureImpl''))),
  write_to = ((\<lambda> v s .  (( s (| vector_259_bool_reg :=
  ((\<lambda> reg .  if reg = (''FeatureImpl'') then v else(vector_259_bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  vector_of_regval ((\<lambda> v .  bool_of_register_value v)) v)),
  regval_of = ((\<lambda> v .  regval_of_vector ((\<lambda> v .  register_value_of_bool v)) v)) |) )\<close>


definition v9Ap4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v9Ap4_IMPLEMENTED_ref = ( (|
  name = (''v9Ap4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v9Ap4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v9Ap4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v9Ap3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v9Ap3_IMPLEMENTED_ref = ( (|
  name = (''v9Ap3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v9Ap3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v9Ap3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v9Ap2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v9Ap2_IMPLEMENTED_ref = ( (|
  name = (''v9Ap2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v9Ap2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v9Ap2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v9Ap1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v9Ap1_IMPLEMENTED_ref = ( (|
  name = (''v9Ap1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v9Ap1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v9Ap1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v9Ap0_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v9Ap0_IMPLEMENTED_ref = ( (|
  name = (''v9Ap0_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v9Ap0_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v9Ap0_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v8Ap9_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v8Ap9_IMPLEMENTED_ref = ( (|
  name = (''v8Ap9_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v8Ap9_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v8Ap9_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v8Ap8_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v8Ap8_IMPLEMENTED_ref = ( (|
  name = (''v8Ap8_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v8Ap8_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v8Ap8_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v8Ap7_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v8Ap7_IMPLEMENTED_ref = ( (|
  name = (''v8Ap7_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v8Ap7_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v8Ap7_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v8Ap6_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v8Ap6_IMPLEMENTED_ref = ( (|
  name = (''v8Ap6_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v8Ap6_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v8Ap6_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v8Ap5_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v8Ap5_IMPLEMENTED_ref = ( (|
  name = (''v8Ap5_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v8Ap5_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v8Ap5_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v8Ap4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v8Ap4_IMPLEMENTED_ref = ( (|
  name = (''v8Ap4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v8Ap4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v8Ap4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v8Ap3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v8Ap3_IMPLEMENTED_ref = ( (|
  name = (''v8Ap3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v8Ap3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v8Ap3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v8Ap2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v8Ap2_IMPLEMENTED_ref = ( (|
  name = (''v8Ap2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v8Ap2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v8Ap2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v8Ap1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v8Ap1_IMPLEMENTED_ref = ( (|
  name = (''v8Ap1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v8Ap1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v8Ap1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition v8Ap0_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> v8Ap0_IMPLEMENTED_ref = ( (|
  name = (''v8Ap0_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''v8Ap0_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''v8Ap0_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TRBE_MPAM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TRBE_MPAM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TRBE_MPAM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TRBE_MPAM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TRBE_MPAM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TRBE_EXT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TRBE_EXT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TRBE_EXT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TRBE_EXT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TRBE_EXT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SYSREG128_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SYSREG128_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SYSREG128_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SYSREG128_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SYSREG128_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SYSINSTR128_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SYSINSTR128_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SYSINSTR128_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SYSINSTR128_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SYSINSTR128_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SVE_B16B16_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SVE_B16B16_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SVE_B16B16_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SVE_B16B16_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SVE_B16B16_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SVE2p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SVE2p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SVE2p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SVE2p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SVE2p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SME_F16F16_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SME_F16F16_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SME_F16F16_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SME_F16F16_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SME_F16F16_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SME2p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SME2p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SME2p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SME2p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SME2p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SEBEP_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SEBEP_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SEBEP_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SEBEP_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SEBEP_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LVA3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LVA3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LVA3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LVA3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LVA3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LSE128_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LSE128_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LSE128_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LSE128_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LSE128_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ITE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ITE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ITE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ITE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ITE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_GCS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_GCS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_GCS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_GCS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_GCS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETEv1p3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETEv1p3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETEv1p3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETEv1p3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETEv1p3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_EBEP_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_EBEP_IMPLEMENTED_ref = ( (|
  name = (''FEAT_EBEP_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_EBEP_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_EBEP_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_D128_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_D128_IMPLEMENTED_ref = ( (|
  name = (''FEAT_D128_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_D128_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_D128_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CHK_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CHK_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CHK_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CHK_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CHK_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ABLE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ABLE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ABLE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ABLE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ABLE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SME2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SME2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SME2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SME2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SME2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MEC_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MEC_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MEC_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MEC_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MEC_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_BRBEv1p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_BRBEv1p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_BRBEv1p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_BRBEv1p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_BRBEv1p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SME_I16I64_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SME_I16I64_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SME_I16I64_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SME_I16I64_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SME_I16I64_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SME_FA64_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SME_FA64_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SME_FA64_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SME_FA64_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SME_FA64_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SME_F64F64_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SME_F64F64_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SME_F64F64_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SME_F64F64_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SME_F64F64_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SME_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SME_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SME_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SME_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SME_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RME_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RME_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RME_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RME_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RME_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETEv1p2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETEv1p2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETEv1p2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETEv1p2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETEv1p2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_BRBE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_BRBE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_BRBE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_BRBE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_BRBE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETEv1p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETEv1p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETEv1p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETEv1p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETEv1p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TRBE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TRBE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TRBE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TRBE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TRBE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TME_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TME_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TME_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TME_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TME_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SVE_SM4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SVE_SM4_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SVE_SM4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SVE_SM4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SVE_SM4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SVE_SHA3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SVE_SHA3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SVE_SHA3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SVE_SHA3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SVE_SHA3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SVE_PMULL128_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SVE_PMULL128_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SVE_PMULL128_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SVE_PMULL128_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SVE_PMULL128_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SVE_BitPerm_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SVE_BitPerm_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SVE_BitPerm_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SVE_BitPerm_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SVE_BitPerm_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SVE_AES_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SVE_AES_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SVE_AES_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SVE_AES_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SVE_AES_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SVE2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SVE2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SVE2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SVE2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SVE2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_DoPD_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_DoPD_IMPLEMENTED_ref = ( (|
  name = (''FEAT_DoPD_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_DoPD_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_DoPD_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_THE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_THE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_THE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_THE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_THE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SPMU_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SPMU_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SPMU_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SPMU_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SPMU_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SPEv1p4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SPEv1p4_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SPEv1p4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SPEv1p4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SPEv1p4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SPE_FDS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SPE_FDS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SPE_FDS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SPE_FDS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SPE_FDS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SPE_CRR_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SPE_CRR_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SPE_CRR_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SPE_CRR_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SPE_CRR_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SPECRES2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SPECRES2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SPECRES2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SPECRES2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SPECRES2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_S2POE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_S2POE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_S2POE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_S2POE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_S2POE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_S2PIE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_S2PIE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_S2PIE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_S2PIE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_S2PIE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_S1POE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_S1POE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_S1POE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_S1POE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_S1POE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_S1PIE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_S1PIE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_S1PIE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_S1PIE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_S1PIE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RPRFM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RPRFM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RPRFM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RPRFM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RPRFM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RASv2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RASv2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RASv2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RASv2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RASv2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RASSAv2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RASSAv2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RASSAv2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RASSAv2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RASSAv2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PRFMSLC_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PRFMSLC_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PRFMSLC_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PRFMSLC_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PRFMSLC_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3p9_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3p9_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3p9_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3p9_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3p9_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3_SS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3_SS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3_SS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3_SS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3_SS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3_ICNTR_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3_ICNTR_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3_ICNTR_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3_ICNTR_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3_ICNTR_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3_EDGE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3_EDGE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3_EDGE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3_EDGE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3_EDGE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PFAR_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PFAR_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PFAR_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PFAR_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PFAR_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PCSRv8p9_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PCSRv8p9_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PCSRv8p9_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PCSRv8p9_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PCSRv8p9_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE_TAGGED_FAR_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE_TAGGED_FAR_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE_TAGGED_FAR_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE_TAGGED_FAR_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE_TAGGED_FAR_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE_STORE_ONLY_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE_STORE_ONLY_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE_STORE_ONLY_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE_STORE_ONLY_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE_STORE_ONLY_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE_PERM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE_PERM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE_PERM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE_PERM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE_PERM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE_NO_ADDRESS_TAGS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE_NO_ADDRESS_TAGS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE_NO_ADDRESS_TAGS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE_NO_ADDRESS_TAGS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE_NO_ADDRESS_TAGS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE_CANONICAL_TAGS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE_CANONICAL_TAGS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE_CANONICAL_TAGS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE_CANONICAL_TAGS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE_CANONICAL_TAGS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE_ASYNC_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE_ASYNC_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE_ASYNC_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE_ASYNC_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE_ASYNC_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE_ASYM_FAULT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE_ASYM_FAULT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE_ASYM_FAULT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE_ASYM_FAULT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE_ASYM_FAULT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE4_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LRCPC3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LRCPC3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LRCPC3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LRCPC3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LRCPC3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_HAFT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_HAFT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_HAFT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_HAFT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_HAFT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FGT2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FGT2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FGT2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FGT2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FGT2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ECBHB_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ECBHB_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ECBHB_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ECBHB_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ECBHB_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_DoubleFault2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_DoubleFault2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_DoubleFault2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_DoubleFault2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_DoubleFault2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_Debugv8p9_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_Debugv8p9_IMPLEMENTED_ref = ( (|
  name = (''FEAT_Debugv8p9_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_Debugv8p9_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_Debugv8p9_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CSSC_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CSSC_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CSSC_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CSSC_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CSSC_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CLRBHB_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CLRBHB_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CLRBHB_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CLRBHB_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CLRBHB_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ANERR_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ANERR_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ANERR_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ANERR_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ANERR_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AIE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AIE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AIE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AIE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AIE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ADERR_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ADERR_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ADERR_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ADERR_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ADERR_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TIDCP1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TIDCP1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TIDCP1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TIDCP1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TIDCP1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TCR2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TCR2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TCR2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TCR2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TCR2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SPEv1p3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SPEv1p3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SPEv1p3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SPEv1p3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SPEv1p3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SCTLR2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SCTLR2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SCTLR2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SCTLR2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SCTLR2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3p8_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3p8_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3p8_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3p8_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3p8_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3_TH_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3_TH_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3_TH_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3_TH_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3_TH_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3_EXT64_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3_EXT64_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3_EXT64_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3_EXT64_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3_EXT64_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_NMI_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_NMI_IMPLEMENTED_ref = ( (|
  name = (''FEAT_NMI_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_NMI_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_NMI_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MOPS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MOPS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MOPS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MOPS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MOPS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_HBC_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_HBC_IMPLEMENTED_ref = ( (|
  name = (''FEAT_HBC_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_HBC_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_HBC_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_GICv3_NMI_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_GICv3_NMI_IMPLEMENTED_ref = ( (|
  name = (''FEAT_GICv3_NMI_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_GICv3_NMI_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_GICv3_NMI_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_Debugv8p8_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_Debugv8p8_IMPLEMENTED_ref = ( (|
  name = (''FEAT_Debugv8p8_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_Debugv8p8_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_Debugv8p8_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CMOW_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CMOW_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CMOW_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CMOW_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CMOW_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_XS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_XS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_XS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_XS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_XS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_WFxT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_WFxT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_WFxT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_WFxT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_WFxT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SPEv1p2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SPEv1p2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SPEv1p2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SPEv1p2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SPEv1p2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RPRES_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RPRES_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RPRES_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RPRES_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RPRES_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3p7_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3p7_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3p7_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3p7_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3p7_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PAN3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PAN3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PAN3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PAN3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PAN3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LS64_V_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LS64_V_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LS64_V_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LS64_V_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LS64_V_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LS64_ACCDATA_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LS64_ACCDATA_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LS64_ACCDATA_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LS64_ACCDATA_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LS64_ACCDATA_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LS64_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LS64_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LS64_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LS64_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LS64_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LPA2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LPA2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LPA2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LPA2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LPA2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_HCX_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_HCX_IMPLEMENTED_ref = ( (|
  name = (''FEAT_HCX_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_HCX_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_HCX_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_EBF16_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_EBF16_IMPLEMENTED_ref = ( (|
  name = (''FEAT_EBF16_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_EBF16_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_EBF16_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AFP_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AFP_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AFP_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AFP_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AFP_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TWED_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TWED_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TWED_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TWED_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TWED_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PAuth2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PAuth2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PAuth2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PAuth2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PAuth2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTPMU_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTPMU_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTPMU_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTPMU_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTPMU_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MPAMv1p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MPAMv1p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MPAMv1p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MPAMv1p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MPAMv1p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MPAMv0p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MPAMv0p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MPAMv0p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MPAMv0p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MPAMv0p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_HPMN0_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_HPMN0_IMPLEMENTED_ref = ( (|
  name = (''FEAT_HPMN0_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_HPMN0_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_HPMN0_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FGT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FGT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FGT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FGT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FGT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ECV_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ECV_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ECV_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ECV_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ECV_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_DGH_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_DGH_IMPLEMENTED_ref = ( (|
  name = (''FEAT_DGH_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_DGH_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_DGH_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_BF16_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_BF16_IMPLEMENTED_ref = ( (|
  name = (''FEAT_BF16_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_BF16_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_BF16_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AMUv1p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AMUv1p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AMUv1p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AMUv1p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AMUv1p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SSBS2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SSBS2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SSBS2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SSBS2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SSBS2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SSBS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SSBS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SSBS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SSBS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SSBS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SPECRES_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SPECRES_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SPECRES_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SPECRES_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SPECRES_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SB_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SB_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SB_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SB_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SB_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RNG_TRAP_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RNG_TRAP_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RNG_TRAP_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RNG_TRAP_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RNG_TRAP_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RNG_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RNG_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RNG_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RNG_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RNG_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3p5_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3p5_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3p5_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3p5_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3p5_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MTE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MTE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MTE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MTE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MTE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_GTG_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_GTG_IMPLEMENTED_ref = ( (|
  name = (''FEAT_GTG_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_GTG_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_GTG_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FlagM2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FlagM2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FlagM2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FlagM2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FlagM2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FRINTTS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FRINTTS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FRINTTS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FRINTTS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FRINTTS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ExS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ExS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ExS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ExS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ExS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_EVT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_EVT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_EVT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_EVT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_EVT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_E0PD_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_E0PD_IMPLEMENTED_ref = ( (|
  name = (''FEAT_E0PD_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_E0PD_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_E0PD_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_DPB2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_DPB2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_DPB2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_DPB2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_DPB2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CSV3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CSV3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CSV3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CSV3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CSV3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CSV2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CSV2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CSV2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CSV2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CSV2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_BTI_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_BTI_IMPLEMENTED_ref = ( (|
  name = (''FEAT_BTI_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_BTI_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_BTI_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TTST_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TTST_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TTST_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TTST_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TTST_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TTL_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TTL_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TTL_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TTL_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TTL_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TRF_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TRF_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TRF_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TRF_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TRF_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TLBIRANGE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TLBIRANGE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TLBIRANGE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TLBIRANGE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TLBIRANGE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TLBIOS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TLBIOS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TLBIOS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TLBIOS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TLBIOS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SEL2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SEL2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SEL2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SEL2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SEL2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_S2FWB_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_S2FWB_IMPLEMENTED_ref = ( (|
  name = (''FEAT_S2FWB_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_S2FWB_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_S2FWB_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RASv1p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RASv1p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RASv1p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RASv1p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RASv1p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RASSAv1p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RASSAv1p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RASSAv1p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RASSAv1p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RASSAv1p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3p4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3p4_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3p4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3p4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3p4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_NV2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_NV2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_NV2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_NV2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_NV2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LSE2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LSE2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LSE2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LSE2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LSE2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LRCPC2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LRCPC2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LRCPC2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LRCPC2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LRCPC2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_IDST_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_IDST_IMPLEMENTED_ref = ( (|
  name = (''FEAT_IDST_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_IDST_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_IDST_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FlagM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FlagM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FlagM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FlagM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FlagM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FHM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FHM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FHM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FHM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FHM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_DoubleFault_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_DoubleFault_IMPLEMENTED_ref = ( (|
  name = (''FEAT_DoubleFault_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_DoubleFault_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_DoubleFault_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_DotProd_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_DotProd_IMPLEMENTED_ref = ( (|
  name = (''FEAT_DotProd_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_DotProd_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_DotProd_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_Debugv8p4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_Debugv8p4_IMPLEMENTED_ref = ( (|
  name = (''FEAT_Debugv8p4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_Debugv8p4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_Debugv8p4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_DIT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_DIT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_DIT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_DIT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_DIT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CNTSC_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CNTSC_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CNTSC_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CNTSC_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CNTSC_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_BBM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_BBM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_BBM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_BBM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_BBM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AMUv1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AMUv1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AMUv1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AMUv1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AMUv1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SPEv1p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SPEv1p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SPEv1p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SPEv1p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SPEv1p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PAuth_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PAuth_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PAuth_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PAuth_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PAuth_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PACQARMA5_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PACQARMA5_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PACQARMA5_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PACQARMA5_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PACQARMA5_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PACQARMA3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PACQARMA3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PACQARMA3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PACQARMA3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PACQARMA3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PACIMP_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PACIMP_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PACIMP_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PACIMP_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PACIMP_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_NV_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_NV_IMPLEMENTED_ref = ( (|
  name = (''FEAT_NV_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_NV_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_NV_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LRCPC_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LRCPC_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LRCPC_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LRCPC_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LRCPC_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_JSCVT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_JSCVT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_JSCVT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_JSCVT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_JSCVT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FPACCOMBINE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FPACCOMBINE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FPACCOMBINE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FPACCOMBINE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FPACCOMBINE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FPAC_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FPAC_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FPAC_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FPAC_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FPAC_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FCMA_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FCMA_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FCMA_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FCMA_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FCMA_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_EPAC_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_EPAC_IMPLEMENTED_ref = ( (|
  name = (''FEAT_EPAC_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_EPAC_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_EPAC_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CONSTPACFIELD_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CONSTPACFIELD_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CONSTPACFIELD_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CONSTPACFIELD_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CONSTPACFIELD_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CCIDX_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CCIDX_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CCIDX_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CCIDX_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CCIDX_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_XNX_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_XNX_IMPLEMENTED_ref = ( (|
  name = (''FEAT_XNX_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_XNX_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_XNX_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_VPIPT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_VPIPT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_VPIPT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_VPIPT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_VPIPT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_UAO_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_UAO_IMPLEMENTED_ref = ( (|
  name = (''FEAT_UAO_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_UAO_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_UAO_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TTCNP_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TTCNP_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TTCNP_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TTCNP_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TTCNP_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SVE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SVE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SVE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SVE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SVE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SPE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SPE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SPE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SPE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SPE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SM4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SM4_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SM4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SM4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SM4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SM3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SM3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SM3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SM3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SM3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SHA512_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SHA512_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SHA512_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SHA512_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SHA512_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SHA3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SHA3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SHA3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SHA3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SHA3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RAS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RAS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RAS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RAS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RAS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PCSRv8p2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PCSRv8p2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PCSRv8p2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PCSRv8p2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PCSRv8p2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PAN2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PAN2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PAN2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PAN2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PAN2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_MPAM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_MPAM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_MPAM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_MPAM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_MPAM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LVA_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LVA_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LVA_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LVA_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LVA_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LSMAOC_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LSMAOC_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LSMAOC_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LSMAOC_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LSMAOC_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LPA_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LPA_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LPA_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LPA_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LPA_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_IESB_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_IESB_IMPLEMENTED_ref = ( (|
  name = (''FEAT_IESB_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_IESB_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_IESB_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_I8MM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_I8MM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_I8MM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_I8MM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_I8MM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_HPDS2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_HPDS2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_HPDS2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_HPDS2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_HPDS2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FP16_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FP16_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FP16_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FP16_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FP16_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_F64MM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_F64MM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_F64MM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_F64MM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_F64MM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_F32MM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_F32MM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_F32MM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_F32MM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_F32MM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_EDHSR_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_EDHSR_IMPLEMENTED_ref = ( (|
  name = (''FEAT_EDHSR_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_EDHSR_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_EDHSR_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_Debugv8p2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_Debugv8p2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_Debugv8p2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_Debugv8p2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_Debugv8p2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_DPB_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_DPB_IMPLEMENTED_ref = ( (|
  name = (''FEAT_DPB_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_DPB_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_DPB_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ASMv8p2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ASMv8p2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ASMv8p2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ASMv8p2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ASMv8p2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA32I8MM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA32I8MM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA32I8MM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA32I8MM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA32I8MM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA32HPD_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA32HPD_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA32HPD_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA32HPD_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA32HPD_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA32BF16_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA32BF16_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA32BF16_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA32BF16_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA32BF16_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_VMID16_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_VMID16_IMPLEMENTED_ref = ( (|
  name = (''FEAT_VMID16_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_VMID16_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_VMID16_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_VHE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_VHE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_VHE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_VHE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_VHE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_RDM_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_RDM_IMPLEMENTED_ref = ( (|
  name = (''FEAT_RDM_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_RDM_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_RDM_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PAN_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PAN_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PAN_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PAN_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PAN_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LSE_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LSE_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LSE_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LSE_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LSE_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_LOR_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_LOR_IMPLEMENTED_ref = ( (|
  name = (''FEAT_LOR_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_LOR_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_LOR_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_HPDS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_HPDS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_HPDS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_HPDS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_HPDS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_HAFDBS_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_HAFDBS_IMPLEMENTED_ref = ( (|
  name = (''FEAT_HAFDBS_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_HAFDBS_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_HAFDBS_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_Debugv8p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_Debugv8p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_Debugv8p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_Debugv8p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_Debugv8p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CRC32_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CRC32_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CRC32_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CRC32_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CRC32_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_nTLBPA_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_nTLBPA_IMPLEMENTED_ref = ( (|
  name = (''FEAT_nTLBPA_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_nTLBPA_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_nTLBPA_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TRC_SR_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TRC_SR_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TRC_SR_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TRC_SR_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TRC_SR_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_TRC_EXT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_TRC_EXT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_TRC_EXT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_TRC_EXT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_TRC_EXT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SHA256_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SHA256_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SHA256_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SHA256_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SHA256_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_SHA1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_SHA1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_SHA1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_SHA1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_SHA1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3_EXT32_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3_EXT32_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3_EXT32_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3_EXT32_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3_EXT32_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3_EXT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3_EXT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3_EXT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3_EXT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3_EXT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMUv3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMUv3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMUv3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMUv3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMUv3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PMULL_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PMULL_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PMULL_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PMULL_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PMULL_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_PCSRv8_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_PCSRv8_IMPLEMENTED_ref = ( (|
  name = (''FEAT_PCSRv8_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_PCSRv8_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_PCSRv8_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_IVIPT_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_IVIPT_IMPLEMENTED_ref = ( (|
  name = (''FEAT_IVIPT_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_IVIPT_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_IVIPT_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_GICv4p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_GICv4p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_GICv4p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_GICv4p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_GICv4p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_GICv4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_GICv4_IMPLEMENTED_ref = ( (|
  name = (''FEAT_GICv4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_GICv4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_GICv4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_GICv3p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_GICv3p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_GICv3p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_GICv3p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_GICv3p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_GICv3_TDIR_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_GICv3_TDIR_IMPLEMENTED_ref = ( (|
  name = (''FEAT_GICv3_TDIR_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_GICv3_TDIR_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_GICv3_TDIR_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_GICv3_LEGACY_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_GICv3_LEGACY_IMPLEMENTED_ref = ( (|
  name = (''FEAT_GICv3_LEGACY_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_GICv3_LEGACY_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_GICv3_LEGACY_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_GICv3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_GICv3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_GICv3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_GICv3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_GICv3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_FP_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_FP_IMPLEMENTED_ref = ( (|
  name = (''FEAT_FP_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_FP_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_FP_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETS2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETS2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETS2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETS2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETS2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETMv4p6_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETMv4p6_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETMv4p6_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETMv4p6_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETMv4p6_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETMv4p5_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETMv4p5_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETMv4p5_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETMv4p5_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETMv4p5_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETMv4p4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETMv4p4_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETMv4p4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETMv4p4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETMv4p4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETMv4p3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETMv4p3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETMv4p3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETMv4p3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETMv4p3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETMv4p2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETMv4p2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETMv4p2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETMv4p2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETMv4p2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETMv4p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETMv4p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETMv4p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETMv4p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETMv4p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_ETMv4_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_ETMv4_IMPLEMENTED_ref = ( (|
  name = (''FEAT_ETMv4_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_ETMv4_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_ETMv4_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_DoubleLock_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_DoubleLock_IMPLEMENTED_ref = ( (|
  name = (''FEAT_DoubleLock_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_DoubleLock_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_DoubleLock_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CSV2_3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CSV2_3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CSV2_3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CSV2_3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CSV2_3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CSV2_2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CSV2_2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CSV2_2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CSV2_2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CSV2_2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CSV2_1p2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CSV2_1p2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CSV2_1p2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CSV2_1p2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CSV2_1p2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_CSV2_1p1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_CSV2_1p1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_CSV2_1p1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_CSV2_1p1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_CSV2_1p1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AdvSIMD_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AdvSIMD_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AdvSIMD_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AdvSIMD_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AdvSIMD_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AES_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AES_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AES_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AES_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AES_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_EL3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_EL3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_EL3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_EL3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_EL3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_EL2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_EL2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_EL2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_EL2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_EL2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_EL1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_EL1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_EL1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_EL1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_EL1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_EL0_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_EL0_IMPLEMENTED_ref = ( (|
  name = (''FEAT_EL0_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_EL0_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_EL0_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA64EL3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA64EL3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA64EL3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA64EL3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA64EL3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA64EL2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA64EL2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA64EL2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA64EL2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA64EL2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA64EL1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA64EL1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA64EL1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA64EL1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA64EL1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA64EL0_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA64EL0_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA64EL0_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA64EL0_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA64EL0_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA32EL3_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA32EL3_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA32EL3_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA32EL3_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA32EL3_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA32EL2_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA32EL2_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA32EL2_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA32EL2_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA32EL2_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA32EL1_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA32EL1_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA32EL1_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA32EL1_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA32EL1_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition FEAT_AA32EL0_IMPLEMENTED_ref  :: \<open>((regstate),(register_value),(bool))register_ref \<close>  where 
     \<open> FEAT_AA32EL0_IMPLEMENTED_ref = ( (|
  name = (''FEAT_AA32EL0_IMPLEMENTED''),
  read_from = ((\<lambda> s . (bool_reg   s) (''FEAT_AA32EL0_IMPLEMENTED''))),
  write_to = ((\<lambda> v s .  (( s (| bool_reg :=
  ((\<lambda> reg .  if reg = (''FEAT_AA32EL0_IMPLEMENTED'') then v else(bool_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  bool_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_bool v)) |) )\<close>


definition SEE_ref  :: \<open>((regstate),(register_value),(int))register_ref \<close>  where 
     \<open> SEE_ref = ( (|
  name = (''SEE''),
  read_from = ((\<lambda> s . (int_reg   s) (''SEE''))),
  write_to = ((\<lambda> v s .  (( s (| int_reg := ((\<lambda> reg .  if reg = (''SEE'') then v else(int_reg   s) reg)) |))))),
  of_regval = ((\<lambda> v .  int_of_register_value v)),
  regval_of = ((\<lambda> v .  register_value_of_int v)) |) )\<close>


\<comment> \<open>\<open>val registers : list (string * register_ops regstate register_value)\<close>\<close>
definition registers  :: \<open>(string*((register_value \<Rightarrow> bool)*(regstate \<Rightarrow> register_value)*(register_value \<Rightarrow> regstate \<Rightarrow>(regstate)option)))list \<close>  where 
     \<open> registers = ( [
    ((''__emulator_termination_opcode''), register_ops_of emulator_termination_opcode_ref),
    ((''_HACTLR2''), register_ops_of HACTLR2_ref),
    ((''_ERXSTATUS''), register_ops_of ERXSTATUS_ref),
    ((''_ERXMISC3''), register_ops_of ERXMISC3_ref),
    ((''_ERXMISC7''), register_ops_of ERXMISC7_ref),
    ((''_ERXADDR2''), register_ops_of ERXADDR2_ref),
    ((''_ERXMISC4''), register_ops_of ERXMISC4_ref),
    ((''_ERXMISC6''), register_ops_of ERXMISC6_ref),
    ((''_ERXCTLR''), register_ops_of ERXCTLR_ref),
    ((''_ERXMISC1''), register_ops_of ERXMISC1_ref),
    ((''_ERXCTLR2''), register_ops_of ERXCTLR2_ref),
    ((''_ERXMISC5''), register_ops_of ERXMISC5_ref),
    ((''_ERXMISC0''), register_ops_of ERXMISC0_ref),
    ((''_ERXADDR''), register_ops_of ERXADDR_ref),
    ((''_ERXFR''), register_ops_of ERXFR_ref),
    ((''_ERXMISC2''), register_ops_of ERXMISC2_ref),
    ((''_ERXFR2''), register_ops_of ERXFR2_ref),
    ((''_AMEVTYPER1''), register_ops_of AMEVTYPER1_ref),
    ((''_AMEVTYPER0''), register_ops_of AMEVTYPER0_ref),
    ((''_ICH_LRC''), register_ops_of ICH_LRC_ref),
    ((''_AMAIR1_NS''), register_ops_of AMAIR1_NS_ref),
    ((''AMAIR1_S''), register_ops_of AMAIR1_S_ref),
    ((''_DBGDTRTXint''), register_ops_of DBGDTRTXint_ref),
    ((''_HTPIDR''), register_ops_of HTPIDR_ref),
    ((''_DBGDTRRXint''), register_ops_of DBGDTRRXint_ref),
    ((''_TPIDRPRW_NS''), register_ops_of TPIDRPRW_NS_ref),
    ((''TPIDRPRW_S''), register_ops_of TPIDRPRW_S_ref),
    ((''_ICC_AP0R''), register_ops_of ICC_AP0R_ref),
    ((''_HAIFSR''), register_ops_of HAIFSR_ref),
    ((''_HAMAIR1''), register_ops_of HAMAIR1_ref),
    ((''_ACTLR2_NS''), register_ops_of ACTLR2_NS_ref),
    ((''ACTLR2_S''), register_ops_of ACTLR2_S_ref),
    ((''_DBGOSECCR''), register_ops_of DBGOSECCR_ref),
    ((''_PMINTENSET''), register_ops_of PMINTENSET_ref),
    ((''_CNTFRQ''), register_ops_of CNTFRQ_ref),
    ((''_HADFSR''), register_ops_of HADFSR_ref),
    ((''_ICH_LR''), register_ops_of ICH_LR_ref),
    ((''_AIDR''), register_ops_of AIDR_ref),
    ((''_ICH_AP0R''), register_ops_of ICH_AP0R_ref),
    ((''_HAMAIR0''), register_ops_of HAMAIR0_ref),
    ((''_AMAIR0_NS''), register_ops_of AMAIR0_NS_ref),
    ((''AMAIR0_S''), register_ops_of AMAIR0_S_ref),
    ((''_ICH_AP1R''), register_ops_of ICH_AP1R_ref),
    ((''_ICC_AP1R_NS''), register_ops_of ICC_AP1R_NS_ref),
    ((''_ICC_AP1R_S''), register_ops_of ICC_AP1R_S_ref),
    ((''_DBGDTRRXext''), register_ops_of DBGDTRRXext_ref),
    ((''DBGOSLAR''), register_ops_of DBGOSLAR_ref),
    ((''_ACTLR_NS''), register_ops_of ACTLR_NS_ref),
    ((''ACTLR_S''), register_ops_of ACTLR_S_ref),
    ((''_DBGDTRTXext''), register_ops_of DBGDTRTXext_ref),
    ((''_TPIDRURO_NS''), register_ops_of TPIDRURO_NS_ref),
    ((''TPIDRURO_S''), register_ops_of TPIDRURO_S_ref),
    ((''_REVIDR''), register_ops_of REVIDR_ref),
    ((''_ADFSR_NS''), register_ops_of ADFSR_NS_ref),
    ((''ADFSR_S''), register_ops_of ADFSR_S_ref),
    ((''_ICV_AP1R''), register_ops_of ICV_AP1R_ref),
    ((''_TPIDRURW_NS''), register_ops_of TPIDRURW_NS_ref),
    ((''TPIDRURW_S''), register_ops_of TPIDRURW_S_ref),
    ((''_ICV_AP0R''), register_ops_of ICV_AP0R_ref),
    ((''TCMTR''), register_ops_of TCMTR_ref),
    ((''_HACTLR''), register_ops_of HACTLR_ref),
    ((''_HACR''), register_ops_of HACR_ref),
    ((''_AIFSR_NS''), register_ops_of AIFSR_NS_ref),
    ((''AIFSR_S''), register_ops_of AIFSR_S_ref),
    ((''BRBSRC_EL1''), register_ops_of BRBSRC_EL1_ref),
    ((''BRBTGT_EL1''), register_ops_of BRBTGT_EL1_ref),
    ((''BRBINF_EL1''), register_ops_of BRBINF_EL1_ref),
    ((''ERXPFGCTL_EL1''), register_ops_of ERXPFGCTL_EL1_ref),
    ((''ERXMISC2_EL1''), register_ops_of ERXMISC2_EL1_ref),
    ((''ERXMISC3_EL1''), register_ops_of ERXMISC3_EL1_ref),
    ((''ERXGSR_EL1''), register_ops_of ERXGSR_EL1_ref),
    ((''ERXFR_EL1''), register_ops_of ERXFR_EL1_ref),
    ((''ERXSTATUS_EL1''), register_ops_of ERXSTATUS_EL1_ref),
    ((''ERXCTLR_EL1''), register_ops_of ERXCTLR_EL1_ref),
    ((''ERXMISC1_EL1''), register_ops_of ERXMISC1_EL1_ref),
    ((''ERXPFGF_EL1''), register_ops_of ERXPFGF_EL1_ref),
    ((''ERXPFGCDN_EL1''), register_ops_of ERXPFGCDN_EL1_ref),
    ((''ERXMISC0_EL1''), register_ops_of ERXMISC0_EL1_ref),
    ((''ERXADDR_EL1''), register_ops_of ERXADDR_EL1_ref),
    ((''AMEVTYPER1_EL0''), register_ops_of AMEVTYPER1_EL0_ref),
    ((''AMEVCNTVOFF1_EL2''), register_ops_of AMEVCNTVOFF1_EL2_ref),
    ((''_AMEVCNTR0_EL0''), register_ops_of AMEVCNTR0_EL0_ref),
    ((''_AMEVCNTR1''), register_ops_of AMEVCNTR1_ref),
    ((''AMEVCNTR0''), register_ops_of AMEVCNTR0_ref),
    ((''AMEVCNTVOFF0_EL2''), register_ops_of AMEVCNTVOFF0_EL2_ref),
    ((''AMEVCNTR1_EL0''), register_ops_of AMEVCNTR1_EL0_ref),
    ((''_CNTV_CVAL''), register_ops_of CNTV_CVAL_ref),
    ((''_CNTVOFF''), register_ops_of CNTVOFF_ref),
    ((''SPMACCESSR_EL3''), register_ops_of SPMACCESSR_EL3_ref),
    ((''AMAIR2_EL1''), register_ops_of AMAIR2_EL1_ref),
    ((''AFSR0_EL2''), register_ops_of AFSR0_EL2_ref),
    ((''ICV_AP1R_EL1''), register_ops_of ICV_AP1R_EL1_ref),
    ((''AFSR1_EL3''), register_ops_of AFSR1_EL3_ref),
    ((''AMAIR2_EL3''), register_ops_of AMAIR2_EL3_ref),
    ((''HACR_EL2''), register_ops_of HACR_EL2_ref),
    ((''RNDR''), register_ops_of RNDR_ref),
    ((''SMPRIMAP_EL2''), register_ops_of SMPRIMAP_EL2_ref),
    ((''RNDRRS''), register_ops_of RNDRRS_ref),
    ((''TPIDR_EL0''), register_ops_of TPIDR_EL0_ref),
    ((''SCXTNUM_EL3''), register_ops_of SCXTNUM_EL3_ref),
    ((''TPIDR2_EL0''), register_ops_of TPIDR2_EL0_ref),
    ((''SCXTNUM_EL0''), register_ops_of SCXTNUM_EL0_ref),
    ((''AMAIR_EL1''), register_ops_of AMAIR_EL1_ref),
    ((''TPIDRRO_EL0''), register_ops_of TPIDRRO_EL0_ref),
    ((''SCXTNUM_EL1''), register_ops_of SCXTNUM_EL1_ref),
    ((''AMAIR_EL3''), register_ops_of AMAIR_EL3_ref),
    ((''AMAIR_EL2''), register_ops_of AMAIR_EL2_ref),
    ((''ACTLR_EL3''), register_ops_of ACTLR_EL3_ref),
    ((''TPIDR_EL3''), register_ops_of TPIDR_EL3_ref),
    ((''PMIAR_EL1''), register_ops_of PMIAR_EL1_ref),
    ((''SCXTNUM_EL2''), register_ops_of SCXTNUM_EL2_ref),
    ((''PMICNTSVR_EL1''), register_ops_of PMICNTSVR_EL1_ref),
    ((''SPMACCESSR_EL2''), register_ops_of SPMACCESSR_EL2_ref),
    ((''AFSR0_EL1''), register_ops_of AFSR0_EL1_ref),
    ((''AFSR1_EL2''), register_ops_of AFSR1_EL2_ref),
    ((''AFSR0_EL3''), register_ops_of AFSR0_EL3_ref),
    ((''ICV_AP0R_EL1''), register_ops_of ICV_AP0R_EL1_ref),
    ((''AMAIR2_EL2''), register_ops_of AMAIR2_EL2_ref),
    ((''PMCCNTSVR_EL1''), register_ops_of PMCCNTSVR_EL1_ref),
    ((''AFSR1_EL1''), register_ops_of AFSR1_EL1_ref),
    ((''ICC_AP1R_EL1_NS''), register_ops_of ICC_AP1R_EL1_NS_ref),
    ((''ICC_AP1R_EL1_S''), register_ops_of ICC_AP1R_EL1_S_ref),
    ((''ACTLR_EL1''), register_ops_of ACTLR_EL1_ref),
    ((''TPIDR_EL1''), register_ops_of TPIDR_EL1_ref),
    ((''ICH_AP0R_EL2''), register_ops_of ICH_AP0R_EL2_ref),
    ((''PMEVCNTSVR_EL1''), register_ops_of PMEVCNTSVR_EL1_ref),
    ((''ICH_AP1R_EL2''), register_ops_of ICH_AP1R_EL2_ref),
    ((''SPMACCESSR_EL1''), register_ops_of SPMACCESSR_EL1_ref),
    ((''ACTLR_EL2''), register_ops_of ACTLR_EL2_ref),
    ((''TPIDR_EL2''), register_ops_of TPIDR_EL2_ref),
    ((''REVIDR_EL1''), register_ops_of REVIDR_EL1_ref),
    ((''AIDR_EL1''), register_ops_of AIDR_EL1_ref),
    ((''ICC_AP0R_EL1''), register_ops_of ICC_AP0R_EL1_ref),
    ((''ICH_LR_EL2''), register_ops_of ICH_LR_EL2_ref),
    ((''_PMCCNTR''), register_ops_of PMCCNTR_ref),
    ((''_PMOVSSET''), register_ops_of PMOVSSET_ref),
    ((''_PMEVCNTR''), register_ops_of PMEVCNTR_ref),
    ((''_DBGWVR''), register_ops_of DBGWVR_ref),
    ((''_DBGWCR''), register_ops_of DBGWCR_ref),
    ((''_DBGBXVR''), register_ops_of DBGBXVR_ref),
    ((''_DBGBVR''), register_ops_of DBGBVR_ref),
    ((''_DBGBCR''), register_ops_of DBGBCR_ref),
    ((''STACK_LIMIT''), register_ops_of STACK_LIMIT_ref),
    ((''STACK_BASE''), register_ops_of STACK_BASE_ref),
    ((''HEAP_LIMIT''), register_ops_of HEAP_LIMIT_ref),
    ((''HEAP_BASE''), register_ops_of HEAP_BASE_ref),
    ((''__has_spe_pseudo_cycles''), register_ops_of has_spe_pseudo_cycles_ref),
    ((''SMCR_EL3_LEN_VALUE''), register_ops_of SMCR_EL3_LEN_VALUE_ref),
    ((''CPTR_EL3_ESM_VALUE''), register_ops_of CPTR_EL3_ESM_VALUE_ref),
    ((''CPTR_EL3_EZ_VALUE''), register_ops_of CPTR_EL3_EZ_VALUE_ref),
    ((''ZCR_EL3_LEN_VALUE''), register_ops_of ZCR_EL3_LEN_VALUE_ref),
    ((''CFG_RMR_AA64''), register_ops_of CFG_RMR_AA64_ref),
    ((''__DBG_ROM_ADDR''), register_ops_of DBG_ROM_ADDR_ref),
    ((''__mops_forward_copy''), register_ops_of mops_forward_copy_ref),
    ((''__trickbox_enabled''), register_ops_of trickbox_enabled_ref),
    ((''__ignore_rvbar_in_aarch32''), register_ops_of ignore_rvbar_in_aarch32_ref),
    ((''__unpred_tsize_aborts''), register_ops_of unpred_tsize_aborts_ref),
    ((''__syncAbortOnDeviceWrite''), register_ops_of syncAbortOnDeviceWrite_ref),
    ((''__syncAbortOnWriteNormNonCache''), register_ops_of syncAbortOnWriteNormNonCache_ref),
    ((''__syncAbortOnWriteNormCache''), register_ops_of syncAbortOnWriteNormCache_ref),
    ((''__syncAbortOnTTWNonCache''), register_ops_of syncAbortOnTTWNonCache_ref),
    ((''__syncAbortOnTTWCache''), register_ops_of syncAbortOnTTWCache_ref),
    ((''__syncAbortOnPrefetch''), register_ops_of syncAbortOnPrefetch_ref),
    ((''__syncAbortOnSoWrite''), register_ops_of syncAbortOnSoWrite_ref),
    ((''__syncAbortOnSoRead''), register_ops_of syncAbortOnSoRead_ref),
    ((''__syncAbortOnDeviceRead''), register_ops_of syncAbortOnDeviceRead_ref),
    ((''__syncAbortOnReadNormNonCache''), register_ops_of syncAbortOnReadNormNonCache_ref),
    ((''__syncAbortOnReadNormCache''), register_ops_of syncAbortOnReadNormCache_ref),
    ((''__PMUBase''), register_ops_of PMUBase_ref),
    ((''__GICITSControlBase''), register_ops_of GICITSControlBase_ref),
    ((''__GICDistBase''), register_ops_of GICDistBase_ref),
    ((''__GICCPUInterfaceBase''), register_ops_of GICCPUInterfaceBase_ref),
    ((''__ExtDebugBase''), register_ops_of ExtDebugBase_ref),
    ((''__CNTControlBase''), register_ops_of CNTControlBase_ref),
    ((''__CTIBase''), register_ops_of CTIBase_ref),
    ((''_DBGDTR_EL0''), register_ops_of DBGDTR_EL0_ref),
    ((''DACR_S''), register_ops_of DACR_S_ref),
    ((''_DACR_NS''), register_ops_of DACR_NS_ref),
    ((''_HMAIR1''), register_ops_of HMAIR1_ref),
    ((''_HMAIR0''), register_ops_of HMAIR0_ref),
    ((''_MAIR1_S''), register_ops_of MAIR1_S_ref),
    ((''_MAIR1_NS''), register_ops_of MAIR1_NS_ref),
    ((''_MAIR0_S''), register_ops_of MAIR0_S_ref),
    ((''_MAIR0_NS''), register_ops_of MAIR0_NS_ref),
    ((''BRBTGTINJ_EL1''), register_ops_of BRBTGTINJ_EL1_ref),
    ((''BRBSRCINJ_EL1''), register_ops_of BRBSRCINJ_EL1_ref),
    ((''SPESampleCounter''), register_ops_of SPESampleCounter_ref),
    ((''SPERecordData''), register_ops_of SPERecordData_ref),
    ((''PMSDSFR_EL1''), register_ops_of PMSDSFR_EL1_ref),
    ((''PMBPTR_EL1''), register_ops_of PMBPTR_EL1_ref),
    ((''PMCCNTR_EL0''), register_ops_of PMCCNTR_EL0_ref),
    ((''PMEVCNTR_EL0''), register_ops_of PMEVCNTR_EL0_ref),
    ((''__rme_l0gptsz''), register_ops_of rme_l0gptsz_ref),
    ((''__mpam_has_altsp''), register_ops_of mpam_has_altsp_ref),
    ((''__mecid_width''), register_ops_of mecid_width_ref),
    ((''__gmid_log2_block_size''), register_ops_of gmid_log2_block_size_ref),
    ((''__dczid_log2_block_size''), register_ops_of dczid_log2_block_size_ref),
    ((''__CNTbase_frequency''), register_ops_of CNTbase_frequency_ref),
    ((''__g1_activity_monitor_offset_implemented''), register_ops_of g1_activity_monitor_offset_implemented_ref),
    ((''__g1_activity_monitor_implemented''), register_ops_of g1_activity_monitor_implemented_ref),
    ((''ID_AA64PFR0_EL1''), register_ops_of ID_AA64PFR0_EL1_ref),
    ((''ID_AA64MMFR1_EL1''), register_ops_of ID_AA64MMFR1_EL1_ref),
    ((''ID_AA64ISAR1_EL1''), register_ops_of ID_AA64ISAR1_EL1_ref),
    ((''ID_AA64DFR1_EL1''), register_ops_of ID_AA64DFR1_EL1_ref),
    ((''ID_AA64DFR0_EL1''), register_ops_of ID_AA64DFR0_EL1_ref),
    ((''GICD_TYPER''), register_ops_of GICD_TYPER_ref),
    ((''__supported_va_size''), register_ops_of supported_va_size_ref),
    ((''EDDEVARCH''), register_ops_of EDDEVARCH_ref),
    ((''CTIDEVARCH''), register_ops_of CTIDEVARCH_ref),
    ((''CNTFID0''), register_ops_of CNTFID0_ref),
    ((''CFG_MPIDR''), register_ops_of CFG_MPIDR_ref),
    ((''AMIIDR''), register_ops_of AMIIDR_ref),
    ((''AMEVTYPER0_EL0''), register_ops_of AMEVTYPER0_EL0_ref),
    ((''AMDEVARCH''), register_ops_of AMDEVARCH_ref),
    ((''SPMSELR_EL0''), register_ops_of SPMSELR_EL0_ref),
    ((''SMPRI_EL1''), register_ops_of SMPRI_EL1_ref),
    ((''SMIDR_EL1''), register_ops_of SMIDR_EL1_ref),
    ((''PMZR_EL0''), register_ops_of PMZR_EL0_ref),
    ((''PMXEVCNTR_EL0''), register_ops_of PMXEVCNTR_EL0_ref),
    ((''PMUACR_EL1''), register_ops_of PMUACR_EL1_ref),
    ((''PMSSCR_EL1''), register_ops_of PMSSCR_EL1_ref),
    ((''PMSNEVFR_EL1''), register_ops_of PMSNEVFR_EL1_ref),
    ((''PMSLATFR_EL1''), register_ops_of PMSLATFR_EL1_ref),
    ((''PMSIRR_EL1''), register_ops_of PMSIRR_EL1_ref),
    ((''PMSICR_EL1''), register_ops_of PMSICR_EL1_ref),
    ((''PMSFCR_EL1''), register_ops_of PMSFCR_EL1_ref),
    ((''PMSEVFR_EL1''), register_ops_of PMSEVFR_EL1_ref),
    ((''PMMIR_EL1''), register_ops_of PMMIR_EL1_ref),
    ((''PMECR_EL1''), register_ops_of PMECR_EL1_ref),
    ((''PMBIDR_EL1''), register_ops_of PMBIDR_EL1_ref),
    ((''_PAR_EL1''), register_ops_of PAR_EL1_ref),
    ((''OSLAR_EL1''), register_ops_of OSLAR_EL1_ref),
    ((''OSDTRTX_EL1''), register_ops_of OSDTRTX_EL1_ref),
    ((''OSDTRRX_EL1''), register_ops_of OSDTRRX_EL1_ref),
    ((''MECIDR_EL2''), register_ops_of MECIDR_EL2_ref),
    ((''MDSELR_EL1''), register_ops_of MDSELR_EL1_ref),
    ((''LORSA_EL1''), register_ops_of LORSA_EL1_ref),
    ((''LORN_EL1''), register_ops_of LORN_EL1_ref),
    ((''LORID_EL1''), register_ops_of LORID_EL1_ref),
    ((''LOREA_EL1''), register_ops_of LOREA_EL1_ref),
    ((''LORC_EL1''), register_ops_of LORC_EL1_ref),
    ((''ID_AA64ZFR0_EL1''), register_ops_of ID_AA64ZFR0_EL1_ref),
    ((''ID_AA64SMFR0_EL1''), register_ops_of ID_AA64SMFR0_EL1_ref),
    ((''ID_AA64PFR2_EL1''), register_ops_of ID_AA64PFR2_EL1_ref),
    ((''ID_AA64PFR1_EL1''), register_ops_of ID_AA64PFR1_EL1_ref),
    ((''ID_AA64MMFR4_EL1''), register_ops_of ID_AA64MMFR4_EL1_ref),
    ((''ID_AA64MMFR3_EL1''), register_ops_of ID_AA64MMFR3_EL1_ref),
    ((''ID_AA64MMFR2_EL1''), register_ops_of ID_AA64MMFR2_EL1_ref),
    ((''ID_AA64MMFR0_EL1''), register_ops_of ID_AA64MMFR0_EL1_ref),
    ((''ID_AA64ISAR2_EL1''), register_ops_of ID_AA64ISAR2_EL1_ref),
    ((''ID_AA64ISAR0_EL1''), register_ops_of ID_AA64ISAR0_EL1_ref),
    ((''ID_AA64AFR1_EL1''), register_ops_of ID_AA64AFR1_EL1_ref),
    ((''ID_AA64AFR0_EL1''), register_ops_of ID_AA64AFR0_EL1_ref),
    ((''ICV_NMIAR1_EL1''), register_ops_of ICV_NMIAR1_EL1_ref),
    ((''ICC_SRE_EL3''), register_ops_of ICC_SRE_EL3_ref),
    ((''ICC_NMIAR1_EL1''), register_ops_of ICC_NMIAR1_EL1_ref),
    ((''ICC_IGRPEN1_EL3''), register_ops_of ICC_IGRPEN1_EL3_ref),
    ((''ICC_CTLR_EL3''), register_ops_of ICC_CTLR_EL3_ref),
    ((''HFGWTR_EL2''), register_ops_of HFGWTR_EL2_ref),
    ((''HFGWTR2_EL2''), register_ops_of HFGWTR2_EL2_ref),
    ((''HFGRTR_EL2''), register_ops_of HFGRTR_EL2_ref),
    ((''HFGRTR2_EL2''), register_ops_of HFGRTR2_EL2_ref),
    ((''HFGITR2_EL2''), register_ops_of HFGITR2_EL2_ref),
    ((''HDFGWTR_EL2''), register_ops_of HDFGWTR_EL2_ref),
    ((''HDFGWTR2_EL2''), register_ops_of HDFGWTR2_EL2_ref),
    ((''HDFGRTR_EL2''), register_ops_of HDFGRTR_EL2_ref),
    ((''HDFGRTR2_EL2''), register_ops_of HDFGRTR2_EL2_ref),
    ((''HAFGRTR_EL2''), register_ops_of HAFGRTR_EL2_ref),
    ((''GMID_EL1''), register_ops_of GMID_EL1_ref),
    ((''DCZID_EL0''), register_ops_of DCZID_EL0_ref),
    ((''DBGDTRTX_EL0''), register_ops_of DBGDTRTX_EL0_ref),
    ((''DBGDTRRX_EL0''), register_ops_of DBGDTRRX_EL0_ref),
    ((''DACR32_EL2''), register_ops_of DACR32_EL2_ref),
    ((''CNTV_TVAL_EL0''), register_ops_of CNTV_TVAL_EL0_ref),
    ((''CNTP_TVAL_EL0''), register_ops_of CNTP_TVAL_EL0_ref),
    ((''CNTPS_TVAL_EL1''), register_ops_of CNTPS_TVAL_EL1_ref),
    ((''CNTHV_TVAL_EL2''), register_ops_of CNTHV_TVAL_EL2_ref),
    ((''CNTHVS_TVAL_EL2''), register_ops_of CNTHVS_TVAL_EL2_ref),
    ((''CNTHP_TVAL_EL2''), register_ops_of CNTHP_TVAL_EL2_ref),
    ((''CNTHPS_TVAL_EL2''), register_ops_of CNTHPS_TVAL_EL2_ref),
    ((''CNTFRQ_EL0''), register_ops_of CNTFRQ_EL0_ref),
    ((''BRBINFINJ_EL1''), register_ops_of BRBINFINJ_EL1_ref),
    ((''AMCG1IDR_EL0''), register_ops_of AMCG1IDR_EL0_ref),
    ((''ACCDATA_EL1''), register_ops_of ACCDATA_EL1_ref),
    ((''__num_ctx_breakpoints''), register_ops_of num_ctx_breakpoints_ref),
    ((''__exclusive_granule_size''), register_ops_of exclusive_granule_size_ref),
    ((''TLBTR''), register_ops_of TLBTR_ref),
    ((''_PMCEID3''), register_ops_of PMCEID3_ref),
    ((''_PMCEID2''), register_ops_of PMCEID2_ref),
    ((''_PMCEID1''), register_ops_of PMCEID1_ref),
    ((''PMCEID1_EL0''), register_ops_of PMCEID1_EL0_ref),
    ((''_PMCEID0''), register_ops_of PMCEID0_ref),
    ((''PMCEID0_EL0''), register_ops_of PMCEID0_EL0_ref),
    ((''NMRR_S''), register_ops_of NMRR_S_ref),
    ((''_NMRR_NS''), register_ops_of NMRR_NS_ref),
    ((''_MVFR1''), register_ops_of MVFR1_ref),
    ((''MVFR1_EL1''), register_ops_of MVFR1_EL1_ref),
    ((''_MVFR0''), register_ops_of MVFR0_ref),
    ((''MVFR0_EL1''), register_ops_of MVFR0_EL1_ref),
    ((''_MIDR''), register_ops_of MIDR_ref),
    ((''MIDR_EL1''), register_ops_of MIDR_EL1_ref),
    ((''_ID_PFR1''), register_ops_of ID_PFR1_ref),
    ((''ID_PFR1_EL1''), register_ops_of ID_PFR1_EL1_ref),
    ((''_ID_PFR0''), register_ops_of ID_PFR0_ref),
    ((''ID_PFR0_EL1''), register_ops_of ID_PFR0_EL1_ref),
    ((''_ID_MMFR4''), register_ops_of ID_MMFR4_ref),
    ((''ID_MMFR4_EL1''), register_ops_of ID_MMFR4_EL1_ref),
    ((''_ID_MMFR3''), register_ops_of ID_MMFR3_ref),
    ((''ID_MMFR3_EL1''), register_ops_of ID_MMFR3_EL1_ref),
    ((''_ID_MMFR2''), register_ops_of ID_MMFR2_ref),
    ((''ID_MMFR2_EL1''), register_ops_of ID_MMFR2_EL1_ref),
    ((''_ID_MMFR1''), register_ops_of ID_MMFR1_ref),
    ((''ID_MMFR1_EL1''), register_ops_of ID_MMFR1_EL1_ref),
    ((''_ID_MMFR0''), register_ops_of ID_MMFR0_ref),
    ((''ID_MMFR0_EL1''), register_ops_of ID_MMFR0_EL1_ref),
    ((''_ID_ISAR6''), register_ops_of ID_ISAR6_ref),
    ((''ID_ISAR6_EL1''), register_ops_of ID_ISAR6_EL1_ref),
    ((''_ID_ISAR4''), register_ops_of ID_ISAR4_ref),
    ((''ID_ISAR4_EL1''), register_ops_of ID_ISAR4_EL1_ref),
    ((''_ID_ISAR3''), register_ops_of ID_ISAR3_ref),
    ((''ID_ISAR3_EL1''), register_ops_of ID_ISAR3_EL1_ref),
    ((''_ID_ISAR2''), register_ops_of ID_ISAR2_ref),
    ((''ID_ISAR2_EL1''), register_ops_of ID_ISAR2_EL1_ref),
    ((''_ID_ISAR1''), register_ops_of ID_ISAR1_ref),
    ((''ID_ISAR1_EL1''), register_ops_of ID_ISAR1_EL1_ref),
    ((''_ID_DFR0''), register_ops_of ID_DFR0_ref),
    ((''ID_DFR0_EL1''), register_ops_of ID_DFR0_EL1_ref),
    ((''FPSID''), register_ops_of FPSID_ref),
    ((''DBGDEVID''), register_ops_of DBGDEVID_ref),
    ((''_CLIDR''), register_ops_of CLIDR_ref),
    ((''_VTCR''), register_ops_of VTCR_ref),
    ((''_VPIDR''), register_ops_of VPIDR_ref),
    ((''VPIDR_EL2''), register_ops_of VPIDR_EL2_ref),
    ((''_VMPIDR''), register_ops_of VMPIDR_ref),
    ((''VMPIDR_EL2''), register_ops_of VMPIDR_EL2_ref),
    ((''TTBCR2_S''), register_ops_of TTBCR2_S_ref),
    ((''_TTBCR2_NS''), register_ops_of TTBCR2_NS_ref),
    ((''_TRFCR''), register_ops_of TRFCR_ref),
    ((''TRFCR_EL1''), register_ops_of TRFCR_EL1_ref),
    ((''_RMR''), register_ops_of RMR_ref),
    ((''RMR_EL3''), register_ops_of RMR_EL3_ref),
    ((''RMR_EL1''), register_ops_of RMR_EL1_ref),
    ((''PRRR_S''), register_ops_of PRRR_S_ref),
    ((''_PRRR_NS''), register_ops_of PRRR_NS_ref),
    ((''PMVIDSR''), register_ops_of PMVIDSR_ref),
    ((''PMVCIDSR''), register_ops_of PMVCIDSR_ref),
    ((''_PMUSERENR''), register_ops_of PMUSERENR_ref),
    ((''PMUSERENR_EL0''), register_ops_of PMUSERENR_EL0_ref),
    ((''_PMSWINC''), register_ops_of PMSWINC_ref),
    ((''PMSWINC_EL0''), register_ops_of PMSWINC_EL0_ref),
    ((''_PMSELR''), register_ops_of PMSELR_ref),
    ((''PMSELR_EL0''), register_ops_of PMSELR_EL0_ref),
    ((''PMPIDR4''), register_ops_of PMPIDR4_ref),
    ((''PMPIDR3''), register_ops_of PMPIDR3_ref),
    ((''PMPIDR2''), register_ops_of PMPIDR2_ref),
    ((''PMPIDR1''), register_ops_of PMPIDR1_ref),
    ((''PMPIDR0''), register_ops_of PMPIDR0_ref),
    ((''PMPCSR''), register_ops_of PMPCSR_ref),
    ((''PMPCSCTL''), register_ops_of PMPCSCTL_ref),
    ((''_PMOVS''), register_ops_of PMOVS_ref),
    ((''PMMIR''), register_ops_of PMMIR_ref),
    ((''PMLSR''), register_ops_of PMLSR_ref),
    ((''PMLAR''), register_ops_of PMLAR_ref),
    ((''PMITCTRL''), register_ops_of PMITCTRL_ref),
    ((''_PMINTEN''), register_ops_of PMINTEN_ref),
    ((''PMINTENSET_EL1''), register_ops_of PMINTENSET_EL1_ref),
    ((''PMIIDR''), register_ops_of PMIIDR_ref),
    ((''PMDEVTYPE''), register_ops_of PMDEVTYPE_ref),
    ((''PMDEVID''), register_ops_of PMDEVID_ref),
    ((''_PMCNTEN''), register_ops_of PMCNTEN_ref),
    ((''PMCIDR3''), register_ops_of PMCIDR3_ref),
    ((''PMCIDR2''), register_ops_of PMCIDR2_ref),
    ((''PMCIDR1''), register_ops_of PMCIDR1_ref),
    ((''PMCIDR0''), register_ops_of PMCIDR0_ref),
    ((''PMCGCR0''), register_ops_of PMCGCR0_ref),
    ((''PMCFGR''), register_ops_of PMCFGR_ref),
    ((''PMAUTHSTATUS''), register_ops_of PMAUTHSTATUS_ref),
    ((''PAR_S''), register_ops_of PAR_S_ref),
    ((''PAR_NS''), register_ops_of PAR_NS_ref),
    ((''_MVFR2''), register_ops_of MVFR2_ref),
    ((''MVFR2_EL1''), register_ops_of MVFR2_EL1_ref),
    ((''_MPIDR''), register_ops_of MPIDR_ref),
    ((''MPIDR_EL1''), register_ops_of MPIDR_EL1_ref),
    ((''JOSCR''), register_ops_of JOSCR_ref),
    ((''JMCR''), register_ops_of JMCR_ref),
    ((''JIDR''), register_ops_of JIDR_ref),
    ((''_ISR''), register_ops_of ISR_ref),
    ((''ISR_EL1''), register_ops_of ISR_EL1_ref),
    ((''_ID_PFR2''), register_ops_of ID_PFR2_ref),
    ((''ID_PFR2_EL1''), register_ops_of ID_PFR2_EL1_ref),
    ((''_ID_MMFR5''), register_ops_of ID_MMFR5_ref),
    ((''ID_MMFR5_EL1''), register_ops_of ID_MMFR5_EL1_ref),
    ((''_ID_ISAR5''), register_ops_of ID_ISAR5_ref),
    ((''ID_ISAR5_EL1''), register_ops_of ID_ISAR5_EL1_ref),
    ((''_ID_ISAR0''), register_ops_of ID_ISAR0_ref),
    ((''ID_ISAR0_EL1''), register_ops_of ID_ISAR0_EL1_ref),
    ((''_ID_DFR1''), register_ops_of ID_DFR1_ref),
    ((''ID_DFR1_EL1''), register_ops_of ID_DFR1_EL1_ref),
    ((''_ID_AFR0''), register_ops_of ID_AFR0_ref),
    ((''ID_AFR0_EL1''), register_ops_of ID_AFR0_EL1_ref),
    ((''_ICV_RPR''), register_ops_of ICV_RPR_ref),
    ((''ICV_RPR_EL1''), register_ops_of ICV_RPR_EL1_ref),
    ((''_ICV_PMR''), register_ops_of ICV_PMR_ref),
    ((''ICV_PMR_EL1''), register_ops_of ICV_PMR_EL1_ref),
    ((''_ICV_IGRPEN1''), register_ops_of ICV_IGRPEN1_ref),
    ((''ICV_IGRPEN1_EL1''), register_ops_of ICV_IGRPEN1_EL1_ref),
    ((''_ICV_IGRPEN0''), register_ops_of ICV_IGRPEN0_ref),
    ((''ICV_IGRPEN0_EL1''), register_ops_of ICV_IGRPEN0_EL1_ref),
    ((''_ICV_IAR1''), register_ops_of ICV_IAR1_ref),
    ((''ICV_IAR1_EL1''), register_ops_of ICV_IAR1_EL1_ref),
    ((''_ICV_IAR0''), register_ops_of ICV_IAR0_ref),
    ((''ICV_IAR0_EL1''), register_ops_of ICV_IAR0_EL1_ref),
    ((''_ICV_HPPIR1''), register_ops_of ICV_HPPIR1_ref),
    ((''ICV_HPPIR1_EL1''), register_ops_of ICV_HPPIR1_EL1_ref),
    ((''_ICV_HPPIR0''), register_ops_of ICV_HPPIR0_ref),
    ((''ICV_HPPIR0_EL1''), register_ops_of ICV_HPPIR0_EL1_ref),
    ((''_ICV_EOIR1''), register_ops_of ICV_EOIR1_ref),
    ((''ICV_EOIR1_EL1''), register_ops_of ICV_EOIR1_EL1_ref),
    ((''_ICV_EOIR0''), register_ops_of ICV_EOIR0_ref),
    ((''ICV_EOIR0_EL1''), register_ops_of ICV_EOIR0_EL1_ref),
    ((''_ICV_DIR''), register_ops_of ICV_DIR_ref),
    ((''ICV_DIR_EL1''), register_ops_of ICV_DIR_EL1_ref),
    ((''_ICV_CTLR''), register_ops_of ICV_CTLR_ref),
    ((''ICV_CTLR_EL1''), register_ops_of ICV_CTLR_EL1_ref),
    ((''_ICV_BPR1''), register_ops_of ICV_BPR1_ref),
    ((''ICV_BPR1_EL1''), register_ops_of ICV_BPR1_EL1_ref),
    ((''_ICV_BPR0''), register_ops_of ICV_BPR0_ref),
    ((''ICV_BPR0_EL1''), register_ops_of ICV_BPR0_EL1_ref),
    ((''_ICH_VTR''), register_ops_of ICH_VTR_ref),
    ((''ICH_VTR_EL2''), register_ops_of ICH_VTR_EL2_ref),
    ((''_ICH_VMCR''), register_ops_of ICH_VMCR_ref),
    ((''ICH_VMCR_EL2''), register_ops_of ICH_VMCR_EL2_ref),
    ((''_ICH_MISR''), register_ops_of ICH_MISR_ref),
    ((''ICH_MISR_EL2''), register_ops_of ICH_MISR_EL2_ref),
    ((''_ICH_HCR''), register_ops_of ICH_HCR_ref),
    ((''ICH_HCR_EL2''), register_ops_of ICH_HCR_EL2_ref),
    ((''_ICH_ELRSR''), register_ops_of ICH_ELRSR_ref),
    ((''ICH_ELRSR_EL2''), register_ops_of ICH_ELRSR_EL2_ref),
    ((''_ICH_EISR''), register_ops_of ICH_EISR_ref),
    ((''ICH_EISR_EL2''), register_ops_of ICH_EISR_EL2_ref),
    ((''_ICC_SRE_S''), register_ops_of ICC_SRE_S_ref),
    ((''ICC_SRE_EL1_S''), register_ops_of ICC_SRE_EL1_S_ref),
    ((''_ICC_SRE_NS''), register_ops_of ICC_SRE_NS_ref),
    ((''ICC_SRE_EL1_NS''), register_ops_of ICC_SRE_EL1_NS_ref),
    ((''_ICC_SGI1R''), register_ops_of ICC_SGI1R_ref),
    ((''ICC_SGI1R_EL1''), register_ops_of ICC_SGI1R_EL1_ref),
    ((''_ICC_SGI0R''), register_ops_of ICC_SGI0R_ref),
    ((''ICC_SGI0R_EL1''), register_ops_of ICC_SGI0R_EL1_ref),
    ((''_ICC_RPR''), register_ops_of ICC_RPR_ref),
    ((''ICC_RPR_EL1''), register_ops_of ICC_RPR_EL1_ref),
    ((''_ICC_PMR''), register_ops_of ICC_PMR_ref),
    ((''ICC_MSRE''), register_ops_of ICC_MSRE_ref),
    ((''ICC_MGRPEN1''), register_ops_of ICC_MGRPEN1_ref),
    ((''ICC_MCTLR''), register_ops_of ICC_MCTLR_ref),
    ((''_ICC_IGRPEN1_S''), register_ops_of ICC_IGRPEN1_S_ref),
    ((''ICC_IGRPEN1_EL1_S''), register_ops_of ICC_IGRPEN1_EL1_S_ref),
    ((''_ICC_IGRPEN1_NS''), register_ops_of ICC_IGRPEN1_NS_ref),
    ((''ICC_IGRPEN1_EL1_NS''), register_ops_of ICC_IGRPEN1_EL1_NS_ref),
    ((''_ICC_IGRPEN0''), register_ops_of ICC_IGRPEN0_ref),
    ((''ICC_IGRPEN0_EL1''), register_ops_of ICC_IGRPEN0_EL1_ref),
    ((''_ICC_IAR1''), register_ops_of ICC_IAR1_ref),
    ((''ICC_IAR1_EL1''), register_ops_of ICC_IAR1_EL1_ref),
    ((''_ICC_IAR0''), register_ops_of ICC_IAR0_ref),
    ((''ICC_IAR0_EL1''), register_ops_of ICC_IAR0_EL1_ref),
    ((''_ICC_HSRE''), register_ops_of ICC_HSRE_ref),
    ((''ICC_SRE_EL2''), register_ops_of ICC_SRE_EL2_ref),
    ((''_ICC_HPPIR1''), register_ops_of ICC_HPPIR1_ref),
    ((''ICC_HPPIR1_EL1''), register_ops_of ICC_HPPIR1_EL1_ref),
    ((''_ICC_HPPIR0''), register_ops_of ICC_HPPIR0_ref),
    ((''ICC_HPPIR0_EL1''), register_ops_of ICC_HPPIR0_EL1_ref),
    ((''_ICC_EOIR1''), register_ops_of ICC_EOIR1_ref),
    ((''ICC_EOIR1_EL1''), register_ops_of ICC_EOIR1_EL1_ref),
    ((''_ICC_EOIR0''), register_ops_of ICC_EOIR0_ref),
    ((''ICC_EOIR0_EL1''), register_ops_of ICC_EOIR0_EL1_ref),
    ((''_ICC_DIR''), register_ops_of ICC_DIR_ref),
    ((''ICC_DIR_EL1''), register_ops_of ICC_DIR_EL1_ref),
    ((''_ICC_CTLR_S''), register_ops_of ICC_CTLR_S_ref),
    ((''ICC_CTLR_EL1_S''), register_ops_of ICC_CTLR_EL1_S_ref),
    ((''_ICC_CTLR_NS''), register_ops_of ICC_CTLR_NS_ref),
    ((''ICC_CTLR_EL1_NS''), register_ops_of ICC_CTLR_EL1_NS_ref),
    ((''_ICC_BPR1_S''), register_ops_of ICC_BPR1_S_ref),
    ((''ICC_BPR1_EL1_S''), register_ops_of ICC_BPR1_EL1_S_ref),
    ((''_ICC_BPR1_NS''), register_ops_of ICC_BPR1_NS_ref),
    ((''ICC_BPR1_EL1_NS''), register_ops_of ICC_BPR1_EL1_NS_ref),
    ((''_ICC_BPR0''), register_ops_of ICC_BPR0_ref),
    ((''ICC_BPR0_EL1''), register_ops_of ICC_BPR0_EL1_ref),
    ((''_ICC_ASGI1R''), register_ops_of ICC_ASGI1R_ref),
    ((''ICC_ASGI1R_EL1''), register_ops_of ICC_ASGI1R_EL1_ref),
    ((''_HTRFCR''), register_ops_of HTRFCR_ref),
    ((''TRFCR_EL2''), register_ops_of TRFCR_EL2_ref),
    ((''_HTCR''), register_ops_of HTCR_ref),
    ((''_HSTR''), register_ops_of HSTR_ref),
    ((''HSTR_EL2''), register_ops_of HSTR_EL2_ref),
    ((''_HRMR''), register_ops_of HRMR_ref),
    ((''RMR_EL2''), register_ops_of RMR_EL2_ref),
    ((''GITS_TYPER''), register_ops_of GITS_TYPER_ref),
    ((''GITS_STATUSR''), register_ops_of GITS_STATUSR_ref),
    ((''GITS_SGIR''), register_ops_of GITS_SGIR_ref),
    ((''GITS_PARTIDR''), register_ops_of GITS_PARTIDR_ref),
    ((''GITS_MPIDR''), register_ops_of GITS_MPIDR_ref),
    ((''GITS_MPAMIDR''), register_ops_of GITS_MPAMIDR_ref),
    ((''GITS_IIDR''), register_ops_of GITS_IIDR_ref),
    ((''GITS_CWRITER''), register_ops_of GITS_CWRITER_ref),
    ((''GITS_CTLR''), register_ops_of GITS_CTLR_ref),
    ((''GITS_CREADR''), register_ops_of GITS_CREADR_ref),
    ((''GITS_CBASER''), register_ops_of GITS_CBASER_ref),
    ((''GICV_STATUSR''), register_ops_of GICV_STATUSR_ref),
    ((''GICV_RPR''), register_ops_of GICV_RPR_ref),
    ((''GICV_PMR''), register_ops_of GICV_PMR_ref),
    ((''GICV_IAR''), register_ops_of GICV_IAR_ref),
    ((''GICV_HPPIR''), register_ops_of GICV_HPPIR_ref),
    ((''GICV_EOIR''), register_ops_of GICV_EOIR_ref),
    ((''GICV_DIR''), register_ops_of GICV_DIR_ref),
    ((''GICV_CTLR''), register_ops_of GICV_CTLR_ref),
    ((''GICV_BPR''), register_ops_of GICV_BPR_ref),
    ((''GICV_AIAR''), register_ops_of GICV_AIAR_ref),
    ((''GICV_AHPPIR''), register_ops_of GICV_AHPPIR_ref),
    ((''GICV_AEOIR''), register_ops_of GICV_AEOIR_ref),
    ((''GICV_ABPR''), register_ops_of GICV_ABPR_ref),
    ((''GICR_WAKER''), register_ops_of GICR_WAKER_ref),
    ((''GICR_VSGIR''), register_ops_of GICR_VSGIR_ref),
    ((''GICR_VSGIPENDR''), register_ops_of GICR_VSGIPENDR_ref),
    ((''GICR_VPROPBASER''), register_ops_of GICR_VPROPBASER_ref),
    ((''GICR_VPENDBASER''), register_ops_of GICR_VPENDBASER_ref),
    ((''GICR_SYNCR''), register_ops_of GICR_SYNCR_ref),
    ((''GICR_STATUSR''), register_ops_of GICR_STATUSR_ref),
    ((''GICR_SETLPIR''), register_ops_of GICR_SETLPIR_ref),
    ((''GICR_PROPBASER''), register_ops_of GICR_PROPBASER_ref),
    ((''GICR_PENDBASER''), register_ops_of GICR_PENDBASER_ref),
    ((''GICR_PARTIDR''), register_ops_of GICR_PARTIDR_ref),
    ((''GICR_MPAMIDR''), register_ops_of GICR_MPAMIDR_ref),
    ((''GICR_ISENABLER0''), register_ops_of GICR_ISENABLER0_ref),
    ((''GICR_INVLPIR''), register_ops_of GICR_INVLPIR_ref),
    ((''GICR_INVALLR''), register_ops_of GICR_INVALLR_ref),
    ((''GICR_INMIR0''), register_ops_of GICR_INMIR0_ref),
    ((''GICR_IIDR''), register_ops_of GICR_IIDR_ref),
    ((''GICR_CTLR''), register_ops_of GICR_CTLR_ref),
    ((''GICR_CLRLPIR''), register_ops_of GICR_CLRLPIR_ref),
    ((''GICM_TYPER''), register_ops_of GICM_TYPER_ref),
    ((''GICM_SETSPI_SR''), register_ops_of GICM_SETSPI_SR_ref),
    ((''GICM_SETSPI_NSR''), register_ops_of GICM_SETSPI_NSR_ref),
    ((''GICM_IIDR''), register_ops_of GICM_IIDR_ref),
    ((''GICM_CLRSPI_SR''), register_ops_of GICM_CLRSPI_SR_ref),
    ((''GICM_CLRSPI_NSR''), register_ops_of GICM_CLRSPI_NSR_ref),
    ((''GICH_VTR''), register_ops_of GICH_VTR_ref),
    ((''GICH_VMCR''), register_ops_of GICH_VMCR_ref),
    ((''GICH_MISR''), register_ops_of GICH_MISR_ref),
    ((''GICH_HCR''), register_ops_of GICH_HCR_ref),
    ((''GICH_ELRSR''), register_ops_of GICH_ELRSR_ref),
    ((''GICH_EISR''), register_ops_of GICH_EISR_ref),
    ((''GICD_TYPER2''), register_ops_of GICD_TYPER2_ref),
    ((''GICD_STATUSR''), register_ops_of GICD_STATUSR_ref),
    ((''GICD_SGIR''), register_ops_of GICD_SGIR_ref),
    ((''GICD_SETSPI_SR''), register_ops_of GICD_SETSPI_SR_ref),
    ((''GICD_SETSPI_NSR''), register_ops_of GICD_SETSPI_NSR_ref),
    ((''GICD_IIDR''), register_ops_of GICD_IIDR_ref),
    ((''GICD_CTLR''), register_ops_of GICD_CTLR_ref),
    ((''GICD_CLRSPI_SR''), register_ops_of GICD_CLRSPI_SR_ref),
    ((''GICD_CLRSPI_NSR''), register_ops_of GICD_CLRSPI_NSR_ref),
    ((''GICC_STATUSR''), register_ops_of GICC_STATUSR_ref),
    ((''GICC_RPR''), register_ops_of GICC_RPR_ref),
    ((''GICC_PMR''), register_ops_of GICC_PMR_ref),
    ((''GICC_IAR''), register_ops_of GICC_IAR_ref),
    ((''GICC_HPPIR''), register_ops_of GICC_HPPIR_ref),
    ((''GICC_EOIR''), register_ops_of GICC_EOIR_ref),
    ((''GICC_DIR''), register_ops_of GICC_DIR_ref),
    ((''GICC_BPR''), register_ops_of GICC_BPR_ref),
    ((''GICC_AIAR''), register_ops_of GICC_AIAR_ref),
    ((''GICC_AHPPIR''), register_ops_of GICC_AHPPIR_ref),
    ((''GICC_AEOIR''), register_ops_of GICC_AEOIR_ref),
    ((''GICC_ABPR''), register_ops_of GICC_ABPR_ref),
    ((''FCSEIDR''), register_ops_of FCSEIDR_ref),
    ((''_ERRSELR''), register_ops_of ERRSELR_ref),
    ((''ERRSELR_EL1''), register_ops_of ERRSELR_EL1_ref),
    ((''_ERRIDR''), register_ops_of ERRIDR_ref),
    ((''ERRIDR_EL1''), register_ops_of ERRIDR_EL1_ref),
    ((''EDVIDSR''), register_ops_of EDVIDSR_ref),
    ((''EDRCR''), register_ops_of EDRCR_ref),
    ((''EDPRSR''), register_ops_of EDPRSR_ref),
    ((''EDPRCR''), register_ops_of EDPRCR_ref),
    ((''EDPIDR4''), register_ops_of EDPIDR4_ref),
    ((''EDPIDR3''), register_ops_of EDPIDR3_ref),
    ((''EDPIDR2''), register_ops_of EDPIDR2_ref),
    ((''EDPIDR1''), register_ops_of EDPIDR1_ref),
    ((''EDPIDR0''), register_ops_of EDPIDR0_ref),
    ((''EDPFR''), register_ops_of EDPFR_ref),
    ((''EDPCSR''), register_ops_of EDPCSR_ref),
    ((''EDLSR''), register_ops_of EDLSR_ref),
    ((''EDLAR''), register_ops_of EDLAR_ref),
    ((''EDITCTRL''), register_ops_of EDITCTRL_ref),
    ((''EDHSR''), register_ops_of EDHSR_ref),
    ((''EDDFR1''), register_ops_of EDDFR1_ref),
    ((''EDDFR''), register_ops_of EDDFR_ref),
    ((''EDDEVTYPE''), register_ops_of EDDEVTYPE_ref),
    ((''EDDEVID2''), register_ops_of EDDEVID2_ref),
    ((''EDDEVID1''), register_ops_of EDDEVID1_ref),
    ((''EDDEVID''), register_ops_of EDDEVID_ref),
    ((''EDCIDR3''), register_ops_of EDCIDR3_ref),
    ((''EDCIDR2''), register_ops_of EDCIDR2_ref),
    ((''EDCIDR1''), register_ops_of EDCIDR1_ref),
    ((''EDCIDR0''), register_ops_of EDCIDR0_ref),
    ((''EDAA32PFR''), register_ops_of EDAA32PFR_ref),
    ((''DBGWFAR''), register_ops_of DBGWFAR_ref),
    ((''_DBGVCR''), register_ops_of DBGVCR_ref),
    ((''DBGVCR32_EL2''), register_ops_of DBGVCR32_EL2_ref),
    ((''DBGDSAR''), register_ops_of DBGDSAR_ref),
    ((''_DBGDRAR''), register_ops_of DBGDRAR_ref),
    ((''MDRAR_EL1''), register_ops_of MDRAR_EL1_ref),
    ((''DBGDIDR''), register_ops_of DBGDIDR_ref),
    ((''DBGDEVID2''), register_ops_of DBGDEVID2_ref),
    ((''DBGDEVID1''), register_ops_of DBGDEVID1_ref),
    ((''_DBGDCCINT''), register_ops_of DBGDCCINT_ref),
    ((''MDCCINT_EL1''), register_ops_of MDCCINT_EL1_ref),
    ((''_DBGCLAIMSET''), register_ops_of DBGCLAIMSET_ref),
    ((''DBGCLAIMSET_EL1''), register_ops_of DBGCLAIMSET_EL1_ref),
    ((''_DBGCLAIMCLR''), register_ops_of DBGCLAIMCLR_ref),
    ((''DBGCLAIMCLR_EL1''), register_ops_of DBGCLAIMCLR_EL1_ref),
    ((''_DBGAUTHSTATUS''), register_ops_of DBGAUTHSTATUS_ref),
    ((''DBGAUTHSTATUS_EL1''), register_ops_of DBGAUTHSTATUS_EL1_ref),
    ((''_CTR''), register_ops_of CTR_ref),
    ((''CTIPIDR4''), register_ops_of CTIPIDR4_ref),
    ((''CTIPIDR3''), register_ops_of CTIPIDR3_ref),
    ((''CTIPIDR2''), register_ops_of CTIPIDR2_ref),
    ((''CTIPIDR1''), register_ops_of CTIPIDR1_ref),
    ((''CTIPIDR0''), register_ops_of CTIPIDR0_ref),
    ((''CTILSR''), register_ops_of CTILSR_ref),
    ((''CTILAR''), register_ops_of CTILAR_ref),
    ((''CTIITCTRL''), register_ops_of CTIITCTRL_ref),
    ((''CTIDEVTYPE''), register_ops_of CTIDEVTYPE_ref),
    ((''CTIDEVID2''), register_ops_of CTIDEVID2_ref),
    ((''CTIDEVID1''), register_ops_of CTIDEVID1_ref),
    ((''CTIDEVID''), register_ops_of CTIDEVID_ref),
    ((''CTIDEVCTL''), register_ops_of CTIDEVCTL_ref),
    ((''CTICONTROL''), register_ops_of CTICONTROL_ref),
    ((''CTICIDR3''), register_ops_of CTICIDR3_ref),
    ((''CTICIDR2''), register_ops_of CTICIDR2_ref),
    ((''CTICIDR1''), register_ops_of CTICIDR1_ref),
    ((''CTICIDR0''), register_ops_of CTICIDR0_ref),
    ((''CTIAUTHSTATUS''), register_ops_of CTIAUTHSTATUS_ref),
    ((''CSSELR_S''), register_ops_of CSSELR_S_ref),
    ((''_CSSELR_NS''), register_ops_of CSSELR_NS_ref),
    ((''CSSELR_EL1''), register_ops_of CSSELR_EL1_ref),
    ((''_CNTV_CTL''), register_ops_of CNTV_CTL_ref),
    ((''CNTSR''), register_ops_of CNTSR_ref),
    ((''CNTNSAR''), register_ops_of CNTNSAR_ref),
    ((''CNTID''), register_ops_of CNTID_ref),
    ((''_CNTHV_CTL''), register_ops_of CNTHV_CTL_ref),
    ((''_CNTHVS_CTL''), register_ops_of CNTHVS_CTL_ref),
    ((''_CNTHPS_CTL''), register_ops_of CNTHPS_CTL_ref),
    ((''_CNTHCTL''), register_ops_of CNTHCTL_ref),
    ((''CNTEL0ACR''), register_ops_of CNTEL0ACR_ref),
    ((''_CCSIDR''), register_ops_of CCSIDR_ref),
    ((''CCSIDR_EL1''), register_ops_of CCSIDR_EL1_ref),
    ((''_CCSIDR2''), register_ops_of CCSIDR2_ref),
    ((''CCSIDR2_EL1''), register_ops_of CCSIDR2_EL1_ref),
    ((''_AMUSERENR''), register_ops_of AMUSERENR_ref),
    ((''AMUSERENR_EL0''), register_ops_of AMUSERENR_EL0_ref),
    ((''AMPIDR4''), register_ops_of AMPIDR4_ref),
    ((''AMPIDR3''), register_ops_of AMPIDR3_ref),
    ((''AMPIDR2''), register_ops_of AMPIDR2_ref),
    ((''AMPIDR1''), register_ops_of AMPIDR1_ref),
    ((''AMPIDR0''), register_ops_of AMPIDR0_ref),
    ((''AMDEVTYPE''), register_ops_of AMDEVTYPE_ref),
    ((''_AMCR''), register_ops_of AMCR_ref),
    ((''AMCR_EL0''), register_ops_of AMCR_EL0_ref),
    ((''_AMCNTENSET1''), register_ops_of AMCNTENSET1_ref),
    ((''AMCNTENSET1_EL0''), register_ops_of AMCNTENSET1_EL0_ref),
    ((''_AMCNTENSET0''), register_ops_of AMCNTENSET0_ref),
    ((''AMCNTENSET0_EL0''), register_ops_of AMCNTENSET0_EL0_ref),
    ((''_AMCNTENCLR1''), register_ops_of AMCNTENCLR1_ref),
    ((''AMCNTENCLR1_EL0''), register_ops_of AMCNTENCLR1_EL0_ref),
    ((''_AMCNTENCLR0''), register_ops_of AMCNTENCLR0_ref),
    ((''AMCNTENCLR0_EL0''), register_ops_of AMCNTENCLR0_EL0_ref),
    ((''AMCIDR3''), register_ops_of AMCIDR3_ref),
    ((''AMCIDR2''), register_ops_of AMCIDR2_ref),
    ((''AMCIDR1''), register_ops_of AMCIDR1_ref),
    ((''AMCIDR0''), register_ops_of AMCIDR0_ref),
    ((''_AMCGCR''), register_ops_of AMCGCR_ref),
    ((''AMCGCR_EL0''), register_ops_of AMCGCR_EL0_ref),
    ((''_AMCFGR''), register_ops_of AMCFGR_ref),
    ((''AMCFGR_EL0''), register_ops_of AMCFGR_EL0_ref),
    ((''RVBAR_EL3''), register_ops_of RVBAR_EL3_ref),
    ((''RVBAR_EL2''), register_ops_of RVBAR_EL2_ref),
    ((''RVBAR_EL1''), register_ops_of RVBAR_EL1_ref),
    ((''_VDISR''), register_ops_of VDISR_ref),
    ((''VDISR_EL2''), register_ops_of VDISR_EL2_ref),
    ((''_VDFSR''), register_ops_of VDFSR_ref),
    ((''VSESR_EL2''), register_ops_of VSESR_EL2_ref),
    ((''_DISR''), register_ops_of DISR_ref),
    ((''DISR_EL1''), register_ops_of DISR_EL1_ref),
    ((''HFGITR_EL2''), register_ops_of HFGITR_EL2_ref),
    ((''VNCR_EL2''), register_ops_of VNCR_EL2_ref),
    ((''RCWSMASK_EL1''), register_ops_of RCWSMASK_EL1_ref),
    ((''RCWMASK_EL1''), register_ops_of RCWMASK_EL1_ref),
    ((''SPESampleCounterValid''), register_ops_of SPESampleCounterValid_ref),
    ((''SPESampleCounterPending''), register_ops_of SPESampleCounterPending_ref),
    ((''VMECID_A_EL2''), register_ops_of VMECID_A_EL2_ref),
    ((''S2POR_EL1''), register_ops_of S2POR_EL1_ref),
    ((''VSTTBR_EL2''), register_ops_of VSTTBR_EL2_ref),
    ((''VSTCR_EL2''), register_ops_of VSTCR_EL2_ref),
    ((''S2PIR_EL2''), register_ops_of S2PIR_EL2_ref),
    ((''MECID_RL_A_EL3''), register_ops_of MECID_RL_A_EL3_ref),
    ((''MECID_P1_EL2''), register_ops_of MECID_P1_EL2_ref),
    ((''MECID_A1_EL2''), register_ops_of MECID_A1_EL2_ref),
    ((''MECID_A0_EL2''), register_ops_of MECID_A0_EL2_ref),
    ((''VMECID_P_EL2''), register_ops_of VMECID_P_EL2_ref),
    ((''MECID_P0_EL2''), register_ops_of MECID_P0_EL2_ref),
    ((''POR_EL0''), register_ops_of POR_EL0_ref),
    ((''POR_EL3''), register_ops_of POR_EL3_ref),
    ((''POR_EL2''), register_ops_of POR_EL2_ref),
    ((''POR_EL1''), register_ops_of POR_EL1_ref),
    ((''EDWAR''), register_ops_of EDWAR_ref),
    ((''DBGWVR_EL1''), register_ops_of DBGWVR_EL1_ref),
    ((''DBGWCR_EL1''), register_ops_of DBGWCR_EL1_ref),
    ((''_VTTBR_EL2''), register_ops_of VTTBR_EL2_ref),
    ((''VTTBR''), register_ops_of VTTBR_ref),
    ((''VTCR_EL2''), register_ops_of VTCR_EL2_ref),
    ((''_EDSCR2''), register_ops_of EDSCR2_ref),
    ((''DBGBVR_EL1''), register_ops_of DBGBVR_EL1_ref),
    ((''DBGBCR_EL1''), register_ops_of DBGBCR_EL1_ref),
    ((''CONTEXTIDR_EL2''), register_ops_of CONTEXTIDR_EL2_ref),
    ((''TFSR_EL3''), register_ops_of TFSR_EL3_ref),
    ((''TFSR_EL2''), register_ops_of TFSR_EL2_ref),
    ((''TFSR_EL1''), register_ops_of TFSR_EL1_ref),
    ((''TFSRE0_EL1''), register_ops_of TFSRE0_EL1_ref),
    ((''RGSR_EL1''), register_ops_of RGSR_EL1_ref),
    ((''GCR_EL1''), register_ops_of GCR_EL1_ref),
    ((''_CNTKCTL''), register_ops_of CNTKCTL_ref),
    ((''APGAKeyLo_EL1''), register_ops_of APGAKeyLo_EL1_ref),
    ((''APGAKeyHi_EL1''), register_ops_of APGAKeyHi_EL1_ref),
    ((''APDBKeyLo_EL1''), register_ops_of APDBKeyLo_EL1_ref),
    ((''APDBKeyHi_EL1''), register_ops_of APDBKeyHi_EL1_ref),
    ((''APDAKeyLo_EL1''), register_ops_of APDAKeyLo_EL1_ref),
    ((''APDAKeyHi_EL1''), register_ops_of APDAKeyHi_EL1_ref),
    ((''APIBKeyLo_EL1''), register_ops_of APIBKeyLo_EL1_ref),
    ((''APIBKeyHi_EL1''), register_ops_of APIBKeyHi_EL1_ref),
    ((''APIAKeyLo_EL1''), register_ops_of APIAKeyLo_EL1_ref),
    ((''APIAKeyHi_EL1''), register_ops_of APIAKeyHi_EL1_ref),
    ((''TTBR0_EL3''), register_ops_of TTBR0_EL3_ref),
    ((''SCTLR2_EL3''), register_ops_of SCTLR2_EL3_ref),
    ((''PIR_EL3''), register_ops_of PIR_EL3_ref),
    ((''MAIR_EL3''), register_ops_of MAIR_EL3_ref),
    ((''MAIR2_EL3''), register_ops_of MAIR2_EL3_ref),
    ((''PIRE0_EL2''), register_ops_of PIRE0_EL2_ref),
    ((''TCR2_EL2''), register_ops_of TCR2_EL2_ref),
    ((''PIR_EL2''), register_ops_of PIR_EL2_ref),
    ((''MAIR_EL2''), register_ops_of MAIR_EL2_ref),
    ((''MAIR2_EL2''), register_ops_of MAIR2_EL2_ref),
    ((''TCR2_EL1''), register_ops_of TCR2_EL1_ref),
    ((''PIR_EL1''), register_ops_of PIR_EL1_ref),
    ((''PIRE0_EL1''), register_ops_of PIRE0_EL1_ref),
    ((''MAIR_EL1''), register_ops_of MAIR_EL1_ref),
    ((''MAIR2_EL1''), register_ops_of MAIR2_EL1_ref),
    ((''GICC_CTLR''), register_ops_of GICC_CTLR_ref),
    ((''__tlb_enabled''), register_ops_of tlb_enabled_ref),
    ((''GPTBR_EL3''), register_ops_of GPTBR_EL3_ref),
    ((''GPCCR_EL3''), register_ops_of GPCCR_EL3_ref),
    ((''CNTKCTL_EL1''), register_ops_of CNTKCTL_EL1_ref),
    ((''CNTSCR''), register_ops_of CNTSCR_ref),
    ((''CNTCR''), register_ops_of CNTCR_ref),
    ((''CNTPS_CVAL_EL1''), register_ops_of CNTPS_CVAL_EL1_ref),
    ((''CNTPS_CTL_EL1''), register_ops_of CNTPS_CTL_EL1_ref),
    ((''CNTHV_CVAL_EL2''), register_ops_of CNTHV_CVAL_EL2_ref),
    ((''CNTHV_CTL_EL2''), register_ops_of CNTHV_CTL_EL2_ref),
    ((''CNTHVS_CVAL_EL2''), register_ops_of CNTHVS_CVAL_EL2_ref),
    ((''CNTHVS_CTL_EL2''), register_ops_of CNTHVS_CTL_EL2_ref),
    ((''CNTHPS_CVAL_EL2''), register_ops_of CNTHPS_CVAL_EL2_ref),
    ((''CNTHPS_CTL_EL2''), register_ops_of CNTHPS_CTL_EL2_ref),
    ((''CNTV_CVAL_EL0''), register_ops_of CNTV_CVAL_EL0_ref),
    ((''CNTV_CTL_EL0''), register_ops_of CNTV_CTL_EL0_ref),
    ((''CNTP_CVAL_S''), register_ops_of CNTP_CVAL_S_ref),
    ((''_CNTP_CVAL_NS''), register_ops_of CNTP_CVAL_NS_ref),
    ((''CNTP_CVAL_EL0''), register_ops_of CNTP_CVAL_EL0_ref),
    ((''CNTP_CTL_S''), register_ops_of CNTP_CTL_S_ref),
    ((''_CNTP_CTL_NS''), register_ops_of CNTP_CTL_NS_ref),
    ((''CNTP_CTL_EL0''), register_ops_of CNTP_CTL_EL0_ref),
    ((''_CNTHP_CVAL''), register_ops_of CNTHP_CVAL_ref),
    ((''CNTHP_CVAL_EL2''), register_ops_of CNTHP_CVAL_EL2_ref),
    ((''_CNTHP_CTL''), register_ops_of CNTHP_CTL_ref),
    ((''CNTHP_CTL_EL2''), register_ops_of CNTHP_CTL_EL2_ref),
    ((''_FPEXC''), register_ops_of FPEXC_ref),
    ((''FPEXC32_EL2''), register_ops_of FPEXC32_EL2_ref),
    ((''SCTLR2_EL2''), register_ops_of SCTLR2_EL2_ref),
    ((''SCTLR2_EL1''), register_ops_of SCTLR2_EL1_ref),
    ((''_IFAR_S''), register_ops_of IFAR_S_ref),
    ((''_IFAR_NS''), register_ops_of IFAR_NS_ref),
    ((''_HCR2''), register_ops_of HCR2_ref),
    ((''_DBGDSCRext''), register_ops_of DBGDSCRext_ref),
    ((''_DBGDSCRint''), register_ops_of DBGDSCRint_ref),
    ((''IFSR_S''), register_ops_of IFSR_S_ref),
    ((''_IFSR_NS''), register_ops_of IFSR_NS_ref),
    ((''IFSR32_EL2''), register_ops_of IFSR32_EL2_ref),
    ((''DFSR_S''), register_ops_of DFSR_S_ref),
    ((''_DFSR_NS''), register_ops_of DFSR_NS_ref),
    ((''_DFAR_S''), register_ops_of DFAR_S_ref),
    ((''_DFAR_NS''), register_ops_of DFAR_NS_ref),
    ((''MVBAR''), register_ops_of MVBAR_ref),
    ((''_HVBAR''), register_ops_of HVBAR_ref),
    ((''_ELR_hyp''), register_ops_of ELR_hyp_ref),
    ((''_HSR''), register_ops_of HSR_ref),
    ((''_HPFAR''), register_ops_of HPFAR_ref),
    ((''_HIFAR''), register_ops_of HIFAR_ref),
    ((''_HDFAR''), register_ops_of HDFAR_ref),
    ((''TTBR1_EL2''), register_ops_of TTBR1_EL2_ref),
    ((''_TTBR1_EL1''), register_ops_of TTBR1_EL1_ref),
    ((''TTBR1_S''), register_ops_of TTBR1_S_ref),
    ((''TTBR1_NS''), register_ops_of TTBR1_NS_ref),
    ((''_TTBR0_EL2''), register_ops_of TTBR0_EL2_ref),
    ((''HTTBR''), register_ops_of HTTBR_ref),
    ((''_TTBR0_EL1''), register_ops_of TTBR0_EL1_ref),
    ((''TTBR0_S''), register_ops_of TTBR0_S_ref),
    ((''TTBR0_NS''), register_ops_of TTBR0_NS_ref),
    ((''CONTEXTIDR_S''), register_ops_of CONTEXTIDR_S_ref),
    ((''_CONTEXTIDR_NS''), register_ops_of CONTEXTIDR_NS_ref),
    ((''TTBCR_S''), register_ops_of TTBCR_S_ref),
    ((''_TTBCR_NS''), register_ops_of TTBCR_NS_ref),
    ((''CONTEXTIDR_EL1''), register_ops_of CONTEXTIDR_EL1_ref),
    ((''CLIDR_EL1''), register_ops_of CLIDR_EL1_ref),
    ((''MPAMSM_EL1''), register_ops_of MPAMSM_EL1_ref),
    ((''MPAM0_EL1''), register_ops_of MPAM0_EL1_ref),
    ((''MPAMVPM7_EL2''), register_ops_of MPAMVPM7_EL2_ref),
    ((''MPAMVPM6_EL2''), register_ops_of MPAMVPM6_EL2_ref),
    ((''MPAMVPM5_EL2''), register_ops_of MPAMVPM5_EL2_ref),
    ((''MPAMVPM4_EL2''), register_ops_of MPAMVPM4_EL2_ref),
    ((''MPAMVPM3_EL2''), register_ops_of MPAMVPM3_EL2_ref),
    ((''MPAMVPM2_EL2''), register_ops_of MPAMVPM2_EL2_ref),
    ((''MPAMVPM1_EL2''), register_ops_of MPAMVPM1_EL2_ref),
    ((''MPAMVPMV_EL2''), register_ops_of MPAMVPMV_EL2_ref),
    ((''MPAMVPM0_EL2''), register_ops_of MPAMVPM0_EL2_ref),
    ((''MPAMHCR_EL2''), register_ops_of MPAMHCR_EL2_ref),
    ((''MPAMIDR_EL1''), register_ops_of MPAMIDR_EL1_ref),
    ((''_MPAM1_EL1''), register_ops_of MPAM1_EL1_ref),
    ((''_MPAM3_EL3''), register_ops_of MPAM3_EL3_ref),
    ((''MPAM2_EL2''), register_ops_of MPAM2_EL2_ref),
    ((''HCRX_EL2''), register_ops_of HCRX_EL2_ref),
    ((''GCSCRE0_EL1''), register_ops_of GCSCRE0_EL1_ref),
    ((''VBAR_S''), register_ops_of VBAR_S_ref),
    ((''_VBAR_NS''), register_ops_of VBAR_NS_ref),
    ((''VBAR_EL3''), register_ops_of VBAR_EL3_ref),
    ((''VBAR_EL2''), register_ops_of VBAR_EL2_ref),
    ((''VBAR_EL1''), register_ops_of VBAR_EL1_ref),
    ((''EDESR''), register_ops_of EDESR_ref),
    ((''_EDECCR''), register_ops_of EDECCR_ref),
    ((''OSECCR_EL1''), register_ops_of OSECCR_EL1_ref),
    ((''SPSR_und''), register_ops_of SPSR_und_ref),
    ((''_SPSR_svc''), register_ops_of SPSR_svc_ref),
    ((''SPSR_mon''), register_ops_of SPSR_mon_ref),
    ((''SPSR_irq''), register_ops_of SPSR_irq_ref),
    ((''_SPSR_hyp''), register_ops_of SPSR_hyp_ref),
    ((''SPSR_fiq''), register_ops_of SPSR_fiq_ref),
    ((''SPSR_abt''), register_ops_of SPSR_abt_ref),
    ((''SPSR_EL3''), register_ops_of SPSR_EL3_ref),
    ((''SPSR_EL2''), register_ops_of SPSR_EL2_ref),
    ((''SPSR_EL1''), register_ops_of SPSR_EL1_ref),
    ((''ELR_EL3''), register_ops_of ELR_EL3_ref),
    ((''ELR_EL2''), register_ops_of ELR_EL2_ref),
    ((''ELR_EL1''), register_ops_of ELR_EL1_ref),
    ((''PFAR_EL2''), register_ops_of PFAR_EL2_ref),
    ((''PFAR_EL1''), register_ops_of PFAR_EL1_ref),
    ((''MFAR_EL3''), register_ops_of MFAR_EL3_ref),
    ((''HPFAR_EL2''), register_ops_of HPFAR_EL2_ref),
    ((''FAR_EL3''), register_ops_of FAR_EL3_ref),
    ((''FAR_EL2''), register_ops_of FAR_EL2_ref),
    ((''FAR_EL1''), register_ops_of FAR_EL1_ref),
    ((''ESR_EL3''), register_ops_of ESR_EL3_ref),
    ((''ESR_EL2''), register_ops_of ESR_EL2_ref),
    ((''ESR_EL1''), register_ops_of ESR_EL1_ref),
    ((''SCTLR_S''), register_ops_of SCTLR_S_ref),
    ((''_SCTLR_NS''), register_ops_of SCTLR_NS_ref),
    ((''SCTLR_EL3''), register_ops_of SCTLR_EL3_ref),
    ((''SCTLR_EL1''), register_ops_of SCTLR_EL1_ref),
    ((''_HSCTLR''), register_ops_of HSCTLR_ref),
    ((''SCTLR_EL2''), register_ops_of SCTLR_EL2_ref),
    ((''_HCR''), register_ops_of HCR_ref),
    ((''_DBGOSLSR''), register_ops_of DBGOSLSR_ref),
    ((''OSLSR_EL1''), register_ops_of OSLSR_EL1_ref),
    ((''MDSCR_EL1''), register_ops_of MDSCR_EL1_ref),
    ((''GCSCR_EL3''), register_ops_of GCSCR_EL3_ref),
    ((''GCSCR_EL2''), register_ops_of GCSCR_EL2_ref),
    ((''GCSCR_EL1''), register_ops_of GCSCR_EL1_ref),
    ((''__GIC_Pending''), register_ops_of GIC_Pending_ref),
    ((''__GIC_Active''), register_ops_of GIC_Active_ref),
    ((''_DBGPRCR''), register_ops_of DBGPRCR_ref),
    ((''DBGPRCR_EL1''), register_ops_of DBGPRCR_EL1_ref),
    ((''_DBGOSDLR''), register_ops_of DBGOSDLR_ref),
    ((''OSDLR_EL1''), register_ops_of OSDLR_EL1_ref),
    ((''SP_EL3''), register_ops_of SP_EL3_ref),
    ((''SP_EL2''), register_ops_of SP_EL2_ref),
    ((''SP_EL1''), register_ops_of SP_EL1_ref),
    ((''SP_EL0''), register_ops_of SP_EL0_ref),
    ((''NSACR''), register_ops_of NSACR_ref),
    ((''_HCPTR''), register_ops_of HCPTR_ref),
    ((''_CPACR''), register_ops_of CPACR_ref),
    ((''CPTR_EL3''), register_ops_of CPTR_EL3_ref),
    ((''CPTR_EL2''), register_ops_of CPTR_EL2_ref),
    ((''CPACR_EL1''), register_ops_of CPACR_EL1_ref),
    ((''GCSPR_EL3''), register_ops_of GCSPR_EL3_ref),
    ((''GCSPR_EL2''), register_ops_of GCSPR_EL2_ref),
    ((''GCSPR_EL1''), register_ops_of GCSPR_EL1_ref),
    ((''GCSPR_EL0''), register_ops_of GCSPR_EL0_ref),
    ((''SMCR_EL3''), register_ops_of SMCR_EL3_ref),
    ((''SMCR_EL2''), register_ops_of SMCR_EL2_ref),
    ((''SMCR_EL1''), register_ops_of SMCR_EL1_ref),
    ((''ZCR_EL3''), register_ops_of ZCR_EL3_ref),
    ((''ZCR_EL2''), register_ops_of ZCR_EL2_ref),
    ((''ZCR_EL1''), register_ops_of ZCR_EL1_ref),
    ((''PMBSR_EL1''), register_ops_of PMBSR_EL1_ref),
    ((''PMBLIMITR_EL1''), register_ops_of PMBLIMITR_EL1_ref),
    ((''PMSCR_EL2''), register_ops_of PMSCR_EL2_ref),
    ((''PMSCR_EL1''), register_ops_of PMSCR_EL1_ref),
    ((''SPESampleAddressValid''), register_ops_of SPESampleAddressValid_ref),
    ((''SPESampleAddress''), register_ops_of SPESampleAddress_ref),
    ((''PMSIDR_EL1''), register_ops_of PMSIDR_EL1_ref),
    ((''Records_TGT''), register_ops_of Records_TGT_ref),
    ((''Records_SRC''), register_ops_of Records_SRC_ref),
    ((''Records_INF''), register_ops_of Records_INF_ref),
    ((''BRBIDR0_EL1''), register_ops_of BRBIDR0_EL1_ref),
    ((''TCR_EL3''), register_ops_of TCR_EL3_ref),
    ((''TCR_EL2''), register_ops_of TCR_EL2_ref),
    ((''TCR_EL1''), register_ops_of TCR_EL1_ref),
    ((''_DSPSR2''), register_ops_of DSPSR2_ref),
    ((''_DSPSR''), register_ops_of DSPSR_ref),
    ((''DSPSR_EL0''), register_ops_of DSPSR_EL0_ref),
    ((''_DLR''), register_ops_of DLR_ref),
    ((''DLR_EL0''), register_ops_of DLR_EL0_ref),
    ((''EDECR''), register_ops_of EDECR_ref),
    ((''__mpam_vpmr_max''), register_ops_of mpam_vpmr_max_ref),
    ((''__mpam_pmg_max''), register_ops_of mpam_pmg_max_ref),
    ((''__mpam_partid_max''), register_ops_of mpam_partid_max_ref),
    ((''__mpam_has_hcr''), register_ops_of mpam_has_hcr_ref),
    ((''__impdef_TG1''), register_ops_of impdef_TG1_ref),
    ((''__impdef_TG0''), register_ops_of impdef_TG0_ref),
    ((''CFG_RVBAR''), register_ops_of CFG_RVBAR_ref),
    ((''CNTHCTL_EL2''), register_ops_of CNTHCTL_EL2_ref),
    ((''CNTVOFF_EL2''), register_ops_of CNTVOFF_EL2_ref),
    ((''CNTPOFF_EL2''), register_ops_of CNTPOFF_EL2_ref),
    ((''BRBTS_EL1''), register_ops_of BRBTS_EL1_ref),
    ((''BRBFCR_EL1''), register_ops_of BRBFCR_EL1_ref),
    ((''BRBCR_EL2''), register_ops_of BRBCR_EL2_ref),
    ((''BRBCR_EL1''), register_ops_of BRBCR_EL1_ref),
    ((''PMOVSSET_EL0''), register_ops_of PMOVSSET_EL0_ref),
    ((''PMICNTR_EL0''), register_ops_of PMICNTR_EL0_ref),
    ((''_SDER''), register_ops_of SDER_ref),
    ((''_SDER32_EL3''), register_ops_of SDER32_EL3_ref),
    ((''SDER32_EL2''), register_ops_of SDER32_EL2_ref),
    ((''SDCR''), register_ops_of SDCR_ref),
    ((''PMICFILTR_EL0''), register_ops_of PMICFILTR_EL0_ref),
    ((''_PMEVTYPER''), register_ops_of PMEVTYPER_ref),
    ((''PMEVTYPER_EL0''), register_ops_of PMEVTYPER_EL0_ref),
    ((''_PMCNTENSET''), register_ops_of PMCNTENSET_ref),
    ((''PMCNTENSET_EL0''), register_ops_of PMCNTENSET_EL0_ref),
    ((''_PMCCFILTR''), register_ops_of PMCCFILTR_ref),
    ((''PMCCFILTR_EL0''), register_ops_of PMCCFILTR_EL0_ref),
    ((''MDCR_EL3''), register_ops_of MDCR_EL3_ref),
    ((''_PMOVSR''), register_ops_of PMOVSR_ref),
    ((''PMOVSCLR_EL0''), register_ops_of PMOVSCLR_EL0_ref),
    ((''_PMINTENCLR''), register_ops_of PMINTENCLR_ref),
    ((''PMINTENCLR_EL1''), register_ops_of PMINTENCLR_EL1_ref),
    ((''_PMCR''), register_ops_of PMCR_ref),
    ((''PMCR_EL0''), register_ops_of PMCR_EL0_ref),
    ((''_PMCNTENCLR''), register_ops_of PMCNTENCLR_ref),
    ((''PMCNTENCLR_EL0''), register_ops_of PMCNTENCLR_EL0_ref),
    ((''_EDSCR''), register_ops_of EDSCR_ref),
    ((''MDCCSR_EL0''), register_ops_of MDCCSR_EL0_ref),
    ((''_HDCR''), register_ops_of HDCR_ref),
    ((''MDCR_EL2''), register_ops_of MDCR_EL2_ref),
    ((''__supported_pa_size''), register_ops_of supported_pa_size_ref),
    ((''__max_implemented_sveveclen''), register_ops_of max_implemented_sveveclen_ref),
    ((''__max_implemented_smeveclen''), register_ops_of max_implemented_smeveclen_ref),
    ((''__has_sve_extended_bf16''), register_ops_of has_sve_extended_bf16_ref),
    ((''__block_bbm_implemented''), register_ops_of block_bbm_implemented_ref),
    ((''CTR_EL0''), register_ops_of CTR_EL0_ref),
    ((''ERRnFR''), register_ops_of ERRnFR_ref),
    ((''RVBAR''), register_ops_of RVBAR_ref),
    ((''_FPSCR''), register_ops_of FPSCR_ref),
    ((''__sme_only''), register_ops_of sme_only_ref),
    ((''__setg_mops_option_a_supported''), register_ops_of setg_mops_option_a_supported_ref),
    ((''__set_mops_option_a_supported''), register_ops_of set_mops_option_a_supported_ref),
    ((''__mte_implemented''), register_ops_of mte_implemented_ref),
    ((''__mpam_major''), register_ops_of mpam_major_ref),
    ((''__mpam_frac''), register_ops_of mpam_frac_ref),
    ((''__isb_is_branch''), register_ops_of isb_is_branch_ref),
    ((''__has_sme_priority_control''), register_ops_of has_sme_priority_control_ref),
    ((''__feat_rpres''), register_ops_of feat_rpres_ref),
    ((''__empam_tidr_implemented''), register_ops_of empam_tidr_implemented_ref),
    ((''__empam_sdeflt_implemented''), register_ops_of empam_sdeflt_implemented_ref),
    ((''__empam_force_ns_implemented''), register_ops_of empam_force_ns_implemented_ref),
    ((''__empam_force_ns_RAO''), register_ops_of empam_force_ns_RAO_ref),
    ((''__cpyf_mops_option_a_supported''), register_ops_of cpyf_mops_option_a_supported_ref),
    ((''__cpy_mops_option_a_supported''), register_ops_of cpy_mops_option_a_supported_ref),
    ((''__apply_effective_shareability''), register_ops_of apply_effective_shareability_ref),
    ((''SCR''), register_ops_of SCR_ref),
    ((''SCR_EL3''), register_ops_of SCR_EL3_ref),
    ((''HCR_EL2''), register_ops_of HCR_EL2_ref),
    ((''_Dclone''), register_ops_of Dclone_ref),
    ((''LR_mon''), register_ops_of LR_mon_ref),
    ((''SP_mon''), register_ops_of SP_mon_ref),
    ((''sp_rel_access_pc''), register_ops_of sp_rel_access_pc_ref),
    ((''__DCACHE_CCSIDR_RESET''), register_ops_of DCACHE_CCSIDR_RESET_ref),
    ((''__ICACHE_CCSIDR_RESET''), register_ops_of ICACHE_CCSIDR_RESET_ref),
    ((''__highest_el_aarch32''), register_ops_of highest_el_aarch32_ref),
    ((''__ExclusiveMonitorSet''), register_ops_of ExclusiveMonitorSet_ref),
    ((''__BranchTaken''), register_ops_of BranchTaken_ref),
    ((''Branchtypetaken''), register_ops_of Branchtypetaken_ref),
    ((''__currentCond''), register_ops_of currentCond_ref),
    ((''__ThisInstrEnc''), register_ops_of ThisInstrEnc_ref),
    ((''__ThisInstr''), register_ops_of ThisInstr_ref),
    ((''__ETEBase''), register_ops_of ETEBase_ref),
    ((''__VLPI_base''), register_ops_of VLPI_base_ref),
    ((''__SGI_base''), register_ops_of SGI_base_ref),
    ((''__RD_base''), register_ops_of RD_base_ref),
    ((''__CNTCTLBase''), register_ops_of CNTCTLBase_ref),
    ((''__CNTEL0BaseN''), register_ops_of CNTEL0BaseN_ref),
    ((''__CNTBaseN''), register_ops_of CNTBaseN_ref),
    ((''__CNTReadBase''), register_ops_of CNTReadBase_ref),
    ((''__InstructionStep''), register_ops_of InstructionStep_ref),
    ((''RTPIDEN''), register_ops_of RTPIDEN_ref),
    ((''RLPIDEN''), register_ops_of RLPIDEN_ref),
    ((''SPNIDEN''), register_ops_of SPNIDEN_ref),
    ((''SPIDEN''), register_ops_of SPIDEN_ref),
    ((''NIDEN''), register_ops_of NIDEN_ref),
    ((''DBGEN''), register_ops_of DBGEN_ref),
    ((''__last_branch_valid''), register_ops_of last_branch_valid_ref),
    ((''__last_cycle_count''), register_ops_of last_cycle_count_ref),
    ((''SPERecordSize''), register_ops_of SPERecordSize_ref),
    ((''__SPE_LFSR_initialized''), register_ops_of SPE_LFSR_initialized_ref),
    ((''__SPE_LFSR''), register_ops_of SPE_LFSR_ref),
    ((''SPESampleEvents''), register_ops_of SPESampleEvents_ref),
    ((''SPESampleTimestampValid''), register_ops_of SPESampleTimestampValid_ref),
    ((''SPESampleTimestamp''), register_ops_of SPESampleTimestamp_ref),
    ((''SPESampleSubclassValid''), register_ops_of SPESampleSubclassValid_ref),
    ((''SPESampleSubclass''), register_ops_of SPESampleSubclass_ref),
    ((''SPESampleClass''), register_ops_of SPESampleClass_ref),
    ((''SPESampleOpType''), register_ops_of SPESampleOpType_ref),
    ((''SPESampleDataSourceValid''), register_ops_of SPESampleDataSourceValid_ref),
    ((''SPESampleDataSource''), register_ops_of SPESampleDataSource_ref),
    ((''SPESamplePreviousBranchAddressValid''), register_ops_of SPESamplePreviousBranchAddressValid_ref),
    ((''SPESamplePreviousBranchAddress''), register_ops_of SPESamplePreviousBranchAddress_ref),
    ((''SPESampleInstIsNV2''), register_ops_of SPESampleInstIsNV2_ref),
    ((''SPESampleContextEL2Valid''), register_ops_of SPESampleContextEL2Valid_ref),
    ((''SPESampleContextEL2''), register_ops_of SPESampleContextEL2_ref),
    ((''SPESampleContextEL1Valid''), register_ops_of SPESampleContextEL1Valid_ref),
    ((''SPESampleContextEL1''), register_ops_of SPESampleContextEL1_ref),
    ((''SPESampleInFlight''), register_ops_of SPESampleInFlight_ref),
    ((''TSTATE''), register_ops_of TSTATE_ref),
    ((''ICC_PMR_EL1''), register_ops_of ICC_PMR_EL1_ref),
    ((''FPSR''), register_ops_of FPSR_ref),
    ((''FPCR''), register_ops_of FPCR_ref),
    ((''_ZT0''), register_ops_of ZT0_ref),
    ((''_ZA''), register_ops_of ZA_ref),
    ((''_FFR''), register_ops_of FFR_ref),
    ((''_P''), register_ops_of P_ref),
    ((''_Z''), register_ops_of Z_ref),
    ((''BTypeCompatible''), register_ops_of BTypeCompatible_ref),
    ((''BTypeNext''), register_ops_of BTypeNext_ref),
    ((''InGuardedPage''), register_ops_of InGuardedPage_ref),
    ((''RC''), register_ops_of RC_ref),
    ((''PhysicalCount''), register_ops_of PhysicalCount_ref),
    ((''_PC''), register_ops_of PC_ref),
    ((''R30''), register_ops_of R30_ref),
    ((''R29''), register_ops_of R29_ref),
    ((''R28''), register_ops_of R28_ref),
    ((''R27''), register_ops_of R27_ref),
    ((''R26''), register_ops_of R26_ref),
    ((''R25''), register_ops_of R25_ref),
    ((''R24''), register_ops_of R24_ref),
    ((''R23''), register_ops_of R23_ref),
    ((''R22''), register_ops_of R22_ref),
    ((''R21''), register_ops_of R21_ref),
    ((''R20''), register_ops_of R20_ref),
    ((''R19''), register_ops_of R19_ref),
    ((''R18''), register_ops_of R18_ref),
    ((''R17''), register_ops_of R17_ref),
    ((''R16''), register_ops_of R16_ref),
    ((''R15''), register_ops_of R15_ref),
    ((''R14''), register_ops_of R14_ref),
    ((''R13''), register_ops_of R13_ref),
    ((''R12''), register_ops_of R12_ref),
    ((''R11''), register_ops_of R11_ref),
    ((''R10''), register_ops_of R10_ref),
    ((''R9''), register_ops_of R9_ref),
    ((''R8''), register_ops_of R8_ref),
    ((''R7''), register_ops_of R7_ref),
    ((''R6''), register_ops_of R6_ref),
    ((''R5''), register_ops_of R5_ref),
    ((''R4''), register_ops_of R4_ref),
    ((''R3''), register_ops_of R3_ref),
    ((''R2''), register_ops_of R2_ref),
    ((''R1''), register_ops_of R1_ref),
    ((''R0''), register_ops_of R0_ref),
    ((''EventRegister''), register_ops_of EventRegister_ref),
    ((''ShouldAdvanceSS''), register_ops_of ShouldAdvanceSS_ref),
    ((''ShouldAdvanceIT''), register_ops_of ShouldAdvanceIT_ref),
    ((''PSTATE''), register_ops_of PSTATE_ref),
    ((''__clock_divider''), register_ops_of clock_divider_ref),
    ((''PMULastThresholdValue''), register_ops_of PMULastThresholdValue_ref),
    ((''PMUEventAccumulator''), register_ops_of PMUEventAccumulator_ref),
    ((''_DormantCtlReg''), register_ops_of DormantCtlReg_ref),
    ((''_ConfigReg''), register_ops_of ConfigReg_ref),
    ((''IsWFEsleep''), register_ops_of IsWFEsleep_ref),
    ((''IsWFIsleep''), register_ops_of IsWFIsleep_ref),
    ((''CP15SDISABLE2''), register_ops_of CP15SDISABLE2_ref),
    ((''CP15SDISABLE''), register_ops_of CP15SDISABLE_ref),
    ((''__cycle_count''), register_ops_of cycle_count_ref),
    ((''__trcclaim_tags''), register_ops_of trcclaim_tags_ref),
    ((''NUM_WATCHPOINTS''), register_ops_of NUM_WATCHPOINTS_ref),
    ((''NUM_BREAKPOINTS''), register_ops_of NUM_BREAKPOINTS_ref),
    ((''NUM_GIC_LIST_REGS''), register_ops_of NUM_GIC_LIST_REGS_ref),
    ((''NUM_GIC_PRIORITY_BITS''), register_ops_of NUM_GIC_PRIORITY_BITS_ref),
    ((''NUM_GIC_PREEMPTION_BITS''), register_ops_of NUM_GIC_PREEMPTION_BITS_ref),
    ((''NUM_BRBE_RECORDS''), register_ops_of NUM_BRBE_RECORDS_ref),
    ((''NUM_PMU_COUNTERS''), register_ops_of NUM_PMU_COUNTERS_ref),
    ((''NUM_AMU_CG1_MONITORS''), register_ops_of NUM_AMU_CG1_MONITORS_ref),
    ((''NUM_AMU_CG0_MONITORS''), register_ops_of NUM_AMU_CG0_MONITORS_ref),
    ((''NUM_AMU_COUNTER_GROUPS''), register_ops_of NUM_AMU_COUNTER_GROUPS_ref),
    ((''VariantImplemented''), register_ops_of VariantImplemented_ref),
    ((''FeatureImpl''), register_ops_of FeatureImpl_ref),
    ((''v9Ap4_IMPLEMENTED''), register_ops_of v9Ap4_IMPLEMENTED_ref),
    ((''v9Ap3_IMPLEMENTED''), register_ops_of v9Ap3_IMPLEMENTED_ref),
    ((''v9Ap2_IMPLEMENTED''), register_ops_of v9Ap2_IMPLEMENTED_ref),
    ((''v9Ap1_IMPLEMENTED''), register_ops_of v9Ap1_IMPLEMENTED_ref),
    ((''v9Ap0_IMPLEMENTED''), register_ops_of v9Ap0_IMPLEMENTED_ref),
    ((''v8Ap9_IMPLEMENTED''), register_ops_of v8Ap9_IMPLEMENTED_ref),
    ((''v8Ap8_IMPLEMENTED''), register_ops_of v8Ap8_IMPLEMENTED_ref),
    ((''v8Ap7_IMPLEMENTED''), register_ops_of v8Ap7_IMPLEMENTED_ref),
    ((''v8Ap6_IMPLEMENTED''), register_ops_of v8Ap6_IMPLEMENTED_ref),
    ((''v8Ap5_IMPLEMENTED''), register_ops_of v8Ap5_IMPLEMENTED_ref),
    ((''v8Ap4_IMPLEMENTED''), register_ops_of v8Ap4_IMPLEMENTED_ref),
    ((''v8Ap3_IMPLEMENTED''), register_ops_of v8Ap3_IMPLEMENTED_ref),
    ((''v8Ap2_IMPLEMENTED''), register_ops_of v8Ap2_IMPLEMENTED_ref),
    ((''v8Ap1_IMPLEMENTED''), register_ops_of v8Ap1_IMPLEMENTED_ref),
    ((''v8Ap0_IMPLEMENTED''), register_ops_of v8Ap0_IMPLEMENTED_ref),
    ((''FEAT_TRBE_MPAM_IMPLEMENTED''), register_ops_of FEAT_TRBE_MPAM_IMPLEMENTED_ref),
    ((''FEAT_TRBE_EXT_IMPLEMENTED''), register_ops_of FEAT_TRBE_EXT_IMPLEMENTED_ref),
    ((''FEAT_SYSREG128_IMPLEMENTED''), register_ops_of FEAT_SYSREG128_IMPLEMENTED_ref),
    ((''FEAT_SYSINSTR128_IMPLEMENTED''), register_ops_of FEAT_SYSINSTR128_IMPLEMENTED_ref),
    ((''FEAT_SVE_B16B16_IMPLEMENTED''), register_ops_of FEAT_SVE_B16B16_IMPLEMENTED_ref),
    ((''FEAT_SVE2p1_IMPLEMENTED''), register_ops_of FEAT_SVE2p1_IMPLEMENTED_ref),
    ((''FEAT_SME_F16F16_IMPLEMENTED''), register_ops_of FEAT_SME_F16F16_IMPLEMENTED_ref),
    ((''FEAT_SME2p1_IMPLEMENTED''), register_ops_of FEAT_SME2p1_IMPLEMENTED_ref),
    ((''FEAT_SEBEP_IMPLEMENTED''), register_ops_of FEAT_SEBEP_IMPLEMENTED_ref),
    ((''FEAT_LVA3_IMPLEMENTED''), register_ops_of FEAT_LVA3_IMPLEMENTED_ref),
    ((''FEAT_LSE128_IMPLEMENTED''), register_ops_of FEAT_LSE128_IMPLEMENTED_ref),
    ((''FEAT_ITE_IMPLEMENTED''), register_ops_of FEAT_ITE_IMPLEMENTED_ref),
    ((''FEAT_GCS_IMPLEMENTED''), register_ops_of FEAT_GCS_IMPLEMENTED_ref),
    ((''FEAT_ETEv1p3_IMPLEMENTED''), register_ops_of FEAT_ETEv1p3_IMPLEMENTED_ref),
    ((''FEAT_EBEP_IMPLEMENTED''), register_ops_of FEAT_EBEP_IMPLEMENTED_ref),
    ((''FEAT_D128_IMPLEMENTED''), register_ops_of FEAT_D128_IMPLEMENTED_ref),
    ((''FEAT_CHK_IMPLEMENTED''), register_ops_of FEAT_CHK_IMPLEMENTED_ref),
    ((''FEAT_ABLE_IMPLEMENTED''), register_ops_of FEAT_ABLE_IMPLEMENTED_ref),
    ((''FEAT_SME2_IMPLEMENTED''), register_ops_of FEAT_SME2_IMPLEMENTED_ref),
    ((''FEAT_MEC_IMPLEMENTED''), register_ops_of FEAT_MEC_IMPLEMENTED_ref),
    ((''FEAT_BRBEv1p1_IMPLEMENTED''), register_ops_of FEAT_BRBEv1p1_IMPLEMENTED_ref),
    ((''FEAT_SME_I16I64_IMPLEMENTED''), register_ops_of FEAT_SME_I16I64_IMPLEMENTED_ref),
    ((''FEAT_SME_FA64_IMPLEMENTED''), register_ops_of FEAT_SME_FA64_IMPLEMENTED_ref),
    ((''FEAT_SME_F64F64_IMPLEMENTED''), register_ops_of FEAT_SME_F64F64_IMPLEMENTED_ref),
    ((''FEAT_SME_IMPLEMENTED''), register_ops_of FEAT_SME_IMPLEMENTED_ref),
    ((''FEAT_RME_IMPLEMENTED''), register_ops_of FEAT_RME_IMPLEMENTED_ref),
    ((''FEAT_ETEv1p2_IMPLEMENTED''), register_ops_of FEAT_ETEv1p2_IMPLEMENTED_ref),
    ((''FEAT_BRBE_IMPLEMENTED''), register_ops_of FEAT_BRBE_IMPLEMENTED_ref),
    ((''FEAT_ETEv1p1_IMPLEMENTED''), register_ops_of FEAT_ETEv1p1_IMPLEMENTED_ref),
    ((''FEAT_TRBE_IMPLEMENTED''), register_ops_of FEAT_TRBE_IMPLEMENTED_ref),
    ((''FEAT_TME_IMPLEMENTED''), register_ops_of FEAT_TME_IMPLEMENTED_ref),
    ((''FEAT_SVE_SM4_IMPLEMENTED''), register_ops_of FEAT_SVE_SM4_IMPLEMENTED_ref),
    ((''FEAT_SVE_SHA3_IMPLEMENTED''), register_ops_of FEAT_SVE_SHA3_IMPLEMENTED_ref),
    ((''FEAT_SVE_PMULL128_IMPLEMENTED''), register_ops_of FEAT_SVE_PMULL128_IMPLEMENTED_ref),
    ((''FEAT_SVE_BitPerm_IMPLEMENTED''), register_ops_of FEAT_SVE_BitPerm_IMPLEMENTED_ref),
    ((''FEAT_SVE_AES_IMPLEMENTED''), register_ops_of FEAT_SVE_AES_IMPLEMENTED_ref),
    ((''FEAT_SVE2_IMPLEMENTED''), register_ops_of FEAT_SVE2_IMPLEMENTED_ref),
    ((''FEAT_ETE_IMPLEMENTED''), register_ops_of FEAT_ETE_IMPLEMENTED_ref),
    ((''FEAT_DoPD_IMPLEMENTED''), register_ops_of FEAT_DoPD_IMPLEMENTED_ref),
    ((''FEAT_THE_IMPLEMENTED''), register_ops_of FEAT_THE_IMPLEMENTED_ref),
    ((''FEAT_SPMU_IMPLEMENTED''), register_ops_of FEAT_SPMU_IMPLEMENTED_ref),
    ((''FEAT_SPEv1p4_IMPLEMENTED''), register_ops_of FEAT_SPEv1p4_IMPLEMENTED_ref),
    ((''FEAT_SPE_FDS_IMPLEMENTED''), register_ops_of FEAT_SPE_FDS_IMPLEMENTED_ref),
    ((''FEAT_SPE_CRR_IMPLEMENTED''), register_ops_of FEAT_SPE_CRR_IMPLEMENTED_ref),
    ((''FEAT_SPECRES2_IMPLEMENTED''), register_ops_of FEAT_SPECRES2_IMPLEMENTED_ref),
    ((''FEAT_S2POE_IMPLEMENTED''), register_ops_of FEAT_S2POE_IMPLEMENTED_ref),
    ((''FEAT_S2PIE_IMPLEMENTED''), register_ops_of FEAT_S2PIE_IMPLEMENTED_ref),
    ((''FEAT_S1POE_IMPLEMENTED''), register_ops_of FEAT_S1POE_IMPLEMENTED_ref),
    ((''FEAT_S1PIE_IMPLEMENTED''), register_ops_of FEAT_S1PIE_IMPLEMENTED_ref),
    ((''FEAT_RPRFM_IMPLEMENTED''), register_ops_of FEAT_RPRFM_IMPLEMENTED_ref),
    ((''FEAT_RASv2_IMPLEMENTED''), register_ops_of FEAT_RASv2_IMPLEMENTED_ref),
    ((''FEAT_RASSAv2_IMPLEMENTED''), register_ops_of FEAT_RASSAv2_IMPLEMENTED_ref),
    ((''FEAT_PRFMSLC_IMPLEMENTED''), register_ops_of FEAT_PRFMSLC_IMPLEMENTED_ref),
    ((''FEAT_PMUv3p9_IMPLEMENTED''), register_ops_of FEAT_PMUv3p9_IMPLEMENTED_ref),
    ((''FEAT_PMUv3_SS_IMPLEMENTED''), register_ops_of FEAT_PMUv3_SS_IMPLEMENTED_ref),
    ((''FEAT_PMUv3_ICNTR_IMPLEMENTED''), register_ops_of FEAT_PMUv3_ICNTR_IMPLEMENTED_ref),
    ((''FEAT_PMUv3_EDGE_IMPLEMENTED''), register_ops_of FEAT_PMUv3_EDGE_IMPLEMENTED_ref),
    ((''FEAT_PFAR_IMPLEMENTED''), register_ops_of FEAT_PFAR_IMPLEMENTED_ref),
    ((''FEAT_PCSRv8p9_IMPLEMENTED''), register_ops_of FEAT_PCSRv8p9_IMPLEMENTED_ref),
    ((''FEAT_MTE_TAGGED_FAR_IMPLEMENTED''), register_ops_of FEAT_MTE_TAGGED_FAR_IMPLEMENTED_ref),
    ((''FEAT_MTE_STORE_ONLY_IMPLEMENTED''), register_ops_of FEAT_MTE_STORE_ONLY_IMPLEMENTED_ref),
    ((''FEAT_MTE_PERM_IMPLEMENTED''), register_ops_of FEAT_MTE_PERM_IMPLEMENTED_ref),
    ((''FEAT_MTE_NO_ADDRESS_TAGS_IMPLEMENTED''), register_ops_of FEAT_MTE_NO_ADDRESS_TAGS_IMPLEMENTED_ref),
    ((''FEAT_MTE_CANONICAL_TAGS_IMPLEMENTED''), register_ops_of FEAT_MTE_CANONICAL_TAGS_IMPLEMENTED_ref),
    ((''FEAT_MTE_ASYNC_IMPLEMENTED''), register_ops_of FEAT_MTE_ASYNC_IMPLEMENTED_ref),
    ((''FEAT_MTE_ASYM_FAULT_IMPLEMENTED''), register_ops_of FEAT_MTE_ASYM_FAULT_IMPLEMENTED_ref),
    ((''FEAT_MTE4_IMPLEMENTED''), register_ops_of FEAT_MTE4_IMPLEMENTED_ref),
    ((''FEAT_LRCPC3_IMPLEMENTED''), register_ops_of FEAT_LRCPC3_IMPLEMENTED_ref),
    ((''FEAT_HAFT_IMPLEMENTED''), register_ops_of FEAT_HAFT_IMPLEMENTED_ref),
    ((''FEAT_FGT2_IMPLEMENTED''), register_ops_of FEAT_FGT2_IMPLEMENTED_ref),
    ((''FEAT_ECBHB_IMPLEMENTED''), register_ops_of FEAT_ECBHB_IMPLEMENTED_ref),
    ((''FEAT_DoubleFault2_IMPLEMENTED''), register_ops_of FEAT_DoubleFault2_IMPLEMENTED_ref),
    ((''FEAT_Debugv8p9_IMPLEMENTED''), register_ops_of FEAT_Debugv8p9_IMPLEMENTED_ref),
    ((''FEAT_CSSC_IMPLEMENTED''), register_ops_of FEAT_CSSC_IMPLEMENTED_ref),
    ((''FEAT_CLRBHB_IMPLEMENTED''), register_ops_of FEAT_CLRBHB_IMPLEMENTED_ref),
    ((''FEAT_ANERR_IMPLEMENTED''), register_ops_of FEAT_ANERR_IMPLEMENTED_ref),
    ((''FEAT_AIE_IMPLEMENTED''), register_ops_of FEAT_AIE_IMPLEMENTED_ref),
    ((''FEAT_ADERR_IMPLEMENTED''), register_ops_of FEAT_ADERR_IMPLEMENTED_ref),
    ((''FEAT_TIDCP1_IMPLEMENTED''), register_ops_of FEAT_TIDCP1_IMPLEMENTED_ref),
    ((''FEAT_TCR2_IMPLEMENTED''), register_ops_of FEAT_TCR2_IMPLEMENTED_ref),
    ((''FEAT_SPEv1p3_IMPLEMENTED''), register_ops_of FEAT_SPEv1p3_IMPLEMENTED_ref),
    ((''FEAT_SCTLR2_IMPLEMENTED''), register_ops_of FEAT_SCTLR2_IMPLEMENTED_ref),
    ((''FEAT_PMUv3p8_IMPLEMENTED''), register_ops_of FEAT_PMUv3p8_IMPLEMENTED_ref),
    ((''FEAT_PMUv3_TH_IMPLEMENTED''), register_ops_of FEAT_PMUv3_TH_IMPLEMENTED_ref),
    ((''FEAT_PMUv3_EXT64_IMPLEMENTED''), register_ops_of FEAT_PMUv3_EXT64_IMPLEMENTED_ref),
    ((''FEAT_NMI_IMPLEMENTED''), register_ops_of FEAT_NMI_IMPLEMENTED_ref),
    ((''FEAT_MOPS_IMPLEMENTED''), register_ops_of FEAT_MOPS_IMPLEMENTED_ref),
    ((''FEAT_HBC_IMPLEMENTED''), register_ops_of FEAT_HBC_IMPLEMENTED_ref),
    ((''FEAT_GICv3_NMI_IMPLEMENTED''), register_ops_of FEAT_GICv3_NMI_IMPLEMENTED_ref),
    ((''FEAT_Debugv8p8_IMPLEMENTED''), register_ops_of FEAT_Debugv8p8_IMPLEMENTED_ref),
    ((''FEAT_CMOW_IMPLEMENTED''), register_ops_of FEAT_CMOW_IMPLEMENTED_ref),
    ((''FEAT_XS_IMPLEMENTED''), register_ops_of FEAT_XS_IMPLEMENTED_ref),
    ((''FEAT_WFxT_IMPLEMENTED''), register_ops_of FEAT_WFxT_IMPLEMENTED_ref),
    ((''FEAT_SPEv1p2_IMPLEMENTED''), register_ops_of FEAT_SPEv1p2_IMPLEMENTED_ref),
    ((''FEAT_RPRES_IMPLEMENTED''), register_ops_of FEAT_RPRES_IMPLEMENTED_ref),
    ((''FEAT_PMUv3p7_IMPLEMENTED''), register_ops_of FEAT_PMUv3p7_IMPLEMENTED_ref),
    ((''FEAT_PAN3_IMPLEMENTED''), register_ops_of FEAT_PAN3_IMPLEMENTED_ref),
    ((''FEAT_MTE3_IMPLEMENTED''), register_ops_of FEAT_MTE3_IMPLEMENTED_ref),
    ((''FEAT_LS64_V_IMPLEMENTED''), register_ops_of FEAT_LS64_V_IMPLEMENTED_ref),
    ((''FEAT_LS64_ACCDATA_IMPLEMENTED''), register_ops_of FEAT_LS64_ACCDATA_IMPLEMENTED_ref),
    ((''FEAT_LS64_IMPLEMENTED''), register_ops_of FEAT_LS64_IMPLEMENTED_ref),
    ((''FEAT_LPA2_IMPLEMENTED''), register_ops_of FEAT_LPA2_IMPLEMENTED_ref),
    ((''FEAT_HCX_IMPLEMENTED''), register_ops_of FEAT_HCX_IMPLEMENTED_ref),
    ((''FEAT_EBF16_IMPLEMENTED''), register_ops_of FEAT_EBF16_IMPLEMENTED_ref),
    ((''FEAT_AFP_IMPLEMENTED''), register_ops_of FEAT_AFP_IMPLEMENTED_ref),
    ((''FEAT_TWED_IMPLEMENTED''), register_ops_of FEAT_TWED_IMPLEMENTED_ref),
    ((''FEAT_PAuth2_IMPLEMENTED''), register_ops_of FEAT_PAuth2_IMPLEMENTED_ref),
    ((''FEAT_MTPMU_IMPLEMENTED''), register_ops_of FEAT_MTPMU_IMPLEMENTED_ref),
    ((''FEAT_MPAMv1p1_IMPLEMENTED''), register_ops_of FEAT_MPAMv1p1_IMPLEMENTED_ref),
    ((''FEAT_MPAMv0p1_IMPLEMENTED''), register_ops_of FEAT_MPAMv0p1_IMPLEMENTED_ref),
    ((''FEAT_HPMN0_IMPLEMENTED''), register_ops_of FEAT_HPMN0_IMPLEMENTED_ref),
    ((''FEAT_FGT_IMPLEMENTED''), register_ops_of FEAT_FGT_IMPLEMENTED_ref),
    ((''FEAT_ECV_IMPLEMENTED''), register_ops_of FEAT_ECV_IMPLEMENTED_ref),
    ((''FEAT_DGH_IMPLEMENTED''), register_ops_of FEAT_DGH_IMPLEMENTED_ref),
    ((''FEAT_BF16_IMPLEMENTED''), register_ops_of FEAT_BF16_IMPLEMENTED_ref),
    ((''FEAT_AMUv1p1_IMPLEMENTED''), register_ops_of FEAT_AMUv1p1_IMPLEMENTED_ref),
    ((''FEAT_SSBS2_IMPLEMENTED''), register_ops_of FEAT_SSBS2_IMPLEMENTED_ref),
    ((''FEAT_SSBS_IMPLEMENTED''), register_ops_of FEAT_SSBS_IMPLEMENTED_ref),
    ((''FEAT_SPECRES_IMPLEMENTED''), register_ops_of FEAT_SPECRES_IMPLEMENTED_ref),
    ((''FEAT_SB_IMPLEMENTED''), register_ops_of FEAT_SB_IMPLEMENTED_ref),
    ((''FEAT_RNG_TRAP_IMPLEMENTED''), register_ops_of FEAT_RNG_TRAP_IMPLEMENTED_ref),
    ((''FEAT_RNG_IMPLEMENTED''), register_ops_of FEAT_RNG_IMPLEMENTED_ref),
    ((''FEAT_PMUv3p5_IMPLEMENTED''), register_ops_of FEAT_PMUv3p5_IMPLEMENTED_ref),
    ((''FEAT_MTE2_IMPLEMENTED''), register_ops_of FEAT_MTE2_IMPLEMENTED_ref),
    ((''FEAT_MTE_IMPLEMENTED''), register_ops_of FEAT_MTE_IMPLEMENTED_ref),
    ((''FEAT_GTG_IMPLEMENTED''), register_ops_of FEAT_GTG_IMPLEMENTED_ref),
    ((''FEAT_FlagM2_IMPLEMENTED''), register_ops_of FEAT_FlagM2_IMPLEMENTED_ref),
    ((''FEAT_FRINTTS_IMPLEMENTED''), register_ops_of FEAT_FRINTTS_IMPLEMENTED_ref),
    ((''FEAT_ExS_IMPLEMENTED''), register_ops_of FEAT_ExS_IMPLEMENTED_ref),
    ((''FEAT_EVT_IMPLEMENTED''), register_ops_of FEAT_EVT_IMPLEMENTED_ref),
    ((''FEAT_E0PD_IMPLEMENTED''), register_ops_of FEAT_E0PD_IMPLEMENTED_ref),
    ((''FEAT_DPB2_IMPLEMENTED''), register_ops_of FEAT_DPB2_IMPLEMENTED_ref),
    ((''FEAT_CSV3_IMPLEMENTED''), register_ops_of FEAT_CSV3_IMPLEMENTED_ref),
    ((''FEAT_CSV2_IMPLEMENTED''), register_ops_of FEAT_CSV2_IMPLEMENTED_ref),
    ((''FEAT_BTI_IMPLEMENTED''), register_ops_of FEAT_BTI_IMPLEMENTED_ref),
    ((''FEAT_TTST_IMPLEMENTED''), register_ops_of FEAT_TTST_IMPLEMENTED_ref),
    ((''FEAT_TTL_IMPLEMENTED''), register_ops_of FEAT_TTL_IMPLEMENTED_ref),
    ((''FEAT_TRF_IMPLEMENTED''), register_ops_of FEAT_TRF_IMPLEMENTED_ref),
    ((''FEAT_TLBIRANGE_IMPLEMENTED''), register_ops_of FEAT_TLBIRANGE_IMPLEMENTED_ref),
    ((''FEAT_TLBIOS_IMPLEMENTED''), register_ops_of FEAT_TLBIOS_IMPLEMENTED_ref),
    ((''FEAT_SEL2_IMPLEMENTED''), register_ops_of FEAT_SEL2_IMPLEMENTED_ref),
    ((''FEAT_S2FWB_IMPLEMENTED''), register_ops_of FEAT_S2FWB_IMPLEMENTED_ref),
    ((''FEAT_RASv1p1_IMPLEMENTED''), register_ops_of FEAT_RASv1p1_IMPLEMENTED_ref),
    ((''FEAT_RASSAv1p1_IMPLEMENTED''), register_ops_of FEAT_RASSAv1p1_IMPLEMENTED_ref),
    ((''FEAT_PMUv3p4_IMPLEMENTED''), register_ops_of FEAT_PMUv3p4_IMPLEMENTED_ref),
    ((''FEAT_NV2_IMPLEMENTED''), register_ops_of FEAT_NV2_IMPLEMENTED_ref),
    ((''FEAT_LSE2_IMPLEMENTED''), register_ops_of FEAT_LSE2_IMPLEMENTED_ref),
    ((''FEAT_LRCPC2_IMPLEMENTED''), register_ops_of FEAT_LRCPC2_IMPLEMENTED_ref),
    ((''FEAT_IDST_IMPLEMENTED''), register_ops_of FEAT_IDST_IMPLEMENTED_ref),
    ((''FEAT_FlagM_IMPLEMENTED''), register_ops_of FEAT_FlagM_IMPLEMENTED_ref),
    ((''FEAT_FHM_IMPLEMENTED''), register_ops_of FEAT_FHM_IMPLEMENTED_ref),
    ((''FEAT_DoubleFault_IMPLEMENTED''), register_ops_of FEAT_DoubleFault_IMPLEMENTED_ref),
    ((''FEAT_DotProd_IMPLEMENTED''), register_ops_of FEAT_DotProd_IMPLEMENTED_ref),
    ((''FEAT_Debugv8p4_IMPLEMENTED''), register_ops_of FEAT_Debugv8p4_IMPLEMENTED_ref),
    ((''FEAT_DIT_IMPLEMENTED''), register_ops_of FEAT_DIT_IMPLEMENTED_ref),
    ((''FEAT_CNTSC_IMPLEMENTED''), register_ops_of FEAT_CNTSC_IMPLEMENTED_ref),
    ((''FEAT_BBM_IMPLEMENTED''), register_ops_of FEAT_BBM_IMPLEMENTED_ref),
    ((''FEAT_AMUv1_IMPLEMENTED''), register_ops_of FEAT_AMUv1_IMPLEMENTED_ref),
    ((''FEAT_SPEv1p1_IMPLEMENTED''), register_ops_of FEAT_SPEv1p1_IMPLEMENTED_ref),
    ((''FEAT_PAuth_IMPLEMENTED''), register_ops_of FEAT_PAuth_IMPLEMENTED_ref),
    ((''FEAT_PACQARMA5_IMPLEMENTED''), register_ops_of FEAT_PACQARMA5_IMPLEMENTED_ref),
    ((''FEAT_PACQARMA3_IMPLEMENTED''), register_ops_of FEAT_PACQARMA3_IMPLEMENTED_ref),
    ((''FEAT_PACIMP_IMPLEMENTED''), register_ops_of FEAT_PACIMP_IMPLEMENTED_ref),
    ((''FEAT_NV_IMPLEMENTED''), register_ops_of FEAT_NV_IMPLEMENTED_ref),
    ((''FEAT_LRCPC_IMPLEMENTED''), register_ops_of FEAT_LRCPC_IMPLEMENTED_ref),
    ((''FEAT_JSCVT_IMPLEMENTED''), register_ops_of FEAT_JSCVT_IMPLEMENTED_ref),
    ((''FEAT_FPACCOMBINE_IMPLEMENTED''), register_ops_of FEAT_FPACCOMBINE_IMPLEMENTED_ref),
    ((''FEAT_FPAC_IMPLEMENTED''), register_ops_of FEAT_FPAC_IMPLEMENTED_ref),
    ((''FEAT_FCMA_IMPLEMENTED''), register_ops_of FEAT_FCMA_IMPLEMENTED_ref),
    ((''FEAT_EPAC_IMPLEMENTED''), register_ops_of FEAT_EPAC_IMPLEMENTED_ref),
    ((''FEAT_CONSTPACFIELD_IMPLEMENTED''), register_ops_of FEAT_CONSTPACFIELD_IMPLEMENTED_ref),
    ((''FEAT_CCIDX_IMPLEMENTED''), register_ops_of FEAT_CCIDX_IMPLEMENTED_ref),
    ((''FEAT_XNX_IMPLEMENTED''), register_ops_of FEAT_XNX_IMPLEMENTED_ref),
    ((''FEAT_VPIPT_IMPLEMENTED''), register_ops_of FEAT_VPIPT_IMPLEMENTED_ref),
    ((''FEAT_UAO_IMPLEMENTED''), register_ops_of FEAT_UAO_IMPLEMENTED_ref),
    ((''FEAT_TTCNP_IMPLEMENTED''), register_ops_of FEAT_TTCNP_IMPLEMENTED_ref),
    ((''FEAT_SVE_IMPLEMENTED''), register_ops_of FEAT_SVE_IMPLEMENTED_ref),
    ((''FEAT_SPE_IMPLEMENTED''), register_ops_of FEAT_SPE_IMPLEMENTED_ref),
    ((''FEAT_SM4_IMPLEMENTED''), register_ops_of FEAT_SM4_IMPLEMENTED_ref),
    ((''FEAT_SM3_IMPLEMENTED''), register_ops_of FEAT_SM3_IMPLEMENTED_ref),
    ((''FEAT_SHA512_IMPLEMENTED''), register_ops_of FEAT_SHA512_IMPLEMENTED_ref),
    ((''FEAT_SHA3_IMPLEMENTED''), register_ops_of FEAT_SHA3_IMPLEMENTED_ref),
    ((''FEAT_RAS_IMPLEMENTED''), register_ops_of FEAT_RAS_IMPLEMENTED_ref),
    ((''FEAT_PCSRv8p2_IMPLEMENTED''), register_ops_of FEAT_PCSRv8p2_IMPLEMENTED_ref),
    ((''FEAT_PAN2_IMPLEMENTED''), register_ops_of FEAT_PAN2_IMPLEMENTED_ref),
    ((''FEAT_MPAM_IMPLEMENTED''), register_ops_of FEAT_MPAM_IMPLEMENTED_ref),
    ((''FEAT_LVA_IMPLEMENTED''), register_ops_of FEAT_LVA_IMPLEMENTED_ref),
    ((''FEAT_LSMAOC_IMPLEMENTED''), register_ops_of FEAT_LSMAOC_IMPLEMENTED_ref),
    ((''FEAT_LPA_IMPLEMENTED''), register_ops_of FEAT_LPA_IMPLEMENTED_ref),
    ((''FEAT_IESB_IMPLEMENTED''), register_ops_of FEAT_IESB_IMPLEMENTED_ref),
    ((''FEAT_I8MM_IMPLEMENTED''), register_ops_of FEAT_I8MM_IMPLEMENTED_ref),
    ((''FEAT_HPDS2_IMPLEMENTED''), register_ops_of FEAT_HPDS2_IMPLEMENTED_ref),
    ((''FEAT_FP16_IMPLEMENTED''), register_ops_of FEAT_FP16_IMPLEMENTED_ref),
    ((''FEAT_F64MM_IMPLEMENTED''), register_ops_of FEAT_F64MM_IMPLEMENTED_ref),
    ((''FEAT_F32MM_IMPLEMENTED''), register_ops_of FEAT_F32MM_IMPLEMENTED_ref),
    ((''FEAT_EDHSR_IMPLEMENTED''), register_ops_of FEAT_EDHSR_IMPLEMENTED_ref),
    ((''FEAT_Debugv8p2_IMPLEMENTED''), register_ops_of FEAT_Debugv8p2_IMPLEMENTED_ref),
    ((''FEAT_DPB_IMPLEMENTED''), register_ops_of FEAT_DPB_IMPLEMENTED_ref),
    ((''FEAT_ASMv8p2_IMPLEMENTED''), register_ops_of FEAT_ASMv8p2_IMPLEMENTED_ref),
    ((''FEAT_AA32I8MM_IMPLEMENTED''), register_ops_of FEAT_AA32I8MM_IMPLEMENTED_ref),
    ((''FEAT_AA32HPD_IMPLEMENTED''), register_ops_of FEAT_AA32HPD_IMPLEMENTED_ref),
    ((''FEAT_AA32BF16_IMPLEMENTED''), register_ops_of FEAT_AA32BF16_IMPLEMENTED_ref),
    ((''FEAT_VMID16_IMPLEMENTED''), register_ops_of FEAT_VMID16_IMPLEMENTED_ref),
    ((''FEAT_VHE_IMPLEMENTED''), register_ops_of FEAT_VHE_IMPLEMENTED_ref),
    ((''FEAT_RDM_IMPLEMENTED''), register_ops_of FEAT_RDM_IMPLEMENTED_ref),
    ((''FEAT_PMUv3p1_IMPLEMENTED''), register_ops_of FEAT_PMUv3p1_IMPLEMENTED_ref),
    ((''FEAT_PAN_IMPLEMENTED''), register_ops_of FEAT_PAN_IMPLEMENTED_ref),
    ((''FEAT_LSE_IMPLEMENTED''), register_ops_of FEAT_LSE_IMPLEMENTED_ref),
    ((''FEAT_LOR_IMPLEMENTED''), register_ops_of FEAT_LOR_IMPLEMENTED_ref),
    ((''FEAT_HPDS_IMPLEMENTED''), register_ops_of FEAT_HPDS_IMPLEMENTED_ref),
    ((''FEAT_HAFDBS_IMPLEMENTED''), register_ops_of FEAT_HAFDBS_IMPLEMENTED_ref),
    ((''FEAT_Debugv8p1_IMPLEMENTED''), register_ops_of FEAT_Debugv8p1_IMPLEMENTED_ref),
    ((''FEAT_CRC32_IMPLEMENTED''), register_ops_of FEAT_CRC32_IMPLEMENTED_ref),
    ((''FEAT_nTLBPA_IMPLEMENTED''), register_ops_of FEAT_nTLBPA_IMPLEMENTED_ref),
    ((''FEAT_TRC_SR_IMPLEMENTED''), register_ops_of FEAT_TRC_SR_IMPLEMENTED_ref),
    ((''FEAT_TRC_EXT_IMPLEMENTED''), register_ops_of FEAT_TRC_EXT_IMPLEMENTED_ref),
    ((''FEAT_SHA256_IMPLEMENTED''), register_ops_of FEAT_SHA256_IMPLEMENTED_ref),
    ((''FEAT_SHA1_IMPLEMENTED''), register_ops_of FEAT_SHA1_IMPLEMENTED_ref),
    ((''FEAT_PMUv3_EXT32_IMPLEMENTED''), register_ops_of FEAT_PMUv3_EXT32_IMPLEMENTED_ref),
    ((''FEAT_PMUv3_EXT_IMPLEMENTED''), register_ops_of FEAT_PMUv3_EXT_IMPLEMENTED_ref),
    ((''FEAT_PMUv3_IMPLEMENTED''), register_ops_of FEAT_PMUv3_IMPLEMENTED_ref),
    ((''FEAT_PMULL_IMPLEMENTED''), register_ops_of FEAT_PMULL_IMPLEMENTED_ref),
    ((''FEAT_PCSRv8_IMPLEMENTED''), register_ops_of FEAT_PCSRv8_IMPLEMENTED_ref),
    ((''FEAT_IVIPT_IMPLEMENTED''), register_ops_of FEAT_IVIPT_IMPLEMENTED_ref),
    ((''FEAT_GICv4p1_IMPLEMENTED''), register_ops_of FEAT_GICv4p1_IMPLEMENTED_ref),
    ((''FEAT_GICv4_IMPLEMENTED''), register_ops_of FEAT_GICv4_IMPLEMENTED_ref),
    ((''FEAT_GICv3p1_IMPLEMENTED''), register_ops_of FEAT_GICv3p1_IMPLEMENTED_ref),
    ((''FEAT_GICv3_TDIR_IMPLEMENTED''), register_ops_of FEAT_GICv3_TDIR_IMPLEMENTED_ref),
    ((''FEAT_GICv3_LEGACY_IMPLEMENTED''), register_ops_of FEAT_GICv3_LEGACY_IMPLEMENTED_ref),
    ((''FEAT_GICv3_IMPLEMENTED''), register_ops_of FEAT_GICv3_IMPLEMENTED_ref),
    ((''FEAT_FP_IMPLEMENTED''), register_ops_of FEAT_FP_IMPLEMENTED_ref),
    ((''FEAT_ETS2_IMPLEMENTED''), register_ops_of FEAT_ETS2_IMPLEMENTED_ref),
    ((''FEAT_ETMv4p6_IMPLEMENTED''), register_ops_of FEAT_ETMv4p6_IMPLEMENTED_ref),
    ((''FEAT_ETMv4p5_IMPLEMENTED''), register_ops_of FEAT_ETMv4p5_IMPLEMENTED_ref),
    ((''FEAT_ETMv4p4_IMPLEMENTED''), register_ops_of FEAT_ETMv4p4_IMPLEMENTED_ref),
    ((''FEAT_ETMv4p3_IMPLEMENTED''), register_ops_of FEAT_ETMv4p3_IMPLEMENTED_ref),
    ((''FEAT_ETMv4p2_IMPLEMENTED''), register_ops_of FEAT_ETMv4p2_IMPLEMENTED_ref),
    ((''FEAT_ETMv4p1_IMPLEMENTED''), register_ops_of FEAT_ETMv4p1_IMPLEMENTED_ref),
    ((''FEAT_ETMv4_IMPLEMENTED''), register_ops_of FEAT_ETMv4_IMPLEMENTED_ref),
    ((''FEAT_DoubleLock_IMPLEMENTED''), register_ops_of FEAT_DoubleLock_IMPLEMENTED_ref),
    ((''FEAT_CSV2_3_IMPLEMENTED''), register_ops_of FEAT_CSV2_3_IMPLEMENTED_ref),
    ((''FEAT_CSV2_2_IMPLEMENTED''), register_ops_of FEAT_CSV2_2_IMPLEMENTED_ref),
    ((''FEAT_CSV2_1p2_IMPLEMENTED''), register_ops_of FEAT_CSV2_1p2_IMPLEMENTED_ref),
    ((''FEAT_CSV2_1p1_IMPLEMENTED''), register_ops_of FEAT_CSV2_1p1_IMPLEMENTED_ref),
    ((''FEAT_AdvSIMD_IMPLEMENTED''), register_ops_of FEAT_AdvSIMD_IMPLEMENTED_ref),
    ((''FEAT_AES_IMPLEMENTED''), register_ops_of FEAT_AES_IMPLEMENTED_ref),
    ((''FEAT_EL3_IMPLEMENTED''), register_ops_of FEAT_EL3_IMPLEMENTED_ref),
    ((''FEAT_EL2_IMPLEMENTED''), register_ops_of FEAT_EL2_IMPLEMENTED_ref),
    ((''FEAT_EL1_IMPLEMENTED''), register_ops_of FEAT_EL1_IMPLEMENTED_ref),
    ((''FEAT_EL0_IMPLEMENTED''), register_ops_of FEAT_EL0_IMPLEMENTED_ref),
    ((''FEAT_AA64EL3_IMPLEMENTED''), register_ops_of FEAT_AA64EL3_IMPLEMENTED_ref),
    ((''FEAT_AA64EL2_IMPLEMENTED''), register_ops_of FEAT_AA64EL2_IMPLEMENTED_ref),
    ((''FEAT_AA64EL1_IMPLEMENTED''), register_ops_of FEAT_AA64EL1_IMPLEMENTED_ref),
    ((''FEAT_AA64EL0_IMPLEMENTED''), register_ops_of FEAT_AA64EL0_IMPLEMENTED_ref),
    ((''FEAT_AA32EL3_IMPLEMENTED''), register_ops_of FEAT_AA32EL3_IMPLEMENTED_ref),
    ((''FEAT_AA32EL2_IMPLEMENTED''), register_ops_of FEAT_AA32EL2_IMPLEMENTED_ref),
    ((''FEAT_AA32EL1_IMPLEMENTED''), register_ops_of FEAT_AA32EL1_IMPLEMENTED_ref),
    ((''FEAT_AA32EL0_IMPLEMENTED''), register_ops_of FEAT_AA32EL0_IMPLEMENTED_ref),
    ((''SEE''), register_ops_of SEE_ref)
  ])\<close>


definition register_accessors  :: \<open>(string \<Rightarrow> regstate \<Rightarrow>(register_value)option)*(string \<Rightarrow> register_value \<Rightarrow> regstate \<Rightarrow>(regstate)option)\<close>  where 
     \<open> register_accessors = ( mk_accessors ((\<lambda> nm .  Map.map_of registers nm)))\<close>


\<comment> \<open>\<open>val get_regval : string -> regstate -> maybe register_value\<close>\<close>
definition get_regval  :: \<open> string \<Rightarrow> regstate \<Rightarrow>(register_value)option \<close>  where 
     \<open> get_regval = ( fst register_accessors )\<close>


\<comment> \<open>\<open>val set_regval : string -> register_value -> regstate -> maybe regstate\<close>\<close>
definition set_regval  :: \<open> string \<Rightarrow> register_value \<Rightarrow> regstate \<Rightarrow>(regstate)option \<close>  where 
     \<open> set_regval = ( snd register_accessors )\<close>



type_synonym( 'a, 'r) MR =" (Fault, Barrier, CacheRecord, ( FaultRecord option), ( 56 Word.word), TLBIInfo, ( TranslationInfo option), arm_acc_type, register_value, regstate, 'a, 'r, exception) base_monadR "
type_synonym 'a M =" (Fault, Barrier, CacheRecord, ( FaultRecord option), ( 56 Word.word), TLBIInfo, ( TranslationInfo option), arm_acc_type, register_value, regstate, 'a, exception) base_monad "
end
